[{"content":"[문제1] 거스름돈 ###[문제] 거스름돈 : 문제 설명\n 당신은 음식점의 계산을 도와주는 점원입니다. 카운트에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈은 N은 항상 10의 배수입니다.\n ###[문제] 거스름돈 : 문제 해결 아이디어\n  최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐의 단위부터 돈을 거슬러 주면 됩니다. N원을 거슬러 줘야 할 때, 가장먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러줍니다. 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러주면 됩니다. N = 1,260일 때의 예시를 확인해 봅시다.    1,260 원을 500원부터 거슬러 준다면 아래와 같이\n    화페단위 500 100 50 10     손님이 받은 개수 2 2 1 1    ###[문제] 거스름돈 : 정당성 분석\n  가장큰 화폐단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요? 가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다. 만약 800원을 거슬러 주어야 하는데 화폐 단위가 500원 400원 100원이라면 어떻게 될까요 ? -\u0026gt; 400원 짜리 2개가 정답이됨 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 합니다.   ####reverse_change.py\nn =1260\rcount = 0 array = [500,100,50,10]\rfor coin in array:\rcount += n / coin\rn %= coin print(count)\r ####ReverseCharge.java\npackage ex.algorism.greedy;\rpublic class ReverseCharge {\rpublic static void main(String[] args) {\rint n = 1260;\rint[] coins = {500,100,50,10};\rint count = 0;\rfor (int coin : coins) {\rcount += n/coin;\rn %= coin;\r}\rSystem.out.println(count);\r}\r}\r ####[문제] 거스름돈 : 시간 복잡도 분석\n  화폐의 종류가 K라고 할때, 소스코드의 시간복잡도는 O(K)이다. 이 알고리즘의 시간복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":0,"section":"blog","tags":["java"],"title":"거스름돈 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/reverse-charge/"},{"content":"그리디 알고리즘(탐욕법) 그리디 알고리즘이란 ?  그리디 알고리즘이란\n 그리디 알고리즘(탐욕법)은 현재상황에서 가장 좋은 것만 고르는 방법을 의미. 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 있는 능력을 요구. 그리디 해법은 그 정당성 분석이 중요. 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토 필요.   [문제 상황] 루트 노드로 부터 시작하여 가는 노드의 합을 최대로 만들고 싶습니다.  Q. 최적의 해는 무엇인가요 ?\n  Q. 단순히 매 상황에서 가장큰 값을 고른다면 어떻게 될까요?\n   일반적인 상황에서 그리디알고리즘은 최적의 해를 보장할 수 없을때가 많다. 하지만 코딩 테스트에서의 대부분의 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됨.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":1,"section":"blog","tags":["java"],"title":"그리디 알고리즘","uri":"https://offetuoso.github.io/blog/greedy-algorithm/"},{"content":"I use ~ (\u0026lsquo;난 -를 사용한다.')  I use Java 난 자바를 사용한다.\n I’m preparing ~ ('-를 준비중입니다\u0026rsquo;)  ** I’m preparing to change job ** 나는 이직을 준비중입니다.\n ~ is intense ('-이 ~빡세다~힘들다.')\n Work is not intense 일은 힘들지 않다.\n I learned ~ (\u0026lsquo;나는 -배웠다\u0026rsquo;)  I learned computer science in my University\n I want to ~ ('-하고 싶습니다.')  I want to hold your hand\n I\u0026rsquo;m good at ~ (\u0026lsquo;나는 -잘해\u0026rsquo;)  I\u0026rsquo;m good at make smile\n I\u0026rsquo;m about to ~ (\u0026lsquo;나는 -할 예정이다\u0026rsquo;)  I\u0026rsquo;m about to go to bed\n Benefits \u0026amp; Drawbacks (장점 \u0026amp; 단점)\rTake your time (천천히) Achievement (성취감)\rWorking late (야근) Intense (빡센) Regular job = Stable job = 안정감 있는 직업 Objective / Goal = 목표\rRegret = 후회\rAge Limit = 나이 제한\rVaccine = 백신\rPandemic = 전국적인 유행병\rGovernance = 통치  end ","description":"영어 회화 문법정리","id":2,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.16","uri":"https://offetuoso.github.io/blog/20210316-english-speak/"},{"content":"I’m used to ~ (\u0026lsquo;난 -에 익숙해\u0026rsquo;)  I\u0026rsquo;m used to you 난 너에게 익숙해\n I\u0026rsquo;m afraid ~ (\u0026lsquo;유감스럽지만,')  I\u0026rsquo;m afraid Rainy outside 유감이지만, 밖에 비가 오는 것 같아\n I’m working on ~ (\u0026lsquo;지금 -를 하고있어\u0026rsquo;)  I’m working on my English speaking 난 영어 말하기를 공부하고 있어\n My girlfriend is another event. → My girlfriend had a personal schedule (She went out to hang out with her friends.)\rI’m English is tiny → My English is bad. / I’m not that good at English. → I’m still learning English. / I’m working on my English speaking.\r(Q. What is the charm of skateboarding?) A. other skateboarders communication → (full sentence) I think the charm of skateboarding is that I can ride skateboards with other skateboarders. / I enjoy riding skateboards with other people → (shorter) Communicating with other skateboarders is the best. / the greatest charm. skateboarding stage → spot\rshortboard and longboard and skateboard → I started with the shortboard and then the longboard and then the skateboard. / I started with the shortboard and then the longboard. Now I can ride the standard skateboard as well.\rIsn’t/Wasn’t living in other countries tough?\rhave an access to\rhang out (Google HangOut / Meet) - to meet someone or to play with someone, usually friends.\rMy hobby is skateboarding. → I enjoy(love) skateboarding in my free time.\rI started in-door climbing recently. / I’m into sth. = having a great interest in sth\r end ","description":"영어 회화 문법정리","id":3,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.15","uri":"https://offetuoso.github.io/blog/20210315-english-speak/"},{"content":"자바 자바가상머신 (JVM) 자바의 장점 자바의 단점 자바의 기초 문법 객체지향과 자바 객체지향 프로그램 언어 객체 상속 오버라이딩 (Overriding)  오버라이딩이란?\n  사전적 의미로는 more important than any other considerations 번역해 보면 다른 고려 사항보다 더 중요하다이다.\n  부모 클래스로 부터 상속받은 메소드를 자식 클래스에서 재정의 하여, 덮어 쓰는 것이다. 상속받은 메소드를 그대로 사용할 수도 있지만, 자식 클래스에서 상황에 맞게 변경해야 하는 경우 오버라이딩을 사용한다.\n  오버라이딩을 사용하기 위한 조건에는 부모 클래스의 메소드를 재정의하는 것이므로 이름, 매개변수 리턴 값이 모두 같아야 한다.\n  오버라이딩의 조건\n 부모 클래스와 자식 클래스 사이에서만 성립한다. static 메소드는 오버라이딩 할 수 없다. static 메소드 끼리의 오버라이딩은 hiding이라 한다. private는 정의된 메소드는 상속 자체가 안된다. interface 메소드를 오버라이딩 할 경우엔 public으로 해야한다. 메소드의 파라미터가 완전히 일치해야 하며, 리턴타입도 같아야 한다. 파라미터의 이름은 상관없다. 부모 클래스의 접근제어자보다 좁아질 수 없다. 확장 될 수는 있다. 부모 클래스보다 더 많은 예외를 던질 수 있다. final 예약어로 정의된 메소드는 오버라이딩 할 수 없다.    아래 소스코드를 보면,\n main 클래스를 가지고 있는 Example 클래스 Talk라는 기능을 가진 부모 클래스, Person 클래스. Person을 부모로 가지고 있는 자식 클래스, Korean, American, Japanese로 구성되어있다. 모두 Talk 메소드를 가지고 있지만 각각 다른 기능을 수행한다.   Example.java package ex.java.overriding;\rpublic class Example {\rpublic static void main(String[] args) {\rPerson person = new Person();\rperson.Talk();\rKorean korean = new Korean();\rkorean.Talk();\rAmerican american = new American();\ramerican.Talk();\rJapanese japanese = new Japanese();\rjapanese.Talk();\r}\r}\rclass Person {\rvoid Talk() {\rString message = \u0026quot;Aaaa\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Korean extends Person{\r@Override\rvoid Talk() {\rString message = \u0026quot;안녕하세요!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass American extends Person{\r@Override\rpublic void Talk() {\rString message = \u0026quot;Hello!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Japanese extends Person{\r@Override\rprotected void Talk() {\rString message = \u0026quot;Konnichiwa!\u0026quot;;\rSystem.out.println(message);\r}\r}\r result Aaaa\r안녕하세요!\rHello!\rKonnichiwa!\r  소스를 보다보면 자식 클래스의 메소드 바로 위에 @override라는 것이 보일 것이다. 이것은 Annotation 이라는 주석 기능이다. 하지만 우리가 알고 있는 주석과는 다르며 컴퓨터는 그것을 이 메소드는 부모 클래스로 부터 오버라이드 받은 메소드이다. 명시해 주는것이다. 만일 메소드가 아래의 경우 오류로 알려준다.\n 1. 메소드 명칭이 잘못된경우\rThe method talks() of type Korean must override or implement a supertype method\r2. 리턴타입이 잘못된경우 The return type is incompatible with Person.Talk()\r3. 파라미터가 잘못된경우\rThe method Talk(String) of type Korean must override or implement a supertype method\r 오버로딩 (Overloading)  오버로딩이란?\n  사전적 의미로는 loading of a vehicle with too heavy a weight. 번역해 보면 너무 무거운 중량의 차량 적재.이다. 쉽게 말하면 과적해서 싣는 것이다.\n  보통 하나의 이름을 가진 메소드는 1개만 존재 하지만, 파라미터가 다르다면 컴퓨터는 오버로드된 메소드로 인식하여 다른 메소르도 인식함.\n  오버로딩이 되는 조건은\n 메소드 이름이 같아야 한다. 메소드의 파라미터의 형이 다르거나 갯수가 다르거나 순서가 다름. 반환타입은 영향을 미치지 않는다.    아래 소스코드를 보면,\n main 클래스를 가지고 있는 Example 클래스 Mountain이라는 클래스가 있고 echo라는 입력하면 답변을 해주는 메소드가 있다. 같은 이름의 다른 파라미터를 갖는 3개의 echo가 있다.   Example.java package ex.java.overloading;\rpublic class Example {\rpublic static void main(String[] args) {\rMountain mountain = new Mountain();\rmountain.echo(\u0026quot;Hello\u0026quot;); //문자열 입력\rmountain.echo(100);\t//숫자 입력\rmountain.echo(true);\t//참,거짓 입력\r}\r}\rclass Mountain {\rvoid echo(String say) {\rSystem.out.println(\u0026quot;you say \u0026quot;+say);\r}\rvoid echo(int money) {\rSystem.out.println(\u0026quot;you have \u0026quot;+money+\u0026quot; doller\u0026quot;);\r}\rvoid echo(Boolean bool) {\rif(bool) {\rSystem.out.println(\u0026quot;this is True\u0026quot;);\r}else {\rSystem.out.println(\u0026quot;this is False\u0026quot;);\r}\r}\r}\r result you say Hello\ryou have 100 doller\rthis is True\r  결과를 보면 어렵진 않다. 컴퓨터는 입력된 파라미터에 따라 어떤 함수를 호출할지 보여준다. 예를들면 우리가 많이 사용하는 System.out.println(); 출력 함수가 있다.\n  주의할점 파라메터의 순서를 다르게 오버라이드 하였지만, int와 long 모두 소숫점이 없는 정수를 입력 가능하기 때문에 컴퓨터의 입장에서는 어느 메소드를 사용할지 애매한경우가 생긴다.\n The method sum(int, long) is ambiguous for the type Calculator Calculator의 메소드 sum (int, long)은 형식에 대해 모호합니다.\n\tpublic class Example {\rpublic static void main(String[] args) {\rCalculator cal = new Calculator();\rcal.sum(1, 5);\r}\r}\rclass Calculator {\rvoid sum(int a, long b) {\rSystem.out.println(\u0026quot;sum is \u0026quot;+ (a+b));\r}\rvoid sum(long a, int b) {\rSystem.out.println(\u0026quot;sum is \u0026quot;+ (a+b));\r}\r}\r 다형성 오버라이딩을 이용한 다형성  위에서 오버라이딩을 설명했던 소스와 다른점 한가지가 있다. 그것은 main 클래스에서 자식 클래스를 선언하는 부분이다.\n Example.java package ex.java.overriding;\rpublic class Example {\rpublic static void main(String[] args) {\rPerson person = new Person();\rperson.Talk();\rperson = new Korean(); // Korea클래스의 인스턴스를 Person타입인 person으로 참조하여 사용.\rperson.Talk();\rperson = new American(); // American클래스의 인스턴스를 Person타입인 person으로 참조하여 사용.\rperson.Talk();\rperson = new Japanese();\t// Japanese클래스의 인스턴스를 Person타입인 person으로 참조하여 사용.\rperson.Talk();\r}\r}\rclass Person {\rvoid Talk() {\rString message = \u0026quot;Aaaa\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Korean extends Person{\r@Override\rvoid Talk() {\rString message = \u0026quot;안녕하세요!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass American extends Person{\r@Override\rpublic void Talk() {\rString message = \u0026quot;Hello!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Japanese extends Person{\r@Override\rprotected void Talk() {\rString message = \u0026quot;Konnichiwa!\u0026quot;;\rSystem.out.println(message);\r}\r}\r result Aaaa\r안녕하세요!\rHello!\rKonnichiwa!\r 참조변수의 다형성  참조변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있다. 클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없기 때문에, 자식클래스에서 사용할 수 있는 멤버의 개수는 언제나 부모 클래스와 같거나 많게 된다.\n \rPerson person = new Person(); //정상\rKorean korean = new Korean(); //정상\r// 부모 클래스인 person은 Korean을 포함할 수 있다.\rPerson person = new Korean(); //정상\r// 부모 클래스는 자식으로 참조 할수 없다. Korean korean = new Person();\t//오류\r 참조변수의 형변환  자식클래스를 부모 클래스로 참조할때 자식 클래스로 형 변환 할 수 있다.\n \rPerson person = new Person();\rperson.Talk();\rKorean korean = new Korean();\rperson = (Korean) korean; //(Korean) 타입으로 형변환\rkorean.Talk();\rAmerican american = new American();\rperson = (American) american; //(American) 타입으로 형변환\ramerican.Talk();\rJapanese japanese = new Japanese(); //(Japanese) 타입으로 형변환\rperson = (Japanese) japanese;\rjapanese.Talk();\rperson = (American) japanese; //오류 !\rjapanese.Talk();\r 추상화 인터페이스 ","description":"자바의 기본 개념정리.","id":4,"section":"blog","tags":["java"],"title":"자바의 기본개념","uri":"https://offetuoso.github.io/blog/basic-java/"},{"content":"Nothing on this page will be visible. This file exists solely to respond to /search URL.\nSetting a very low sitemap priority will tell search engines this is not important content.\n","description":"","id":5,"section":"","tags":null,"title":"Search Results","uri":"https://offetuoso.github.io/search/"}]