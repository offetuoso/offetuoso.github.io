[{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   홈 화면과 레이아웃 상품 등록 화면 개발   강좌와 다르게 Item의 상속관계에 맞게 아이템들을 등록해 보려 합니다. 화면에서 셀렉트 박스로 dtype로 입력받고 컨트롤러에서 입력받은 dtype에 따라 Album, Book, Movie 엔티티를 Item 객체로 생성하여 저장을 할 것입니다.\n  java/jpabook/jpashop/dto/ItemForm.java\n package jpabook.jpashop.dto;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class ItemForm {\rprivate long id; //수정을 위한 id도 추가 private String name;\rprivate int price; private int stockQuantity;\rprivate String dtype; //아이템 타입 (A, B, M)\rprivate String artist;\rprivate String etc;\rprivate String author;\rprivate String isbn;\rprivate String director;\rprivate String actor;\r}\r  ItemController.java\n \rpackage jpabook.jpashop.controller;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.dto.ItemForm;\rimport jpabook.jpashop.exception.NotHasDiscriminator;\rimport jpabook.jpashop.service.ItemService;\rimport lombok.RequiredArgsConstructor;\rimport lombok.extern.slf4j.Slf4j;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.ui.Model;\rimport org.springframework.validation.BindingResult;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.PostMapping;\rimport javax.validation.Valid;\r@Controller\r@RequiredArgsConstructor\r@Slf4j\rpublic class ItemController {\rprivate final ItemService itemService;\r@GetMapping(\u0026quot;/items/new\u0026quot;)\rpublic String newItemsForm(Model modal){\rlog.info(\u0026quot;call get /items/new\u0026quot;);\rmodal.addAttribute(\u0026quot;itemForm\u0026quot;, new ItemForm());\rreturn \u0026quot;items/newItemForm\u0026quot;;\r}\r@PostMapping(\u0026quot;/items/new\u0026quot;)\rpublic String newItems(@Valid ItemForm itemForm, BindingResult result, Model modal){\rlog.info(\u0026quot;call post members/new\u0026quot;);\rif(result.hasErrors()){\rreturn \u0026quot;items/newItemForm\u0026quot;;\r}\rItem item = null;\rif(\u0026quot;A\u0026quot;.equals(itemForm.getDtype())){\ritem = new Album().createItem(itemForm); // 앨범 생성\r}else if(\u0026quot;B\u0026quot;.equals(itemForm.getDtype())){\ritem = new Book().createItem(itemForm); // 책 생성\r}else if(\u0026quot;M\u0026quot;.equals(itemForm.getDtype())){\ritem = new Movie().createItem(itemForm); // 영화 생성\r}else{\rthrow new NotHasDiscriminator(\u0026quot;Not Has Discriminator\u0026quot;);\r}\ritemService.saveItem(item); // Item을 persist()\rreturn \u0026quot;redirect:/items\u0026quot;;\r}\r}\r createItem()  Item에 abstract 메서드를 생성하고, 자식 엔티티인 Album, Book, Movie에서 @override 하여 사용\n  Item.java\n  public abstract Item createItem(ItemForm itemForm);\r  Album.java\n  @Override\rpublic Item createItem(ItemForm itemForm) {\rthis.setName(itemForm.getName());\rthis.setPrice(itemForm.getPrice());\rthis.setStockQuantity(itemForm.getStockQuantity());\rthis.setArtist(itemForm.getArtist());\rthis.setEtc(itemForm.getEtc());\rreturn this;\r}\r  Book.java\n  @Override\rpublic Item createItem(ItemForm itemForm) {\rsuper.name = itemForm.getName();\rsuper.price = itemForm.getPrice();\rsuper.stockQuantity = itemForm.getStockQuantity();\rthis.isbn = itemForm.getIsbn();\rthis.author = itemForm.getAuthor();\rreturn this;\r}\r  Movie.java\n  @Override\rpublic Item createItem(ItemForm itemForm) {\rsuper.name = itemForm.getName();\rsuper.price = itemForm.getPrice();\rsuper.stockQuantity = itemForm.getStockQuantity();\rthis.director = itemForm.getDirector();\rthis.actor = itemForm.getActor();\rreturn this;\r}\r 상품등록 화면  강의에서는 책에 대한 데이터를 집어 넣기 때문에, 등록 화면이 간략했는데 dtype에 따라 다른 엔티티로 객체가 생성되어 들어가는 것을 테스트 해보고 싶었습니다. dtype에 따라 화면과 벨리데이션할 필드가 동적으로 나뉘게 되어 @Valid가 아니라 화면에서 체크를 하였습니다.\n  resources/templates/items/newItemForm.html\n \u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot; /\u0026gt;\r\u0026lt;script src=\u0026quot;https://code.jquery.com/jquery-latest.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r.hidden{\rdisplay: none;\rwidth : inherit;\rheight : 400px;\r}\r.fieldError {\rborder-color: #bd2130;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;script\u0026gt;\r$(document).ready(function(){\rfn_change_dtype();\r});\rlet fn_submit = function() {\rlet dtype = $(\u0026quot;#dtype\u0026quot;).val();\r$(\u0026quot;.fieldError\u0026quot;).removeClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;.errorMsg\u0026quot;).remove();\rif(dtype == ''){\r//alert(\u0026quot;상품구분을 선택하세요.\u0026quot;);\r$(\u0026quot;#dtype\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#dtype\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;상품 구분을 선택해 주세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\rif($.trim($(\u0026quot;#name\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;이름을 입력하세요.\u0026quot;);\r$(\u0026quot;#name\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#name\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;상품 이름을 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\rif($.trim($(\u0026quot;#stockQuantity\u0026quot;).val()) == \u0026quot;\u0026quot; || $(\u0026quot;#stockQuantity\u0026quot;).val() == 0){\r//alert(\u0026quot;수량을 1이상 입력하세요.\u0026quot;);\r$(\u0026quot;#stockQuantity\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#stockQuantity\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;수량을 1이상 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\rif(dtype == 'A'){\rif($.trim($(\u0026quot;#artist\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;아티스트를 입력하세요.\u0026quot;);\r$(\u0026quot;#artist\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#artist\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;아티스트를 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\rif($.trim($(\u0026quot;#etc\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;ETC를 입력하세요.\u0026quot;);\r$(\u0026quot;#etc\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#etc\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;ETC를 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\r}else if(dtype == 'B'){\rif($.trim($(\u0026quot;#author\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;저자를 입력하세요.\u0026quot;);\r$(\u0026quot;#author\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#author\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;저자를 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\rif($.trim($(\u0026quot;#isbn\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;ISBN을 입력하세요.\u0026quot;);\r$(\u0026quot;#isbn\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#isbn\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;ISBN을 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\r}else if(dtype == 'M'){\rif($.trim($(\u0026quot;#director\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;감독을 입력하세요.\u0026quot;);\r$(\u0026quot;#director\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#director\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;감독을 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\rif($.trim($(\u0026quot;#actor\u0026quot;).val()) == \u0026quot;\u0026quot;){\r//alert(\u0026quot;배우를 입력하세요.\u0026quot;);\r$(\u0026quot;#actor\u0026quot;).addClass(\u0026quot;fieldError\u0026quot;);\r$(\u0026quot;#actor\u0026quot;).parent().append(\u0026quot;\u0026lt;p class='errorMsg'\u0026gt;배우를 입력하세요.\u0026lt;/p\u0026gt;\u0026quot;);\rreturn false;\r}\r}\r$(\u0026quot;#itemForm\u0026quot;).submit();\r};\rlet fn_change_dtype = function() {\rlet dtype = $(\u0026quot;#dtype\u0026quot;).val();\r$(\u0026quot;#itemForm\u0026quot;)[0].reset();\r$(\u0026quot;#dtype\u0026quot;).val(dtype);\r//초기화\r$(\u0026quot;.hidden\u0026quot;).css(\u0026quot;display\u0026quot;,\u0026quot;none\u0026quot;);\rif(dtype == ''){\rreturn false;\r}else if(dtype == 'A'){\r$(\u0026quot;#sub-form-A\u0026quot;).css(\u0026quot;display\u0026quot;,\u0026quot;inline\u0026quot;);\r}else if(dtype == 'B'){\r$(\u0026quot;#sub-form-B\u0026quot;).css(\u0026quot;display\u0026quot;,\u0026quot;inline\u0026quot;);\r}else if(dtype == 'M'){\r$(\u0026quot;#sub-form-M\u0026quot;).css(\u0026quot;display\u0026quot;,\u0026quot;inline\u0026quot;);\r}\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot;/\u0026gt;\r\u0026lt;form id=\u0026quot;itemForm\u0026quot; th:action=\u0026quot;@{/items/new}\u0026quot; th:object=\u0026quot;${itemForm}\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;dtype\u0026quot;\u0026gt;상품구분\u0026lt;/label\u0026gt;\r\u0026lt;select th:field=\u0026quot;*{dtype}\u0026quot; class=\u0026quot;form-control\u0026quot; onchange=\u0026quot;fn_change_dtype()\u0026quot;\u0026gt;\r\u0026lt;option value=\u0026quot;\u0026quot;\u0026gt;상품구분\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;A\u0026quot;\u0026gt;앨범\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;B\u0026quot;\u0026gt;책\u0026lt;/option\u0026gt;\r\u0026lt;option value=\u0026quot;M\u0026quot;\u0026gt;영화\u0026lt;/option\u0026gt;\r\u0026lt;/select\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!--\u0026lt;p class=\u0026quot;fieldError\u0026quot; th:if=\u0026quot;${#fields.hasErrors('dtype')}\u0026quot; th:errors=\u0026quot;*{dtype}\u0026quot;\u0026gt;Incorrect date\u0026lt;/p\u0026gt;--\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;name\u0026quot;\u0026gt;상품명\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{name}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;이름을 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;!--\u0026lt;p class=\u0026quot;fieldError\u0026quot; th:if=\u0026quot;${#fields.hasErrors('name')}\u0026quot; th:errors=\u0026quot;*{name}\u0026quot;\u0026gt;Incorrect date\u0026lt;/p\u0026gt;--\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;price\u0026quot;\u0026gt;가격\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;number\u0026quot; th:field=\u0026quot;*{price}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;가격을 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;stockQuantity\u0026quot;\u0026gt;수량\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;number\u0026quot; th:field=\u0026quot;*{stockQuantity}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;수량을 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;sub-form-A\u0026quot; class=\u0026quot;sub-form hidden\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;artist\u0026quot;\u0026gt;아티스트\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{artist}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;아티스트를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;etc\u0026quot;\u0026gt;ETC\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{etc}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;ETC를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;sub-form-B\u0026quot; class=\u0026quot;sub-form hidden\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;author\u0026quot;\u0026gt;저자\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{author}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;저자를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;isbn\u0026quot;\u0026gt;ISBN\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{isbn}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;ISBN을 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div id=\u0026quot;sub-form-M\u0026quot; class=\u0026quot;sub-form hidden\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;director\u0026quot;\u0026gt;감독\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{director}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;감독을 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;actor\u0026quot;\u0026gt;배우\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{actor}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;배우를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-primary\u0026quot; onclick=\u0026quot;fn_submit();\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.dto.OrderSearch;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport org.springframework.util.StringUtils;\rimport javax.persistence.EntityManager;\rimport javax.persistence.TypedQuery;\rimport javax.persistence.criteria.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\rpublic List\u0026lt;Order\u0026gt; findAllByString(OrderSearch orderSearch){\rString jpql = \u0026quot;select o from Order o left join o.member m\u0026quot;;\rboolean isFirstCondition = true;\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;o.status = :status\u0026quot;;\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;m.name like :name\u0026quot;;\r}\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(jpql, Order.class)\r.setMaxResults(1000);\r//주문 상태 검색 setParameter\rif(orderSearch.getOrderStatus() != null){\rquery.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus());\r}\r//회원 이름 검색 setParameter\rif(StringUtils.hasText(orderSearch.getMemberName())){\rquery.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName());\r}\rreturn query.getResultList();\r}\r/**\r* JPA Criteria\r* */\rpublic List\u0026lt;Order\u0026gt; findAllByCriteria(OrderSearch orderSearch){\rCriteriaBuilder cb = em.getCriteriaBuilder(); //엔티티 매니저에서 CriteriaBuilder를 가져옴\rCriteriaQuery\u0026lt;Order\u0026gt; cq = cb.createQuery(Order.class); //CriteriaQuery 생성\rRoot\u0026lt;Order\u0026gt; o = cq.from(Order.class); // o를 Alias로 Root 생성\rJoin\u0026lt;Object, Object\u0026gt; m = o.join(\u0026quot;member\u0026quot;, JoinType.INNER); // m을 Alias로 join 한 Member 생성\rList\u0026lt;Predicate\u0026gt; criteria = new ArrayList\u0026lt;\u0026gt;(); // 동적 쿼리에 대한 컨디션 조합을 배열을 통해 만들 수 있습니다.\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rPredicate status = cb.equal(o.get(\u0026quot;status\u0026quot;), orderSearch.getOrderStatus());\rcriteria.add(status);\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rPredicate name = cb.like(m.\u0026lt;String\u0026gt;get(\u0026quot;name\u0026quot;), \u0026quot;%\u0026quot;+orderSearch.getMemberName()+\u0026quot;%\u0026quot;);\rcriteria.add(name);\r}\rcq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(cq).setMaxResults(1000);\rreturn query.getResultList();\r}\r/**\r* Querydsl\r* */\r// public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r   java/jpabook/jpashop/service/OrderService.java\n  OrderService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.*;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r/**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r/**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r}\r   java/jpabook/jpashop/dto/OrderSearch.java\n  OrderSearch.java \rpackage jpabook.jpashop.dto;\rimport jpabook.jpashop.domain.OrderStatus;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class OrderSearch {\rprivate String memberName; // 회원 이름\rprivate OrderStatus orderStatus; //주문 상태 [ORDER, CANCEL]\r}\r   java/jpabook/jpashop/dto/MemberForm.java\n  MemberForm.java \rpackage jpabook.jpashop.dto;\rimport jpabook.jpashop.domain.Address;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.validation.constraints.NotEmpty;\r@Getter @Setter\rpublic class MemberForm {\r@NotEmpty(message = \u0026quot;회원 이름은 필수 입니다.\u0026quot;)\rprivate String name;\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic Address getAddress(){\rreturn new Address(this.city, this.street, this.getZipcode());\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;MemberForm{\u0026quot; +\r\u0026quot;name='\u0026quot; + name + '\\'' +\r\u0026quot;, city='\u0026quot; + city + '\\'' +\r\u0026quot;, street='\u0026quot; + street + '\\'' +\r\u0026quot;, zipcode='\u0026quot; + zipcode + '\\'' +\r'}';\r}\r}\r  컨트롤러  java/jpabook/jpashop/HelloController.java\n  HelloController.java \rpackage jpabook.jpashop;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.ui.Model;\rimport org.springframework.web.bind.annotation.GetMapping;\r@Controller\rpublic class HelloController {\r@GetMapping(\u0026quot;hello\u0026quot;) // hello 라는 응답을 받으면\rpublic String hello(Model model){\rmodel.addAttribute(\u0026quot;data\u0026quot;, \u0026quot;hello !!\u0026quot;); // addAttribute data의 값에 \u0026quot;hello !!\u0026quot; 를 넣어서\rSystem.out.println(1121);\rreturn \u0026quot;hello\u0026quot;; /* view 라는 페이지를 오픈*/\r}\r}\r   java/jpabook/jpashop/controller/HomeController.java\n  HomeController.java \rpackage jpabook.jpashop.controller;\rimport lombok.extern.slf4j.Slf4j;\rimport org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.servlet.ModelAndView;\r@Controller\r@Slf4j\rpublic class HomeController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\r@RequestMapping(\u0026quot;/\u0026quot;)\rpublic String Home(){\rlog.info(\u0026quot;home controller\u0026quot;);\rreturn \u0026quot;home\u0026quot;;\r}\r}\r   java/jpabook/jpashop/controller/MemberController.java\n  MemberController.java \rpackage jpabook.jpashop.controller;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.dto.MemberForm;\rimport jpabook.jpashop.service.MemberService;\rimport lombok.RequiredArgsConstructor;\rimport lombok.extern.slf4j.Slf4j;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.validation.BindingResult;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.PostMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.ui.Model;\rimport javax.validation.Valid;\rimport java.util.List;\r@Controller\r@RequiredArgsConstructor\r@Slf4j\rpublic class MemberController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\rprivate final MemberService memberService;\r@GetMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembersForm(Model modal){\rlog.info(\u0026quot;call get members/new\u0026quot;);\rmodal.addAttribute(\u0026quot;memberForm\u0026quot;, new MemberForm());\rreturn \u0026quot;members/newMembersForm\u0026quot;;\r}\r@PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm, BindingResult result, Model modal){\rlog.info(\u0026quot;call post members/new\u0026quot;);\rif(result.hasErrors()){\rreturn \u0026quot;members/newMembersForm\u0026quot;;\r}\rMember newMember = new Member();\rnewMember.setName(memberForm.getName());\rnewMember.setAddress(memberForm.getAddress());\rmemberService.join(newMember);\rreturn \u0026quot;redirect:/\u0026quot;; //첫번째 화면으로 이동\r}\r@GetMapping(\u0026quot;/members\u0026quot;)\rpublic String memberList(Model modal){\rlog.info(\u0026quot;call get members\u0026quot;);\rList\u0026lt;Member\u0026gt; members = memberService.findMembers();\rmodal.addAttribute(\u0026quot;members\u0026quot;, members);\rreturn \u0026quot;members/memberList\u0026quot;;\r}\r}\r  뷰  resources/templates/fragments/bodyHeader.html\n  bodyHeader.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;header\u0026quot; th:fragment=\u0026quot;bodyHeader\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;nav nav-pills pull-right\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;h3 class=\u0026quot;text-muted\u0026quot;\u0026gt;HELLO SHOP\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r   resources/templates/fragments/footer.html\n  footer.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;footer\u0026quot; th:fragment=\u0026quot;footer\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026amp;copy; Hello Shop V2\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r   resources/templates/fragments/header.html\n  header.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:fragment=\u0026quot;header\u0026quot;\u0026gt;\r\u0026lt;!-- Required meta tags --\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, shrink-to-fit=no\u0026quot;\u0026gt;\r\u0026lt;!-- Bootstrap CSS --\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/css/bootstrap.min.css\u0026quot; integrity=\u0026quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;!-- Custom styles for this template --\u0026gt;\r\u0026lt;link href=\u0026quot;/css/jumbotron-narrow.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r   resources/templates/home.html\n  home.html \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot; /\u0026gt;\r\u0026lt;div class=\u0026quot;jumbotron\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;HELLO SHOP\u0026lt;/h1\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;회원 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members/new\u0026quot;\u0026gt;회원 가입\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members\u0026quot;\u0026gt;회원 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;상품 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items/new\u0026quot;\u0026gt;상품 등록\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items\u0026quot;\u0026gt;상품 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;주문 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/order\u0026quot;\u0026gt;상품 주문\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/orders\u0026quot;\u0026gt;주문 내역\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r   resources/templates/members/newMembersForm.html\n  newMembersForm.html \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot; /\u0026gt;\r\u0026lt;style\u0026gt;\r.fieldError {\rborder-color: #bd2130;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot;/\u0026gt;\r\u0026lt;form role=\u0026quot;form\u0026quot; action=\u0026quot;/members/new\u0026quot; th:object=\u0026quot;${memberForm}\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;name\u0026quot;\u0026gt;이름\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{name}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;이름을 입력하세요\u0026quot;\rth:class=\u0026quot;${#fields.hasErrors('name')}? 'form-control fieldError' : 'form-control'\u0026quot;\u0026gt;\r\u0026lt;p th:if=\u0026quot;${#fields.hasErrors('name')}\u0026quot; th:errors=\u0026quot;*{name}\u0026quot;\u0026gt;Incorrect date\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;city\u0026quot;\u0026gt;도시\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{city}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;도시를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;street\u0026quot;\u0026gt;거리\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{street}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;거리를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;zipcode\u0026quot;\u0026gt;우편번호\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{zipcode}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;우편번호를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r   resources/templates/members/memberList.html\n  memberList.html \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot; /\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot; /\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;table class=\u0026quot;table table-striped\u0026quot;\u0026gt;\r\u0026lt;thead\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;이름\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;도시\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;주소\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;우편번호\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/thead\u0026gt;\r\u0026lt;tbody\u0026gt;\r\u0026lt;tr th:each=\u0026quot;member : ${members}\u0026quot;\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.id}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.name}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.address?.city}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.address?.street}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.address?.zipcode}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tbody\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  리소스  bootstrap-4.3.1-dist.zip\n 테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r test/java/jpabook/jpashop/service/OrderServiceTest.java\n  OrderServiceTest.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.domain.OrderStatus;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\rclass OrderServiceTest {\r@Autowired ItemRepository itemRepository;\r@Autowired MemberRepository memberRepository;\r@Autowired OrderRepository orderRepository;\r@Autowired OrderService orderService;\r@Autowired EntityManager em;\r@Test\rpublic void 상품주문() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), book.getId(), orderCount);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.ORDER, getOrder.getStatus(), \u0026quot;상품 주문시 상태는 ORDER\u0026quot;);\rassertEquals( 1, getOrder.getOrderItems().size(), \u0026quot;주문한 상품 종류 수가 일치해야한다.\u0026quot;);\rassertEquals( 100000 * orderCount, getOrder.getTotalPrice(), \u0026quot;주문 가격은 가격 * 수량이다.\u0026quot;);\rassertEquals( stockQuantity-orderCount, book.getStockQuantity(), \u0026quot;주문 수량만큼 재고가 줄어야 한다.\u0026quot;);\r}\r@Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 11;\rassertThrows(NotEnoughStockException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r@Test\rpublic void 주문취소() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), item.getId(), orderCount);\r//when\rorderService.cancelOrder(orderId);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.CANCEL, getOrder.getStatus(), \u0026quot;상품 주문 취소시 상태는 CANCEL\u0026quot;);\rassertEquals( 10, item.getStockQuantity(), \u0026quot;주문이 취소된 상품은 그만큼 재고가 증가해야한다.\u0026quot;);\r}\rprivate Member createMember() {\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;, \u0026quot;123-123\u0026quot;));\rem.persist(member);\rreturn member;\r}\rprivate Book createBook(String name, int price, int stockQuantity) {\rBook book = new Book();\rbook.setName(name);\rbook.setPrice(price);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rreturn book;\r}\r}\r \t상품구분을 선택하기 전 초기화면 상품구분을 앨범 선택 상품구분을 책 선택 상품구분을 영화 선택 참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 상품 등록 화면 개발","id":0,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 상품 등록 화면 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/product-register-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   홈 화면과 레이아웃 회원 리스트   MemberController.java - /members Mapping 추가\n  @GetMapping(\u0026quot;/members\u0026quot;)\rpublic String memberList(Model modal){\rlog.info(\u0026quot;call get members\u0026quot;);\rList\u0026lt;Member\u0026gt; members = memberService.findMembers();\rmodal.addAttribute(\u0026quot;members\u0026quot;, members);\rreturn \u0026quot;members/memberList\u0026quot;;\r}\r  resources/templates/members/memberList.html\n \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot; /\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot; /\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;table class=\u0026quot;table table-striped\u0026quot;\u0026gt;\r\u0026lt;thead\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;이름\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;도시\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;주소\u0026lt;/th\u0026gt;\r\u0026lt;th\u0026gt;우편번호\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/thead\u0026gt;\r\u0026lt;tbody\u0026gt;\r\u0026lt;tr th:each=\u0026quot;member : ${members}\u0026quot;\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.id}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.name}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.address?.city}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.address?.street}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${member.address?.zipcode}\u0026quot;\u0026gt;\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tbody\u0026gt;\r\u0026lt;/table\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  ?.city}\"   소스를 보시면 타임리프 문법중 address 하고 ?가 있는데, 이것은 타임리프의 기능으로 city가 null 이면 출력을 하지 않는 것입니다. null인 경우 nullPointException이 나오는데 이것을 if로 있는지 없는지 체크 하고 있는경우 없는경우 작성하다 보면 지저분해지는 것을 간편하게 사용할 수 있습니다.\n 추가   public String newMembers(@Valid Member member, BindingResult result){ 이런 식으로 바로 Member 엔티티로 받지 않는 이유는 Order와 같은 추가가 필요한 데이터들이나\n  벨리데이션을 엔티티에서 하게되면, 소스가 지저분해 지고 화면에서의 벨리데이션과 엔티티에서의 벨리데이션을 분리 하지 못하기 때문에 추후 확장을 위해 분리하는 것을 권장드립니다.\n  엔티티에 불필요한 화면에 대한 로직이 섞일 경우 화면을 수정했는데, 핵심 비즈니스 로직이 안돌거나 핵심 비즈니스 로직을 수정했는데 화면이 깨지는 눈물나는 사태가 발생할 수 있습니다.\n  또한 현재 예제에서 회원 리스트를 조회후 Member엔티티로 바로 전달하였는데, 이또한 Member엔티티가 아니라 DTO 객체를 통해 전달 하는게 좋습니다.\n API를 만들때 절대로 엔티티(Entity)를 반환하면 안되는 이유  API를 만들때 절대로 엔티티(Entity)를 반환하면 안되는 이유는 Member 엔티티에 Password를 추가하게 되면 Password가 그대로 노출되는 문제가 있습니다.\n  엔티티의 로직을 변경하게 되면 API Spec이 변경되어 기존과 전혀 다른 동작을 할 수도 있습니다.\n 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.dto.OrderSearch;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport org.springframework.util.StringUtils;\rimport javax.persistence.EntityManager;\rimport javax.persistence.TypedQuery;\rimport javax.persistence.criteria.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\rpublic List\u0026lt;Order\u0026gt; findAllByString(OrderSearch orderSearch){\rString jpql = \u0026quot;select o from Order o left join o.member m\u0026quot;;\rboolean isFirstCondition = true;\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;o.status = :status\u0026quot;;\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;m.name like :name\u0026quot;;\r}\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(jpql, Order.class)\r.setMaxResults(1000);\r//주문 상태 검색 setParameter\rif(orderSearch.getOrderStatus() != null){\rquery.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus());\r}\r//회원 이름 검색 setParameter\rif(StringUtils.hasText(orderSearch.getMemberName())){\rquery.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName());\r}\rreturn query.getResultList();\r}\r/**\r* JPA Criteria\r* */\rpublic List\u0026lt;Order\u0026gt; findAllByCriteria(OrderSearch orderSearch){\rCriteriaBuilder cb = em.getCriteriaBuilder(); //엔티티 매니저에서 CriteriaBuilder를 가져옴\rCriteriaQuery\u0026lt;Order\u0026gt; cq = cb.createQuery(Order.class); //CriteriaQuery 생성\rRoot\u0026lt;Order\u0026gt; o = cq.from(Order.class); // o를 Alias로 Root 생성\rJoin\u0026lt;Object, Object\u0026gt; m = o.join(\u0026quot;member\u0026quot;, JoinType.INNER); // m을 Alias로 join 한 Member 생성\rList\u0026lt;Predicate\u0026gt; criteria = new ArrayList\u0026lt;\u0026gt;(); // 동적 쿼리에 대한 컨디션 조합을 배열을 통해 만들 수 있습니다.\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rPredicate status = cb.equal(o.get(\u0026quot;status\u0026quot;), orderSearch.getOrderStatus());\rcriteria.add(status);\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rPredicate name = cb.like(m.\u0026lt;String\u0026gt;get(\u0026quot;name\u0026quot;), \u0026quot;%\u0026quot;+orderSearch.getMemberName()+\u0026quot;%\u0026quot;);\rcriteria.add(name);\r}\rcq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(cq).setMaxResults(1000);\rreturn query.getResultList();\r}\r/**\r* Querydsl\r* */\r// public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r   java/jpabook/jpashop/service/OrderService.java\n  OrderService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.*;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r/**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r/**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r}\r   java/jpabook/jpashop/dto/OrderSearch.java\n  OrderSearch.java \rpackage jpabook.jpashop.dto;\rimport jpabook.jpashop.domain.OrderStatus;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class OrderSearch {\rprivate String memberName; // 회원 이름\rprivate OrderStatus orderStatus; //주문 상태 [ORDER, CANCEL]\r}\r   java/jpabook/jpashop/dto/MemberForm.java\n  MemberForm.java \rpackage jpabook.jpashop.dto;\rimport jpabook.jpashop.domain.Address;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.validation.constraints.NotEmpty;\r@Getter @Setter\rpublic class MemberForm {\r@NotEmpty(message = \u0026quot;회원 이름은 필수 입니다.\u0026quot;)\rprivate String name;\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic Address getAddress(){\rreturn new Address(this.city, this.street, this.getZipcode());\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;MemberForm{\u0026quot; +\r\u0026quot;name='\u0026quot; + name + '\\'' +\r\u0026quot;, city='\u0026quot; + city + '\\'' +\r\u0026quot;, street='\u0026quot; + street + '\\'' +\r\u0026quot;, zipcode='\u0026quot; + zipcode + '\\'' +\r'}';\r}\r}\r  컨트롤러  java/jpabook/jpashop/HelloController.java\n  HelloController.java \rpackage jpabook.jpashop;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.ui.Model;\rimport org.springframework.web.bind.annotation.GetMapping;\r@Controller\rpublic class HelloController {\r@GetMapping(\u0026quot;hello\u0026quot;) // hello 라는 응답을 받으면\rpublic String hello(Model model){\rmodel.addAttribute(\u0026quot;data\u0026quot;, \u0026quot;hello !!\u0026quot;); // addAttribute data의 값에 \u0026quot;hello !!\u0026quot; 를 넣어서\rSystem.out.println(1121);\rreturn \u0026quot;hello\u0026quot;; /* view 라는 페이지를 오픈*/\r}\r}\r   java/jpabook/jpashop/controller/HomeController.java\n  HomeController.java \rpackage jpabook.jpashop.controller;\rimport lombok.extern.slf4j.Slf4j;\rimport org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.servlet.ModelAndView;\r@Controller\r@Slf4j\rpublic class HomeController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\r@RequestMapping(\u0026quot;/\u0026quot;)\rpublic String Home(){\rlog.info(\u0026quot;home controller\u0026quot;);\rreturn \u0026quot;home\u0026quot;;\r}\r}\r   java/jpabook/jpashop/controller/MemberController.java\n  MemberController.java \rpackage jpabook.jpashop.controller;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.dto.MemberForm;\rimport jpabook.jpashop.service.MemberService;\rimport lombok.RequiredArgsConstructor;\rimport lombok.extern.slf4j.Slf4j;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.validation.BindingResult;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.PostMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.ui.Model;\rimport javax.validation.Valid;\r@Controller\r@RequiredArgsConstructor\r@Slf4j\rpublic class MemberController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\rprivate final MemberService memberService;\r@GetMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembersForm(Model modal){\rlog.info(\u0026quot;/members/new\u0026quot;);\rmodal.addAttribute(\u0026quot;memberForm\u0026quot;, new MemberForm());\rreturn \u0026quot;members/newMembersForm\u0026quot;;\r}\r@PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm, BindingResult result){\rif(result.hasErrors()){\rreturn \u0026quot;members/newMembersForm\u0026quot;;\r}\rMember newMember = new Member();\rnewMember.setName(memberForm.getName());\rnewMember.setAddress(memberForm.getAddress());\rmemberService.join(newMember);\rreturn \u0026quot;redirect:/\u0026quot;; //첫번째 화면으로 이동\r}\r}\r  뷰  resources/templates/fragments/bodyHeader.html\n  bodyHeader.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;header\u0026quot; th:fragment=\u0026quot;bodyHeader\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;nav nav-pills pull-right\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;h3 class=\u0026quot;text-muted\u0026quot;\u0026gt;HELLO SHOP\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r   resources/templates/fragments/footer.html\n  footer.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;footer\u0026quot; th:fragment=\u0026quot;footer\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026amp;copy; Hello Shop V2\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r   resources/templates/fragments/header.html\n  header.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:fragment=\u0026quot;header\u0026quot;\u0026gt;\r\u0026lt;!-- Required meta tags --\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, shrink-to-fit=no\u0026quot;\u0026gt;\r\u0026lt;!-- Bootstrap CSS --\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/css/bootstrap.min.css\u0026quot; integrity=\u0026quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;!-- Custom styles for this template --\u0026gt;\r\u0026lt;link href=\u0026quot;/css/jumbotron-narrow.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r   resources/templates/home.html\n  home.html \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot; /\u0026gt;\r\u0026lt;div class=\u0026quot;jumbotron\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;HELLO SHOP\u0026lt;/h1\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;회원 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members/new\u0026quot;\u0026gt;회원 가입\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members\u0026quot;\u0026gt;회원 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;상품 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items/new\u0026quot;\u0026gt;상품 등록\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items\u0026quot;\u0026gt;상품 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;주문 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/order\u0026quot;\u0026gt;상품 주문\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/orders\u0026quot;\u0026gt;주문 내역\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r   resources/templates/members/newMembersForm.html\n  newMembersForm.html \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot; /\u0026gt;\r\u0026lt;style\u0026gt;\r.fieldError {\rborder-color: #bd2130;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot;/\u0026gt;\r\u0026lt;form role=\u0026quot;form\u0026quot; action=\u0026quot;/members/new\u0026quot; th:object=\u0026quot;${memberForm}\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;name\u0026quot;\u0026gt;이름\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{name}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;이름을 입력하세요\u0026quot;\rth:class=\u0026quot;${#fields.hasErrors('name')}? 'form-control fieldError' : 'form-control'\u0026quot;\u0026gt;\r\u0026lt;p th:if=\u0026quot;${#fields.hasErrors('name')}\u0026quot; th:errors=\u0026quot;*{name}\u0026quot;\u0026gt;Incorrect date\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;city\u0026quot;\u0026gt;도시\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{city}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;도시를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;street\u0026quot;\u0026gt;거리\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{street}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;거리를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;zipcode\u0026quot;\u0026gt;우편번호\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{zipcode}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;우편번호를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  리소스  bootstrap-4.3.1-dist.zip\n 테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r test/java/jpabook/jpashop/service/OrderServiceTest.java\n  OrderServiceTest.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.domain.OrderStatus;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\rclass OrderServiceTest {\r@Autowired ItemRepository itemRepository;\r@Autowired MemberRepository memberRepository;\r@Autowired OrderRepository orderRepository;\r@Autowired OrderService orderService;\r@Autowired EntityManager em;\r@Test\rpublic void 상품주문() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), book.getId(), orderCount);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.ORDER, getOrder.getStatus(), \u0026quot;상품 주문시 상태는 ORDER\u0026quot;);\rassertEquals( 1, getOrder.getOrderItems().size(), \u0026quot;주문한 상품 종류 수가 일치해야한다.\u0026quot;);\rassertEquals( 100000 * orderCount, getOrder.getTotalPrice(), \u0026quot;주문 가격은 가격 * 수량이다.\u0026quot;);\rassertEquals( stockQuantity-orderCount, book.getStockQuantity(), \u0026quot;주문 수량만큼 재고가 줄어야 한다.\u0026quot;);\r}\r@Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 11;\rassertThrows(NotEnoughStockException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r@Test\rpublic void 주문취소() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), item.getId(), orderCount);\r//when\rorderService.cancelOrder(orderId);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.CANCEL, getOrder.getStatus(), \u0026quot;상품 주문 취소시 상태는 CANCEL\u0026quot;);\rassertEquals( 10, item.getStockQuantity(), \u0026quot;주문이 취소된 상품은 그만큼 재고가 증가해야한다.\u0026quot;);\r}\rprivate Member createMember() {\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;, \u0026quot;123-123\u0026quot;));\rem.persist(member);\rreturn member;\r}\rprivate Book createBook(String name, int price, int stockQuantity) {\rBook book = new Book();\rbook.setName(name);\rbook.setPrice(price);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rreturn book;\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 회원 목록 화면 개발","id":1,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 회원 목록 화면 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/member-list-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   홈 화면과 레이아웃 회원 등록  Member Controller 회원가입 페이지 이동(get) 매핑 추가  java/jpabook/jpashop/controller/MemberController.java\n package jpabook.jpashop.controller;\rimport jpabook.jpashop.dto.MemberForm;\rimport jpabook.jpashop.service.MemberService;\rimport lombok.RequiredArgsConstructor;\rimport lombok.extern.slf4j.Slf4j;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.ui.Model;\r@Controller\r@RequiredArgsConstructor\r@Slf4j\rpublic class MemberController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\rprivate final MemberService memberService;\r@GetMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembersForm(Model modal){\rlog.info(\u0026quot;/members/new\u0026quot;);\rmodal.addAttribute(\u0026quot;memberForm\u0026quot;, new MemberForm());\rreturn \u0026quot;members/newMembersForm\u0026quot;;\r}\r}\r  java/jpabook/jpashop/dto 데이터를 전송할 객체를 관리할 패키지를 생성\n  기존에 OrderSearch도 java/jpabook/jpashop/dto 로 위치 변경\n  java/jpabook/jpashop/dto/MemberForm.java\n package jpabook.jpashop.dto;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.validation.constraints.NotEmpty;\r@Getter @Setter\rpublic class MemberForm {\r@NotEmpty(message = \u0026quot;회원 이름은 필수 입니다.\u0026quot;)\rprivate String name;\rprivate String city;\rprivate String street;\rprivate String zipcode;\r}\r  스프링 부트에서 유효성 검사를 위해 사용하는 어노테이션\n  @NotEmpty 를 사용하려는데, IntelliJ 에서 자동완성으로 뜨지 않고 오류를 뱉는다.\n  스프링 부트 2.2 이하는 javax.validation.constraints 패키지를 포함하고 있지만 스프링 부트 2.3 이상은 따로 의존성을 추가해주어야 한다.\n \timplementation 'org.springframework.boot:spring-boot-starter-validation'\r 회원가입 입력 폼 뷰 생성  resources/templates/members/newMembersForm.html\n \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot; /\u0026gt;\r\u0026lt;style\u0026gt;\r.fieldError {\rborder-color: #bd2130;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot;/\u0026gt;\r\u0026lt;form role=\u0026quot;form\u0026quot; action=\u0026quot;/members/new\u0026quot; th:object=\u0026quot;${memberForm}\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;name\u0026quot;\u0026gt;이름\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{name}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;이름을 입력하세요\u0026quot;\rth:class=\u0026quot;${#fields.hasErrors('name')}? 'form-control fieldError' : 'form-control'\u0026quot;\u0026gt;\r\u0026lt;p th:if=\u0026quot;${#fields.hasErrors('name')}\u0026quot; th:errors=\u0026quot;*{name}\u0026quot;\u0026gt;Incorrect date\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;city\u0026quot;\u0026gt;도시\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{city}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;도시를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;street\u0026quot;\u0026gt;거리\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{street}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;거리를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label th:for=\u0026quot;zipcode\u0026quot;\u0026gt;우편번호\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{zipcode}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;우편번호를 입력하세요\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  Browser 소스보기\n \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;!-- Required meta tags --\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, shrink-to-fit=no\u0026quot;\u0026gt;\r\u0026lt;!-- Bootstrap CSS --\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/css/bootstrap.min.css\u0026quot; integrity=\u0026quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;!-- Custom styles for this template --\u0026gt;\r\u0026lt;link href=\u0026quot;/css/jumbotron-narrow.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;style\u0026gt;\r.fieldError {\rborder-color: #bd2130;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;header\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;nav nav-pills pull-right\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;h3 class=\u0026quot;text-muted\u0026quot;\u0026gt;HELLO SHOP\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;form role=\u0026quot;form\u0026quot; action=\u0026quot;/members/new\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label for=\u0026quot;name\u0026quot;\u0026gt;이름\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;이름을 입력하세요\u0026quot; id=\u0026quot;name\u0026quot; name=\u0026quot;name\u0026quot; value=\u0026quot;\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label for=\u0026quot;city\u0026quot;\u0026gt;도시\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;도시를 입력하세요\u0026quot; id=\u0026quot;city\u0026quot; name=\u0026quot;city\u0026quot; value=\u0026quot;\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label for=\u0026quot;street\u0026quot;\u0026gt;거리\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;거리를 입력하세요\u0026quot; id=\u0026quot;street\u0026quot; name=\u0026quot;street\u0026quot; value=\u0026quot;\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt;\r\u0026lt;label for=\u0026quot;zipcode\u0026quot;\u0026gt;우편번호\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;우편번호를 입력하세요\u0026quot; id=\u0026quot;zipcode\u0026quot; name=\u0026quot;zipcode\u0026quot; value=\u0026quot;\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;div class=\u0026quot;footer\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026amp;copy; Hello Shop V2\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r    타임리프에서 작성한 코드를 실행시키면 아래와 같이 랜더링 되어 화면에서 볼 수 있습니다.\n    타임리프에서 입력 폼을 사용 하는 것은 아래와 같습니다.\n thymeleaf 입력 폼 사용법   th:object : 커맨드 객체를 지정한다. ex) th:object=\u0026quot;${memberForm}\u0026quot; controller 에서 modal.addAttribute(\u0026ldquo;memberForm\u0026rdquo;, new MemberForm()); 넘겨줌     {\u0026lsquo;필드명\u0026rsquo;} : th:object 에서 선택한 객체에 접근한다.\nth:field=\u0026quot;{name}\u0026quot;     th:field : HTML 태그의 id, name, value 속성을 자동으로 변환   \u0026lt;!-- before --\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{name}\u0026quot; /\u0026gt;\r\u0026lt;!-- after --\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;name\u0026quot; name=\u0026quot;name\u0026quot; th:value=\u0026quot;*{name}\u0026quot;/\u0026gt;\r Member Controller 회원가입 처리(Post) 추가  회원가입 입력 폼에서 submit 시 호출할 action(url)을 수행할 메소드 생성\n  MemberController.java - @PostMapping(\u0026quot;/members/new\u0026quot;) 추가\n \r@PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm){ //@Valid를 추가해 입력받은 파라미터를 벨리데이션 체크를 합니다.\rAddress memberAddress = new Address(memberForm.getCity(), memberForm.getStreet(), memberForm.getZipcode());\rMember newMember = new Member();\rnewMember.setName(memberForm.getName());\rnewMember.setAddress(memberAddress);\rmemberService.join(newMember);\rreturn \u0026quot;redirect:/\u0026quot;; //첫번째 화면으로 이동\r}\r  입력받은 MemberFrom에서 Address와 Member를 생성할 데이터를 getter로 찾아와 생성을 다 해주었는데, MemberForm에서 Addres나 Member를 생성하여 반환할 수 도 있습니다.\n    MemberForm.java\n  public Address getNewAddress(){\rreturn new Address(this.city, this.street, this.getZipcode());\r}\r    @PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm){ Member newMember = new Member();\rnewMember.setName(memberForm.getName());\rnewMember.setAddress(memberForm.getAddress());\rmemberService.join(newMember);\rreturn \u0026quot;redirect:/\u0026quot;; //첫번째 화면으로 이동\r}\r  조금더 깔끔해져 가독성이 좋아졌습니다.\n  정상 등록과 실패 후 벨리데이션 체크가 되는지 확인해 보겠습니다.\n 동작 테스트 회원등록 성공  데이터베이스에서 조회 시 회원이 잘 등록된 것을 확인 할 수 있습니다.\n 회원등록 실패  회원의 이름을 공백으로 하여 회원 등록을 해 봅니다.\n  Spring에서 기본적으로 제공하는 Whitelabel Error Page가 뜨고,\n  Validation failed for object=\u0026lsquo;memberForm\u0026rsquo;. Error count: 1\n  default message [회원 이름은 필수 입니다.] 등 필수로 요구하는 값이 빠진채 등록요청 된 것을 서버에서 잘 체크하여 오류를 터트린 것을 확인 할 수 있습니다.\n  하지만 오류를 발생 하는 것 보다\n  @PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm, BindingResult result){ // 처리 결과를 담는 객체\rif(result.hasErrors()){\rreturn \u0026quot;members/newMembersForm\u0026quot;; // 바인딩 결과에 오류가 있을 경우 회원가입 입력 폼을 다시 보여줍니다.\r}\rMember newMember = new Member();\rnewMember.setName(memberForm.getName());\rnewMember.setAddress(memberForm.getAddress());\rmemberService.join(newMember);\rreturn \u0026quot;redirect:/\u0026quot;; //첫번째 화면으로 이동\r}\r  BindingResult를 적용하고 난 후 다시 오류를 발생시켜 봅니다.\n  아까 Whitelabel Error Page 터트리던 것보다 세련되게 화면에서 오류가 나지 않게 처리를 할 수 있습니다.\n 벨리데이션 체크 동작   MemberForm.java에서 벨리데이션 체크할 필드에 @NotEmpty(message = \u0026ldquo;벨리데이션 메시지\u0026rdquo;) 추가    @NotEmpty(message = \u0026quot;회원 이름은 필수 입니다.\u0026quot;)\rprivate String name;\r   MemberController.java에서 입력받은 파라미터에 @Valid 추가    @PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm, BindingResult result){\r   MemberController.java에 파라미터로 BindingResult 받아 오류가 있으면 기존화면으로 이동    @PostMapping(\u0026quot;/members/new\u0026quot;)\rpublic String newMembers(@Valid MemberForm memberForm, BindingResult result){\rif(result.hasErrors()){\rreturn \u0026quot;members/newMembersForm\u0026quot;;\r}\r   타임리프에서 BindingResult를 사용하여 오류 출력    \u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{name}\u0026quot; class=\u0026quot;form-control\u0026quot; placeholder=\u0026quot;이름을 입력하세요\u0026quot;\rth:class=\u0026quot;${#fields.hasErrors('name')}? 'form-control fieldError' : 'form-control'\u0026quot;\u0026gt;\r\u0026lt;p th:if=\u0026quot;${#fields.hasErrors('name')}\u0026quot; th:errors=\u0026quot;*{name}\u0026quot;\u0026gt;Incorrect date\u0026lt;/p\u0026gt;\r  fields.hasErrors에 \u0026lsquo;name\u0026rsquo;을 체크하여 박스의 아웃라인 색상을 빨강으로 변경하고, P 태그에 @NotEmpty(message = \u0026ldquo;벨리데이션 메시지\u0026rdquo;)에 정의된 벨리데이션 메시지를 InnerHtml에 추가 합니다.\n 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.dto.OrderSearch;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport org.springframework.util.StringUtils;\rimport javax.persistence.EntityManager;\rimport javax.persistence.TypedQuery;\rimport javax.persistence.criteria.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\rpublic List\u0026lt;Order\u0026gt; findAllByString(OrderSearch orderSearch){\rString jpql = \u0026quot;select o from Order o left join o.member m\u0026quot;;\rboolean isFirstCondition = true;\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;o.status = :status\u0026quot;;\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;m.name like :name\u0026quot;;\r}\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(jpql, Order.class)\r.setMaxResults(1000);\r//주문 상태 검색 setParameter\rif(orderSearch.getOrderStatus() != null){\rquery.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus());\r}\r//회원 이름 검색 setParameter\rif(StringUtils.hasText(orderSearch.getMemberName())){\rquery.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName());\r}\rreturn query.getResultList();\r}\r/**\r* JPA Criteria\r* */\rpublic List\u0026lt;Order\u0026gt; findAllByCriteria(OrderSearch orderSearch){\rCriteriaBuilder cb = em.getCriteriaBuilder(); //엔티티 매니저에서 CriteriaBuilder를 가져옴\rCriteriaQuery\u0026lt;Order\u0026gt; cq = cb.createQuery(Order.class); //CriteriaQuery 생성\rRoot\u0026lt;Order\u0026gt; o = cq.from(Order.class); // o를 Alias로 Root 생성\rJoin\u0026lt;Object, Object\u0026gt; m = o.join(\u0026quot;member\u0026quot;, JoinType.INNER); // m을 Alias로 join 한 Member 생성\rList\u0026lt;Predicate\u0026gt; criteria = new ArrayList\u0026lt;\u0026gt;(); // 동적 쿼리에 대한 컨디션 조합을 배열을 통해 만들 수 있습니다.\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rPredicate status = cb.equal(o.get(\u0026quot;status\u0026quot;), orderSearch.getOrderStatus());\rcriteria.add(status);\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rPredicate name = cb.like(m.\u0026lt;String\u0026gt;get(\u0026quot;name\u0026quot;), \u0026quot;%\u0026quot;+orderSearch.getMemberName()+\u0026quot;%\u0026quot;);\rcriteria.add(name);\r}\rcq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(cq).setMaxResults(1000);\rreturn query.getResultList();\r}\r/**\r* Querydsl\r* */\r// public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r   java/jpabook/jpashop/service/OrderService.java\n  OrderService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.*;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r/**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r/**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r}\r   java/jpabook/jpashop/dto/OrderSearch.java\n  OrderSearch.java \rpackage jpabook.jpashop.dto;\rimport jpabook.jpashop.domain.OrderStatus;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class OrderSearch {\rprivate String memberName; // 회원 이름\rprivate OrderStatus orderStatus; //주문 상태 [ORDER, CANCEL]\r}\r  컨트롤러  java/jpabook/jpashop/HelloController.java\n  HelloController.java \rpackage jpabook.jpashop;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.ui.Model;\rimport org.springframework.web.bind.annotation.GetMapping;\r@Controller\rpublic class HelloController {\r@GetMapping(\u0026quot;hello\u0026quot;) // hello 라는 응답을 받으면\rpublic String hello(Model model){\rmodel.addAttribute(\u0026quot;data\u0026quot;, \u0026quot;hello !!\u0026quot;); // addAttribute data의 값에 \u0026quot;hello !!\u0026quot; 를 넣어서\rSystem.out.println(1121);\rreturn \u0026quot;hello\u0026quot;; /* view 라는 페이지를 오픈*/\r}\r}\r   java/jpabook/jpashop/controller/HomeController.java\n  HomeController.java \rpackage jpabook.jpashop.controller;\rimport lombok.extern.slf4j.Slf4j;\rimport org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.servlet.ModelAndView;\r@Controller\r@Slf4j\rpublic class HomeController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\r@RequestMapping(\u0026quot;/\u0026quot;)\rpublic String Home(){\rlog.info(\u0026quot;home controller\u0026quot;);\rreturn \u0026quot;home\u0026quot;;\r}\r}\r  뷰  resources/templates/fragments/bodyHeader.html\n  bodyHeader.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;header\u0026quot; th:fragment=\u0026quot;bodyHeader\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;nav nav-pills pull-right\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;h3 class=\u0026quot;text-muted\u0026quot;\u0026gt;HELLO SHOP\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r   resources/templates/fragments/footer.html\n  footer.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;footer\u0026quot; th:fragment=\u0026quot;footer\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026amp;copy; Hello Shop V2\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r   resources/templates/fragments/header.html\n  header.html \r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:fragment=\u0026quot;header\u0026quot;\u0026gt;\r\u0026lt;!-- Required meta tags --\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, shrink-to-fit=no\u0026quot;\u0026gt;\r\u0026lt;!-- Bootstrap CSS --\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/css/bootstrap.min.css\u0026quot; integrity=\u0026quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;!-- Custom styles for this template --\u0026gt;\r\u0026lt;link href=\u0026quot;/css/jumbotron-narrow.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r   resources/templates/home.html\n  home.html \r\u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot; /\u0026gt;\r\u0026lt;div class=\u0026quot;jumbotron\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;HELLO SHOP\u0026lt;/h1\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;회원 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members/new\u0026quot;\u0026gt;회원 가입\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members\u0026quot;\u0026gt;회원 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;상품 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items/new\u0026quot;\u0026gt;상품 등록\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items\u0026quot;\u0026gt;상품 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;주문 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/order\u0026quot;\u0026gt;상품 주문\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/orders\u0026quot;\u0026gt;주문 내역\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  리소스  bootstrap-4.3.1-dist.zip\n 테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r test/java/jpabook/jpashop/service/OrderServiceTest.java\n  OrderServiceTest.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.domain.OrderStatus;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\rclass OrderServiceTest {\r@Autowired ItemRepository itemRepository;\r@Autowired MemberRepository memberRepository;\r@Autowired OrderRepository orderRepository;\r@Autowired OrderService orderService;\r@Autowired EntityManager em;\r@Test\rpublic void 상품주문() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), book.getId(), orderCount);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.ORDER, getOrder.getStatus(), \u0026quot;상품 주문시 상태는 ORDER\u0026quot;);\rassertEquals( 1, getOrder.getOrderItems().size(), \u0026quot;주문한 상품 종류 수가 일치해야한다.\u0026quot;);\rassertEquals( 100000 * orderCount, getOrder.getTotalPrice(), \u0026quot;주문 가격은 가격 * 수량이다.\u0026quot;);\rassertEquals( stockQuantity-orderCount, book.getStockQuantity(), \u0026quot;주문 수량만큼 재고가 줄어야 한다.\u0026quot;);\r}\r@Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 11;\rassertThrows(NotEnoughStockException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r@Test\rpublic void 주문취소() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), item.getId(), orderCount);\r//when\rorderService.cancelOrder(orderId);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.CANCEL, getOrder.getStatus(), \u0026quot;상품 주문 취소시 상태는 CANCEL\u0026quot;);\rassertEquals( 10, item.getStockQuantity(), \u0026quot;주문이 취소된 상품은 그만큼 재고가 증가해야한다.\u0026quot;);\r}\rprivate Member createMember() {\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;, \u0026quot;123-123\u0026quot;));\rem.persist(member);\rreturn member;\r}\rprivate Book createBook(String name, int price, int stockQuantity) {\rBook book = new Book();\rbook.setName(name);\rbook.setPrice(price);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rreturn book;\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 회원 등록 화면 개발","id":2,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 회원 등록 화면 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/member-join-view-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   웹 계층 개발  홈 화면과 레이아웃   java/jpabook/jpashop/controller/HomeController.java\n package jpabook.jpashop.controller;\rimport lombok.extern.slf4j.Slf4j;\rimport org.slf4j.Logger;\rimport org.slf4j.LoggerFactory;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.servlet.ModelAndView;\r@Controller\r@Slf4j\rpublic class HomeController {\r//@Slf4j 사용\r//Logger log = LoggerFactory.getLogger(getClass());\r@RequestMapping(\u0026quot;/\u0026quot;)\rpublic String Home(){\rlog.info(\u0026quot;home controller\u0026quot;);\rreturn \u0026quot;home\u0026quot;;\r}\r}\r  Logger는 org.slf4j 사용\n 홈 뷰 화면 작성   해당 강의의 핵심은 JPA를 사용한 애플리케이션이기 때문에 Front 부분은 예제로 사용해 빠르게 진행하도록 하겠습니다.\n  resources/templates/home.html\n \u0026lt;!DOCTYPE HTML\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:replace=\u0026quot;fragments/header :: header\u0026quot;\u0026gt; \u0026lt;!-- JSP의 include 와 비슷한 기능 --\u0026gt;\r\u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/bodyHeader :: bodyHeader\u0026quot; /\u0026gt;\r\u0026lt;div class=\u0026quot;jumbotron\u0026quot;\u0026gt;\r\u0026lt;h1\u0026gt;HELLO SHOP\u0026lt;/h1\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;회원 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members/new\u0026quot;\u0026gt;회원 가입\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-secondary\u0026quot; href=\u0026quot;/members\u0026quot;\u0026gt;회원 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;상품 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items/new\u0026quot;\u0026gt;상품 등록\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-dark\u0026quot; href=\u0026quot;/items\u0026quot;\u0026gt;상품 목록\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;p class=\u0026quot;lead\u0026quot;\u0026gt;주문 기능\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/order\u0026quot;\u0026gt;상품 주문\u0026lt;/a\u0026gt;\r\u0026lt;a class=\u0026quot;btn btn-lg btn-info\u0026quot; href=\u0026quot;/orders\u0026quot;\u0026gt;주문 내역\u0026lt;/a\u0026gt;\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div th:replace=\u0026quot;fragments/footer :: footer\u0026quot; /\u0026gt;\r\u0026lt;/div\u0026gt; \u0026lt;!-- /container --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  home view를 생성 하였으니 실행 시켜 봅시다.\n  java/jpabook/jpashop/JpashopApplication.java 에서 ctrl + shift + F10\n 2022-06-23 23:54:21.514 INFO 25552 --- [nio-8080-exec-1] j.jpashop.controller.HomeController : home controller // controller 호출 2022-06-23 23:54:21.759 ERROR 25552 --- [nio-8080-exec-1] org.thymeleaf.TemplateEngine : [THYMELEAF][http-nio-8080-exec-1] Exception processing template \u0026quot;home\u0026quot;: An error happened during template parsing (template: \u0026quot;class path resource [templates/home.html]\u0026quot;)\rorg.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: \u0026quot;class path resource [templates/home.html]\u0026quot;)\rat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:366) ~[thymeleaf-spring5-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:190) ~[thymeleaf-spring5-3.0.15.RELEASE.jar:3.0.15.RELEASE]\rat org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1401) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1145) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1084) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat javax.servlet.http.HttpServlet.service(HttpServlet.java:655) ~[tomcat-embed-core-9.0.60.jar:4.0.FR]\rat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.18.jar:5.3.18]\rat javax.servlet.http.HttpServlet.service(HttpServlet.java:764) ~[tomcat-embed-core-9.0.60.jar:4.0.FR]\rat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.18.jar:5.3.18]\rat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]\rat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.18.jar:5.3.18]\rat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]\rat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.18.jar:5.3.18]\rat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.18.jar:5.3.18]\rat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:889) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.60.jar:9.0.60]\rat java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]\rCaused by: org.attoparser.ParseException: Error resolving template [fragments/header], template might not exist or might not be accessible by any of the configured Template Resolvers (template: \u0026quot;home\u0026quot; - line 3, col 7)\rat org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\rat org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]\rat org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.15.RELEASE.jar:3.0.15.RELEASE]\r... 48 common frames omitted\rCaused by: org.thymeleaf.exceptions.TemplateInputException: Error resolving template [fragments/header], template might not exist or might not be accessible by any of the configured Template Resolvers (template: \u0026quot;home\u0026quot; - line 3, col 7) // fragments/header를 해결할 수 없다고 오류 ...\r  JSP와 같이 인클루드를 하여 랜더링 하다 해당 파일이 없어 오류를 발생합니다.   resources/templates/fragments/header.html\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;head th:fragment=\u0026quot;header\u0026quot;\u0026gt;\r\u0026lt;!-- Required meta tags --\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, shrink-to-fit=no\u0026quot;\u0026gt;\r\u0026lt;!-- Bootstrap CSS --\u0026gt;\r\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/css/bootstrap.min.css\u0026quot; integrity=\u0026quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;!-- Custom styles for this template --\u0026gt;\r\u0026lt;link href=\u0026quot;/css/jumbotron-narrow.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r  resources/templates/fragments/bodyHeader.html\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;header\u0026quot; th:fragment=\u0026quot;bodyHeader\u0026quot;\u0026gt;\r\u0026lt;ul class=\u0026quot;nav nav-pills pull-right\u0026quot;\u0026gt;\r\u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;Home\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;h3 class=\u0026quot;text-muted\u0026quot;\u0026gt;HELLO SHOP\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r  resources/templates/fragments/footer.html\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;\r\u0026lt;div class=\u0026quot;footer\u0026quot; th:fragment=\u0026quot;footer\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;\u0026amp;copy; Hello Shop V2\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r  다시 에플리케이션을 재기동 해 보면\n  화면이 뜬것이 보입니다.\n 뷰 리소스 등록   https://getbootstrap.com/\n  부트스트랩 홈페이지에 접속해\n  부트스트랩 최신 버전을 받습니다.\n  다운받은 부트스트랩을 resources/static에 넣어줍니다.\n  최신의 부트스트랩 버전과 예제의 스타일이 달라 문제가 있어서 강좌의 버전의 부트스트랩을 첨부 하였습니다.\n bootstrap-4.3.1-dist.zip\n 폴더에 추가후\n  파일을 IntelliJ에서 읽을 수 있게 디스크에서 다시 로드를 하고\n  프로젝트를 재빌드 합니다.\n  이후 새로고침을 하면 스타일이 아래와 같이 적용된 것을 볼 수 있습니다.\n 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport org.springframework.util.StringUtils;\rimport javax.persistence.EntityManager;\rimport javax.persistence.TypedQuery;\rimport javax.persistence.criteria.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\rpublic List\u0026lt;Order\u0026gt; findAllByString(OrderSearch orderSearch){\rString jpql = \u0026quot;select o from Order o left join o.member m\u0026quot;;\rboolean isFirstCondition = true;\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;o.status = :status\u0026quot;;\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;m.name like :name\u0026quot;;\r}\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(jpql, Order.class)\r.setMaxResults(1000);\r//주문 상태 검색 setParameter\rif(orderSearch.getOrderStatus() != null){\rquery.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus());\r}\r//회원 이름 검색 setParameter\rif(StringUtils.hasText(orderSearch.getMemberName())){\rquery.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName());\r}\rreturn query.getResultList();\r}\r/**\r* JPA Criteria\r* */\rpublic List\u0026lt;Order\u0026gt; findAllByCriteria(OrderSearch orderSearch){\rCriteriaBuilder cb = em.getCriteriaBuilder(); //엔티티 매니저에서 CriteriaBuilder를 가져옴\rCriteriaQuery\u0026lt;Order\u0026gt; cq = cb.createQuery(Order.class); //CriteriaQuery 생성\rRoot\u0026lt;Order\u0026gt; o = cq.from(Order.class); // o를 Alias로 Root 생성\rJoin\u0026lt;Object, Object\u0026gt; m = o.join(\u0026quot;member\u0026quot;, JoinType.INNER); // m을 Alias로 join 한 Member 생성\rList\u0026lt;Predicate\u0026gt; criteria = new ArrayList\u0026lt;\u0026gt;(); // 동적 쿼리에 대한 컨디션 조합을 배열을 통해 만들 수 있습니다.\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rPredicate status = cb.equal(o.get(\u0026quot;status\u0026quot;), orderSearch.getOrderStatus());\rcriteria.add(status);\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rPredicate name = cb.like(m.\u0026lt;String\u0026gt;get(\u0026quot;name\u0026quot;), \u0026quot;%\u0026quot;+orderSearch.getMemberName()+\u0026quot;%\u0026quot;);\rcriteria.add(name);\r}\rcq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(cq).setMaxResults(1000);\rreturn query.getResultList();\r}\r/**\r* Querydsl\r* */\r// public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r   java/jpabook/jpashop/service/OrderService.java\n  OrderService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.*;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r/**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r/**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r}\r   java/jpabook/jpashop/dto/OrderSearch.java\n  OrderSearch.java \rpackage jpabook.jpashop.dto;\rimport jpabook.jpashop.domain.OrderStatus;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class OrderSearch {\rprivate String memberName; // 회원 이름\rprivate OrderStatus orderStatus; //주문 상태 [ORDER, CANCEL]\r}\r  테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r test/java/jpabook/jpashop/service/OrderServiceTest.java\n  OrderServiceTest.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.domain.OrderStatus;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\rclass OrderServiceTest {\r@Autowired ItemRepository itemRepository;\r@Autowired MemberRepository memberRepository;\r@Autowired OrderRepository orderRepository;\r@Autowired OrderService orderService;\r@Autowired EntityManager em;\r@Test\rpublic void 상품주문() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), book.getId(), orderCount);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.ORDER, getOrder.getStatus(), \u0026quot;상품 주문시 상태는 ORDER\u0026quot;);\rassertEquals( 1, getOrder.getOrderItems().size(), \u0026quot;주문한 상품 종류 수가 일치해야한다.\u0026quot;);\rassertEquals( 100000 * orderCount, getOrder.getTotalPrice(), \u0026quot;주문 가격은 가격 * 수량이다.\u0026quot;);\rassertEquals( stockQuantity-orderCount, book.getStockQuantity(), \u0026quot;주문 수량만큼 재고가 줄어야 한다.\u0026quot;);\r}\r@Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 11;\rassertThrows(NotEnoughStockException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r@Test\rpublic void 주문취소() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), item.getId(), orderCount);\r//when\rorderService.cancelOrder(orderId);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.CANCEL, getOrder.getStatus(), \u0026quot;상품 주문 취소시 상태는 CANCEL\u0026quot;);\rassertEquals( 10, item.getStockQuantity(), \u0026quot;주문이 취소된 상품은 그만큼 재고가 증가해야한다.\u0026quot;);\r}\rprivate Member createMember() {\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;, \u0026quot;123-123\u0026quot;));\rem.persist(member);\rreturn member;\r}\rprivate Book createBook(String name, int price, int stockQuantity) {\rBook book = new Book();\rbook.setName(name);\rbook.setPrice(price);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rreturn book;\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 웹 계층 개발","id":3,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 웹 계층 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/web-layer-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   주문 검색 기능 개발  JPA에서 동적 쿼리를 어떻게 해결해야 하는가   화면을 보시면 회원명과 주문상태를 검색조건으로 필터링 할 수 있는 기능인 것을 확인 할 수 있습니다.\n회원명이 있으면 회원에 대한 조건을, 상태를 선택하면 선택한 상태 조건을 동적으로 추가하고 제거해야 하기 때문에, 동적쿼리가 필요하게 됩니다.\n  이전에 OrderRepository에 틀을 만들었던 것을 채워보도록 하겠습니다.\n 검색 기능  검색에 필요한\n  java/jpabook/jpashop/repository/OrderSearch.java\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.OrderStatus;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class OrderSearch {\rprivate String memberName; // 회원 이름\rprivate OrderStatus orderStatus; //주문 상태 [ORDER, CANCEL]\r}\r  만약 항상 파라미터가 있다면, 아래와 같은 코드로 검색은 끝나게 됩니다.\n  OrderRepository.java\n public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){\rList\u0026lt;Order\u0026gt; findOrders = em.createQuery(\u0026quot;select o from Order o left join o.member m\u0026quot; +\r\u0026quot; where o.status = :status\u0026quot; +\r\u0026quot; and m.name like :memberName\u0026quot; +\r\u0026quot;\u0026quot;, Order.class)\r.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus())\r.setParameter(\u0026quot;memberName\u0026quot;, orderSearch.getMemberName())\r.getResultList();\rreturn findOrders;\r}\r 검색 결과 수 제한  OrderRepository.java\n public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){\rreturn em.createQuery(\u0026quot;select o from Order o left join o.member m\u0026quot; +\r\u0026quot; where o.status = :status\u0026quot; +\r\u0026quot; and m.name like :name\u0026quot; +\r\u0026quot;\u0026quot;, Order.class)\r.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus())\r.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName())\r.setMaxResults(1000) // 최대 1000건 조회\r.getResultList();\r}\r 페이징 처리  OrderRepository.java\n public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){\rreturn em.createQuery(\u0026quot;select o from Order o left join o.member m\u0026quot; +\r\u0026quot; where o.status = :status\u0026quot; +\r\u0026quot; and m.name like :name\u0026quot; +\r\u0026quot;\u0026quot;, Order.class)\r.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus())\r.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName())\r.setFirstResult(10) // 10페이지 부터 .setMaxResults(1000) // 최대 1000건 조회\r.getResultList();\r}\r  만약 검색 파라미터가 없다고 한다면\n  OrderRepository.java\n  public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){\rreturn em.createQuery(\u0026quot;select o from Order o left join o.member m\u0026quot; +\r// \u0026quot; where o.status = :status\u0026quot; +\r// \u0026quot; and m.name like :name\u0026quot; +\r\u0026quot;\u0026quot;, Order.class)\r//.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus())\r//.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName())\r.setFirstResult(10)\r.setMaxResults(1000)\r.getResultList();\r}\r  해당 소스 처럼 JPQL과 setParameter가 없으면 전체 조회가 될것 같습니다.\n  JPA가 아닌 마이바티스나 아이바티스는 동적쿼리에 대해 비교적 간편히 적용 할 수 있지만, JPA에서 동적쿼리를 어떻게 해야할지 고민에 빠지게 됩니다.\n 1. JPQL을 문자로 동적 쿼리 적용   무식한 방법이지만, 동적 쿼리를 문자열로 만들어 조건에 따라 넣고 빼고 할 수 있지만 너무 복잡하고 조건이 많아진다면 유지보수는 불가능에 가까워지므로 이런 방법이 있다는 것만 확인 하고 넘어가겠습니니다.\n  OrderRepository.java\n  /**\r* String\r* */\rpublic List\u0026lt;Order\u0026gt; findAllByString(OrderSearch orderSearch){\rString jpql = \u0026quot;select o from Order o left join o.member m\u0026quot;;\rboolean isFirstCondition = true;\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;o.status = :status\u0026quot;;\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rif(isFirstCondition){\rjpql += \u0026quot; where\u0026quot;;\risFirstCondition = false;\r}else{\rjpql += \u0026quot; and\u0026quot;;\r}\rjpql += \u0026quot;m.name like :name\u0026quot;;\r}\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(jpql, Order.class)\r.setMaxResults(1000);\r//주문 상태 검색 setParameter\rif(orderSearch.getOrderStatus() != null){\rquery.setParameter(\u0026quot;status\u0026quot;, orderSearch.getOrderStatus());\r}\r//회원 이름 검색 setParameter\rif(StringUtils.hasText(orderSearch.getMemberName())){\rquery.setParameter(\u0026quot;name\u0026quot;, orderSearch.getMemberName());\r}\rreturn query.getResultList();\r}\r  마이바티스, 아이바티스를 사용하는 이유가 이런 동적 쿼리를 편리하게 사용할 수 있기 때문입니다.\n 2. Criteria (JPA 표준) 동적 쿼리 적용   JPA에서 동적 쿼리를 위해 표준으로 만들었지만 실무에서 사용하기 힘든 부분이 있어 이번에도 간략하게 보고 넘어가겠습니다.\n  OrderRepository.java\n  /**\r* JPA Criteria\r* */\rpublic List\u0026lt;Order\u0026gt; findAllByCriteria(OrderSearch orderSearch){\rCriteriaBuilder cb = em.getCriteriaBuilder(); //엔티티 매니저에서 CriteriaBuilder를 가져옴\rCriteriaQuery\u0026lt;Order\u0026gt; cq = cb.createQuery(Order.class); //CriteriaQuery 생성\rRoot\u0026lt;Order\u0026gt; o = cq.from(Order.class); // o를 Alias로 Root 생성\rJoin\u0026lt;Object, Object\u0026gt; m = o.join(\u0026quot;member\u0026quot;, JoinType.INNER); // m을 Alias로 join 한 Member 생성\rList\u0026lt;Predicate\u0026gt; criteria = new ArrayList\u0026lt;\u0026gt;(); // 동적 쿼리에 대한 컨디션 조합을 배열을 통해 만들 수 있습니다.\r//주문 상태 검색\rif(orderSearch.getOrderStatus() != null){\rPredicate status = cb.equal(o.get(\u0026quot;status\u0026quot;), orderSearch.getOrderStatus());\rcriteria.add(status);\r}\r//회원 이름 검색\rif(StringUtils.hasText(orderSearch.getMemberName())){\rPredicate name = cb.like(m.\u0026lt;String\u0026gt;get(\u0026quot;name\u0026quot;), \u0026quot;%\u0026quot;+orderSearch.getMemberName()+\u0026quot;%\u0026quot;);\rcriteria.add(name);\r}\rcq.where(cb.and(criteria.toArray(new Predicate[criteria.size()])));\rTypedQuery\u0026lt;Order\u0026gt; query = em.createQuery(cq).setMaxResults(1000);\rreturn query.getResultList();\r}\r  이전의 문자열로 만든 것보다 동적쿼리를 훨씬 좋은 방식으로 만들 수 있지만, 치명적인 단점을 가지고 있습니다.\n  작성된 Criteria 코드를 봐도 어떤 쿼리가 만들어지는지 한번에 알 수 없기 때문에 유지보수성에 큰 고통을 겪을 것입니다.\n  실무에서 운영 서비스에서 오류가 빵빵 나는데 쿼리를 열어 봤더니 저런 코드로 되어있다\u0026hellip; 과연 빠르게 캐치하고 수정할 수 있을 것인가 고민해 보셔도 될것 같습니다.\n 3. Querydsl 동적 쿼리 적용   이러한 불편한점들을 해결하기 위해 많은 개발자들이 고심한 끝에 Querydsl을 만들었습니다. 이후 더 자세히 다루도록 하겠습니다.\n  /**\r* Querydsl\r* */\rpublic List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){\rQOrder order = QOrder.order;\rQMember member = QMember.member;\rreturn query\r.select(order)\r.from(order)\r.join(order.member, member)\r.where(statusEq(orderSearch.getOrderStatus()),\rnameLike(orderSearch.getMemberName()))\r.limit(1000)\r.fetch();\r}\rprivate BooleanExpression statusEq(OrderStatus statusCond){\rif(statusCond == null){\rreturn null;\r}\rreturn order.status.eq(statusCond);\r}\rprivate BooleanExpression nameLike(String nameCond){\rif(!StringUtils.hasText(nameCond)){\rreturn null;\r}\rreturn member.name.like(nameCond);\r}\r 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\r//public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r   java/jpabook/jpashop/service/OrderService.java\n  OrderService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.*;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r/**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r/**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r}\r  테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r test/java/jpabook/jpashop/service/OrderServiceTest.java\n  OrderServiceTest.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.domain.OrderStatus;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\rclass OrderServiceTest {\r@Autowired ItemRepository itemRepository;\r@Autowired MemberRepository memberRepository;\r@Autowired OrderRepository orderRepository;\r@Autowired OrderService orderService;\r@Autowired EntityManager em;\r@Test\rpublic void 상품주문() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), book.getId(), orderCount);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.ORDER, getOrder.getStatus(), \u0026quot;상품 주문시 상태는 ORDER\u0026quot;);\rassertEquals( 1, getOrder.getOrderItems().size(), \u0026quot;주문한 상품 종류 수가 일치해야한다.\u0026quot;);\rassertEquals( 100000 * orderCount, getOrder.getTotalPrice(), \u0026quot;주문 가격은 가격 * 수량이다.\u0026quot;);\rassertEquals( stockQuantity-orderCount, book.getStockQuantity(), \u0026quot;주문 수량만큼 재고가 줄어야 한다.\u0026quot;);\r}\r@Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\r//when\rint orderCount = 11;\rassertThrows(NotEnoughStockException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r@Test\rpublic void 주문취소() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), item.getId(), orderCount);\r//when\rorderService.cancelOrder(orderId);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.CANCEL, getOrder.getStatus(), \u0026quot;상품 주문 취소시 상태는 CANCEL\u0026quot;);\rassertEquals( 10, item.getStockQuantity(), \u0026quot;주문이 취소된 상품은 그만큼 재고가 증가해야한다.\u0026quot;);\r}\rprivate Member createMember() {\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;, \u0026quot;123-123\u0026quot;));\rem.persist(member);\rreturn member;\r}\rprivate Book createBook(String name, int price, int stockQuantity) {\rBook book = new Book();\rbook.setName(name);\rbook.setPrice(price);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rreturn book;\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] JPA에서 동적 쿼리를 어떻게 해결하는가?","id":4,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 주문 검색 기능 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/order-search-development/"},{"content":"IntelliJ IDEA 단축키 정리  Ctrl + Alt + N - 인라인화  인라인화는 return의 변수와 속성 변수의 이름이 같은경우 return에 속성 변수에 세팅한 코드를 세팅해 간결하게 변경합니다.\n Ctrl + Alt + V 변수 추출하기 (Extract -\u0026gt; Variable)  블록된 리턴 값 있는 메서드를 변수로 추출\n Ctrl + Alt + p 파라미터 추출하기 (Extract -\u0026gt; Parameter)  메서드의 변수를 파라미터로 받아오게 변경\n Ctrl + Alt + m 메서드 추출하기 (Extract -\u0026gt; Method)  해당 블록으로 선택된 로직을 메서드로 생성\n Ctrl + Shift + T - 테스트 코드 작성  MemberService에서 Intelij IDEA의 단축키 Ctrl + Shift + T (이클립스 스타일 시 go to Test 단축키 변경)\n inteliJ Alt + Insert 생성(Generate)   생성자 Getter, Setter equals, Hashcode toString 매서드 재정의 위임 메서드 테스트 저작권 @Autowired 종속성   Ctrl + Alt + S 설정 (Setting) Ctrl + E 최근에 사용한 리소스 참조  [IntelliJ] intellij 유용한 단축키 정리\n ","description":"IntelliJ IDEA 단축키 정리","id":5,"section":"blog","tags":["Intellij","IDEA","IDE"],"title":"IntelliJ IDEA 단축키 정리","uri":"https://offetuoso.github.io/blog/intellij/intellij-shotcut/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   주문 기능 테스트   테스트 할때는 스프링 기능 없이 메소드 하나 하나 단위 테스트 하는 것이 바람직하나 스프링과 JPA가 잘 엮여서 동작하는 것을 테스트 하기 때문에 통합테스트로 작성합니다.\n 테스트 요구사항    상품 주문이 성공해야 한다. 상품을 주문할 때 재고 수량을 초과하면 안 된다. 주문 취소가 성공해야한다.   테스트 코드 작성   ItemService에서 Intelij IDEA의 단축키 Ctrl + Shift + T (이클립스 스타일 시 go to Test 단축키 변경)\n  생성된것을 확인\n  이전에 생성한 tdd + Tab (라이브 템플릿) 사용\n  tdd + Tab (라이브 템플릿)\n 상품주문 테스트  상품주문의 테스트 시나리오는 아래와 같습니다.\n   given  회원 생성 북 아이템 생성       when 3. 주문 생성     then 4. 상품 주문시 상태는 ORDER 5. 주문한 상품 종류 수가 일치해야한다. 6. 주문 가격은 가격 * 수량이다. 7. 주문 수량만큼 재고가 줄어야 한다.   package jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Address;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.domain.Order;\rimport jpabook.jpashop.domain.OrderStatus;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\rclass OrderServiceTest {\r@Autowired ItemRepository itemRepository;\r@Autowired MemberRepository memberRepository;\r@Autowired OrderRepository orderRepository;\r@Autowired OrderService orderService;\r@Autowired EntityManager em;\r@Test\rpublic void 상품주문() throws Exception{\r//given\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;,\u0026quot;123-123\u0026quot;));\rem.persist(member);\rint stockQuantity = 10;\rBook book = new Book();\rbook.setName(\u0026quot;JPA 기본서\u0026quot;);\rbook.setPrice(100000);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rint orderCount = 2;\r//when\rLong orderId = orderService.order(member.getId(), book.getId(), orderCount);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.ORDER, getOrder.getStatus(), \u0026quot;상품 주문시 상태는 ORDER\u0026quot;);\rassertEquals( 1, getOrder.getOrderItems().size(), \u0026quot;주문한 상품 종류 수가 일치해야한다.\u0026quot;);\rassertEquals( 100000 * orderCount, getOrder.getTotalPrice(), \u0026quot;주문 가격은 가격 * 수량이다.\u0026quot;);\rassertEquals( stockQuantity-orderCount, book.getStockQuantity(), \u0026quot;주문 수량만큼 재고가 줄어야 한다.\u0026quot;);\r}\r}\r 상품주문 테스트  회원과 아이템 생성은 동일하게 사용되므로 함수로 추출하여 사용\n  Intellij IDEA 단축키 함수추출 (ctrl + alt + M)\n  Member member = createMember(); //회원1 생성\rint stockQuantity = 10;\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rprivate Member createMember() {\rMember member = new Member();\rmember.setName(\u0026quot;회원1\u0026quot;);\rmember.setAddress(new Address(\u0026quot;서울\u0026quot;, \u0026quot;강변로\u0026quot;, \u0026quot;123-123\u0026quot;));\rem.persist(member);\rreturn member;\r}\rprivate Book createBook(String name, int price, int stockQuantity) {\rBook book = new Book();\rbook.setName(name);\rbook.setPrice(price);\rbook.setStockQuantity(stockQuantity);\rem.persist(book);\rreturn book;\r}\r 테스트 코드에서 Member와 Book 생성 함수로 생성  Member member = createMember();\rBook book = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,10);\r 상품주문_재고수량초과 테스트  상품주문_재고수량초과 테스트 시나리오는 아래와 같습니다.\n   given  회원 생성 북 아이템 생성 (재고 수량 10개)       when 3. 주문 생성 (주문 수량 11개)     then 4. 재고 수량 부족 예외가 발생해야 한다. (성공) 5. 재고 수량 부족 예외가 발생 안하면 실패    강의에서는 Junit4로 테스트 코드가 작성되어있지만, 내가 테스트 코드를 작성한 버전은 Junit5다 보니 예외에 대한 테스트 코드 작성 방법이 달랐다.\n  JUnit4 Exception Test\n @Test(expected = NotEnoughStockException.class)\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 11;\r//when\rorderService.order(member.getId(), item.getId(), orderCount);\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r  JUnit5 Exception Test\n 만약 테스트시 예상과 다른 Exception이 발생되었을때  @Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 11;\r//when\rassertThrows(IllegalStateException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r  console\n Unexpected exception type thrown ==\u0026gt; expected: \u0026lt;java.lang.IllegalStateException\u0026gt; but was: \u0026lt;jpabook.exception.NotEnoughStockException\u0026gt;\r필요 :java.lang.IllegalStateException\r실제 :jpabook.exception.NotEnoughStockException\r\u0026lt;클릭하여 차이점 확인\u0026gt;\r 예상된 NotEnoughStockException이 발생되었을때  @Test\rpublic void 상품주문_재고수량초과() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 11;\r//when\rassertThrows(NotEnoughStockException.class, () -\u0026gt; {\rorderService.order(member.getId(), item.getId(), orderCount);\r});\r//then\r//fail(\u0026quot;재고 수량 부족 예외가 발생해야 한다.\u0026quot;);\r}\r  테스트 통과\n 주문취소 테스트  상품주문_재고수량초과 테스트 시나리오는 아래와 같습니다.\n   given  회원 생성 북 아이템 생성 (재고 수량 10개) 주문 생성 (주문 수량 2개)       when 4. 주문 취소     then 5. 주문 취소 상태가 CANCEL인지 검증 6. 주문 취소 후 주문한 Item의 수량이 다시 10개가 되었는지 검증   @Test\rpublic void 주문취소() throws Exception{\r//given\rMember member = createMember(); //회원1 생성\rint stockQuantity = 10;\rItem item = createBook(\u0026quot;JPA 기본서\u0026quot;,100000,stockQuantity);\rint orderCount = 2;\rLong orderId = orderService.order(member.getId(), item.getId(), orderCount);\r//when\rorderService.cancelOrder(orderId);\r//then\rOrder getOrder = orderRepository.findOne(orderId);\rassertEquals( OrderStatus.CANCEL, getOrder.getStatus(), \u0026quot;상품 주문 취소시 상태는 CANCEL\u0026quot;);\rassertEquals( 10, item.getStockQuantity(), \u0026quot;주문이 취소된 상품은 그만큼 재고가 증가해야한다.\u0026quot;);\r}\r 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\r//public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r   java/jpabook/jpashop/service/OrderService.java\n  OrderService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.*;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport jpabook.jpashop.repository.MemberRepository;\rimport jpabook.jpashop.repository.OrderRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r/**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r/**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r}\r  테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 주문 기능 테스트","id":6,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 주문 기능 테스트","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/order-logic-test-code/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   주문 서비스 개발   java/jpabook/jpashop/service/OrderService.java 생성\n 주문   예제를 간략하게 하기 위해서 Order를 할때 한번에 한개를 주문 하도록 개발을 하였습니다. 여러 물품을 한번에 주문하게 하려면, 화면에서 멀티로 선택하게 되고 각 Order들을 전달받아 주문을 생성해야합니다.\n  OrderService.java - 주문\n @Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor\rpublic class OrderService {\rprivate final OrderRepository orderRepository;\rprivate final MemberRepository memberRepository;\rprivate final ItemRepository itemRepository;\r/**\r* 주문\r*/\r@Transactional\rpublic Long order(Long memberId, Long itemId, int count){\r// 엔티티 조회\rMember member = memberRepository.findOne(memberId);\rItem item = itemRepository.findOne(itemId);\r// 배송정보 생성\rDelivery delivery = new Delivery();\rdelivery.setAddress(member.getAddress());\rdelivery.setStatus(DeliveryStatus.READY);\r// 주문상품 생성\rOrderItem orderItem = OrderItem.createOrderItem(item, item.getPrice(), count);\r// 주문생성\rOrder order = Order.createOrder(member, delivery , orderItem);\r// 주문 저장\rorderRepository.save(order);\rreturn order.getId();\r}\r  주문 화면을 보면, 사용자를 선택하여 memberId, 아이템을 선택해 ItemId 그리고 개수를 입력 받습니다.   입력받은 내역을 id들을 가지고 Member, Item을 조회하고 배송정보를 생성합니다.\n  또한 주문 상품을 생성하고\n  주문을 생성하여 저장합니다.\n  Order만 저장하고 다른 OrderItem과 Delivery는 따로 저장을 하지 않는데요.\n  이는 Order.java에서 cascade = CascadeType.ALL를 orderItems와 delivery에 추가해 두었기 때문입니다.\n CASCADE  Order.java에 보면 orderItems, delivery에 cascade = CascadeType.ALL 옵션이 적용되어있습니다.\n  // mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\r  어디까지 CASCADE를 적용해야 하느냐에 많이들 고민 하지만,\n  Order와 OrderItem, Delivery 정도의 관계에만 사용합니다. OrderItem과 Delivery는 Order에만 사용하며, 동일한 라이프 사이클에서 관리를 해야할 떄 CASCADE를 이용하면 됩니다.\n  즉 다른곳에서 참조하지 않는 프라이빗한 경우 쓰면 도움을 받을 수 있습니다.\n  최초에 개념이 헤깔리는 경우 이러한 기능을 넣지 않고 개발하다가. 리펙토링을 통해 추가하는 방법도 있습니다.\n 취소   /**\r* 취소\r*/\rpublic void cancelOrder(Long orderId){\r// 주문 엔티티 조회\rOrder order = orderRepository.findOne(orderId);\r// 주문 취소\rorder.cancel();\r}\r  취소는 매우 간결하게 작성되었습니다. 비지니스로직을 Order.java에서 구현해 두었기 때문입니다.\n  Order.java\n  /**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r  또 JPA의 장점 중 하나로 Order에서 cancel()을 사용하게 되면 따로 값으 변경이 있지만, 따로 Update를 코드로 작성하지는 않습니다.\n  JPA는 Duty Checking(변경감지)을 통해 수정된 엔티티의 값들을 자동으로 Update 쿼리를 날려줍니다.\n  그렇기 때문에 OrderService에서 각각 조회해서 변경하고, 업데이트를 쿼리를 날려 수정하는 일련의 작업들을 줄일 수 있습니다.\n 검색   검색은 나중에 설명하기 때문에 껍데기만 만들어 둡니다.\n  /**\r* 검색\r*/\r/*public List\u0026lt;Order\u0026gt; findOrders(OrderSearch orderSearch){\rreturn orderRepository.notifyAll(orderSearch);\r}*/\r 도메인 모델 패턴과 트랜잭션 스크립트 패턴   주문 서비스의 주문과 주문 취소 메서드를 보면 비지니스 로직 대부분이 엔티티에 있습니다.\n  서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 합니다.\n  이처럼 엔티티가 비지니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 도메인 모델 패턴(http://martinfowler.com/eaaCatalog/domainModel.html)이라 합니다.\n  반대로 엔티티에는 비지니스 로직이 거의 없고 서비스 계층에서 대부분의 비지니스 로직을 처리하는 것을 트랜잭션 스크립트 패턴(https://martinfowler.com/eaaCatalog/transactionScript.html)이라 합니다\n  도메인 패턴 모델은 ORM을 사용하는 프로젝트에 좀더 객체 지향 프로그램을 할 수 있게 도와주며, 꼭 트랜잭션 스크립트 모델이 나쁘다 잘못되었다는 내용이 아닙니다.\n  하나의 프로젝트에서 양립을 하여 사용하는 경우도 있기 때문에 현재 개발하는 문맥에 따라 선택하면 됩니다.\n 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r//protected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도 // @NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\r@NoArgsConstructor(access = AccessLevel.PROTECTED)\rpublic class OrderItem {\r//protected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도 //@NoArgsConstructor로 대체\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();;\r}\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r   java/jpabook/jpashop/repository/OrderRepository.java\n  OrderRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Order;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class OrderRepository {\rprivate final EntityManager em;\rpublic void save(Order order){\rem.persist(order);\r}\rpublic Order findOne(Long orderId){\rreturn em.find(Order.class, orderId);\r}\r//public List\u0026lt;Order\u0026gt; findAll(OrderSearch orderSearch){}\r}\r  테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 주문 서비스 개발","id":7,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 주문 서비스 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/2-order-service-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   주문 도메인 개발   지금까지 설명했던것 중에 가장 중요한 부분입니다. 비지니스 로직이 서로 얽혀서 돌아가는 것을 JPA와 엔티티를 가지고 어떻게 풀어 내는지 아실 수 있습니다.\n 주문, 주문 상품 엔티티 개발   또 트랜잭션 스크립트 패턴과 도메인 모델 패턴 중 도메인 모델 패턴을 많이 접해 보지 못했을 텐데 예제를 통해 접해 볼 수 있습니다.\n 구현 기능   상품 주문 주문 내역 조회 주문 취소   상품 주문   주문서 작성 사용자를 선택 상품종류를 선택 상품종류를 선택에 따라 상품 콤보박스 변경 상품 선택 주문수량 입력 후 저장  선택한 상품 입력 주문수량 만큼 감소   주문 내역 리스트 이동   주문 내역 조회   주문 내역 추가 주문 내역 검색   주문 취소   주문 상태 변경  주문 수량 만큼 해당 취소 상품 갯수 추가     구현 순서    주문 엔티티, 주문상품 엔티티 개발 주문 리포지토리개발 주문 서비스 개발 주문 검색 기능 개발 주문 기능 테스트   주문 엔티티, 주문상품 엔티티 개발   Order뿐만 아니라 OrderItem, Delivery를 생성해야 하기 때문에 생성 메서드를 Order 엔티티에 생성합니다.\n  생성할때 밖에서 set, set, set 으로 각각의 엔티티를 설정하는것이 아니라 static 메서드를 호출해 한번에 생성합니다.\n 생성 메서드  Order.java - 생성 메서드\n  //== 생성 메서드 ==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r  해당 코드의 스타일이 중요한 점은 주문을 생성할때, 한곳에 기능을 모아 수정시 돌아다니며 수정할 필요가 없습니다.\n  OrderItem.java - 생성 메서드 orderPrice를 item의 가격에서 안가져오고, 파라미터로 따로 받는 이유는 구매 당시의 가격을 받기 위함\n  //==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ OrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\r// 주문 수량만큼 재고를 감소시킴 item.removeStock(count);\rreturn orderItem;\r}\r 비즈니스 로직  이미 배송완료된 상품은 취소가 불가능하다는 체크로직을 엔티티 안에 넣어 관리합니다.\n  Order.java - 비지니스 로직 (주문 취소)\n //==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r  OrderItem.java - 비지니스 로직 (주문 취소)\n  //==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r 조회 로직  Order에서 OrderItem에 가서 주문 수량과 주문 가격을 계산해주는 getTotalPrice()를 생성하고 Order에서 orderItems의 각각의 getTotalPrice()의 합계를 반환합니다.\n  OrderItem.java - 조회 로직 (주문 금액 가져오기)\n  /**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();\r}\r  Order.java - 조회 로직 (전체 주문 가격 조회)\n  //==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r}\r  위의 코드를 좀더 심플하게 변경할 수 있습니다.\n sum()으로 바꾸기 (Replace with sum())  InteliJ 기능을 이용해서 자바 스트림을 이용해 간결하게 변경합니다.\n Alt + Enter - 현재 컨텍스트에 대한 액션을 표시  //==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\rint totalPrice = this.orderItems.stream().mapToInt(OrderItem::getTotalPrice).sum();\rreturn totalPrice;\r}\r Ctrl + Alt + N - 인라인화  인라인화는 return의 변수와 속성 변수의 이름이 같은경우 return에 속성 변수에 세팅한 코드를 세팅해 간결하게 변경합니다.\n  //==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r  Order.java\n package jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r//== 생성 메서드==//\rpublic static Order createOrder(Member member, Delivery delivery, OrderItem... orderItems){ // OrderItem... 여러개를 넘길 수 있음\rOrder order = new Order();\rorder.setMember(member);\rorder.setDelivery(delivery);\rfor (OrderItem orderItem : orderItems){\rorder.addOrderItem(orderItem);\r}\rorder.setStatus(OrderStatus.ORDER);\rorder.setOrderDate(LocalDateTime.now());\rreturn order;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel(){\r// 배송이 완료된 주문은 취소가 불가\rif (delivery.getStatus() == DeliveryStatus.COMP){\rthrow new IllegalStateException(\u0026quot;이미 배송이 완료된 상품은 취소가 불가능합니다.\u0026quot;);\r}\rthis.setStatus(OrderStatus.CANCEL);\rfor (OrderItem orderItem : this.orderItems){\rorderItem.cancel();\r}\r}\r//==조회 로직==//\r/**\r* 전체 주문 가격 조회\r*/\rpublic int getTotalPrice(){\r/*\rint totalPrice = 0;\rfor (OrderItem orderItem : this.orderItems) {\rtotalPrice += orderItem.getTotalPrice();\r}\rreturn totalPrice;\r*/\rreturn this.orderItems.stream()\r.mapToInt(OrderItem::getTotalPrice)\r.sum();\r}\r}\r  OrderItem.java\n package jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r//==생성 메서드==//\rpublic static OrderItem createOrderItem(Item item, int orderPrice, int count){ //orderPrice는 구매 당시의 가격을 받기 위함\rOrderItem orderItem = new OrderItem();\rorderItem.setItem(item);\rorderItem.setOrderPrice(orderPrice);\rorderItem.setCount(count);\ritem.removeStock(count);\rreturn orderItem;\r}\r//==비즈니스 로직==//\r/**\r* 주문 취소\r*/\rpublic void cancel() {\rgetItem().addStock(this.count);\r}\r//==조회 로직==//\r/**\r* 주문상품 전체 가격 조회\r*/\rpublic int getTotalPrice() {\rreturn getOrderPrice() * getCount();\r}\r}\r 생성 메서드 사용 시 생성자 사용 제약   생성 메서드를 사용하게 되면, new를 이용해 엔티티 객체를 생성하는 것을 막아야합니다. 왜냐하면, 다른 코드 스타일로 개발하면 유지보수가 불편할 뿐만 아니라 추가로 컬럼의 변경이 있을때 각각의 코드에서 수정이 필요하기 때문입니다.\n  Order.java\n @Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\rprotected Order() {} //생성자를 사용 불가로 하고 CteateOrder 사용 유도\r  OrderItem.java\n @Entity\r@Getter @Setter\rpublic class OrderItem {\rprotected OrderItem() {} //생성자를 사용 불가로 하고 CteateOrderItem 사용 유도\r  해당 생성자를 protected로 적용하는 것을 Lombok을 통해 더 편리하게 사용 할 수 있습니다.\n @NoArgsConstructor(access = AccessLevel.PROTECTED)\r  만일 누군가 생성자를 통해 Order나 OrderItem을 생성하려 하면, 빨간줄로 오류를 뱉어 내기 때문에, 해당 소스에 가서 확인 후 @NoArgsConstructor(access = AccessLevel.PROTECTED)를 보고 다른 생성 방법을 찾아 개발을 할 수 있을 것 입니다.\n 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r  테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/java/jpabook/jpashop/service/ItemServiceTest.java\n  ItemServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r \r참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 주문 도메인 개발","id":8,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 주문 도메인 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/order-domain-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   상품 기능 테스트  테스트 요구사항    상품등록을 성공해야한다. 음반, 책, 영화 각각 저장하여 성공하여야한다.   테스트 코드 작성   ItemService에서 Intelij IDEA의 단축키 Ctrl + Shift + T (이클립스 스타일 시 go to Test 단축키 변경)\n  생성된것을 확인\n  이전에 생성한 tdd + Tab (라이브 템플릿) 사용\n  tdd + Tab (라이브 템플릿)\n @Test\rpublic void 회원가입() throws Exception{\r//given //when //then }\r   given : 이렇게 주어졌을때 when : 이렇게 하면 then : 이렇게 된다.    아래 링크 참조\n  [스프링부트 JPA 활용] JPA 동작확인\n 상품등록 테스트  상품은 Album, Book, Movie 3가지 종류가 있습니다. 이를 각각 저장해 저장된 엔티티객체와 DB에서 읽어온 객체를 비교해 보도록 하겠습니다.\n  음반 상품등록\n \t@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r  책 상품등록\n \t@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r  영화 상품등록\n \t@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r  test/java/jpabook/jpashop/service/ItemServiceTest.java\n package jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.item.Album;\rimport jpabook.jpashop.domain.item.Book;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.domain.item.Movie;\rimport jpabook.jpashop.repository.ItemRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass ItemServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired ItemRepository itemRepository;\r@Autowired ItemService itemService;\r@Autowired EntityManager em;\r@Test\rpublic void 음반_상품등록() throws Exception{\r//given\rItem item = new Album();\ritem.setName(\u0026quot;멜론 TOP 100\u0026quot;);\r((Album) item).setArtist(\u0026quot;Various Artists\u0026quot;);\r((Album) item).setEtc(\u0026quot;방탄소년단 외 다수\u0026quot;);\ritem.setPrice(20000);\ritem.addStock(50);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 책_상품등록() throws Exception{\r//given\rItem item = new Book();\ritem.setName(\u0026quot;JPA BOOK\u0026quot;);\r((Book) item).setAuthor(\u0026quot;김영한\u0026quot;);\r((Book) item).setIsbn(\u0026quot;11111\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(100);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r@Test\rpublic void 영화_상품등록() throws Exception{\r//given\rItem item = new Movie();\ritem.setName(\u0026quot;쥬라기월드: 도미니언\u0026quot;);\r((Movie) item).setDirector(\u0026quot;콜린 트레보로우\u0026quot;);\r((Movie) item).setActor(\u0026quot;크리스 프랫\u0026quot;);\ritem.setPrice(15000);\ritem.addStock(1000);\r//when\rItem savedItem = itemService.saveItem(item);\r//then\rem.flush();\rassertEquals(item, itemRepository.findOne(savedItem.getId()));\r}\r}\r  console\n \tinsert into item (name, price, stock_quantity, author, isbn, dtype, item_id) values ('JPA BOOK', 15000, 100, '김영한', '11111', 'B', 1);\r2022-06-02 23:39:12.492 INFO 5672 --- [ Test worker] p6spy : #1654180752492 | took 0ms | rollback | connection 4| url jdbc:h2:mem:1b70f279-db65-46bd-a9f3-0b1d472f66ad\rinsert into item (name, price, stock_quantity, artist, etc, dtype, item_id) values ('멜론 TOP 100', 20000, 50, 'Various Artists', '방탄소년단 외 다수', 'A', 2);\r2022-06-02 23:39:12.524 INFO 5672 --- [ Test worker] p6spy : #1654180752524 | took 0ms | rollback | connection 5| url jdbc:h2:mem:1b70f279-db65-46bd-a9f3-0b1d472f66ad\rinsert into item (name, price, stock_quantity, actor, director, dtype, item_id) values ('쥬라기월드: 도미니언', 15000, 1000, '크리스 프랫', '콜린 트레보로우', 'M', 3);\r2022-06-02 23:39:12.540 INFO 5672 --- [ Test worker] p6spy : #1654180752540 | took 0ms | rollback | connection 6| url jdbc:h2:mem:1b70f279-db65-46bd-a9f3-0b1d472f66ad\r  각각 dtype에 맞게 잘 저장된것을 확인 할 수 있습니다. 또한 모든 테스트가 통과된 것을 확인 할 수 있습니다.\n 이전 소스  설정  /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  엔티티  java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  도메인  java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   java/jpabook/jpashop/repository/ItemRepository.java\n  ItemRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r   java/jpabook/jpashop/service/ItemService.java\n  ItemService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.item.Item;\rimport jpabook.jpashop.repository.ItemRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class ItemService {\rprivate final ItemRepository itemRepository;\r@Transactional\rpublic Item saveItem(Item item){\ritemRepository.save(item);\rreturn item; //등록한 엔티티 정보 리턴, api response 리턴 및 test code 검증용\r}\rpublic List\u0026lt;Item\u0026gt; findItems(){\rreturn itemRepository.findAll();\r}\rpublic Item findItem(Long item_id){\rreturn itemRepository.findOne(item_id);\r}\r}\r  테스트  test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 상품 서비스 개발","id":9,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 상품 서비스 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/product-logic-test-code/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   상품 리포지토리 개발  상품 리포지토리   java/jpabook/jpashop/repository/ItemRepository.java\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class ItemRepository {\rprivate final EntityManager em;\rpublic void save(Item item){\rif (item.getId() == null){\rem.persist(item);\r}else{\rem.merge(item);\r}\r}\rpublic Item findOne(Long id){\rreturn em.find(Item.class, id);\r}\rpublic List\u0026lt;Item\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select i from Item i\u0026quot;, Item.class)\r.getResultList();\r}\r}\r  특이한 점은 save 메소드를 구현할때, Id값이 있는지 체크 하여 없으면 persist() 있으면 merge()를 사용하였습니다.\n   persist(entity) : DB에 추가하려면 완전히 새로운 엔티티와 함께 ​​사용해야합니다 (엔티티가 이미 DB에 존재하는 경우 EntityExistsException 발생).     merge(entity) : 엔티티가 분리되어 변경된 경우 엔티티를 영속성 컨텍스트로 되돌리려면 사용되어야합니다.    merge는 이후 웹 어플리케이션 구현할때 더 자세히 설명하도록 하겠습니다.\n  전반적인 문맥을 이해해야 설명하기 더 명확해지기 때문입니다.\n 이전 소스   /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r   java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r   test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 상품 도메인 개발","id":10,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 상품 리포지토리 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/1-product-repository-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   상품 도메인 개발  구현 기능   상품등록 상품 목록 조회 상품 수정   구현 순서   상품 엔티티 개발(비즈니스 로직 추가) 상품 리포지토리 개발 상품 서비스 개발 상품 기능 테스트   상품 엔티티 개발(비즈니스 로직 추가)   Item.java\n package jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\r/**\r* 재고 감소\r* @param quantity\r*/\r}\r  일반적으로 비즈니스 로직에서 수량을 증가하거나 감소시키는 로직을 수행할 때 아이템의 갯수를 가져와 수량을 더한 후 다시 수량을 Set을 통해 변경된 데이터를 적용 시키는 방법으로 했습니다.\n  하지만 객체지향적으로 생각해 보면 데이터를 가지고 있는 곳에 개수를 추가하고 감소하는 비즈니스 로직을 가지고 있는것이 응집력이 더 좋습니다.\n  엔티티 내부에서 해결할 수 있는 비즈니스 로직은 엔티티에서 처리하는 것이 좀더 객체지향적인 개발 방법입니다.\n  Item.java - 재고 증가\n /**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity; //현재 재고수량에 파라미터로 받은 수량을 더합니다.\r}\r  Item.java - 재고 감소\n  /**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity; //파라미터를 뺀 변경된 재고수량\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;); //변경된 재고수량이 0보다 작으면 예외를 던짐\r}\rthis.stockQuantity = restStock;\r}\r 사용자 정의 예외 생성 (Generate Custom Exception)  RuntimeException을 상속받아 메서드들을 오버라이딩 받아 새로 추가한 사용자 정의 예외 생성 NotEnoughStockException를 RuntimeException과 같이 사용\n  java/jpabook/jpashop/exception 폴더 생성 후\n  NotEnoughStockException.java 생성\n  inteliJ Alt + Insert (Generate) - Method Overriding\n  java/jpabook/exception/NotEnoughStockException.java\n public NotEnoughStockException() {\rsuper();\r}\rpublic NotEnoughStockException(String message) {\rsuper(message);\r}\rpublic NotEnoughStockException(String message, Throwable cause) {\rsuper(message, cause);\r}\rpublic NotEnoughStockException(Throwable cause) {\rsuper(cause);\r}\rprotected NotEnoughStockException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {\rsuper(message, cause, enableSuppression, writableStackTrace);\r}\r   package jpabook.jpashop.domain.item;\rimport jpabook.exception.NotEnoughStockException;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r//==비즈니스 로직==//\r/**\r* 재고 증가\r* @param quantity\r*/\rpublic void addStock(int quantity){\rthis.stockQuantity += quantity;\r}\r/**\r* 재고 감소\r* @param quantity\r*/\rpublic void removeStock(int quantity){\rint restStock = this.stockQuantity - quantity;\rif (restStock \u0026lt; 0) {\rthrow new NotEnoughStockException(\u0026quot;need more stock\u0026quot;);\r}\rthis.stockQuantity = restStock;\r}\r}\r 이전 소스   /main/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r \r main/resources/application.yml\n  application.yml \rspring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다.\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r \r java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r   java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r   test/java/jpabook/jpashop/service/MemberServiceTest.java\n  MemberServiceTest.java \rpackage jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r   test/resources/application.properties\n  application.properties \rspring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\rspring.jpa.properties.hibernate.format_sql=true\r   test/resources/application.yml\n  application.yml \rspring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 상품 도메인 개발","id":11,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 상품 도메인 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/product-domain-development/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   회원 기능 테스트  테스트 요구사항    회원가입을 성공해야한다. 회원가입 할 때 같은 이름이 있으면 예외가 발생해야 한다.   테스트 코드 작성   MemberService에서 Intelij IDEA의 단축키 Ctrl + Shift + T (이클립스 스타일 시 go to Test 단축키 변경)\n  생성된것을 확인\n  이전에 생성한 tdd + Tab (라이브 템플릿) 사용\n  tdd + Tab (라이브 템플릿)\n @Test\rpublic void 회원가입() throws Exception{\r//given //when //then }\r   given : 이렇게 주어졌을때 when : 이렇게 하면 then : 이렇게 된다.    아래 링크 참조\n  [스프링부트 JPA 활용] JPA 동작확인\n 회원가입 테스트  java/jpabook/jpashop/service/MemberServiceTest.java\n package jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.junit.jupiter.api.extension.ExtendWith;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.test.context.junit.jupiter.SpringExtension;\rimport org.springframework.test.context.junit4.SpringRunner;\rimport org.springframework.transaction.annotation.Transactional;\rimport static org.hamcrest.CoreMatchers.equalTo;\rimport static org.hamcrest.CoreMatchers.is;\rimport static org.hamcrest.MatcherAssert.assertThat;\r//@RunWith(SpringRunner.class) //Unit4 전용\r@ExtendWith(SpringExtension.class) //Unit5 이후 사용\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r@Autowired MemberService memberService; // 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository; // 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Test\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rassertEquals(member, memberRepository.findOne(savedId));\r}\r}\r  console\n ...\r...\r2022-05-27 23:28:38.297 INFO 1724 --- [ Test worker] j.jpashop.service.MemberServiceTest : Started MemberServiceTest in 5.799 seconds (JVM running for 8.277)\r2022-05-27 23:28:38.455 INFO 1724 --- [ Test worker] o.s.t.c.transaction.TransactionContext : Began transaction (1) for test context [DefaultTestContext@1deb2c43 testClass = MemberServiceTest, testInstance = jpabook.jpashop.service.MemberServiceTest@8aafd70, testMethod = 회원가입@MemberServiceTest, testException = [null], mergedContextConfiguration = [WebMergedContextConfiguration@3bb9efbc testClass = MemberServiceTest, locations = '{}', classes = '{class jpabook.jpashop.JpashopApplication}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true}', contextCustomizers = set[org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@7756c3cd, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@328cf0e1, org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@183e8023, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@67ab1c47, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@14b030a0, org.springframework.boot.test.context.SpringBootTestArgs@1, org.springframework.boot.test.context.SpringBootTestWebEnvironment@30b6ffe0], resourceBasePath = 'src/main/webapp', contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.web.ServletTestExecutionListener.activateListener' -\u0026gt; true, 'org.springframework.test.context.web.ServletTestExecutionListener.populatedRequestContextHolder' -\u0026gt; true, 'org.springframework.test.context.web.ServletTestExecutionListener.resetRequestContextHolder' -\u0026gt; true, 'org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -\u0026gt; false]]; transaction manager [org.springframework.orm.jpa.JpaTransactionManager@3986b9e9]; rollback [true]\r2022-05-27 23:28:38.809 DEBUG 1724 --- [ Test worker] org.hibernate.SQL : select\rmember0_.member_id as member_i1_4_,\rmember0_.city as city2_4_,\rmember0_.street as street3_4_,\rmember0_.zipcode as zipcode4_4_,\rmember0_.name as name5_4_ from\rmember member0_ where\rmember0_.name=?\r2022-05-27 23:28:38.818 TRACE 1724 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [VARCHAR] - [userA]\r2022-05-27 23:28:38.828 INFO 1724 --- [ Test worker] p6spy : #1653661718828 | took 7ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rselect member0_.member_id as member_i1_4_, member0_.city as city2_4_, member0_.street as street3_4_, member0_.zipcode as zipcode4_4_, member0_.name as name5_4_ from member member0_ where member0_.name=?\rselect member0_.member_id as member_i1_4_, member0_.city as city2_4_, member0_.street as street3_4_, member0_.zipcode as zipcode4_4_, member0_.name as name5_4_ from member member0_ where member0_.name='userA';\r2022-05-27 23:28:38.843 DEBUG 1724 --- [ Test worker] org.hibernate.SQL : call next value for hibernate_sequence\r2022-05-27 23:28:38.845 INFO 1724 --- [ Test worker] p6spy : #1653661718845 | took 1ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rcall next value for hibernate_sequence\rcall next value for hibernate_sequence;\r2022-05-27 23:28:38.909 INFO 1724 --- [ Test worker] p6spy : #1653661718909 | took 0ms | rollback | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\r...\r...\rBUILD SUCCESSFUL in 11s\r4 actionable tasks: 2 executed, 2 up-to-date\r오후 11:28:39: 작업 실행이 완료되었습니다 ':test --tests \u0026quot;jpabook.jpashop.service.MemberServiceTest\u0026quot;'.\r  신기한 것은 Insert Query가 없는데 JPA에서는 memberRepository.save(member); 까지 하여도 em.persist() 까지 한 상태이고 flush() 가 되어야 Insert SQL이 수행됩니다.\n  Transaction Commit이 발생되어야 flush()가 수행되는데, @Transactional은 기본적으로 RollBack을 합니다.\n  그래도 DB에 Insert 되는 것까지 보고싶다 하면 @Rollback(value = false)을 추가합니다.\n  MemberServiceTest.java\n @Test\r@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rassertEquals(member, memberRepository.findOne(savedId));\r  console\n ...\r...\rselect\rmember0_.member_id as member_i1_4_,\rmember0_.city as city2_4_,\rmember0_.street as street3_4_,\rmember0_.zipcode as zipcode4_4_,\rmember0_.name as name5_4_ from\rmember member0_ where\rmember0_.name=?\r2022-05-27 23:41:33.726 TRACE 3504 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [VARCHAR] - [userA]\r2022-05-27 23:41:33.735 INFO 3504 --- [ Test worker] p6spy : #1653662493735 | took 6ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rselect member0_.member_id as member_i1_4_, member0_.city as city2_4_, member0_.street as street3_4_, member0_.zipcode as zipcode4_4_, member0_.name as name5_4_ from member member0_ where member0_.name=?\rselect member0_.member_id as member_i1_4_, member0_.city as city2_4_, member0_.street as street3_4_, member0_.zipcode as zipcode4_4_, member0_.name as name5_4_ from member member0_ where member0_.name='userA';\r2022-05-27 23:41:33.748 DEBUG 3504 --- [ Test worker] org.hibernate.SQL : call next value for hibernate_sequence\r2022-05-27 23:41:33.749 INFO 3504 --- [ Test worker] p6spy : #1653662493749 | took 0ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rcall next value for hibernate_sequence\rcall next value for hibernate_sequence;\r2022-05-27 23:41:33.816 DEBUG 3504 --- [ Test worker] org.hibernate.SQL : insert into\rmember\r(city, street, zipcode, name, member_id) values\r(?, ?, ?, ?, ?)\r2022-05-27 23:41:33.817 TRACE 3504 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [VARCHAR] - [null]\r2022-05-27 23:41:33.818 TRACE 3504 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [2] as [VARCHAR] - [null]\r2022-05-27 23:41:33.818 TRACE 3504 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [3] as [VARCHAR] - [null]\r2022-05-27 23:41:33.818 TRACE 3504 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [4] as [VARCHAR] - [userA]\r2022-05-27 23:41:33.819 TRACE 3504 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [5] as [BIGINT] - [1]\r2022-05-27 23:41:33.821 INFO 3504 --- [ Test worker] p6spy : #1653662493821 | took 0ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rinsert into member (city, street, zipcode, name, member_id) values (?, ?, ?, ?, ?)\rinsert into member (city, street, zipcode, name, member_id) values (NULL, NULL, NULL, 'userA', 1);\r...\r...\r  또한 @Rollback(value = false) 옵션을 사용하지 않고도 @Autowired EntityManager em; 를 추가하고 em.flush();으로 같은 효과를 볼 수 있습니다.\n ...\r...\r@ExtendWith(SpringExtension.class) //Unit5 이후 사용\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r}\r...\r...\r  console\n 2022-05-27 23:47:07.462 DEBUG 5664 --- [ Test worker] org.hibernate.SQL : select\rmember0_.member_id as member_i1_4_,\rmember0_.city as city2_4_,\rmember0_.street as street3_4_,\rmember0_.zipcode as zipcode4_4_,\rmember0_.name as name5_4_ from\rmember member0_ where\rmember0_.name=?\r2022-05-27 23:47:07.462 TRACE 5664 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [VARCHAR] - [userA]\r2022-05-27 23:47:07.477 INFO 5664 --- [ Test worker] p6spy : #1653662827477 | took 6ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rselect member0_.member_id as member_i1_4_, member0_.city as city2_4_, member0_.street as street3_4_, member0_.zipcode as zipcode4_4_, member0_.name as name5_4_ from member member0_ where member0_.name=?\rselect member0_.member_id as member_i1_4_, member0_.city as city2_4_, member0_.street as street3_4_, member0_.zipcode as zipcode4_4_, member0_.name as name5_4_ from member member0_ where member0_.name='userA';\r2022-05-27 23:47:07.486 DEBUG 5664 --- [ Test worker] org.hibernate.SQL : call next value for hibernate_sequence\r2022-05-27 23:47:07.493 INFO 5664 --- [ Test worker] p6spy : #1653662827493 | took 0ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rcall next value for hibernate_sequence\rcall next value for hibernate_sequence;\r2022-05-27 23:47:07.540 DEBUG 5664 --- [ Test worker] org.hibernate.SQL : insert into\rmember\r(city, street, zipcode, name, member_id) values\r(?, ?, ?, ?, ?)\r2022-05-27 23:47:07.540 TRACE 5664 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [VARCHAR] - [null]\r2022-05-27 23:47:07.540 TRACE 5664 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [2] as [VARCHAR] - [null]\r2022-05-27 23:47:07.540 TRACE 5664 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [3] as [VARCHAR] - [null]\r2022-05-27 23:47:07.540 TRACE 5664 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [4] as [VARCHAR] - [userA]\r2022-05-27 23:47:07.540 TRACE 5664 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [5] as [BIGINT] - [1]\r2022-05-27 23:47:07.540 INFO 5664 --- [ Test worker] p6spy : #1653662827540 | took 0ms | statement | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\rinsert into member (city, street, zipcode, name, member_id) values (?, ?, ?, ?, ?)\rinsert into member (city, street, zipcode, name, member_id) values (NULL, NULL, NULL, 'userA', 1);\r2022-05-27 23:47:07.571 INFO 5664 --- [ Test worker] p6spy : #1653662827571 | took 0ms | rollback | connection 3| url jdbc:h2:tcp://localhost/~/jpashop\r  Insert 쿼리가 로그로 찍히게 되고 최종적으로\n insert into member (city, street, zipcode, name, member_id) values (?, ?, ?, ?, ?)\rinsert into member (city, street, zipcode, name, member_id) values (NULL, NULL, NULL, 'userA', 1);\r2022-05-27 23:47:07.571 INFO 5664 --- [ Test worker] p6spy : #1653662827571 | took 0ms | rollback |   롤백되게 됩니다.\n  테스트에서 실행되고 롤백이 되는 이유는 반복적으로 테스트를 해야하기 때문에 테스트 데이터를 롤백으로 지우게 됩니다.\n 눈으로 DB에 테스트 데이터를 보고싶을땐  @Rollback(value = false) 를 사용합니다.\n 회원 중복 예외 테스트  java/jpabook/jpashop/service/MemberServiceTest.java\n ...\r...\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rtry {\rmemberService.join(member2); //예외가 발생해야 한다.\r}catch (IllegalStateException e){\rreturn;\r}\rfail(\u0026quot;예외가 발생해야 한다.\u0026quot;);\r}\r...\r...\r  좀더 코드를 간결하게 수정\n  @Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r  MemberServiceTest 전체 코드\n  MemberServiceTest.java\n package jpabook.jpashop.service;\rimport static org.junit.jupiter.api.Assertions.*;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport javax.persistence.EntityManager;\r@SpringBootTest\r@Transactional\rclass MemberServiceTest {\r// 테스트 케이스에서는 다른곳에서 참조할 곳이 없으므로 @Autowired로 사용\r@Autowired MemberRepository memberRepository;\r@Autowired MemberService memberService;\r@Autowired EntityManager em;\r@Test\r//@Rollback(value = false)\rpublic void 회원가입() throws Exception{\r//given //given : 이렇게 주어졌을때\rMember member = new Member();\rmember.setName(\u0026quot;userA\u0026quot;);\r//when //when : 이렇게 하면\rLong savedId = memberService.join(member);\r//then //then : 이렇게 된다.\r// JPA안에서 하나의 트랜잭션에서 같은 엔티티에서 PK 키가 같으면 같은 영속성 컨텍스트 1차 캐시로 같은 객체로 관리\rem.flush();\rassertEquals(member, memberRepository.findOne(savedId));\r}\r@Test\rpublic void 중복_회원_예외() throws Exception{\r//given\rString username = \u0026quot;user\u0026quot;;\rMember member1 = new Member();\rmember1.setName(username);\rMember member2 = new Member();\rmember2.setName(username);\r//when\rmemberService.join(member1);\r//then\rIllegalStateException thrown = assertThrows(IllegalStateException.class, () -\u0026gt; memberService.join(member2));\r}\r}\r 테스트 코드 소스 설명  @SpringBootTest  스프링 부트는 @SpringBootTest 어노테이션을 통해 스프링부트 어플리케이션 테스트에 필요한 거의 모든 의존성을 제공합니다.\n   - @SpringBootTest는 통합 테스트를 제공하는 기본적인 스프링 부트 테스트 어노테이션입니다. - 해당 어노테이션을 사용시 Junit 버전에 따라 유의할 사항이 있습니다.\n @SpringBootTest가 없으면, @Autowired가 모두 실패합니다   @Transational   기본적으로 테스트 코드에서 @Transational를 사용하면, 테스트 완료 후 rollback 처리 합니다.   메모리 DB 사용해서 테스트 하기   프로젝트 구조를 보면, main과 test 폴더로 소스가 나뉘게 되는데, main은 실제 소스, test는 테스트코드 소스가 위치합니다.\n  main과 마찬가지로 resources 폴더를 test폴더에도 추가해 줍니다.\n /src/test/resources   /src/main/java의 소스들이 /src/main/resources의 설정을 참조 하듯이 /src/test/java의 소스들은 /src/test/resources를 우선적으로 참조합니다.\n  /src/test/resources/application.yml을 복사해 추가합니다.\n  build.gradle\n dependencies {\r...\rruntimeOnly 'com.h2database:h2' ...\r}\r  h2가 java로 수행되기 때문에 jvm안에서 띄울수 있습니다. 그렇기 때문에 메모리 모드로 H2를 사용하여 런타임 시에만 테스트용으로 사용할 수 있습니다.\n H2 Database URL Overview Embedded (local) connection   jdbc:h2:[file:][] jdbc:h2:~/test jdbc:h2:file:/data/sample jdbc:h2:file:C:/data/sample (Windows only)   In-memory (private)   jdbc:h2:mem:   In-memory (named)   jdbc:h2:mem: jdbc:h2:mem:test_mem   Server mode (remote connections) using TCP/IP   jdbc:h2:tcp://[:]/[] jdbc:h2:tcp://localhost/~/test jdbc:h2:tcp://dbserv:8084/~/sample jdbc:h2:tcp://localhost/mem:test   Server mode (remote connections) using TLS   jdbc:h2:ssl://[:]/[] jdbc:h2:ssl://localhost:8085/~/sample;    test/resources/application.yml\n spring:\rdatasource:\rurl: jdbc:h2:mem:test\rusername: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\ruse_sql_comments: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  이제 테스트를 돌리면 H2를 메모리 DB로 사용하게 됩니다.\n  확인 방법은 H2 데이터베이스를 종료하고 테스트를 실행해 보면 됩니다.\n  p6spy 커넥션 부분을 보면 아까 설정한 url jdbc:h2:mem:test 를 확인 할 수 있습니다. 또한 테스트 2건이 정상으로 테스트된것도 확인 됩니다.\n  또한 스프링 부트에서 놀라운 것은\n  test/resources/application.yml\n spring:\r# datasource:\r# url: jdbc:h2:mem:test\r# username: sa\r# password:\r# driver-class-name: org.h2.Driver\r# jpa:\r# hibernate:\r# ddl-auto: create-drop # 애플리케이션 동작 시점에 엔티티 재생성\r# use_sql_comments: true\r# database: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\rorg.hibernate.type: trace #파라미터 로깅\rorg.hibernate.type.descriptor.sql: trace\rdecorator:\rdatasource:\rp6spy:\renable-logging : true\rmultiline: true\rlogging: slf4j\r  해당 h2 데이터베이스 세팅과 jpa 세팅을 생략해도 테스트를 할 수 있습니다.\n  왜냐하면, 스프링 부트는 기본적으로 설정이 없으면 테스트 코드를 메모리 모드로 수행합니다.\n  url: jdbc:h2:mem:test과 다르게 설정되어 수행되는 것을 볼 수 있습니다.\n  메모리 모드로 DB는 create-drop으로 동작하여, 테스트 종료후에 모든 DB를 삭제하여 메모리를 정리합니다. 물론 서버가 내려가게되면 메모리 DB도 초기화 되기 때문에 신경쓰시지 않아도 됩니다.\n application.yml  설정은 개발과 운영의 설정은 다르게 가는게 좋습니다. 테스트 코드를 위해서 더 디테일 하게 출력을 할 수 있으며, 운영에 올릴때는 꼭 필요한 로그만 나오게 한다던가 설정을 나눌 필요는 있습니다.\n 이전 소스   java/jpabook/jpashop/domain/Member.java\n  Member.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Member {\rpublic Member() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;member_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@Embedded\rprivate Address address;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;();\r}\r \r java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r   java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\r@RequiredArgsConstructor\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext // EntityManager는 @PersistenceContext라는 표준 어노테이션을 통해서만 가능 (@AutoWired 불가)\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA JPA 에서 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r   java/jpabook/jpashop/service/MemberService.java\n  MemberService.java \rpackage jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport lombok.RequiredArgsConstructor;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true)\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberService {\r/*\r// 최초 코드 이며, Setter Injection로 대체\r@Autowired\rprivate MemberRepository memberRepository;\r*/\r/*\r//Constructor Injection로 대체\rprivate MemberRepository memberRepository;\rpublic void setMemberService(MemberRepository memberRepository) { //Setter Injection\rthis.memberRepository = memberRepository;\r}\r*/\r/*\r// @RequiredArgsConstructor로 대체\rprivate final MemberRepository memberRepository;\rpublic MemberService(MemberRepository memberRepository) { //Constructor Injection\rthis.memberRepository = memberRepository;\r}\r*/\rprivate final MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false)\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true)\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true)\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 회원 기능 테스트","id":12,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 회원 기능 테스트","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/member-logic-test-code/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   회원 서비스 개발  서비스 디렉토리 생성  java/jpabook/jpashop/service 위치에 리포지토리 경로 생성\n 회원 서비스 생성   java/jpabook/jpashop/service/MemberService.java\n package jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport java.util.List;\r@Service\rpublic class MemberService {\r@Autowired\rprivate MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r Service 기능 설명 및 성능 향상  @Service  @Service는 아래 게시물 링크에서 설명하도록 하겠습니다.\n  [Spring] @Controller, @Service, @Repository 어노테이션\n @Transactional  @Transactional를 import 하려고 보면, \u0026lsquo;org.springframework.transaction.annotation.Transactional\u0026rsquo; 과 \u0026lsquo;javax.transaction.Transactional\u0026rsquo; 2개가 있습니다.\n  springframework에서 제공하는 기능들이 더 많기 때문에 @Transactional을 사용하는 것을 권장드립니다.\n  MemberService.java\n ...\rimport javax.transaction.Transactional;\r@Service\r@Transactional\rpublic class MemberService {\r...\r  Service에 @Transactional를 걸어둘 수 있지만 서비스 내부에서 JPA를 사용할때 @Transactional 설정에 따라 성능향상을 시킬 수 있습니다.\n @Transactional(readOnly = true)  스프링 프레임워크에서 어노테이션으로 트랜잭션을 읽기 전용 모드로 설정할 수 있다. (boolean readOnly() default false; 기본값은 false)\n  트랜젝션에 readOnly=true 옵션을 주면 스프링 프레임워크가 하이버네이트 세션 플러시 모드를 수동(Manual)로 설정한다. 이렇게 되면 강제로 플러시를 호출 하지 않는 이상 플러시가 일어나지 않습니다. 따라서 트랜잭션을 커밋하더라도 영속성 컨텍스트가 플러시 되지 않아서 엔티티의 등록, 수정, 삭제가 동작하지 않으며, 읽기 전용으로 영속성 컨텍스트는 변경 감지를 위한 스냅샷을 보관하지 않기 때문에 성능향상이 됩니다.\n  readOnly=true 옵션을 사용하면 엔티티의 등록, 수정, 삭제가 동작하지 않기 때문에 기본적으로 Service를 통으로 @Transactional(readOnly = true) 으로 세팅하고,\n  등록, 수정, 삭제가 필요한 로직에 @Transactional(readOnly = false)를 지정하면, 지정된 로직만 오버라이딩 되어 readOnly = false의 옵션을 사용할 수 있습니다.\n package jpabook.jpashop.service;\rimport jpabook.jpashop.domain.Member;\rimport jpabook.jpashop.repository.MemberRepository;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.stereotype.Service;\rimport org.springframework.transaction.annotation.Transactional;\rimport java.util.List;\r@Service\r@Transactional(readOnly = true) // 조회 모드\rpublic class MemberService {\r@Autowired\rprivate MemberRepository memberRepository;\r/**\r* 회원 가입\r*/\r@Transactional(readOnly = false) // 등록, 수정, 삭제 가능 트랜잭션\rpublic Long join(Member member){\rvalidateDuplicateMember(member); //중복 회원 검증\rmemberRepository.save(member);\rreturn member.getId(); //save()를 통해 em.persist()를 수행하므로 Member 엔티티의 키 생성을 보장함\r}\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r/**\r* 회원 전체 조회\r*/\r//@Transactional(readOnly = true) // 조회 모드\rpublic List\u0026lt;Member\u0026gt; findMembers(){\rreturn memberRepository.findAll();\r}\r/**\r* 회원 조회\r*/\r//@Transactional(readOnly = true) // 조회 모드\rpublic Member findOne(Long memberId){\rreturn memberRepository.findOne(memberId);\r}\r}\r validateDuplicateMember  해당 벨리데이션 함수는 예제를 위해 추가한 로직이기 때문에 중복체크를 이름만 걸었습니다.  ...\rprivate void validateDuplicateMember(Member member) {\rList\u0026lt;Member\u0026gt; findMembers = memberRepository.findByName(member.getName());\rif(findMembers.size() != 0){\rthrow new IllegalStateException(\u0026quot;이미 존재하는 회원입니다.\u0026quot;);\r}\r}\r...\r  또한 WAS 환경 상 멀티쓰레드를 지원하기 때문에 동시에 같은 이름으로 등록을 할 경우에도 등록이 되기 때문에 최후의 보루로 name 컬럼에 UNIQUE 제약 조건을 추가해 두어야 합니다.\n @Autowired  해당 어노테이션은 스프링 빈에 등록된 객체를 주입(Injection) 해줍니다.\n  MemberService.java\n ...\r@Service\r@Transactional(readOnly = true)\rpublic class MemberService {\r@Autowired\rprivate MemberRepository memberRepository;\r...\r  위와 같은 방식을 필드 인젝션(field injection)이라 합니다. 필드 인젝션은 강한 결합으로 @Autowired로 지정된 객체를 변경한다면 소스를 모두 수정해야하는 단점이 있습니다. 이를 해결하기 위하여 수정자(Setter) 주입 방식으로 변경하면 됩니다.\n 수정자(Setter) 주입  MemberService.java\n ...\r@Service\r@Transactional(readOnly = true)\rpublic class MemberService {\rprivate MemberRepository memberRepository;\r@Autowired\rpublic void setMemberRepository(MemberRepository memberRepository){\rthis.memberRepository = memberRepository;\r}\r...\r    위와 같이 변경해줍니다.\n  하지만 수정자(Setter) 주입 방식에도 큰 단점이 있습니다. setter를 이용해 최초 1회만 세팅되고 나면 수정될일이 없지만, setMemberRepository()를 코드에서 직접 호출해 수정할 수 있는 여지가 있기 때문에 이 방법보다 더 좋은 방법이 있습니다.\n 생성자(Constructor) 주입  심지어 InteliJ IDEA에서도 경고를 통해 생성자 주입 방식으로 수정을 권고하고 있습니다.\n  // 생성 시점에 세팅하고 변경하지 않기 때문에 fianl로 지정하고, 컴파일 시점에 주입을 빼먹었을때도 체크를 해주기 때문에 final 키워드 추가하는 것을 권장\rprivate final MemberRepository memberRepository; //@Autowired // 또한 최신의 스프링 버전 사용시 1개의 생성자는 @Autowired를 생략해도 자동으로 Autowired를 해줌 public MemberService(MemberRepository memberRepository) {\rthis.memberRepository = memberRepository;\r}\r  생성자 주입방식을 사용하면 생성시 세팅이 되어 끝나 버리기 때문에 중간에 수정을 할 수 없습니다.\n  또한 좋은점은 테스트케이스 작성할 때,\n public static void main(String[] args){\rMemberService memberService = new MemberService(Mock()); //가짜객체 주입 }\r  가짜 객체를 주입하여 테스트를 할 수 도 있습니다.\n  여기에 lombok 까지 적용을 하게 된다면 !!\n 생성자(Constructor) 주입 lombok 적용   @AllArgsConstructor : 모든 필드 값을 파라미터로 받는 생성자를 만들어 줍니다. @RequiredArgsConstructor : final로 지정된 필드 값을 파라미터로 받는 생성자를 만들어 줍니다.    물론 생성자 주입을 위한 생성자를 만들어주기 때문에, @RequiredArgsConstructor를 추가합니다.\n ...\r@Service\r@Transactional(readOnly = true)\r@RequireArgsConstructor\rpublic class MemberService {\rprivate final MemberRepository memberRepository; /*\rpublic MemberService(MemberRepository memberRepository) {\rthis.memberRepository = memberRepository;\r}\r*/\r  그리고 생성했던 Repository에서\n  MemberRepository.java\n ...\r@Repository\rpublic class MemberRepository {\r@PersistenceContext\rprivate EntityManager em;\r...\r  추가된 EntityManager또한 생성자 주입을 할 수 있습니다.\n  MemberRepository.java\n @Repository\r@RequiredArgsConstructor // 생성자 주입\rpublic class MemberRepository {\r/*\r//최초 소스이며 아래 소스로 대체\r@PersistenceContext\rprivate EntityManager em;\r*/\r/*\r//2번째 버전의 소스이며, @RequiredArgsConstructor로 대체\r@Autowired //스프링 DATA 지원\rprivate EntityManager em;\rpublic MemberRepository(EntityManager em){\rthis.em = em;\r}\r*/\rprivate final EntityManager em;\r 이전 소스   java/jpabook/jpashop/domain/Member.java\n  Member.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Member {\rpublic Member() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;member_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@Embedded\rprivate Address address;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;();\r}\r \r java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r   java/jpabook/jpashop/repository/MemberRepository.java\n  MemberRepository.java \rpackage jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\rpublic class MemberRepository {\r@PersistenceContext\rprivate EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 회원 서비스 개발","id":13,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 회원 서비스 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/member-service-development/"},{"content":"[Spring] context:component-scan과 @Component  Component-scan   기존에 오래된 버전의 스프링으로 프로젝트를 진행했을때, 가장 어려운 점이 XML을 이용한 설정이였고, 그중에 생성한 Java 파일들이 Bean으로 사용할 수 있도록 각각 추가하여 설정하는 부분이 있었습니다.\n  application.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt;\r\u0026lt;bean id=\u0026quot;testService\u0026quot; class=\u0026quot;com.spring.test.TestService\u0026quot; /\u0026gt;\r\u0026lt;bean id=\u0026quot;testRepository\u0026quot; class=\u0026quot;com.spring.test.TestRepository\u0026quot;/\u0026gt;\r\u0026lt;/beans\u0026gt;\r  component-scan은 이러한 일련의 작업을 드라마틱하게 줄여주는 기능입니다.\n  component-scan의 대상으로는\n  @Component를 포함하여 @Component를 상속 받는 @Controller, @Service, @Repository가 대상이 됩니다.\n  해당 어노테이션이 붙은 클래스들을 스캔하여 bean으로서 생성해주는 것을 가능하게 해주는 설정입니다.\n  component-scan은 XML에서의 설정과 Java에서의 설정 2가지 방법이 있습니다.\n XML에서의 Component-scan 설정   component-scan은 context xmlns(이하 xml namespace)에 정의되어 있는 접두어를 통해 사용 가능한데, 이때 위에서 언급하였듯이 어노테이션이 붙은 클래스들을 스캔하여 bean으로 만들기 위해서 base-package=\u0026ldquo;패키 지명\u0026quot;을 통해 스캔 범위를 정할 수 있습니다.\n \u0026lt;context:component-scan base-package=\u0026quot;패키지명\u0026quot;/\u0026gt;   application.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot;\rxsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026quot;\u0026gt;\r\u0026lt;context:component-scan base-package=\u0026quot;com.spring.test\u0026quot;/\u0026gt;\r\u0026lt;/beans\u0026gt;\r XML에서의 Component-scan의 Customize   설정한 Component-scan에 대하여 필터를 이용한 스캐닝의 커스터마이징에 대해서 살펴보겠습니다.\n  Customize이라는 것은 기본 적용된 설정을 수정하여 좀더 세부적인 설정을 하는 것입니다.\n context접두어를 이용하는 component-scan의 두 가지 필터   context:include-filter : 필터를 통해 포함시키고자 하는 대상. context:exclude-filter : 필터를 통해 제외시키고자 하는 대상.    이 두 가지는 모두 type, expression 속성을 갖는데, 이때 사용되는 값들은 다음과 같습니다.\n    Filter Example Expression Description     annotation org.example.SomeAnnotation 타겟 컴포넌트의 타입 레벨에 존재하는 어노테이션을 스캔   assignable org.example.SomeClass 지정한 타입과 할당(extends/implements)할 수 있는 클래스들을 스캔   aspectj org.example..*Service+ aspectj의 표현식과 매치되는 컴포넌트들을 스캔   regex org.example.Default.* 클래스 이름이 정규 표현식과 매치되는 컴포넌트들을 스캔    \u0026lt;context:component-scan base-package=\u0026quot;최상위 패키지명\u0026quot; use-default-filters=\u0026quot;false\u0026quot;\u0026gt;\r\u0026lt;context:include-filter type=\u0026quot;aspectj\u0026quot; expression=\u0026quot;하위 패키지명\u0026quot; /\u0026gt;\r\u0026lt;context:include-filter type=\u0026quot;aspectj\u0026quot; expression=\u0026quot;하위 패키지명\u0026quot; /\u0026gt;\r...\r\u0026lt;/context:component-scan\u0026gt;\r use-default-filters 속성  use-default-filters은 컴포넌트 스캔을 할 것인지, 안할 것인지에 대한 옵션이며 기본값은 true입니다. true인경우 @Component, @Controller, @Repository, @Service와 같은 기본 컴포넌트를 스캔한다는 의미이며, 반대로 false는 기본 컴포넌트를 스캔하지 않는다는 것입니다.\n    Option Example Expression Description     use-default-filters true default, 컴포넌트 스캔 사용   use-default-filters false 컴포넌트 스캔 미사용    Java 에서의 component-scan 설정  Java 파일로 직접 Bean 등록 설정 1. Setter 방식의 Bean 주입 방식  ApplicationConfig.java\n @Configuration // Bean 설정 파일임을 알려주기 위한 어노테이션\rpublic class ApplicationConfig {\r@Bean\rpublic TestRepository testRepository(){\rreturn new TestRepository();\r}\r@Bean\rpublic TestService testService(){\rTestService testService = new TestService();\rtestService.setTestRepository(testRepository()); // Setter 방식의 의존성 주입\rreturn testService;\r}\r}\r 2. 메소드 파라미터로 의존성 주입    ApplicationConfig.java\n @Configuration // Bean 설정 파일임을 알려주기 위한 어노테이션\rpublic class ApplicationConfig {\r@Bean\rpublic TestRepository testRepository(){\rreturn new TestRepository();\r}\r@Bean\rpublic TestService testService(TestRepository testRepository){\rTestService testService = new TestService();\rtestService.setTestRepository(testRepository);\rreturn testService;\r}\r}\r  Java 설정 파일에 직접 Bean 등록은 XML 직접 Bean 등록의 단점과 마찬가지로 하나하나 Bean으로 등록을 해줘야합니다.\n  그래서 나온 개념이 Component Scan 방식입니다.\n Java 파일로 Component Scan 방식 설정    ComponentScan option type safe parameter     basePackageClasses Type Safe Application.class   basePackages Not Type Safe com.spring.test     ApplicationConfig.java\n @Configuration // Bean 설정파일이다를 알려주기 위해서\r@ComponentScan(basePackageClasses = Application.class) //@ComponentScan(basePackages = \u0026quot;com.spring.test\u0026quot;) public class ApplicationConfig {\r}\r  Application.java\n public class Application {\rpublic static void main(String[] args) {\r// Java 파일로 ApplicationContext를 생성하기 때문에\r// AnnotationConfigApplicationContext 클래스를 사용한다.\rApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);\rString[] beans = context.getBeanDefinitionNames();\rSystem.out.println(Arrays.toString(beans)); // ApplicationContext 안에 등록된 Bean들을 출력\r// context.getBean()을 호출하면 Object 타입이 Return되기 때문에\r// 타입 캐스팅을 해줘야한다.\rTestService testService = (TestService) context.getBean(\u0026quot;testService\u0026quot;);\r}\r}\r @Component   IoC Container는 특정 어노테이션이 달려있는 클래스를 빈으로 만들기 위해 빈 스캐닝을 합니다.\n   @Configuration @Bean @Component @Repository @Service @Controller    그중 @Component는 \u0026ldquo;이 클래스를 정의했으니 빈으로 등록하라\u0026rdquo; 라는 뜻으로, 개발자가 직접 작성한 Class 위에 선언하면 됩니다.\n @Component\rpublic class TestClassSample {\r...\r  그리고 @Controller, @Service, @Repository 모두 @Component를 상속받아 컴포넌트 스캔에 의해서 자동으로 스프링 빈으로 관리가 되게 됩니다.\n @Controller, @Service, @Repository   해당 어노테이션들은 @Component를 상속 받기 때문에 Component Scan의 대상입니다.\n  그리고 각각의 어노테이션들을 설명하기 위해 MVC 패턴 모델을 먼저 아는 것이 중요합니다.\n MVC 모델  MVC 모델이란 Model, View, Controller의 약자로서 개발을 할때 3가지 역할로 나누어 개발하는 방법론입니다.\n Model  어 어플리케이션이 무엇을 할 것인지 정의하는 부분 입니다. 즉, 내부 비즈니스 로직을 처리하기 위한 역할을 합니다. DB와 연동하여 사용자가 입력한 데이터나 사용자에게 출력할 데이터를 다룹니다. 특히 여러 개의 데이터 변경 작업을 하나의 작업으로 묶는 트랜잭션을 다루는 일도 합니다. Controller 이하 Service(ServiceImpl), DAO(Repository), SQL(JPQL, Persistence)이 Model에 해당합니다.\n View  최종 사용자에게 무엇을 화면(UI)로 보여줍니다. 화면에 무엇을 보여주기 위한 역할 이며, 모델이 처리한 데이터나 그 작업 결과를 가지고 사용자에게 출력할 화면을 만듭니다. 만든 화면은 웹 브라우저가 랜더링합니다.\n Controller  Model과 View 사이에 있는 컴포넌트이며, View에서 클라이언트의 요청에 맞게 Model이 데이터를 어떻게 처리할지 알려주는 역할을 합니다. 클라이언트가 보낸 데이터가 있다면, 모델을 호출할 때 전달하기 쉽게 적절히 가공하며, Model이 로직 수행을 완료하면 그 결과를 가지고 화면을 생성하도록 View에 전달합니다.\n 스프링과 Controller  스프링에서 컨트롤러를 지정해주기 위한 어노테이션은 @Controller와 @RestController가 있습니다. 두 어노테이션은 컨트롤러(*Controller.java)에 붙여두면, 컴포넌트 스캔에 의해서 자동으로 스프링 빈으로 관리가 되게 됩니다.\n @Controller  전통적인 Spring MVC의 컨트롤러인 @Controller는 주로 View를 반환하기 위해 사용합니다.\n  하지만 @ResponseBody 어노테이션을 같이 사용하면 RestController와 똑같은 기능을 수행할 수 있습니다.\n  즉, JSON/XML형태로 객체 데이터 반환을 목적으로 동작할 수 있습니다.\n @RestController  RestController는 Controller에서 @ResponseBody 어노테이션이 붙은 효과를 지니게 됩니다.\n  즉, 주용도는 JSON/XML형태로 객체 데이터 반환을 목적으로 합니다.\n @Service  비즈니스 로직에(*Service.java) @Service 어노테이션을 추가하면, 컴포넌트 스캔에 의해서 자동으로 스프링 빈으로 관리가 되게 됩니다.\n   비즈니스 로직이나 리포지토리 레이어를 호출하는 함수에 사용 다른 어노테이션과 다르게 @Component에 추가된 기능은 없음 비즈니스 로직에 @Service 어노테이션을 추가해야 나중에 추가적인 exception handling을 해줄 수도 있음   @Repository  DAO(*Dao.java) 클래스 또는 JPA의 Repository(*Repository.java)에 @Repository 어노테이션을 추가하면, 컴포넌트 스캔에 의해서 자동으로 스프링 빈으로 관리가 됩니다.\n  또 @Component와 다르게 Exception translation 라는 특성이 추가됩니다.\n Exception translation  @Component를 사용하면, Persistence 기술(JPA 또는 Hibernate API)를 사용하면, 네이티브 예외 클래스를 처리할지 정해야합니다.\n  Persistence 기술에 따라 HibernateException PersistenceException의 하위 클래스를 던지겠지만, 모두 런타임 예외라 선언하거나 Catch 하지 않아도 됩니다. 던져지는 예외의 타입을 알 수 있는 방법이 없기 때문에 각각 다 예외처리 하거나 전체를 다 예외처리 해야하는 문제가 있습니다.   @Repository를 사용하여 Exception translation의 특성을 이용해 예외가 더 디테일 하게 스프링의 커스텀 예외 계층 구조로 변환하여 처리할 수 있도록 해야합니다.\n 참조   [Spring] context:component-scan에 관하여 [Spring] context:component-scan에 관하여 @Repository, @Service 어노테이션 Object Relational Mapping (ORM) Data Access Controller, Service, Repository 가 무엇일까?   ","description":"@Controller, @Service, @Repository 어노테이션","id":14,"section":"blog","tags":["Spring","Framework","SpringFramework"],"title":"[Spring] @Controller, @Service, @Repository 어노테이션","uri":"https://offetuoso.github.io/blog/develop/framework/spring/contoller-service-repository-annotation/"},{"content":"애플리케이션 구현  목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   회원 도메인 개발  구현 기능    회원 등록 회원 목록 조회   구현순서    회원 엔티티 코드 다시 보기 회원 리포지토리 개발 회원 서비스 개발 회원 기능 테스트   회원 엔티티 코드 다시 보기   java/jpabook/jpashop/domain/Member.java\n \tpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Member {\rpublic Member() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;member_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@Embedded\rprivate Address address;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;();\r}\r  간단하게 id, name, address, 1:N 관계로 orders가 속성으로 있었고, 이를 사용해 리포지토리를 개발하도록 하겠습니다.\n 회원 리포지토리 개발  리포지토리 디렉토리 생성  java/jpabook/jpashop/repository 위치에 리포지토리 경로 생성\n 회원 리포지토리 생성  java/jpabook/jpashop/repository/MemberRepository.java\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.domain.Member;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\rimport javax.persistence.TypedQuery;\rimport java.util.List;\r@Repository\rpublic class MemberRepository {\r@PersistenceContext\rprivate EntityManager em;\rpublic void save(Member member){\rem.persist(member);\r}\rpublic Member findOne(Long id){\rreturn em.find(Member.class, id);\r}\rpublic List\u0026lt;Member\u0026gt; findAll(){\rreturn em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class)\r.getResultList();\r}\rpublic List\u0026lt;Member\u0026gt; findByName(String name){\rreturn em.createQuery(\u0026quot;select m from Member m where m.name = :name\u0026quot;, Member.class)\r.setParameter(\u0026quot;name\u0026quot;,name).getResultList();\r}\r}\r @Repository  스프링을 사용하기 때문에 @Repository 어노테이션을 리포지토리에 추가하게 되면, 컴포넌트 스캔에 의해서 자동으로 스프링 빈으로 관리가 되게 됩니다.\n @PersistenceContext  또한 JPA를 사용하므로 스프링에서 제공하는 @PersistenceContext로 private EntityManager em를 추가합니다. 그러면 스프링이 EntityManager 객체를 만들어서 주입(injection)해주게 됩니다.\n  만약 EntityManagerFactory를 직접 사용하고 싶다면 @PersistenceUnit을 사용하면 private EntityManagerFactory emf를 주입받을 수 있습니다.\n 이전 소스   java/jpabook/jpashop/domain/Member.java\n  Member.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Member {\rpublic Member() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;member_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@Embedded\rprivate Address address;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;();\r}\r \r java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 회원 도메인 개발","id":15,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 회원 도메인 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/member-domain-development/"},{"content":"애플리케이션 구현 준비  목차    구현 요구사항 애플리케이션 아키텍쳐   구현 요구사항   이번에는 애플리케이션을 어떻게 구현할지에 대한 구현 요구사항이랑 애플리케이션 아키텍처에 대하여 정리하겠습니다.\n  도메인 설계가 다 끝났는데, 그것은 데이터 적인 설계였고 이번에는 어디까지 구현할지 범위에 대한 요구사항을 정리해 보도록 하겠습니다.\n   회원 기능  회원 등록 회원 조회   상품 기능  상품 등록 상품 수정 상품 조회   주문 기능  상품 주문 주문 내역 조회 주문 취소     회원 기능  회원 등록   회원 등록하는 페이지이며, 비지니스 메서드를 통해 회원등록 구현 되어야 합니다.   회원 조회   등록된 회원을 조회하고 화면에 리스트로 뿌려줘야 합니다.   회원 기능  상품 등록   상품을 등록하고 수정할 수 있어야 합니다. 상품종류를 선택하여, 각각의 상품을 등록할 수 있어야 합니다.     등록된 상품을 조회할 수 있어야 합니다. 수정버튼을 눌러 상품을 수정할 수 있습니다.   주문 기능  상품 주문   등록된 회원과 재고가 있는 상품을 선택 후 주문수량을 입력해 주문을 등록합니다. 주문 수량은 재고보다 많으면 안됩니다. 주문수량이 적절하면 주문이 됩니다.   주문 내역 조회   주문을 하면 주문 내역에 리스트 형태로 조회가 됩니다.   주문 취소   주문을 하면, 주문한 물품 갯수에 따라 상품 재고가 줄어듭니다. 취소를 하면 주문한 상품의 재고가 다시 늘어납니다.   검색   조건에 따라 조회가 가능합니다.   기능구현 제외   선택과 집중을 하기 위하여 강좌에서 예제를 단순화 하여 다음 기능은 구현하지 않습니다.\n   로그인과 권한 관리 X 파라미터 검증과 예외 처리 단순화 상품은 도서만 사용 카테고리는 사용 X 배송 정보는 사용 X    강좌를 정리하고 추가적으로 공부할 여력이 된다면 추가 하도록 하겠습니다.\n 애플리케이션 아키텍처  계층형 구조   Controller를 통해 Service, Repository를 거처 DB에 접근하지만, Controller에서 Repository를 바로 접근하여 DB에 접근할 수 있게 유연하게 개발하도록 하겠습니다.\n   controller, web : 웹 계층 service : 비즈니스 로직, 트랜잭션 처리 repository : JPA를 직접 사용하는 계층, 엔티티 매니저 사용 domain : 엔티티가 모여있는 계층, 모든 계층에서 사용   계층형 구조    controller, web : 웹 계층 service : 비즈니스 로직, 트랜잭션 처리 repository : JPA를 직접 사용하는 계층, 엔티티 매니저 사용 domain : 엔티티가 모여있는 계층, 모든 계층에서 사용   패키지 구조    jpabook.jpashop  domain exection repository service web     개발 순서    서비스, 리포지토리 계층을 개발 테스트 케이스를 작성 및 검증 웹 계층 적용   개발 목차    회원 도메인 개발   회원 리포지토리 개발 회원 서비스 개발 기능 테스트  상품 도메인 개발   상품 엔티티개발(비즈니스 로직추가) 상품 리포지토리 개발 상품 서비스 개발  주문 도메인 개발   주문, 주문상품 엔티티 개발 주문 리포지토리 개발 주문 서비스 개발  웹 계층 개발   홈 화면과 레이아웃 회원 등록 회원 목록 조회 상품 등록 상품 목록 상품 수정 변경 감지와 병함(merge) 상품 주문 주문 목록 검색, 취소  API 개발 기본   회원 등록 API 회원 수정 API 회원 조회 API  API 개발 고급   조회용 샘플 데이터 입력 지연 로딩과 조회 성능 최적화 페이징과 한계 돌파 OSIV와 성능 최적화  다음으로   스프링 데이터 JPA 소개 QueryDSL 소개 마무리   이전 소스   java/jpabook/jpashop/domain/Member.java\n  Member.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Member {\rpublic Member() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;member_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@Embedded\rprivate Address address;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;();\r}\r \r java/jpabook/jpashop/domain/Address.java\n  Address.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r   java/jpabook/jpashop/domain/Order.java\n  Order.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r   java/jpabook/jpashop/domain/OrderItem.java\n  OrderItem.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/OrderStatus.java\n  OrderStatus.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r   java/jpabook/jpashop/domain/Delivery.java\n  Delivery.java \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(fetch = FetchType.LAZY // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r, mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r   java/jpabook/jpashop/domain/item/Item.java\n  Item.java \rpackage jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r}\r   java/jpabook/jpashop/domain/item/Album.java\n  Album.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r   java/jpabook/jpashop/domain/item/Book.java\n  Book.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r   java/jpabook/jpashop/domain/item/Movie.java\n  Movie.java \rpackage jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r   java/jpabook/jpashop/domain/Category.java\n  Category.java \rpackage jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 애플리케이션 구현 준비","id":16,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 애플리케이션 구현 준비","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/preparing-for-application-implementation/"},{"content":"도메인 분석 설계  목차    요구사항 분석 도메인 모델과 테이블 설계 엔티티 클래스 개발 엔티티 설계시 주의점   엔티티 클래스 개발    예제에서는 설명을 쉽게하기 위해 엔타타 클래스에 Getter, Setter를 모두 열고, 최대한 단순하게 설계 실무에서는 가급적 Getter, Setter는 꼭 필요한 경우에만 사용하는 것을 추천   도메인 패키지 생성   jpabook/jpashop/domain 패키지를 생성하여 추가할 엔티티 클래스들을 모아두도록 하겠습니다.\n  기존의 jpabook/jpashop/entity의 패키지는 지우도록 하겠습니다.\n Member 엔티티   jpabook/jpashop/domain/Member.java 생성\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport org.graalvm.compiler.nodes.memory.address.AddressNode;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\rimport java.util.ArrayList;\r@Entity\r@Getter @Setter\rpublic class Member {\rpublic Member() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;member_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate Address address;\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;();\r}\r  Address.java와 Order는 미리 껍데기 만이라도 생성해 둡니다.\n Address 값 타입 생성   jpabook/jpashop/domain/Address.java 생성 - @Embeddable 추가\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter //Getter만 public class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rprotected Address(){\r}\r//Setter 대신 생성자 사용\rpublic Address(String city, String street, String zipcode){\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\r}\r Member.java  Member.java - @Embedded 어노테이션 추가\n  @Embedded // \u0026lt;\u0026lt; 추가해 줍니다. private Address address;\r  @Embeddable이나 @Embedded 하나만 추가해도 적용 되지만, 코드 가독성을 위해 둘다 추가해 줍니다.\n Order.java   jpabook/jpashop/domain/Order.java 생성\n package jpabook.jpashop.domain;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;orders\u0026quot;) // order는 키워드므로 orders로 관습적으로 사용\r@Getter @Setter\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r}\r OrderStatus  jpabook/jpashop/domain/OrderStatus.java 열거형 타입 생성\n package jpabook.jpashop.domain;\rpublic enum OrderStatus {\rORDER, CANCEL\r}\r Order.java  Order.java - @Enumerated(EnumType.STRING) 추가\n \t@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r OrderItem.java   jpabook/jpashop/domain/OrderItem.java 생성\n package jpabook.jpashop.domain;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class OrderItem {\r@Id @GeneratedValue\r@Column(name = \u0026quot;order_item_id\u0026quot;)\rprivate Long id;\rprivate Item item;\r@ManyToOne\r@JoinColumn(name = \u0026quot;order_id\u0026quot;)\rprivate Order order;\rprivate int orderPrice; //주문 당시의 가격\rprivate int count; //주문 수량\r}\r Order.java  Order.java - @OneToMany(mappedBy = \u0026ldquo;order\u0026rdquo;) 추가\n  @OneToMany(mappedBy = \u0026quot;order\u0026quot;) // 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻 private List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r Item.java   Item는 상속관계로 Album.java, Book.java, Movie.java를 같이 생성해야 하므로 따로 item 패키지를 추가해 모아둡니다.\n  jpabook/jpashop/domain/item/Item.java 생성\n @Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 상속 테이블 전략 싱글테이블 @DiscriminatorColumn(name = \u0026ldquo;dtype\u0026rdquo;) // 구분 컬럼명   package jpabook.jpashop.domain.item; import lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r}\r Album.java  jpabook/jpashop/domain/item/Album.java 생성\n @DiscriminatorValue(\u0026ldquo;A\u0026rdquo;) //구분값 A   package jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;) //구분값 A\r@Getter @Setter\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\r}\r Book.java  jpabook/jpashop/domain/item/Book.java 생성\n @DiscriminatorValue(\u0026ldquo;B\u0026rdquo;) //구분값 B   package jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;) //구분값 B\r@Getter @Setter\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\r}\r Movie.java  jpabook/jpashop/domain/item/Movie.java 생성\n @DiscriminatorValue(\u0026ldquo;M\u0026rdquo;) //구분값 M   package jpabook.jpashop.domain.item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;) //구분값 M\r@Getter @Setter\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\r}\r OrderItem.java  OrderItem.java - @JoinColumn(name = \u0026ldquo;item_id\u0026rdquo;)\n  @ManyToOne\r@JoinColumn(name = \u0026quot;item_id\u0026quot;)\rprivate Item item;\r Delivery.java   jpabook/jpashop/domain/Delivery.java 생성 - @Enumerated(EnumType.STRING)\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r DeliveryStatus.java   jpabook/jpashop/domain/DeliveryStatus.java 열거형 타입 생성\n package jpabook.jpashop.domain;\rpublic enum DeliveryStatus {\rREADY, COMP\r}\r Order - Delivery  1:1 관계에서는 FK를 어느 위치에 둬도 상관은 없지만, Order에서 Delivery를 조회하는게 Delivery에서 Order를 조회 하는것보다 많기 때문에 FK를 더 많이 접근하는 엔티티에 FK를 위치 시킵니다.\n  Order - @JoinColumn(name = \u0026ldquo;delivery_id\u0026rdquo;) 추가\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;) // 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r@OneToOne\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r}\r  Delivery.java - @OneToOne(mappedBy = \u0026ldquo;delivery\u0026rdquo;) 추가\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\r@Entity\r@Getter @Setter\rpublic class Delivery {\rpublic Delivery() {\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;delivery_id\u0026quot;)\rprivate Long id;\r@OneToOne(mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status; //READY, COMP\r}\r CATEGORY.java CATEGORY - ITEM (N : M)   N:M 관계를 JPA로 구현하기 위해서는 테이블과 테이블 사이에 JoinTable을 추가해 N:1, 1:M 구조가 되게끔 생성합니다.\n  Category.java\n @ManyToMany 추가 @JoinTable 추가   package jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r}\r  Item.java - @ManyToMany(mappedBy = \u0026ldquo;items\u0026rdquo;) 추가\n package jpabook.jpashop.domain.item;\rimport jpabook.jpashop.domain.Category;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn(name = \u0026quot;dtype\u0026quot;)\r@Getter @Setter\rpublic abstract class Item {\r@Id @GeneratedValue\r@Column(name = \u0026quot;item_id\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\r}\r Category의 계층형 관계   카테고리나 코드 같은 엔티티는 본인과 부모 관계의 계층형 관계의 구조로 구성할 수 있는데 parent와 child 모두 본인 엔티티에 가지게 된다. 코드성 테이블 생성시 부모(또는 그룹코드)를 가지고 있지만, JPA에서는 자식을 조회할 수 있도록 child도 가진다.\n   @ManyToOne - 추가 @OneToMany - 추가   package jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r}\r  애플리케이션을 실행\n  테이블이 정상적으로 생성된것을 확인할 수 있습니다.\n 엔티티 설계 시 참고  엔티티의 Getter와 Setter  이론적으로 Getter, Setter를 모두 제공하지 않고, 꼭 필요한 별도의 메서드를 제공하는게 가장 이상적이다. 하지만 실무에서 엔티티의 데이는 조회할 일이 너무 많으므로, Getter의 경우 모두 열어 두는 것이 편리하다. Getter는 아무리 호출해도 호출하는 것 만으로 어떤 일이 발생하지는 않는다. 하지만 Setter는 문제가 다르다. Setter를 호출하면 데이터가 변한다. Setter를 막 열어두면 가까운 미래에 엔티티가 도대체 왜 변경되는지 추적하기 점점 힘들어진다. 그래서 엔티티를 변경할 때는 Setter 대신에 변경 지점이 명확하도록 변경을 위한 비지니스 메서드를 별도로 제공해야한다.\n 엔티티의 Id  엔티티의 식별자는 \u0026lsquo;id\u0026rsquo;를 사용하고 컬럼명은 \u0026lsquo;member_id\u0026rsquo; 이런식으로 엔티티_id를 사용했다. 엔티티는 타입이 있으므로 id 필드만으로 쉽게 구분할 수 있다. 테이블은 타입이 없으므로 구분이 어렵다. 그리고 테이블은 관례상 \u0026lsquo;테이블명 + id\u0026rsquo;를 많이 사용한다. 참고로 객체에서 \u0026lsquo;id\u0026rsquo; 대신에 \u0026lsquo;memberId\u0026rsquo;를 사용해도 된다. 중요한 것은 일관성이다.\n 실무에서는 ManyToMany를 사용하지 말자.  @ManyToMany는 편리할 것 같지만, 중간테이블(CATEGORY_ITEM)에 컬럼을 추가 할 수 없고, 세밀하게 쿼리를 실행하기 어렵기 때문에 실무엣 사용하기에는 한계가 있다. 중간 엔티티(CategoryItem)를 만들고 @ManyToOne @OneToMany로 매핑해서 사용하자. 정리하면 다대다 매핑을 일대다, 다대일 매핑으로 풀어내서 사용하자\n 값 타입에 Setter를 추가 하지 않은 이유  Address.java\n \rpackage jpabook.jpashop.domain;\rimport lombok.Getter;\rimport javax.persistence.Embeddable;\r@Embeddable\r@Getter\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rproteted\r}\r  값 타입인 Address에는 Getter만 추가하고 Setter는 만들지 않았습니다. 값 타입 변경해 사용하는 것이 아니라, 새로 생성 또는 복사를 통해 새로 등록 해야한다.\n  값 타입은 변경 불가능하게 설계해야한다. \u0026lsquo;@Setter\u0026rsquo;를 제거하고, 생성자에서 값을 모두 초기화 해서 변경 불가능한 클래스를 만들자. JPA 스펙상 엔티티나 임베디드 타입(@Embeddable)은 자바 기본 생성자를 public 또는 protected로 설정해야 한다. public으로 두는 것 보다는 protected로 설정하는 것이 그나마 인전 하다. JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플랙션 같은 기술을 사용할 수 있도록 지원해야 하기 때문이다.\n 엔티티 설계시 주의점  엔티티에는 가급적으로 Setter를 사용하지 말자.    Setter가 모두 열려있으면, 변경 포인트가 너무 많아 유지보수가 어렵다. Setter 대신 비즈니스 메서드를 구현해 사용한다.   모든 연관관계는 지연로딩으로 설정!    즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 떄 N+1 문제가 자주 발생한다. 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야 한다. 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다. @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야한    즉시로딩의 최악의 경우 테이블에 연관된 데이터를 다 불러오기 때문에 어떤 쿼리가 나오는지 정확히 알수 없습니다.\n  예를들어 Order 엔티티에 같이 설정이 되어 있습니다.\n @ManyToOne(fetch = FetchType.EAGER) // FetchType.EAGER가 Defualt(설정 안해두면 FetchType.EAGER)\r@JoinCoulmn(name = \u0026quot;member_id\u0026quot;)\rprivate Member member;\r  즉, Order와 Member는 N:1 관계로 즉시로딩으로 기본 설정되어 있습니다.\n이런 상황에서 JPQL로 100 ROW의 ORDERS를 조회합니다.\n //JPQL \u0026quot;SELECTo FROM ORDER p\u0026quot; -\u0026gt; SQL \u0026quot;SELECT * FROM ORDERS\u0026quot;\r  즉시 로딩은 엔티티의 각각의 Row당 Member를 즉시 쿼리를 날려 호출하기 때문에 N+1 의 문제점을 발생시킵니다.\n  즉시로딩은 Order를 조회하는 시점에 어떻게든 Member를 조회하겠다는 뜻입니다.\n  지연로딩으로 세팅 후 fetch join이나 엔티티 그래프 기능을 사용해야 합니다.\n ToOne 전체 검색 후 (fetch = FetchTpye.LAZY)로 세팅 컬렉션은 필드에서 초기화하자   컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.\n null 문제에서 안전하다. 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 만약 getOrders() 처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다.   컬렉션은 초기화 후 변경하면 절대 안됨  JAVA\n \rMember member = new Member();\rSystem.out.println(member.getOrders().getClass());\rem.persist(member);\rSystem.out.println(member.getOrders().getClass());\r//출력결과 class java.util.ArrayList\rclass org.hibernate.collection.internal.PersistentBag\r  JPA에서 컬렉션을 JPA에서 추적할 수 있는 객체로 변경합니다.\n  JPA가 기껏 컬렉션을 PersistentBag으로 변환 했는데, set을 통해 새로 객체를 생성한다면 Hibernate가 원하는 메커니즘으로 동작 못하게 됩니다.\n  그렇기 때문에 최초 객체를 생성해서 컬렉션을 생성하면, 변경하면 안됩니다.\n 테이블, 컬럼명 생성 전략   스프링 부트에서 하이버네이트 기본 매핑 전략을 변경해서 실제 테이블 필드명은 다름\n   https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-hibernate-naming-strategy https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html   하이버네이트 기존 구현  엔티티의 필드명을 그대로 테이블 명으로 사용되었지만, 아래와 같은 방식으로 변경 되었습니다.\n 스프링부트 기본 네이밍 전략 'SpringPhysicalNamingStrategy'\r  스프링 부트 신규 설정(엔티티(필드) -\u0026gt; 테이블(컬럼))\n 카멜 케이스 -\u0026gt; 언더스코어(memberPoint -\u0026gt; member_point) .(점) -\u0026gt; _(언더스코어) 대문자 -\u0026gt; 소문자    예를 들면\n  Order.java\n // order_date\rprivate LocalDateTime orderDate; //주문시간\r  카멜케이스를 언더스코어 방식으로 변경하는 것을 알 수 있습니다.\n  H2 DB에서 컬럼이 대문자로 보이지만, 소문자로 컬럼을 사용 가능합니다. SELECT order_date FROM ORDERS\n 적용 2단계(설정)   논리명 생성 : 명시적으로 컬럼, 테이블명을 직접 적지 않으면 ImplicitNamingStrategy 사   'spring.jpa.hibernate.naming.implicit-strategy' //테이블이나, 컬럼명을 명시 하지 않을 때 논리명 적용\r  물리명 적용 :   'spring.jpa.hibernate.naming.physical-strategy' //모든 논리명에 적용됨, 실제 테이블에 적용(username -\u0026gt; usernm 등으로 회사 룰로 바꿀 수 있음)\r 스프링 부트 기본 설정 'spring.jpa.hibernate.naming.implicit-strategy : org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamimgStrategy'\r'spring.jpa.hibernate.naming.physical-strategy : org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamimgStrategy'\r 영속화 전파 (Cascade)   Order.java - cascade = CascadeType.ALL 추가\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL) @JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r}\r  Order를 저장(.persist())할때, orderItems를 따로 저장해줘야 하는데 Cascade를 추가해 같이 저장시킬 수 있다.\n  예를들어 orderItemA,B,C 를 가지는 order를 저장 시\n persist(orderItemA)\rpersist(orderItemB)\rpersist(orderItemC)\rpersist(order)\r  각각의 객체들을 저장해 줘야 하지만,\n  Cascade를 적용했다면\n //persist(orderItemA)\r//persist(orderItemB)\r//persist(orderItemC)\rpersist(order)\r  order에 저장되는 각각의 orderItemA,B,C를 persist 안해도 persist를 전파(cascade) 합니다.\n 연관관계 편의 메서드   양방향 연관관계를 세팅하려고 하면\n  예를 들어 Member가 Order를 추가 하게 되면 member.orders 추가해 줘야합니다.\n  Java\n public static void main(String[] args){\rMember member = new Member();\rOrder order = new Order();\rmember.getOrders().add(order); //orders 컬렉션에 order 추가\rorder.setMember(member); // order에 member 추가\r}\r  위와 같이 양쪽다 세팅을 해줘야 합니다. 하지만 개발을 하다보면, 한쪽을 빼먹고 안넣는 경우가 발생 할 수 있습니다.\n  그래서 연관관계 편의 메서드를 추가해 2개를 같이 세팅하는 메서드를 만들어 제공하면 휴먼 에러를 줄일 수 있습니다.\n  Order.java - 연관관계 편의 메서드 추가\n package jpabook.jpashop.domain;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\r@Table(name = \u0026quot;orders\u0026quot;)\rpublic class Order {\r@Id @GeneratedValue\r@Column(name=\u0026quot;order_id\u0026quot;)\rprivate Long id;\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;member_id\u0026quot;) // Order의 member가 수정되면 Order의 외래키 값이 변경됩니다.\rprivate Member member;\r// mappedBy 연관관계의 주인인 OrderItem의 order로 매핑 되어있다는 뜻\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;();\r// ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;delivery_id\u0026quot;)\rprivate Delivery delivery;\rprivate LocalDateTime orderDate; //주문시간\r@Enumerated(EnumType.STRING) // EnumType.ORDINAL(숫자라 순서바뀌면 큰일)이 기본이지만 무조건 EnumType.STRING(문자 코드)\rprivate OrderStatus status; // 주문상태 [ORDER, CANCEL]\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void setMember(Member member){\rthis.member = member;\rmember.getOrders().add(this);\r}\rpublic void addOrderItem(OrderItem orderItem){\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void setDelivery(Delivery delivery){\rthis.delivery = delivery;\rdelivery.setOrder(this);\r}\r}\r  Category.java\n package jpabook.jpashop.domain;\rimport jpabook.jpashop.domain.item.Item;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Getter @Setter\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;category_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToMany\r@JoinTable(name = \u0026quot;category_item\u0026quot;\r, joinColumns = @JoinColumn(name = \u0026quot;category_id\u0026quot;)\r, inverseJoinColumns = @JoinColumn(name = \u0026quot;item_id\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\r@ManyToOne(fetch = FetchType.LAZY) // ToOne은 fetch = FetchType.LAZY로 꼭 !!! 세팅\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;();\r//==연관관계 메서드 (양방향 연관관계시 추가)==//\rpublic void addChildCategory(Category child){\rthis.child.add(child);\rchild.setParent(this);\r}\r}\r  여기까지 세팅은 어느정도 된것 같고 다음 강의 부터는 실제 요구사항을 보며 비즈니스 서비스를 개발해보도록 하겠습니다.\n 참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 엔티티 클래스 개발","id":17,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 엔티티 클래스 개발","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/entity-class-development/"},{"content":"도메인 분석 설계  목차    요구사항 분석 도메인 모델과 테이블 설계 엔티티 클래스 개발 엔티티 설계시 주의점   도메인 모델과 테이블 설계  도메인 모델 설계   회원은 주문 여러개를 주문 할 수 있습니다. 회원과 주문은 1:N의 관계 입니다.\n  회원은 주문을 할때 한번에 여러 상품을 주문할 수 있습니다. 상품은 또한 여러개의 각각의 주문에 담길 수 있습니다. 주문에 여러개의 상품이 담길 수 있기 때문에\n  주문과 상품은 N:M 이기 때문에 1:N, M:1로 풀어서 가운데 주문상품을 둡니다.\n  1개의 주문당 1개의 배송지가 입력됩니다.\n  상품은 여거래의 카테고리를 가질수 있고, 카테고리는 여러 상품을 포함할 수 있기 때문에 N:M 의 괸계입니다.\n  상품은 도서, 음반, 영화로 구분되는데 상품이라는 공통속성을 이용하므로 상속 구조로 표현 했습니다.\n 엔티티 설계  회원(Member)  JPA에서 생성해주는 회원 SEQ(PK)인 Id, Name, 임베디드 타입의 Address, Orders 리스트를 가진다.\n 주소(Address) 임베디드 타입  값 타입 또는 임베디드 타입이며, city, street, zipcode를 가진다.\n 주문(Order)  한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문 상품은 1:N관계 주문은 상품을 주문한 회원과 주문 정보, 주문 날짜, 주문 상태를 가지고 있다. 주문 상태는 열거형을 이용했는데 ORDER와 CANCEL을 표현할 수 있다.\n 배송(Delivery)  배송정보는 어떤 주문으로 인한 배송인지 알아야하기 때문에, 배송정보와 주소 값타입 그리고 주문상태를 가지고 있습니다.\n 상품(Item)  상품의 이름, 가격, 재고수량, 어느 카테고리에 포함되는지 카테고리 리스트를 가지고 있습니다. 상품에는 앨범, 책, 영화가 있으며 앨범은 가수와 기타, 책은 저자와 ISBN, 영화는 감독과 배우 등 각각의 개별 속성들이 있습니다.\n 카테고리(Category)  카테고리는 계층구조로 부모 카테고리를 가지고 있습니다.\n  예제로는 JPA에서 나올 수 있는 모든 연관관계가 포함되었습니다. 하지만 N:M이나 양방향 관계는 실무에서 사용하면 안되는것이며 N:1, 1:M 으로 변환하여 사용해야합니다. 관련 내용은 저번 강의 내용을 확인 해 보시면 될듯합니다.\n  [자바 ORM 표준 JPA] JPA 다양한 연관관계 매핑\n  회원과 주문의 관계에서 회원이 주문을 했기 때문에 회원에 주문리스트가 있어야 할 것 같지만, 시스템의 입장에서 데이터를 구성할 때 주문에 주문한 회원이 있는것이 바람직 합니다.\n  주문에서 필터를 통해 회원을 식별하는 것이 가능하기 떄문에 회원에서 주문으로의 리스트는 사실 필요 없다고 보면 됩니다.\n 테이블 분석  회원(MEMBER)  회원의 CITY, STREET, ZIPCODE는 값 타입(임베디드) ADRESS의 정보들이 세팅된 것을 볼 수 있습니다.\n 배송(DELIVERY)  회원과 마찬가지로 CITY, STREET, ZIPCODE는 값 타입(임베디드) ADRESS의 정보들이 세팅된 것을 볼 수 있습니다.\n 상품(ITEM)  상속구조로 되어있던 구조가 한개의 테이블로 생성되었습니다. 또한 DTYPE라는 컬럼이 추가되었습니다. 이것은 Single Table 전략을 적용된것입니다.\n  [자바 ORM 표준 JPA] JPA 상속관계 매핑\n 주문(ORDERS)  회원ID와 주문ID를 가지고, 날짜와 상태를 가집니다. 또 ORDER는 키워드이기 때문에 ORDERS라는 이름으로 관례상 많이 사용합니다.\n 주문 상품(ORDER_ITEM)  주문ID와 상품ID를 외래키로 가지고 있습니다. 주문했을 당시의 ITEM 단가, 구매 수량 등을 가지고 있습니다.\n 카테고리(CATEGORY), 상품(ITEM)  객체지향에서는 양방향 관계에서 각각 List를 가질 수 있지만, 관계형 DB에서는 불가하기 때문에 중간에 CATEGORY_ITEM 라는 매핑 테이블을 두고 N:1, 1:M 관계로 풀어야 합니다.\n  참고로 생성할 때에는 테이블 명과 컬럼은 소문자 그리고 언더스코어 스타일로 사용합니다.\n 연관관계 분석  회원 - 주문  N:1, 1:M의 스타일로 회원에서 주문으로 주문에서 회원으로 모두 가능하며, 연관관계의 주인을 정해야 하는데 외래키가 있는 주문을 연관관계의 주인으로 정하는게 좋다. 그러므로 Order.member를 ORDERS.MEMBER_ID 외래 키와 매핑한다.\n  관계형 DB에서는 1:N이라면 N인 위치에 외래키를 두게 됩니다.\n  외래키가 있는 Oder에 연관관계를 두고 Member에는 mappedBy를 써서 연결을 해둡니다. 연관관계의 반대 쪽은 단순 조회 용으로 사용하며 연관관계의 주인을 등록 할때 데이터 세팅을 같이 해줘야 사용할 수 있습니다.\n 주문 - 주문상품ㄷ  주문을 할때 여러개의 상품을 주문할 수 있고 주문 할때 상품 수량과 가격을 가지게 되는데 원 데이터인 상품을 수정할 수 없기 때문에 중간에 테이블 하나를 더 둡니다.\n  Order가 1이고 OrderItem이 N이 됩니다. 그렇기 때문에 외래키는 OrderItem에 두게 되며 연관관계의 주인은 OrderItem이 되게 됩니다. OrderItem.order를 ORDER_ITEM.ITEM_ID 와 매핑합니다.\n 주문상품 - 상품  주문상품과 상품은 N : 1 관계이며 단방향 관계 입니다. OrderItem은 Item을 가지고 있으며 Item을 갈 수있지만, Item에서는 OrderItem으로 갈 수 없습니다. OrderItem * - 1 Item의 *도 지워야하지만, N:1의 관계를 설명하기 위해 추가하고 대신 단방향이라고 설명하기 위해서 화살표를 추가하였습니다.\n  다대일 단방향 관계 OrderItem.order를 ORDER_ITEM.ITEM_ID 외래키랑 매핑한다.\n 주문 - 배송  일대일 단방향 관계 Order.Delivery를 ORDERS.DELIVERY_ID 외래키랑 매핑한다.\n 카테고리 - 상품  @ManyToMany를 사용해서 사용한다실무에서 @ManyToMany는 사용하지 말자, 공부 예제를 위해 사용\n ##### 연관관계의 주인\n 외래키가 있는 곳을 연관관계의 주인으로 정해야한다. 연관관계의 주인은 단순히 외래키를 누가 관리하나의 문제지 비즈니스상 우위에 있다고 주인으로 정하면 안된다. 예를 들어서 자동차의 바퀴가 있으면, 일대다 관계에서 항상 다쪽에 외래키가 있으므로 바퀴를 연관관계의 주인으로 정하면 된다. 물론 자동차를 연관관계의 주인으로 정하는 것이 불가능 하지 않지만 자동차를 연관관계의 주인으로 정하면 자동차가 관리하지 않는 바퀴테이블의 외래 키 값이 업데이트 되므로 관리와 유지보수가 어렵고 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 있다.\n  [자바 ORM 표준 JPA] JPA 다양한 연관관계 매핑\n 참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 도메인 모델과 테이블 설계","id":18,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 도메인 모델과 테이블 설계","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/domain-model-and-db-architecture/"},{"content":"도메인 분석 설계  목차    요구사항 분석 도메인 모델과 테이블 설계 엔티티 클래스 개발 엔티티 설계시 주의점   요구사항 분석   회원기능\n 회원가입 - 이름, 도시, 거리, 우편번호 입력 받아 회원을 등록 회원 목록 - 가입자 seq, 이름, 도시, 주소, 우편번호 조회가능    상품기능\n 상품등록 - 상품명, 가격, 수량, 저자, ISBN 입력받아 상품등록 상품목록 - 등록된 상품 seq, 상품명, 가격 재고수량, 수정버튼 상품수정 - 상품명, 가격, 수량, 저자, ISBN 저장한 값 로드 후 상품수정    상품 주문\n 상품 주문 - 주문회원(선택), 상품(선택), 주문수량을 입력받아 상품 주문, 주문한 물품 수량 감소 , 주문 수량과 재고 수량 비교    주문 목록 - 주문 seq, 주문자명, 대표상품 이름, 대표상품 주문가격, 대표상품 주문 수량, 상태(주문,취소), 일시, 주문 취소 버튼 검색 기능 회원명, 주문상태    주문 취소 - 구매한 물품 갯수만큼 재고 증가, 주문 상태 취소로 변경, 일시 취소 일자로 변경   기능 목록   회원 기능  회원등록 조회   상품 기능  상품 수정 상품 조회   주문 기능  상품 주문 주문 내역 조회 주문 취소   기타 요구사항  상품은 재고관리가 필요 상품의 종류는 도서, 음반, 영화가 있다. 상품은 카테고리로 구분 할 수 있다. 상품 주문시 배송 정보를 입력할 수 있다.     참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 요구사항 분석","id":19,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 요구사항 분석","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/requirement-analysis/"},{"content":"[Spring] @Bean 과 @Component  @Bean 과 @Component 어노테이션이란 ?   IoC Container는 특정 어노테이션이 달려있는 클래스를 빈으로 만들기 위해 빈 스캐닝을 합니다.\n   @Configuration @Bean @Component @Repository @Service @Controller    대표적으로 빈으로 사용 할 수 있게 해주는 어노테이션은 대표적으로 빈으로 사용 할 수 있도록 해주는 어노테이션은 @Bean과 @Component이 있습니다.\n @Bean VS @Component  @Bean   개발자가 작성한 메소드를 통해 반환되는 객체를 Bean으로 만듬.\n @Bean은 개발자가 직접 제어가 불가능한 외부 라이브러리를 사용할 때 사용. @Configuration을 선언한 클래스 내부에서 사용   @Component   @Component는 개발자가 직접 작성한 Class를 Bean으로 만듬.\n ","description":"@Bean과 @Component","id":20,"section":"blog","tags":["Spring","Framework","SpringFramework"],"title":"[Spring] @Bean과 @Component","uri":"https://offetuoso.github.io/blog/develop/framework/spring/spring-bean-component/"},{"content":"JPA 동작확인  JPA와 DB설정   여태까지 application.properties 를 이용해왔는데, 간혹 yml을 사용하는 것을 봐왔는데 이번에 사용하게 되었습니다.\n  resources/application.properties를 확장자를 변경하여 백업(또는 제거) 하고 같은 resources/ 위치에 application.yml 생성\n  resources/application.yml\n spring:\rdatasource:\rurl: jdbc:h2:tcp://localhost/~/jpashop; # MVCC=true H2 1.4.200 버전부터 MVCC 옵션이 제거되었습니다. username: sa\rpassword:\rdriver-class-name: org.h2.Driver\rjpa:\rhibernate:\rddl-auto: create # 애플리케이션 동작 시점에 엔티티 재생성\rproperties:\r# show_sql: true #sysout을 통해 남기는 sql\rformat_sql: true\rdatabase: h2\rdevtools:\rlivereload:\renabled: true # livereload 사용시 활성화\rrestart:\renabled: false #운영 에서는 제거.\rthymeleaf:\rcache: false\rlogging:\rlevel:\rorg.hibernate.SQL: debug\r  이렇게만 세팅하여도 SpringBoot에서 커넥션풀(HikariCP) 설정을 해줍니다.\n  이러한 설정에 대한 메뉴얼은 스프링부트의 LEARN의 버전별 Reference Doc.에 있습니다.\n https://docs.spring.io/spring-boot/docs/current/reference/html/\r\r MVCC=true 옵션 설명 \rMVCC=true   다중 버전 동시성 제어 (Multi-Version Concurrency Control) 동시성을 제어하기 위해 사용하는 매커니즘 중 하나    동시성이란 데이터베이스에 동시 접근하는 것을 의미\n  일관성과 동시성은 반비례관계 동시성↑일관성↓ / 동시성↓일관성↑\n  동시에 DB에 접근하는 사람이 많으면 데이터가 일관적이지 않을 수 있기 때문에 동시성을 낮출수 밖에 없다.\n  \u0026lsquo;동시성 제어\u0026rsquo;란 동시에 실행되는 트랜잭션을 최소화하며, 일관성을 최대화 하여 데이터 무결성 유지 되도록 하는것이 목표\n  읽기와 쓰기가 서로의 작업을 방해해 동시성 저하와 리소스 Lock을 사용함에도 데이터 일관성이 훼손될 수 있는 문제를 해결하기 위해 MVCC 매커니즘을 사용\n MVCC 매커니즘   데이터를 변경 할 때 변경사항을 Undo 영역에 저장. 데이터를 읽다가 트랜잭션 시작한 시점 이후 변경된 값을 발견하면 Undo 영역에 저장된 정보를 이용해 버전을 생성하고 그것을 읽는다.   장점   Lock을 기다릴 필요가 없어 일반적인 RDBMS보다 빠르다. 데이터를 읽을 때 다른 사용자의 CRUD에 영향을 받지 않는다.   단점   데이터의 버전 충돌이 있을 수 있다.  애플리케이션 영역에서 문제를 해결해야함.   사용하지 않는 버전들에 대한 정리가 필요하다.   \rJPA 동작확인  엔티티 생성   엔티티 패키지 java/jpabook/jpashop/entity 패키지 생성\n  java/jpabook/jpashop/entity/Member.java\n package jpabook.jpashop.entity;\rimport lombok.Getter;\rimport lombok.Setter;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\r@Getter @Setter // Lombok으로 Getter Setter 사용\rpublic class Member {\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\r}\r  엔티티 패키지 java/jpabook/jpashop/repository 패키지 생성\n @PersistenceContext  JPA를 쓰기 때문에 EntityManger가 있어야 하는데 SpringBoot를 사용하면 스프링컨텍스트 위에서 동작하기 때문에, \u0026lsquo;@PersistenceContext\u0026rsquo;가 붙어진 EntityManger에 EntityManger 객체를 스프링에서 자동으로 주입해줍니다.\n  java/jpabook/jpashop/repository/MemberRepository.java\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.entity.Member;\rimport org.springframework.stereotype.Repository;\rimport javax.persistence.Entity;\rimport javax.persistence.EntityManager;\rimport javax.persistence.PersistenceContext;\r@Repository\rpublic class MemberRepository {\r@PersistenceContext\rprivate EntityManager em;\rpublic Long save(Member member){\rem.persist(member);\rreturn member.getId();\r}\rpublic Member find(Long id){\rreturn em.find(Member.class, id);\r}\r}\r  return member.getId(); member를 직접 반환하지 않고 member.getId()를 반환하는 이유는\n  command와 query를 분리해라 라는 원칙에 따라서\n  저장을 하고나온 member는 바로 사용하게 되면 사이드이펙트가 발생할 여지가 있기 때문에, 최소한의 id만 리턴하여 다시 사용할때는 다시 조회해서 사용하는게 안전합니다.\n 테스트 코드  테스트 코드를 작성할 클래스명을 블록잡아서 Alt + Enter \u0026gt; 테스트 생성\n  JUnit5로 선택하고 확인\n  Alt + Insert로 빈 테스트코드 생성\n 테스트코드 라이브템플릿 추가  Ctrl + Alt + S\n  추가를 눌러 tdd로 새로운 템플릿을 작성합니다.\n @Test\rpublic void $NAME$() throws Exception{\r//given\r$END$\r//when\r//then\r}\r  *Test.java 에디터에서 tdd를 입력하고 tab을 눌러 tdd 템플릿을 사용할 수 있습니다.\n  java/jpabook/jpashop/repository/MemberRepositoryTest.java\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.entity.Member;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\rclass MemberRepositoryTest {\r@Autowired MemberRepository memberRepository;\r@Test\rpublic void memberTest() throws Exception{\r//given\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\r//when\rLong saveId = memberRepository.save(member);\rMember findMember = memberRepository.find(saveId);\r//then\rAssertions.assertEquals(findMember.getId(), member.getId());\rAssertions.assertEquals(findMember.getUsername(), member.getUsername());\r}\r}\r  테스트를 실행하면, 오류가 발생합니다.\n No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call; nested exception is javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call\r현재 스레드에 사용할 수 있는 실제 트랜잭션이 있는 EntityManager가 없습니다. '영속' 호출을 안정적으로 처리할 수 없습니다. 중첩 예외는 javax.persistence.TransactionRequiredException입니다: 현재 스레드에 사용할 수 있는 실제 트랜잭션이 있는 EntityManager가 없습니다. '영속' 호출을 안정적으로 처리할 수 없습니다.\r  EntityManager는 트랜잭션 안에서 동작하여야 안정적인 처리를 할 수 있다는 오류를 뱉어냅니다.\n  MemberRepositoryTest.java\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.entity.Member;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.transaction.annotation.Transactional;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional /* org.springframework.transaction.annotation.Transactional 권장 */\rclass MemberRepositoryTest {\r@Autowired MemberRepository memberRepository;\r@Test\rpublic void memberTest() throws Exception{\r//given\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\r//when\rLong saveId = memberRepository.save(member);\rMember findMember = memberRepository.find(saveId);\r//then\rAssertions.assertEquals(findMember.getId(), member.getId());\rAssertions.assertEquals(findMember.getUsername(), member.getUsername());\r}\r}\r  다시 테스트를 실행하면 테스트가 성공한 것을 확인 할 수 있습니다.\n  Test를 진행하면 DB에 쌓이지 않고 Rollback을 하게 되는데 @Rollback(false) 어노테이션을 추가하면 데이터가 쌓이는 것을 확인 할 수 있습니다.\n  여기까지 확인을 하게되면 JPA가 잘 세팅 되어있는 것을 확인 할 수있습니다.\n Junit5  Junit4의 assertThat() 과 isEqualTo 사용하기 위해서는 Hamcrest 라이브러리의 도움을 받아햐 합니다.\n  gradle.build\n dependencies{\rimplementation 'org.hamcrest:hamcrest-core:2.2'\r}\r import static org.hamcrest.CoreMatchers.equalTo;\rimport static org.hamcrest.CoreMatchers.is;\rimport static org.hamcrest.MatcherAssert.assertThat;\rassertThat(findMember, equalTo(member));\rassertThat(findMember, is(member));\r  생성한 member와 조회한 findMember는 같은 객체일까 ?\n package jpabook.jpashop.repository;\rimport jpabook.jpashop.entity.Member;\rimport org.junit.jupiter.api.Assertions;\rimport org.junit.jupiter.api.Test;\rimport static org.hamcrest.CoreMatchers.equalTo;\rimport static org.hamcrest.CoreMatchers.is;\rimport static org.hamcrest.MatcherAssert.assertThat;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.boot.test.context.SpringBootTest;\rimport org.springframework.test.annotation.Rollback;\rimport org.springframework.transaction.annotation.Transactional;\rimport static org.junit.jupiter.api.Assertions.*;\r@SpringBootTest\r@Transactional\r/*@Rollback(false) 테스트 시 데이터 쌓임 */\rclass MemberRepositoryTest {\r@Autowired MemberRepository memberRepository;\r@Test\rpublic void memberTest() throws Exception{\r//given\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\r//when\rLong saveId = memberRepository.save(member);\rMember findMember = memberRepository.find(saveId);\r//then\rAssertions.assertEquals(findMember.getId(), member.getId());\rAssertions.assertEquals(findMember.getUsername(), member.getUsername());\rassertThat(findMember, equalTo(member));\r}\r}\r  같은 영속성 컨텍스트 안에서는 생성한 객체와 조회한 객체가 같습니다.\n  1차 캐시에 값이 있기 때문에, 굳이 재조회를 하지 않고 값을 찾아 넣어줍니다.\n Jar 빌드해서 동작 확인  Gradle 빌드를 합니다.\n  윈도우 cmd 창 프로젝트 경로에서\n .\\gradlew.bat // 배치 실행 자동으로 .\\이 붙네요\r.\\gradlew build //윈도우 11에서는 이렇게도 실행되네요   실행을 마치고 나면, ~~\\jpashop\\build\\libs 프로젝트 빌드 라이브러리 안에 Jar 파일이 생성됩니다.\n  생성된 Jar를 실행해 봅니다.\n java -jar .\\jpashop-0.0.1-SNAPSHOT.jar\r  스프링부트에서는 Jar기동만 해도 스프링부트가 톰캣을 실행 시키는군요 이런 방식으로는 처음 구동해 보네요\n 스프링부트의 자동설정  스프링부트를 통해 persistence.xml이나 localContainerEntityFactoryBean 등 번거러운 설정을 자동으로 해준다.\n 쿼리 파라미터 로그 남기기  https://github.com/gavlyukovskiy/spring-boot-data-source-decorator\n  오픈소스로 사용할 수 있는 라이브러리 spring-boot-data-source-decorator의 P6Spy를 추가해 보도록 하겠습니다.\n P6Spy - 대부분의 Connection, Statement 및 ResultSet 메소드 호출을 가로채는 것을 포함하여 SQL 쿼리를 가로채고 기록하는 기능을 추가합니다.\r  Quick Start를 보고 p6spy를 build.gradle에 추가합니다.\n dependencies {\rimplementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.8.0'\r}\r  이후 설정 리로딩 후 라이브러리를 받은 후 바로 적용이 됩니다.\n  테스트를 돌려보면, p6spy 가 포함된 로그를 볼 수 있습니다.\n  p6spy 설정 application.yml에 필요한 옵션을 추가하면 된다.\n # JDBC 이벤트를 기록하기 위해 P6LogFactory 등록\rdecorator.datasource.p6spy.enable-logging=true\r# com.p6spy.engine.spy.appender.SingleLineFormat 대신 com.p6spy.engine.spy.appender.MultiLineFormat 사용\rdecorator.datasource.p6spy.multiline=true\r# 기본 리스너 [slf4j, sysout, file, custom]에 대한 로깅 사용\rdecorator.datasource.p6spy.logging=slf4j\r# 사용할 로그 파일(logging=file일 때만)\rdecorator.datasource.p6spy.log-file=spy.log\r# 사용할 클래스 파일(logging=custom인 경우에만). 클래스는 com.p6spy.engine.spy.appender.FormattedLogger를 구현해야 합니다.\rdecorator.datasource.p6spy.custom-appender-class=my.custom.LoggerClass\r# 사용자 지정 로그 형식(지정된 경우 com.p6spy.engine.spy.appender.CustomLineFormat이 이 로그 형식과 함께 사용됨)\rdecorator.datasource.p6spy.log 형식=\r# 정규식 패턴을 사용하여 로그 메시지를 필터링합니다. 지정된 경우 일치하는 메시지만 기록됩니다.\rdecorator.datasource.p6spy.log-filter.pattern=\r# 추적 시스템에 유효한 SQL 문자열(실제 값으로 대체된 '?')을 보고합니다.\r# 참고 이 설정은 로깅 메시지에 영향을 주지 않습니다.\rdecorator.datasource.p6spy.tracing.include-parameter-values=true\r  이런 기능들은 개발시 편리와 도움을 주지만, 운영에 배포할 때에는 성능에 이슈가 있을 수 있어서 성능 테스트 이후 제거하거나 수정해서 배포를 하도록해야합니다.\n 참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] JPA 동작확인","id":21,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] JPA 동작확인","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/jpa-start/"},{"content":"H2 데이터베이스 설치 및 세팅  H2 데이터베이스   개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공\n 다운로드 및 설치    사용 환경에 따라 받으시면 되며, 저는 1.4.200 버전을 받아 설치 하였습니다.\n H2 Database 설치   JPA 시작 과거 포스팅 참조\n  H2 Database 설치 \r H2 홈페이지에서 OS에 맞는 설치 파일을 다운로드한다.\n  C:\\Program Files (x86)\\H2\\bin\\h2.bat 실행\n  jdbc:h2:~/jpashop (최초 1회, 세션키 유지한 상태로 실행)\n  이후 부터는 jdbc:h2:tcp://localhost/~/jpashop 으로 접속\n  http://localhost:8082/login.jsp 에서 연결버튼 클릭\n  데이터베이스 파일 생성 방법   http://localhost:8082 접속 jdbc:h2:~/jpashop (최초 1회, 세션키 유지한 상태로 실행) ~/jpashop.mv.db 파일 생성 확인 (C:\\Users\\UserId\\에 위치) 이후 부터는 jdbc:h2:tcp://localhost/~/jpashop 으로 접속   참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] H2 데이터베이스 설치 및 세팅","id":22,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] H2 데이터베이스 설치 및 세팅","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/h2-preferences/"},{"content":"View 환경 설정 Thymeleaf  Thymeleaf\n  Spring에서도 밀고 있고, 스프링과 많은 기능을 제공하고 있어, Jsp 보다 Thymeleaf를 사용하는 추세입니다.\n  장점은\n  자연 템플릿 (Natural Templates) 마크업을 깨트리지 않고 html 마커 안에 프로그래밍 문법을 넣어 기능을 개발 할 수 있습니다. WAS 없이도 브라우저만으로도 템플릿의 결과물을 볼 수 있습니다.\n \u0026lt;table\u0026gt;\r\u0026lt;thead\u0026gt;\r\u0026lt;tr\u0026gt;\r\u0026lt;th th:text=\u0026quot;#{msgs.headers.name}\u0026quot;\u0026gt;Name\u0026lt;/th\u0026gt;\r\u0026lt;th th:text=\u0026quot;#{msgs.headers.price}\u0026quot;\u0026gt;Price\u0026lt;/th\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/thead\u0026gt;\r\u0026lt;tbody\u0026gt;\r\u0026lt;tr th:each=\u0026quot;prod: ${allProducts}\u0026quot;\u0026gt;\r\u0026lt;td th:text=\u0026quot;${prod.name}\u0026quot;\u0026gt;Oranges\u0026lt;/td\u0026gt;\r\u0026lt;td th:text=\u0026quot;${#numbers.formatDecimal(prod.price, 1, 2)}\u0026quot;\u0026gt;0.99\u0026lt;/td\u0026gt;\r\u0026lt;/tr\u0026gt;\r\u0026lt;/tbody\u0026gt;\r\u0026lt;/table\u0026gt;\r  단점은 마크업을  이런식으로 정확하게 닫아줘야 인식 하는 문제가 있었지만, 3.0에서는 개선되어 로 사용가능합니다.\n  또 기존 JSP 문법과 다르기 때문에 메뉴얼을 참조해 사용해야합니다.\n  최근에는 서버 사이드 뷰 템플릿 보다 리액트나 뷰js 등 좋은 프론트엔드 프레임워크가 있기 때문에 그쪽을 더 많이 사용합니다.\n 스프링부트 thymeleaf viewName 매핑   resuources:templates/[viewName].html 기본적으로 스프링부트가 리소스 템플릿즈 밑에 뷰 이름으로 매핑을 합니다.\n  build.gradle\n \t...\rdependencies {\rimplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\rimplementation 'org.springframework.boot:spring-boot-starter-thymeleaf' /* 해당 디펜던시 있으면 사용가능 */\rimplementation 'org.springframework.boot:spring-boot-starter-web'\rcompileOnly 'org.projectlombok:lombok'\rruntimeOnly 'com.h2database:h2'\rannotationProcessor 'org.projectlombok:lombok'\rtestImplementation 'org.springframework.boot:spring-boot-starter-test'\r}\r...\r Tymeleaf 서버사이드 랜더링  Controller 생성\n  HelloController.java\n package jpabook.jpashop;\rimport org.springframework.stereotype.Controller;\rimport org.springframework.ui.Model;\rimport org.springframework.web.bind.annotation.GetMapping;\r@Controller\rpublic class HelloController {\r@GetMapping(\u0026quot;hello\u0026quot;) // hello 라는 응답을 받으면\rpublic String hello(Model model){\rmodel.addAttribute(\u0026quot;data\u0026quot;, \u0026quot;hello !!\u0026quot;); // addAttribute data의 값에 \u0026quot;hello !!\u0026quot; 를 넣어서\rreturn \u0026quot;hello\u0026quot;; /* view 라는 페이지를 오픈*/\r}\r}\r  view 파일 생성\n  resources \u0026gt;templates 우크릭 \u0026ldquo;hello.html\u0026rdquo; 생성\n  hello.html\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt; \u0026lt;!-- html에 thymeleaf url 추가 --\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;Hello\u0026lt;/title\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;content-type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p th:text=\u0026quot;'안녕하세요. ' + ${data}\u0026quot;\u0026gt; 안녕하세요. 손님\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  해당 파일 경로에서 html을 열어보면 작성한 그대로 실행 되는 것을 확인 할 수 있습니다.\n  페이지 소스보기를 하면 thymeleaf의 문법을 추가한 소스도 볼 수 있습니다.\n  JpashopApplication.java - 애플리케이션 실행\n  console\n  . ____ _ __ _ _\r/\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\\r( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\r\\\\/ ___)| |_)| | | | | || (_| | ) ) ) )\r' |____| .__|_| |_|_| |_\\__, | / / / /\r=========|_|==============|___/=/_/_/_/\r:: Spring Boot :: (v2.6.6)\r  http://localhost:8080/hello 로 애플리케이션 호출\n  정상적으로 애플리케이션이 화면을 \u0026ldquo;안녕하세요. hello !!\u0026ldquo;로 랜더링 하는것을 확인 할 수 있습니다.\n Tymeleaf 정적(Static) 페이지 생성  resources \u0026gt; static \u0026gt; index.html 생성\n \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;인덱스\u0026lt;/p\u0026gt;\r\u0026lt;a href=\u0026quot;/hello\u0026quot;\u0026gt;hello\u0026lt;/a\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r thymeleaf 수정시 자동 리로드 되도록 설정하기   서버사이드 뷰 템플릿을 사용하다 보면 간단 텍스트 수정을 하여도 적용을 하기 위해서는 서버를 재기동 해야하는 불편함이 있습니다.\n  이러한 불편함을 해결하기 위해서 필요한 라이브러리가 있습니다.\n  build.gradle\n ...\rdependencies {\r...\rdevelopmentOnly(\u0026quot;org.springframework.boot:spring-boot-devtools\u0026quot;)\r...\r}\r...\r  dependency 추가후 gradle 리로딩\n  이 라이브러리가 개발할때 많은 도와주는 기능을 하는데, 캐시 같은 것들을 제거하고 리로딩이 되게 지원을 합니다.\n  Controller에서 return 하는 viewName을 트리거로 서버가 리로딩 되지만, thymeleaf의 화면이 수정되었을때 리로딩되는 것을 원하기 때문에 좀더 찾아보았습니다.\n  resources/application.properties\n spring.devtools.restart.enabled=true\rspring.devtools.restart.poll-interval=2s\rspring.devtools.restart.quiet-period=1s\rspring.thymeleaf.cache=false\r  애플리케이션 업데이트 정책 실행 중 옵션을 통해 thymeleaf 수정 시 서버가 리로드 되는 것을 사용할 수 있었습니다.   현재 IDEA Ultimate 사용중이라 Community도 가능한지는 확인하지 못했습니다.\n 참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용]  View 환경 설정","id":23,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] View 환경 설정","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/view-preferences/"},{"content":"스프링부트 JPA 활용(Using SpringBoot JPA)  목차    프로젝트 생성 라이브러리 살펴보기 H2 데이터베이스 설치 JPA와 DB 설정, 동작확인   프로젝트 생성    스프링 부트 스타터(https://start.spring.io/) 사용기능 : Web, Thymeleaf, JPA, H2, Lombok  groupId : jpabook artifactId : jpashop      프로젝트 타입은 Gradle Project 최근에는 Maven이 아니라 Gradle이 많이 사용된다고 합니다.\n  언어는 당연히 자바 !\n  스프링부트는 안정화 버전을 추천하며, 전 2.6.6\n  GroupId는 jpabook\n  ArtifactId는 jpashop\n  Dependencies는\n web (Spring Web) Thymeleaf JPA H2 Lombok   1. web (Spring Web)  RESTful, MVC, tomcat 내장하고 있는 라이브러리로 웹을 개발할 때 꼭 필요합니다.\n 2. Thymeleaf  jsp가 아닌 모던한 서버 사이드 자바 템플릿 - 최근에는 JSP를 잘 안쓴다고합니다.\n 3. JPA  JPA는 따로 없고 Spring Data JPA를 사용, 스프링 데이터와 하이버네이트를 이용한 JPA\n  이번 강의는 Spring Data JPA의 설명은 없고 SpringBoot와 JPA를 가지고 웹 애플리케이션을 만드는데 초점을 두었습니다. Spring Data JPA는 스프링과 JPA를 가지고 애플리케이션을 잘 만드는 방법을 안다면, Spring Data JPA를 쉽게 터득하고 많은 코드 중복 사용을 줄일수 있기 때문에 JPA를 깊이 터득하고 도움용으로 사용하기를 권장합니다.\n 4. H2  데이터베이스는 H2를 사용하겠습니다. H2 데이터베이스는 내장으로 쉽게 사용할 수 있는 장점이 있습니다. 테스트용으로 많이 사용합니다.\n 5. Lombok  엔티티의 Getter Setter를 추가 하지 않아도 사용가능하게 만들어주는 어노테이션\n SpringBoot 세팅   여기까지 Dependencies 설정을 하겠습니다.\n  자바 버전은 8로 하고 GENERATE를 눌러 다운받습니다.\n  다운받은 프로젝트 압축파일은 적당한 위치에 위치시킵니다.\n  저는 개인적으로 공부한 프로젝트는 깃에 올리기 때문에 깃 폴더로 이동시켰습니다.\n  IntelliJ IDEA에서 Import 또는 Open 으로 프로젝트를 불러옵니다.\n  Gradle 프로젝트를 신뢰하는지 물어보는데 당연히 신뢰를 눌러줍니다.\n  처음 프로젝트를 오픈하게 되면 2에서 최대 5분까지 라이브러리를 받아옵니다.\n  한참 Gradle로 라이브러리들을 다운받고 나면, build.gradle을 열어확인해 봅니다.\n 라이브러리 설정 확인  bulild.gradle\n plugins {\t/*\t플러그인에 대한 설정\t*/\rid 'org.springframework.boot' version '2.6.6'\t/*\t스프링부트를 사용하면 스프링부트가 필요한 플러그인들이 기본적으로 추가됩니다. */\rid 'io.spring.dependency-management' version '1.0.11.RELEASE'\t/*\t스프링부트 버전에 따라 라이브러리에 대한 Dependency까지 관리 */\rid 'java'\r}\rgroup = 'jpabook'\rversion = '0.0.1-SNAPSHOT'\rsourceCompatibility = '1.8'\tconfigurations {\rcompileOnly {\rextendsFrom annotationProcessor\t/* lombok에서 추가된 세팅 뒤에서 설명 */\r}\r}\rrepositories {\rmavenCentral()\t// mavenCentral에서 라이브러리를 받겠다는 설정\r}\rdependencies {\t/* 의존관계 */\rimplementation 'org.springframework.boot:spring-boot-starter-data-jpa'\rimplementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\rimplementation 'org.springframework.boot:spring-boot-starter-web'\rcompileOnly 'org.projectlombok:lombok'\rruntimeOnly 'com.h2database:h2'\rannotationProcessor 'org.projectlombok:lombok'\rtestImplementation 'org.springframework.boot:spring-boot-starter-test'\r}\rtasks.named('test') {\ruseJUnitPlatform()\r}\r 프로젝트 실행  java/jpabook/jpashop/JpashopApplication.java\n  스프링 부트 스타터에서 생성해준 main class를 열어서\n  파일 우클릭 후 실행 \u0026lsquo;JpashopApplication(U)\u0026rsquo; 또는 Ctrl + Shift + F10\n  Tomcat started on port(s): 8080 (http) with context path '' 가 정상적으로 나오면 톰캣이 성공적으로 구동된 것을 알 수 있습니다.\n  브라우저에서 localhost:8080 또는 127.0.0.1:8080 를 입력해 봅니다.\n  아무것도 없기 때문에, Whitelabel Error Page 페이지가 뜨는게 맞습니다.\n  src/test/ 경로 밑에 테스트 코드를 자동으로 생성해 주는데 테스트 코드도 실행해 봅니다.\n  테스트 코드 작성된게 없지만 설정이 잘 되었는지 확인합니다.\n  외부 라이브러리가 잘 받아졌는지도 확인 합니다.\n  왜 라이브러리가 선택한 것보다 많지? 해도 gradle을 통하여 라이브러리를 가져오게 되면, 의존 관계에 있는 모든 라이브러리를 불러오기 때문에 지정한 라이브러리보다 많이 받습니다.\n  여기까지 확인이되면 세팅이 정상적으로 마무리 된 것입니다.\n Lombok 세팅   IntelliJ의 파일\u0026gt;설정에서 플러그인을 검색\n  플러그인 검색에서 Lombok을 검색합니다. 저는 이미 설치가 되어 있지만 설치/업데이트 를 하고 IDE를 재시작합니다.\n  Lombok을 깔게 되면 무조건 해줘야 하는 세팅이 있습니다.\n  다시 파일\u0026gt;설정 (ctrl+alt+S)\n  한글팩 시 어노테이션 프로세서 로 검색 (annotation processors)\n  어노테이션 처리 활성화 (Enable annotation processing) 체크\n  Lombok이 설치가 잘 되었는지 아무 class를 추가해서 테스트 해보겠습니다.\n  Hello.java 생성\n package jpabook.jpashop;\rimport lombok.Getter;\rimport lombok.Setter;\r@Getter @Setter\rpublic class Hello {\rprivate String data;\r}\r  JpashopApplication.java\n package jpabook.jpashop;\rimport org.springframework.boot.SpringApplication;\rimport org.springframework.boot.autoconfigure.SpringBootApplication;\r@SpringBootApplication\rpublic class JpashopApplication {\rpublic static void main(String[] args) {\rSpringApplication.run(JpashopApplication.class, args);\rHello hello = new Hello();\rhello. // ctrl+space\r}\r}\r  Hello 객체를 생성하여 .뒤에서 자동완성(ctrl+space)를 누르면 Lombok을 통해 추가한 Getter Setter가 나오는 것을 확인 할 수 있습니다.\n  이로서 기본적으로 프로젝트를 생성하는것은 정리가 끝났습니다.\n 참고   실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발 - 김영한   ","description":"[스프링부트 JPA 활용] 프로젝트 생성","id":24,"section":"blog","tags":["스프링부트 JPA 활용","김영한","JPA","ORM","Java","Spring","인프런"],"title":"[스프링부트 JPA 활용] 프로젝트 생성","uri":"https://offetuoso.github.io/blog/develop/backend/using-springboot-jpa/new-project-setting/"},{"content":"JPA 에필로그(Epilogue)   장장 4개월의 기간동안 강의를 보며, 강의 PPT를 읽고 넘기는 것이 아니라 하나 하나 블로그로 정리를 한다는 목적으로 타자연습을 하였습니다.\n  조금이라도 머리에 남기 바라는 심정과 고질적인 독수리 타법을 개선하고자 노력하였습니다.\n  일이 바쁘다, 몸이 아프다 라는 핑계로 매우 늦게 완강을 하였지만, 결국 해냈습니다.\n  사실 SI에서 JPA를 만져볼 일이 없지만, 저와 같이 새로운 것에 도전하고 배우려는 사람이 늘어나고 지금보다 JPA가 더 많은 기업에서 사용하고 많은 개발자들이 사용하는 날이 온다면 SI에서도 당연히 JPA를 사용하는 날이 오리라 믿습니다.\n  탈 SI를 꿈꾸며 부지런히 공부를 해야겠습니다.\n  좋은 강의를 만들어 공유해 주신 김영한 강사님에게 감사의 인사를 드립니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 에필로그(Epilogue)","id":25,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 에필로그(Epilogue)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpa-epilogue/"},{"content":"JPQL 벌크 연산(Bulk Operation)   여러 건(대량의 데이터)을 한 번에 수정하거나 삭제하는 방법\n 벌크 연산    재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면? JPA 변경 감지(Duty Checking) 기능으로 실행하려면 너무 많은 SQL 실행  재고가 10개 미만인 상품을 리스트로 조회한다. 상품 엔티티의 가격을 10% 증가한다. 트랜잭션 커밋 시점에 변경감지가 동작한다.   변경된 데이터가 100건이라면 100번의 UPDATE SQL실행   벌크 연산 예제    쿼리 한 번으로 여러 테이블 로우 변경(엔티티) excuteUpdate()의 결과는 영향받은 엔티티 수 반환 UPDATE, DELETE 지원 INSERT(insert into .. select, 하이버네이트 지원) JPA 표준 스펙에는 없는데 하이버네이트는 지원   String qlString = \u0026quot;UPDATE Product p \u0026quot; +\r\u0026quot;SET p.price = p.price * 1.1 \u0026quot; +\r\u0026quot;WHERE p.stockAmount \u0026lt; :stockAmount\u0026quot;;\rint resultCount = em.createQuery(qlString)\r.setParameter(\u0026quot;stockAmount\u0026quot;, 10)\r.executeUpdate();\t  JpqlMain.java\n \rTeam team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rint resultCnt = em.createQuery(\u0026quot;UPDATE Member m SET m.age = m.age+1\u0026quot;)\r.executeUpdate();\rSystem.out.println(resultCnt);\rtx.commit();\r  console\n Hibernate: /* UPDATE\rMember m SET\rm.age = m.age+1 */ update\rMember set\rage=age+1\r4 // 결과 4명\r  모든 사용자 나이 +1 업데이트된 결과를 볼 수 있습니다.\n 벌크 연산 주의   벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리   이를 간단히 해결하기 위해서는\n 벌크 연산을 먼저 실행 벌크 연한 수행 후 영속성 컨텍스트 초기화 em.refresh() 사용    예를 들어 회원의 연봉이 5천만원 이였는데\n회원의 연봉을 엔티티로 조회했더니 5천만원이였고 벌크 연산이 실행되어 6천만원으로 업데이트가 됨\nDB에는 6천만원으로 되어있고, 엔티티에는 5천만원으로 남아있는 상태가 됩니다. 이러한 경우에는 벌크 연산 후 엔티티를 초기화 한다면 아무 문제가 없습니다.\n  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\r// FLUSH 자동 호출 (커밋, query실행, 강제 Flush)\rint resultCnt = em.createQuery(\u0026quot;UPDATE Member m SET m.age = m.age+1\u0026quot;)\r.executeUpdate();\rSystem.out.println(resultCnt);\rtx.commit();\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rint resultCnt = em.createQuery(\u0026quot;UPDATE Member m SET m.age = m.age+1\u0026quot;)\r.executeUpdate();\rSystem.out.println(resultCnt);\rSystem.out.println(\u0026quot;member1.getAge() = \u0026quot;+member1.getAge());\t//*** 출력 추가\rSystem.out.println(\u0026quot;member2.getAge() = \u0026quot;+member2.getAge());\rSystem.out.println(\u0026quot;member3.getAge() = \u0026quot;+member3.getAge());\rSystem.out.println(\u0026quot;member4.getAge() = \u0026quot;+member4.getAge());\rtx.commit();\r  console\n Hibernate: /* UPDATE\rMember m SET\rm.age = m.age+1 */ update\rMember set\rage=age+1\r4\rmember1.getAge() = 31\rmember2.getAge() = 32\rmember3.getAge() = 33\rmember4.getAge() = 34\r종료 코드 0(으)로 완료된 프로세스\r  출력된 결과는 31, 32, 33 살이지만 데이터베이스에서 조회한 결과는 32, 33, 34 로 1살 추가된 것을 확인 할 수 있습니다.\n  벌크 연산은 영속성 컨텍스트와 상관없이 DB에 직접 수정하기 때문에 영속성 컨텍스트에는 DB에 벌크 연산으로 수정되기 전 데이터가 남아있습니다.\n  잘못 사용하다가 데이터 접합성 문제가 생길 수 있어 조심해야 합니다.\n 벌크 연한 수행 후 영속성 컨텍스트 초기화  JqplMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rint resultCnt = em.createQuery(\u0026quot;UPDATE Member m SET m.age = m.age+1\u0026quot;)\r.executeUpdate();\rSystem.out.println(resultCnt);\rem.clear(); // 영속성 컨텍스트를 초기화 한후 다시 조회\rMember findMember1 = em.find(Member.class, member1.getId());\rMember findMember2 = em.find(Member.class, member2.getId());\rMember findMember3 = em.find(Member.class, member3.getId());\rMember findMember4 = em.find(Member.class, member4.getId());\rSystem.out.println(\u0026quot;findMember1.getAge() = \u0026quot;+findMember1.getAge());\rSystem.out.println(\u0026quot;findMember2.getAge() = \u0026quot;+findMember2.getAge());\rSystem.out.println(\u0026quot;findMember3.getAge() = \u0026quot;+findMember3.getAge());\rSystem.out.println(\u0026quot;findMember4.getAge() = \u0026quot;+findMember4.getAge());\r  console\n Hibernate: select\rmember0_.id as id1_0_0_,\rmember0_.age as age2_0_0_,\rmember0_.TEAM_ID as team_id5_0_0_,\rmember0_.type as type3_0_0_,\rmember0_.username as username4_0_0_ from\rMember member0_ where\rmember0_.id=?\r4\rfindMember1.getAge() = 32\rfindMember2.getAge() = 33\rfindMember3.getAge() = 34\rfindMember4.getAge() = 35\r  벌크 연산을 사용하고 바로 직후에 엔티티를 사용하면, 컨텍스트에 1차 캐시된 데이터를 사용하기 때문에 em.clear를 이용해 영속성 컨텍스트를 초기화 후 사용\n em.refresh()  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\r// em.flush(); // em.refresh는 영속성 컨텍스트에서 관리되는 항목만 적용가능\r// em.clear(); int resultCnt = em.createQuery(\u0026quot;UPDATE Member m SET m.age = m.age+1\u0026quot;)\r.executeUpdate();\rSystem.out.println(resultCnt);\rem.refresh(member1);\rem.refresh(member2);\rem.refresh(member3);\rem.refresh(member4);\rSystem.out.println(\u0026quot;member1.getAge() = \u0026quot;+member1.getAge());\rSystem.out.println(\u0026quot;member2.getAge() = \u0026quot;+member2.getAge());\rSystem.out.println(\u0026quot;member3.getAge() = \u0026quot;+member3.getAge());\rSystem.out.println(\u0026quot;member4.getAge() = \u0026quot;+member4.getAge());\r  console\n Hibernate: /* load jpql.domain.Member */ select\rmember0_.id as id1_0_0_,\rmember0_.age as age2_0_0_,\rmember0_.TEAM_ID as team_id5_0_0_,\rmember0_.type as type3_0_0_,\rmember0_.username as username4_0_0_ from\rMember member0_ where\rmember0_.id=?\rmember1.getAge() = 32\rmember2.getAge() = 33\rmember3.getAge() = 34\rmember4.getAge() = 35\r Spring Data JPA - Modifying Queries  Sprimg Data JPA에서는 @Modifying 애노테이션을 이용해 벌크 연산 쿼리를 사용할 수 있으며, 마찬가지로 벌크 연산과 같이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 수정하기 때문에 주의 해야합니다. Spring Data JPA의 기능을 사용하기 이전에 원리를 미리 배워둬야 장애를 예방하고 왜 그런 문제가 생기는지 알 수 있습니다.\n @Modifying\r@Query(\u0026quot;UPDATE User u SET u.firstname = ?1 WHERE u.lastname = ?2\u0026quot;)\rint setFixedFirstnameFor(String fristname, String lastname);\r 정리   벌크 연산을 사용할 때는 벌크 연한 수행 후 무지성으로 영속성 컨텍스트 초기화 하고, 단건의 수정 삭제에 대해서는 일반적인 JPA가 제공하는 Update와 Delete를 사용하는게 안전합니다.\n 이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r'}';\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 벌크 연산(Bulk Operation)","id":26,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 벌크 연산(Bulk Operation)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/bulk-operation/"},{"content":"JPQL 네임드 쿼리(Named Query)  Named 쿼리  @NamedQuery   쿼리를 엔티티 같은 곳에 미리 선언을 해둘 수 있는 기능. 쿼리를 재활용 해서 사용할 수 있습니다.\n @Entity\r@NamedQuery(\rname = \u0026quot;member.findByUsername\u0026quot;,\rquery = \u0026quot;SELECT m FROM Member WHERE n.username :username\u0026quot;\r)\rpublic class Member {\r...\r}\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(\u0026quot;Member.findByUsername\u0026quot;, Member.class)\r.setParameter(\u0026quot;username\u0026quot;, \u0026quot;회원1\u0026quot;)\r.getResultList();\r 정적 쿼리    미리 정의해서 이름을 부여해두고 사용하는 JPQL 정적 쿼리 어노테이션, XML에 정의 애플리케이션 로딩 시점에 초기화 후 재사용  애플리케이션 로딩 시점에 정적인 쿼리를 JPA 또는 하이버네이트가 SQL로 파싱을 하고, 캐싱을 합니다.   애플리케이션 로딩 시점에 쿼리를 검증   @NamedQuery 사용 테스트  Member.java\n package jpql.domain;\rimport javax.persistence.*;\rimport jpql.domain.*;\r@Entity\r@NamedQuery(name = \u0026quot;Member.findByUsername\u0026quot;, // * 관례로 엔티티명.쿼리명 으로 많이 사용\rquery = \u0026quot;SELECT m FROM Member m WHERE m.username = :username\u0026quot;\r)\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne(fetch = FetchType.LAZY)\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic void changeTeam(Team team){\rthis.team = team;\rteam.getMembers().add(this);\r}\r@Enumerated(EnumType.STRING) // 기본이 숫자 EnumType.ORDINAL 이기 때문에 String으로 필수로 세팅\rprivate MemberType type;\rpublic MemberType getType() {\rreturn type;\r}\rpublic void setType(MemberType type) {\rthis.type = type;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r/*\u0026quot;, team=\u0026quot; + team //toString 양방향 적용시 무한루프될 가능성 toString 에서는 연관관계 제거 */\r'}';\r}\r}\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; resultList = em.createNamedQuery(\u0026quot;Member.findByUsername\u0026quot;, Member.class)\r.setParameter(\u0026quot;username\u0026quot;, \u0026quot;회원1\u0026quot;)\r.getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;name = \u0026quot; + member.getUsername()+ \u0026quot;, age = \u0026quot; + member.getAge());\r}\rtx.commit();\r  console\n Hibernate: /* Member.findByUsername */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id5_0_,\rmember0_.type as type3_0_,\rmember0_.username as username4_0_ from\rMember member0_ where\rmember0_.username=?\rname = 회원1, age = 31\r 애플리케이션 로딩 시점에 쿼리를 검증  만약 누군가가 쿼리를 작성할때 실수로 오타를 냈다고 하고 테스트를 해보겠습니다.\n @Entity\r@NamedQuery(name = \u0026quot;Member.findByUsername\u0026quot;, // * 관례로 엔티티명.쿼리명 으로 많이 사용\rquery = \u0026quot;SELECT m FROM Membe m WHERE m.username = :username\u0026quot;\r)\r  JpqlMain.java - 애플리케이션 재시작\n  console\n \rCaused by: org.hibernate.HibernateException: Errors in named queries: Member.findByUsername failed because of: org.hibernate.hql.internal.ast.QuerySyntaxException: Membe is not mapped [SELECT m FROM Membe m WHERE m.username = :username]\rat org.hibernate.internal.SessionFactoryImpl.\u0026lt;init\u0026gt;(SessionFactoryImpl.java:341)\rat org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:469)\rat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259)\r... 4 more\r  어노테이션에 등록이 되어있기 때문에 Jpa가 미리 파싱을 하고 캐싱을 하려는 중\n  문법이 맞지 않는 상황이 벌어지면 오류를 발생시킵니다.\n Member.findByUsername failed because of: org.hibernate.hql.internal.ast.QuerySyntaxException: Membe is not mapped [SELECT m FROM Membe m WHERE m.username = :username]\r  개발하면서 가장 좋은 에러는 즉시 나는 에러가 좋습니다. 바로 찾을 수 있고 수정할 수 있기 때문입니다. 그러면 가장 안좋은 에러는 사용자가 사용중에 무언가 액션을 했을때 나는 오류입니다. 그리고 그 중간 정도의 오류는 컴파일 시점에 나는 오류입니다. 어떻게든지 로컬에서라도 실행은 시키고 배포를 하기 때문에 대부분의 오류를 다 잡아줄수 있습니다.\n Named 쿼리 - XML에 정의  [META-INF/persistence.xml]\n \u0026lt;persistance-unit name=\u0026quot;jpabook\u0026quot;\u0026gt;\r\u0026lt;mapping-file\u0026gt;META-INF/ormMember.xml\u0026lt;/mapping-file\u0026gt;\r  [META-INF/ormMemer.xml]\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;entity-mappings xmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence/orm\u0026quot; version=\u0026quot;2.1\u0026quot;\u0026gt;\r\u0026lt;named-query name=\u0026quot;Member.findByUsername\u0026quot;\u0026gt;\r\u0026lt;query\u0026gt;\u0026lt;![CDATA[\rSELECT m\rFROM Member m\rWHERE m.username = :username\r]]\u0026gt;\u0026lt;/query\u0026gt;\r\u0026lt;/named-query\u0026gt;\r\u0026lt;named-query name=\u0026quot;Member.count\u0026quot;\u0026gt;\r\u0026lt;query\u0026gt;\u0026lt;![CDATA[\rSELECT COUNT(m) FROM Member m\r]]\u0026gt;\u0026lt;/query\u0026gt;\r\u0026lt;/named-query\u0026gt;\r\u0026lt;/entity-mappings\u0026gt;\r Named 쿼리 환경에 따른 설정   XML이 항상 우선권을 가진다. 애플리케이션 운영 환경에 따라 다른 XML을 배포할 수 있다.    스프링 데이터 JPA를 사용하게 되면 인터페이스 바로 위에 사용 가능합니다.\n  Spring Data JPA\n public interface UserRepository extends JpaReposotory\u0026lt;User, Long\u0026gt;{\r@Query(\u0026quot;SELECT u from User u WHERE u.emailAddress = ?1\u0026quot;)\rUser findByEmailAddress(String emailAddress);\r}\r  스프링 JPA는 JPA를 편하게 사용하기 위해 추상화 하여, JPA의 껍데기 역활만 합니다. @Query(\u0026ldquo;SELECT u from User u WHERE u.emailAddress = ?1\u0026rdquo;) 가 바로 Named 쿼리 입니다. JPA가 해당 어노테이션과 쿼리를 Named 쿼리로 등록합니다. 그래서 애플리케이션 로딩 시점에 파싱하게 되고 문법 오류가 있으면 바로 잡아주게 됩니다.\n 결론  @Entity\r@NamedQuery(\rname = \u0026quot;member.findByUsername\u0026quot;,\rquery = \u0026quot;SELECT m FROM Member WHERE n.username :username\u0026quot;\r)\rpublic class Member {\r...\r}\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(\u0026quot;Member.findByUsername\u0026quot;, Member.class)\r.setParameter(\u0026quot;username\u0026quot;, \u0026quot;회원1\u0026quot;)\r.getResultList();\r  위와 같이 엔티티에 Named Query를 추가하는 것은 코드가 매우 지저분 해지고, 결국 실무에서는 Spring Data JPA를 섞어 쓰는게 좋기 때문에\n  Spring Data JPA\n public interface UserRepository extends JpaReposotory\u0026lt;User, Long\u0026gt;{\r@Query(\u0026quot;SELECT u from User u WHERE u.emailAddress = ?1\u0026quot;)\rUser findByEmailAddress(String emailAddress);\r}\r  이와 같이 Spring Data JPA 방식으로 개발하는게 좋습니다.\n 이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r'}';\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 네임드 쿼리(Named Query)","id":27,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 네임드 쿼리(Named Query)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-named-query/"},{"content":"JPQL 엔티티 직접 사용(Direct Use Of Entity)  엔티티 직접 사용  기본 키 값   JPQL에서 엔티티를 직접 사용하면 SQL로 어떠한 쿼리가 실행되는 지에 대한 정리 입니다.\n  COUNT(m) 같은 SQL 함수에서 엔티티를 직접 사용했을때, SQL에서 해당 엔티티의 식별자인 기본 키 값을 사용하게됩니다.\n  [JPQL]\n SELECT COUNT(m.id) FROM Member M // 엔티티의 아이디를 사용\rSELECT COUNT(m) FROM Member M // 엔티티를 직접 사용\r  [SQL] (둘다 같은 다음 SQL 실행)\n SELECT COUNT(m.id) as CNT FROM Member m\r  엔티티를 파라미터로 전달\n String jpql = \u0026quot;SELECT m FROM Member m WHERE m WHERE m = :member\u0026quot;;\rList resultList = em.createQuery(jqpl)\r.setParameter(\u0026quot;member\u0026quot;, member)\r.getResultList();\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m WHERE m = :mmbr\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;mmbr\u0026quot;,member1)\r.getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;name = \u0026quot; + member.getUsername()+ \u0026quot;, age = \u0026quot; + member.getAge());\r}\rtx.commit();\r  console\n \rHibernate: /* SELECT\rm FROM\rMember m WHERE\rm = :mmbr */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id5_0_,\rmember0_.type as type3_0_,\rmember0_.username as username4_0_ from\rMember member0_ where\rmember0_.id=?\rname = 회원1, age = 31\r  식별자를 직접 전달\n String jpql = \u0026quot;SELECT m FROM Member m WHERE m.id = :memberId\u0026quot;;\rList resultList = em.createQuery(jqpl)\r.setParameter(\u0026quot;memberId\u0026quot;, memberId)\r.getResultList();\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m WHERE m.id = :mmbrId\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;mmbrId\u0026quot;,member1.getId())\r.getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;name = \u0026quot; + member.getUsername()+ \u0026quot;, age = \u0026quot; + member.getAge());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m WHERE\rm.id = :mmbrId */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id5_0_,\rmember0_.type as type3_0_,\rmember0_.username as username4_0_ from\rMember member0_ where\rmember0_.id=?\rname = 회원1, age = 31\r  실행된 SQL\n SELECT m.* FROM Member m WHERE m.id = ?\r 외래 키 값   외래 키 값은\n  Member.java\n  @ManyToOne(fetch = FetchType.LAZY)\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;) // ** 연관관계로 매핑된 외래키\rprivate Team team;\r  엔티티를 파라미터로 전달\n Team team = em.find(Team.class, 1L);\rString jpql = \u0026quot;SELECT m FROM Member m WHERE m.team = :team\u0026quot;;\rList resultList = em.createQury(jpql)\r.setParameter(\u0026quot;team\u0026quot;, team)\r.getResultList();\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m WHERE m.team = :team\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;team\u0026quot;,team1)\r.getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;name = \u0026quot; + member.getUsername()+ \u0026quot;, age = \u0026quot; + member.getAge());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m WHERE\rm.team = :team */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id5_0_,\rmember0_.type as type3_0_,\rmember0_.username as username4_0_ from\rMember member0_ where\rmember0_.TEAM_ID=?\rname = 회원1, age = 31\rname = 회원2, age = 32\r  식별자를 직접 전달\n Team team = em.find(Team.class, 1L);\rString jpql = \u0026quot;SELECT m FROM Member m WHERE m.team.id = :teamId\u0026quot;;\rList resultList = em.createQury(jpql)\r.setParameter(\u0026quot;teamId\u0026quot;, teamId)\r.getResultList();\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m WHERE m.team.id = :teamId\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;teamId\u0026quot;,team1.getId())\r.getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;name = \u0026quot; + member.getUsername()+ \u0026quot;, age = \u0026quot; + member.getAge());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m WHERE\rm.team.id = :teamId */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id5_0_,\rmember0_.type as type3_0_,\rmember0_.username as username4_0_ from\rMember member0_ where\rmember0_.TEAM_ID=?\rname = 회원1, age = 31\rname = 회원2, age = 32\r  실행된 SQL\n SELECT m.* FROM Member m WHERE m.team_id = ?  이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r'}';\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 엔티티 직접 사용(Direct Use Of Entity)","id":28,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 엔티티 직접 사용(Direct Use Of Entity)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-direct-use-of-entity/"},{"content":"JPQL 다형성 쿼리(Polymorphic Query)   이번 시간에는 다형성 쿼리에 대해 정리를해 보겠습니다.\n 다형성 쿼리   JPA가 이러한 다형성을 위해 제공하는 특수한 기능들이 있습니다.\n TYPE   조회 대상을 특정 자식으로 한정\n  예) Item 중에 Book, Movie를 조회해라\n  [JPQL]\n SELECT i FROM Item i\rWHERE TYPE(i) IN (Book, Movie)\r  [SQL]\n SELECT i.* from Item i\rWHERE i.DTYPE IN ('B', 'M')\r TREAT (JPA2.1)    자바의 타입 캐스팅과 유사 (다운 캐스팅 : 자식 타입으로 캐스팅) 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용 FROM, WHERE, SELECT(하이버네이트 지원) 사용    예) 부모인 Item과 자식 Book이 있다.\n  [JPQL]\n SELECT i FROM Item i\rWHERE TREAT(i AS Book).author = 'Kim'   [SQL]\n SELECT i.* from Item i\rWHERE i.DTYPE = 'B' and i.author = 'Kim'\r  자식과 부모의 어떤 전략으로 구성이 되어있느냐에 따라 SQL이 다르게 나가게 되며, 해당 SQL문은 싱글 테이블 전략 시 나오는 쿼리\n 이전 소스   실전 예제 프로젝트 jpa-shop 프로젝트의 소스\n  Item.java \rpackage jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic abstract class Item extends BaseEntity{\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r \r Album.java \rpackage jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;)\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\rpublic String getArtist() {\rreturn artist;\r}\rpublic void setArtist(String artist) {\rthis.artist = artist;\r}\rpublic String getEtc() {\rreturn etc;\r}\rpublic void setEtc(String etc) {\rthis.etc = etc;\r}\r}\r \r Book.java \rpackage jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;)\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic String getIsbn() {\rreturn isbn;\r}\rpublic void setIsbn(String isbn) {\rthis.isbn = isbn;\r}\r}\r \r Movie.java \rpackage jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;)\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\rpublic String getDirector() {\rreturn director;\r}\rpublic void setDirector(String director) {\rthis.director = director;\r}\rpublic String getActor() {\rreturn actor;\r}\rpublic void setActor(String actor) {\rthis.actor = actor;\r}\r}\r \r참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 다형성 쿼리(Polymorphic Query)","id":29,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 다형성 쿼리(Polymorphic Query)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-polymorphic-query/"},{"content":"JPQL 페치 조인(Fetch Join)   실무에서 정말 정말 중요함 쿼리가 여러번 나갈거 같은 쿼리를 한방 쿼리로 변환\n 페치 조인    SQL 조인 종류가 아니다. JPQL에서 성능 최적화를 위해 제공하는 기능 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능 join fetch 명령어 사용 [LEFT [OUTER] | INNER] JOIN FETCH 조인경로   엔티티 페치 조인    회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에) SQL을 보면 회원 뿐만 아니라 팀(T.*)도 함께 SELECT    [JPQL]\n SELECT m FROM Member m JOIN FETCH m.team\r  LEFT OUTER JOIN에 FETCH 만 붙였을 뿐\n  [SQL]\n SELECT M.*, T.* FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID = T.ID\r  M.*, T.*은 모든 컬럼을 축약 SELECT m 만 했는데, 프로젝션에 Member와 Team의 모든 컬럼 추가\n  과거 나왔던 즉시 로딩과 흡사한거 같지만, 개발자가 원하는 대로 객체 그래프를 한번에 조회할 것을 명시적으로 동적인 타이밍에 사용 할 수 있습니다.\n  JPA에서 컬렉션을 조회하면, 위 그림과 같다면 회원1,2,3 그리고 팀A,팀B 레퍼런스로 JPA가 5개의 엔티티로 만들어 영속성 컨텍스트의 1차 캐시에 보관하고 그림과 같은 형태로 반환합니다.\n 페치 조인 미사용   JPQL \u0026ldquo;SELECT m FROM Member m\u0026quot;로 호출 후 Member와 Team의 @ManyToOne FetchType.LAZY 설정을 통한 지연로딩 사용\n  JpqlMain.java\n  Team team1 = new Team();\t//팀A 생성\rteam1.setName(\u0026quot;팀A\u0026quot;);\tem.persist(team1);\tTeam team2 = new Team();\t//팀B 생성\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\t//팀C 생성\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\t//회원1 생성\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\t//회원2 생성\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\t//회원3 생성\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\t//회원4 생성\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.getResultList();\rint i = 0;\rfor(Member member : resultList){\rif(member.getTeam() != null){\rSystem.out.println(\u0026quot;Member = \u0026quot; + member.getUsername()+\u0026quot;, team = \u0026quot;+member.getTeam().getName());\r} else{\rSystem.out.println(\u0026quot;Member = \u0026quot; + member.getUsername()+\u0026quot;, team = null\u0026quot;);\r}\r}\rtx.commit();\r  console\n Hibernate: // MEMBER 조회 회원 4명 가져옴\r/* SELECT\rm FROM\rMember m */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id5_0_,\rmember0_.type as type3_0_,\rmember0_.username as username4_0_ from\rMember member0_\rHibernate: // 회원1의 Team 지연로딩 발생 팀A 조회\rselect\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\rMember = 회원1, team = 팀A\t// i=0, Member = 회원2, team = 팀A\t// i=1, 회원2의 Team 1차 캐시 조회\rHibernate: // 회원3의 Team 지연로딩 발생 팀B 조회\rselect\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\rMember = 회원3, team = 팀B\t// i=2\rMember = 회원4, team = null\t// i=3\r  현재 4명의 회원을 조회 하였고, 지연로딩을 통해 팀A와 팀B가 조회 되었습니다. 자세하게 수행된 것을 보면\n   Member를 조회 Roof 시작 (회원1, 회원2, 회원3, 회원4) 회원1 출력, 회원1의 Team 조회 후 팀A 1차 캐시 회원2 출력, 1차 캐시의 팀A 조회 회원3 출력, 회원3의 Team 조회 후 팀B 1차 캐시 회원4 출력    문제는 최악의 경우 회원 조회 쿼리 + 팀의 수 N만큼 조회쿼리가 발행할 수 있습니다. O(N+1)\n  이것은 즉시로딩이거나 지연로딩 모두 같은 문제가 발생합니다. 이것을 해결하기 위해서 Fetch Join을 사용합니다.\n 페치 조인 사용    JPQL \u0026ldquo;SELECT m FROM Member m JOIN fetch m.team t\u0026quot;로 호출 JPQL \u0026ldquo;SELECT m FROM Member m LEFT JOIN fetch m.team t\u0026quot;로 OUTER JOIN으로도 가능   페치 조인 사용 코드 String jpql = \u0026quot;select m from Member m join fetch m.team t\u0026quot;;\rList\u0026lt;Member\u0026gt; members = em.createQuery(jpql, Member.class)\r.getResultList();\rfor(Member member : members){\rSystem.out.println(\u0026quot;userName\u0026quot;+member.getUsername()+\u0026quot;,\u0026quot;+\r\u0026quot;teamName\u0026quot;+member.getTeam().getName());\r}\r  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m JOIN fetch m.team t \u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.getResultList();\rint i = 0;\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;Member = \u0026quot; + member.getUsername()+\u0026quot;, team = \u0026quot;+member.getTeam().getName());\r}\rtx.commit();\r  console - INNER JOIN FETCH\n Hibernate: /* SELECT\rm FROM\rMember m JOIN\rfetch m.team t */ select\rmember0_.id as id1_0_0_,\rteam1_.id as id1_3_1_,\rmember0_.age as age2_0_0_,\rmember0_.TEAM_ID as team_id5_0_0_,\rmember0_.type as type3_0_0_,\rmember0_.username as username4_0_0_,\rteam1_.name as name2_3_1_ /* 팀의 정보 조인을 통해 미리 들어감*/\rfrom\rMember member0_ inner join\rTeam team1_ on member0_.TEAM_ID=team1_.id\rMember = 회원1, team = 팀A\rMember = 회원2, team = 팀A\rMember = 회원3, team = 팀B\r  SELECT 문을 1번만 수행한 것을 확인할 수 있습니다. 조회 시점에 Team의 데이터 또한 프록시가 아니라, 실제 데이터로 채워져 있습니다.\n  Member와 Team의 INNER 조인이기 때문에 회원4의 정보가 없는 것 또한 확인 할 수 있습니다.\n  JpqlMain.java - LEFT OUTER JOIN FETCH\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m LEFT JOIN fetch m.team t \u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.getResultList();\rfor(Member member : resultList){\rif(member.getTeam() != null){\rSystem.out.println(\u0026quot;Member = \u0026quot; + member.getUsername()+\u0026quot;, team = \u0026quot;+member.getTeam().getName());\r}else{\rSystem.out.println(\u0026quot;Member = \u0026quot; + member.getUsername()+\u0026quot;, team = null\u0026quot;);\r}\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m LEFT JOIN\rfetch m.team t */ select\rmember0_.id as id1_0_0_,\rteam1_.id as id1_3_1_,\rmember0_.age as age2_0_0_,\rmember0_.TEAM_ID as team_id5_0_0_,\rmember0_.type as type3_0_0_,\rmember0_.username as username4_0_0_,\rteam1_.name as name2_3_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.id\rMember = 회원1, team = 팀A\rMember = 회원2, team = 팀A\rMember = 회원3, team = 팀B\rMember = 회원4, team = null\r  회원4까지 조회 된것을 확인할 수 있습니다.\n  결국 지연로딩을 세팅한다고 하여도, Fetch 조인이 우선입니다.\n 컬렉션 페치 조인   1:N 관계, 컬렉션 페치 조인 Team의 입장에서 Member를 조회\n  [JPQL]\n SELECT t\rFROM Team t JOIN FETCH t.members m\rWHERE t.name = '팀A'\r  [SQL]\n SELECT T.*, M.*\rFROM TEAM T INNER JOIN MEMBER M ON T.ID = M.TEAM_ID\r 컬렉션 페치 조인   JpqlMain.java - INNER JOIN FETCH\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t FROM Team t LEFT JOIN fetch t.members m \u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t LEFT JOIN\rfetch t.members m */ select\rteam0_.id as id1_3_0_,\rmembers1_.id as id1_0_1_,\rteam0_.name as name2_3_0_,\rmembers1_.age as age2_0_1_,\rmembers1_.TEAM_ID as team_id5_0_1_,\rmembers1_.type as type3_0_1_,\rmembers1_.username as username4_0_1_,\rmembers1_.TEAM_ID as team_id5_0_0__,\rmembers1_.id as id1_0_0__ from\rTeam team0_ left outer join\rMember members1_ on team0_.id=members1_.TEAM_ID\rTeam = 팀A, members[Member{id=4, username='회원1', age=31}, Member{id=5, username='회원2', age=32}]\rTeam = 팀A, members[Member{id=4, username='회원1', age=31}, Member{id=5, username='회원2', age=32}]\rTeam = 팀B, members[Member{id=6, username='회원3', age=33}]\rTeam = 팀C, members[]\r  각 팀과 팀의 팀원들을 출력하였습니다. 하지만 여기서 이상한 점은\n  팀A는 2번 나왔습니다. 왜냐하면, 팀A의 회원은 2명이기 때문입니다. 여기서 조심해야 할것은 바로 이것입니다.\n  Team의 Member 컬렉션을 가져온다고 하여도, Member의 수 만큼 조인을 통하여 데이터가 늘어나기 때문에 잊지 말고 신경을 써야합니다.\n  Join을 통해 팀A * [회원1, 회원2]의 Team List가 2개가 됩니다. Roof를 통해, 팀A가 2번 돌며, 팀A와 getMembers 컬렉션을 2번 찍게 됩니다.\n  위 쿼리를 조회하고 ID가 1인 Team을 영속성 컨텍스트(1차 캐시)에 담고, 2번째에는 영속성 컨텍스트에 이미 있기 때문에 스킵\n  같은 주소를 사용하는 결과가 2줄이 나오게 됩니다. 페치조인을 했기 때문에 팀A는 회원1, 2를 가지게 됩니다.\n  SQL과 같은 결과로 리턴해 주며 예를 들어 팀A와 회원1, 회원 2의 데이터를 2개의 로우로 주는 것을 어떤 사용자는 1줄만 원할 수 있고 2줄을 모두 원할 수 있기 때문에 이러한 결정은 사용자에게 넘기게 됩니다. 뒤에서 팀A가 2줄이 나오는 것을 한줄로 합쳐 결과를 설정을 통해 만들 수도 있습니다.\n 페치 조인과 DISTINCT    SQL의 DISTINCT는 중복된 결과를 제거하는 명령 JPQL의 DISTINCT 2가지 기능 제공  SQL에 DISTINCT를 추가 애플리케이션에서 엔티티 중복제거     Team 조회와 Team t JOIN t.members m 비교   더 보기 쉬운 테스트를 위해 팀C 추가는 주석해 두겠습니다.\n  그리고 DISTINCT 테스트 이전에 \u0026ldquo;SELECT t FROM Team t\u0026quot;와 \u0026ldquo;SELECT t FROM Team t JOIN FETCH t.members m\u0026quot;의 차이를 보며 결과의 차이를 먼저 확인 해보겠습니다.\n  JpqlMain.java - \u0026ldquo;SELECT t FROM Team t\u0026rdquo;\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\r/*\r// DISTINCT 를 통해 테스트의 편의를 위해 주석\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\r*/\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t FROM Team t JOIN FETCH t.members m\u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\r/*\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\r*/\rtx.commit();\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t */ select\rteam0_.id as id1_3_,\rteam0_.name as name2_3_ from\rTeam team0_\rresultCnt = 2\r/** H2 Console\rID | NAME\r-----+------ 1\t| 팀A\r2\t| 팀B\r**/\r  Team만 조회 했기 때문에 2건이 나옵니다.\n  JpqlMain.java - \u0026ldquo;SELECT t FROM Team t\u0026rdquo;\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\r/*\r// DISTINCT 를 통해 테스트의 편의를 위해 주석\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\r*/\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t FROM Team t JOIN FETCH t.members m\u0026quot;; // *** JOIN FETCH t.members m 추가\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\r/*\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\r*/\rtx.commit();\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t JOIN\rFETCH t.members m */ select\rteam0_.id as id1_3_0_,\rmembers1_.id as id1_0_1_,\rteam0_.name as name2_3_0_,\rmembers1_.age as age2_0_1_,\rmembers1_.TEAM_ID as team_id5_0_1_,\rmembers1_.type as type3_0_1_,\rmembers1_.username as username4_0_1_,\rmembers1_.TEAM_ID as team_id5_0_0__,\rmembers1_.id as id1_0_0__ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID\rresultCnt = 3\r/** H2 Console\rID\t| NAME\t| AGE\t| TEAM_ID\t| TYPE\t| USERNAME\r-----+--------+--------+-------------+-------------+----------\r1\t| 팀A\t| 31\t| 1\t| USER\t| 회원1\r1\t| 팀A\t| 32\t| 1\t| USER\t| 회원2\r2\t| 팀B\t| 33\t| 2\t| USER\t| 회원3\r**/\r  Team과 Member의 Inner Join 으로 인해 Team의 데이터가 Team * Member 된 것을 확인 할 수 있습니다.\n SQL의 DISTINCT 추가  SELECT DISTINCT t FROM Team t JOIN t.members\r  SQL에 DISTINCT를 추가 하지만 데이터가 다르므로 SQL 결과에서 중복제거 실패\n  JpqlMain.java - Sql DISTINCT\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\r/*\r// DISTINCT 를 통해 테스트의 편의를 위해 주석\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\r*/\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT DISTINCT t FROM Team t JOIN FETCH t.members m\u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\r/*\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\r*/\rtx.commit();\r  console\n Hibernate: /* SELECT\rDISTINCT t FROM\rTeam t JOIN\rFETCH t.members m */ select\rdistinct team0_.id as id1_3_0_,\rmembers1_.id as id1_0_1_,\rteam0_.name as name2_3_0_,\rmembers1_.age as age2_0_1_,\rmembers1_.TEAM_ID as team_id5_0_1_,\rmembers1_.type as type3_0_1_,\rmembers1_.username as username4_0_1_,\rmembers1_.TEAM_ID as team_id5_0_0__,\rmembers1_.id as id1_0_0__ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID\r/** H2 Console\rID\tTEAM_ID NAME AGE\tTYPE\tUSERNAME\r1\t3\t팀A\t31\tUSER\t회원1\r1\t4\t팀A\t32\tUSER\t회원2\r2\t5\t팀B\t33\tUSER\t회원3\r**/   1, 2 번 로우는 Team의 데이터 ID와 Name은 같지만, Member의 데이터 ID, USERNAME까지 같지 않기 때문에 중복제거되지 않습니다.\n  SQL에서는 완전히 데이터가 똑같아야 DISTINCT 됩니다.\n 애플리케이션에서 엔티티 중복제거    DISTINCT가 추가로 애플리케이션에서 중복 제거시도 같은 식별자를 가진 Team 엔티티 제거 (애플리케이션에서 컬렉션을 퍼올릴때)    팀A가 같은 엔티티를 보면 중복이 제거된 결과 리스트를 반환해 줍니다.\n  [DISTINCT 추가시 결과] teamname = 팀A, Team@0x100 -\u0026gt; username = 회원1, member = Member@0x200 -\u0026gt; username = 회원2, member = Member@0x300\n  JpqlMain.java - 결과 For 문으로 출력\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\r/*\r// DISTINCT 를 통해 테스트의 편의를 위해 주석\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\r*/\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT DISTINCT t FROM Team t JOIN FETCH t.members m\u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\rfor(Team team : resultList){ // ** 주석 제거\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rDISTINCT t FROM\rTeam t JOIN\rFETCH t.members m */ select\rdistinct team0_.id as id1_3_0_,\rmembers1_.id as id1_0_1_,\rteam0_.name as name2_3_0_,\rmembers1_.age as age2_0_1_,\rmembers1_.TEAM_ID as team_id5_0_1_,\rmembers1_.type as type3_0_1_,\rmembers1_.username as username4_0_1_,\rmembers1_.TEAM_ID as team_id5_0_0__,\rmembers1_.id as id1_0_0__ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID\rresultCnt = 2\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rTeam = 팀B, members [Member{id=5, username='회원3', age=33}]\r  실제 수행된 쿼리를 H2 console 에서 실행해 보면 3건이 나온다 하지만, 결과 리스트의 갯수는 2건이 나오며, 조회 결과를 출력시 처음 우리가 원했던 결과인 팀A가 Team = 팀A, members [Member{id=3, username=\u0026lsquo;회원1\u0026rsquo;, age=31}, Member{id=4, username=\u0026lsquo;회원2\u0026rsquo;, age=32}] 로 1건만 나온다.\n  String sQuery = \u0026quot;SELECT DISTINCT t FROM Team t JOIN FETCH t.members m\u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\r  Jpql에서 DISTINCT를 사용하면 결과를 컬렉션에 담을때 JPA에서 한번더 중복을 제거해 줍니다.\n  애플리케이션에서 올라올때, 이 컬렉션에 담기는 데이터가 중복이니까 JPA가 한번더 걸러준겁니다.\n 페치 조인과 일반 조인의 차이  일반 조인    일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음    [JPQL]\n SELECT t\rFROM Team t JOIN t.members m\rWHERE t.name = '팀A'\r  [SQL]\n SELECT T.*\rFROM Team T INNER JOIN F Member M ON T.ID = M.TEAM_ID\rWHERE T.name = '팀A'\r  DISTINCT는 테스트를 해보았으니 제거 하고 일반 조인을 하였을때, 생성되는 쿼리를 자세히 살펴보겠습니다.\n  JpqlMain.java\n \t...\rString sQuery = \u0026quot;SELECT t FROM Team t JOIN t.members m\u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\r...\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t JOIN\rt.members m */ select\rteam0_.id as id1_3_,\rteam0_.name as name2_3_ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID\rresultCnt = 3\rHibernate: select\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.id as id1_0_0_,\rmembers0_.id as id1_0_1_,\rmembers0_.age as age2_0_1_,\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.type as type3_0_1_,\rmembers0_.username as username4_0_1_ from\rMember members0_ where\rmembers0_.TEAM_ID=?\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rHibernate: select\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.id as id1_0_0_,\rmembers0_.id as id1_0_1_,\rmembers0_.age as age2_0_1_,\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.type as type3_0_1_,\rmembers0_.username as username4_0_1_ from\rMember members0_ where\rmembers0_.TEAM_ID=?\rTeam = 팀B, members [Member{id=5, username='회원3', age=33}]\r  inner join이 정상적으로 적용된것을 확인 할 수 있습니다. 프로젝션에 team0_.id as id1_3_, team0_.name as name2_3_ Team의 컬럼만 가져온 것을 확인 할 수 있습니다.\n  일반 Join문은 SQL에서 Join만 실행 되는 것이지 데이터를 퍼올리는 것은 Team에 관한 것만 가져오게 됩니다.\n  그런데 문제는 Roof를 돌릴때 아직 Members가 초기화가 안되어있습니다.\n  그렇기 때문에 Roof를 돌면서 team.getMembers()를 호출하게 되면, 지연로딩을 통해 조회된 Team의 엔티티 만큼 Member를 조회하는 쿼리가 발생하게 됩니다.\n 페치 조인    페치 조인은 연관된 엔티티를 함께 조회함    [JPQL]\n SELECT t\rFROM Team t JOIN FETCH t.members m\rWHERE t.name = '팀A'\r  [SQL]\n SELECT T.*, M.*\rFROM Team T INNER JOIN F Member M ON T.ID = M.TEAM_ID\rWHERE T.name = '팀A'\r  위와 같은 문제가 발생할때 FETCH 만 추가해 보면\n \t...\rString sQuery = \u0026quot;SELECT t FROM Team t JOIN FETCH t.members m\u0026quot;; //** FETCH 추가\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\r...\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t JOIN\rFETCH t.members m */ select\rteam0_.id as id1_3_0_,\rmembers1_.id as id1_0_1_,\rteam0_.name as name2_3_0_,\rmembers1_.age as age2_0_1_,\rmembers1_.TEAM_ID as team_id5_0_1_,\rmembers1_.type as type3_0_1_,\rmembers1_.username as username4_0_1_,\rmembers1_.TEAM_ID as team_id5_0_0__,\rmembers1_.id as id1_0_0__ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID\rresultCnt = 3\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rTeam = 팀B, members [Member{id=5, username='회원3', age=33}]\r  이게 일반 조인과 페치조인의 차이입니다.\n  페치 조인을 이용해 1+N의 문제를 모두 해결한다고 보면 됩니다.\n 일반 조인과 페치 조인 정리   JPQL은 결과를 반환할 때 연관관계 고려X 단지 SELECT 절에 지정한 엔티티만 조회할 뿐 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회하지 안습니다. 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩) 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념   페치 조인의 특징과 한계 - 1    페치 조인 대상에는 별칭을 줄 수 없다.(별칭 사용하지 않는게 관례)  하이버네이트는 가능, 가급적 사용X   둘 이상의 컬렉션은 페치 조인 할 수 없다. 컬렉션을 페치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.  일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)     페치 조인 대상에는 별칭을 줄 수 없다.   별칭 사용하지 않는게 관례\n  페치 조인은 엔티티와 연관된 모든 엔티티를 조회하는 것이기 때문에 성능을 위해 별칭을 통해 (ex: tt.name = \u0026lsquo;A\u0026rsquo;) 조건을 걸거나 하면 안됩니다. 그렇게 사용하고 싶다면 페치 조인이 아닌 일반 조인과 프로젝션에서 조회할 컬럼을 지정해서 사용해야합니다.\n  만일 Members에서 특정한 member만 필터로 조회해 가져오고 싶다면 Team과 Member의 Fetch 조인이 아닌, Member에서 조회하는 방식으로 해결해야 합니다.\n  JPA에서 객체 그래프 탐색의 컨셉은 연관된 엔티티의 모든 데이터 조회입니다. 그렇기 때문에 컬렉션을 필터링해 가져 오는 것은 잘못된 사용입니다.\n  만일 된다고 하여도, CASCADE와 같은 설정이 이것 저것 되어있다면 필터링 된 컬렉션의 데이터 조작시 필터에서 제외된 데이터들이 삭제가 된다던가 그런 문제를 낳을 수도 있을 것입니다.\n  또 같은 엔티티의 컬렉션을 한곳에서는 전체 조회하고, 한쪽에서는 필터를 통해 10개만 가져왔을때, 영속성 컨텍스트 입장에서는 같은 엔티티의 컬렉션의 데이터가 다르기에 애매한 입장이 될 것입니다.\n  예외로 사용하게 되는 때는 A 와 B의 Fetch 조인 B와 C의 fetch 조인 이런식으로 사용할 때도 있다고 하지만, 정합성 이슈 때문에 거의 사용하지 않는다고 합니다.\n 둘 이상의 컬렉션은 페치 조인 할 수 없다.   만약에 Team에 Members 외에 OfficeSupplies(비품들)이라는 컬렉션이 1:N으로 가지고 있다면 1:N:M의 관계로 Team * Members * OfficeSupplies 데이터가 늘어날 수도 있습니다. 이런경우 데이터 정확성에 이슈가 있다고 합니다.\n 컬렉션을 페치 조인하면 페이징 API 를 사용할 수 없다.   setFirstResult, setMaxResults\n  일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징이 가능합니다. 왜냐하면 데이터 뻥튀기(조인으로 인한 1*N)가 발생하지 않기 때문입니다.\n 일대다 관계에서 페치 조인 시 페이징 문제   페이징이라는 기능은 DB입장에서 ROW를 줄이는 방법입니다.\n  Member와 Team의 조인을 통해 2건이 나왔을때 \u0026lsquo;팀A\u0026rsquo;의 데이터의 위치 로우가 10(\u0026lsquo;회원1 데이터\u0026rsquo;)과 11(\u0026lsquo;회원2 데이터\u0026rsquo;)이라고 가정해 보겠습니다.\n  페이징을 통해 1페이지를 가져올 경우 결과로 \u0026lsquo;팀A\u0026rsquo;의 .getMembers() 를 했을경우 조회 결과의 데이터에서는 \u0026lsquo;회원1\u0026rsquo;의 데이터만 존재하기 때문에 \u0026lsquo;팀A\u0026rsquo;에 속한 회원이 1명만 조회되는 잘못된 결과가 발생하게 됩니다.\n  JPA가 객체 그래프를 생성하는 것은 조회된 데이터 기반이기 때문에 회원2가 page 2에 있는것을 모르기 때문에 컬렉션에 데이터가 잘못 나옵니다.\n 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)   버전에 따라 다르겠지만 한번 테스트 해보겠습니다.\n  JpqlMain.java\n  String sQuery = \u0026quot;SELECT t FROM Team t JOIN fetch t.members m\u0026quot;;\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.setFirstResult(0)\r.setMaxResults(1)\r.getResultList();\r  console\n //** 경고 발생\rWARN: HHH000104: firstResult/maxResults specified with collection fetch; applying in memory! Hibernate: /* SELECT\rt FROM\rTeam t JOIN\rfetch t.members m */ select\rteam0_.id as id1_3_0_,\rmembers1_.id as id1_0_1_,\rteam0_.name as name2_3_0_,\rmembers1_.age as age2_0_1_,\rmembers1_.TEAM_ID as team_id5_0_1_,\rmembers1_.type as type3_0_1_,\rmembers1_.username as username4_0_1_,\rmembers1_.TEAM_ID as team_id5_0_0__,\rmembers1_.id as id1_0_0__ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID // ** 페이징 관련 쿼리 없음 resultCnt = 1\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\r  WARN: HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!\n  위 경고의 의미는 데이터들을 메모리로 퍼올려서 메모리에서 paging 을 적용한다는 뜻으로 데이터가 100만건이라면 100만건 모두 메모리에서 paging을 처리하다가 시스템에 장애가 발생할 수 있습니다.\n  JPA에서 객체 그래프의 개념은 연관된 모든 데이터를 보여주는 것이기 때문에 전체 데이터를 가져온 후에 경고를 남기고 메모리 상에서 페이징을 처리하게 됩니다. 매우 위험\n 1:N 페치 조인 페이징 사용 제한 해결책  1. 쿼리의 대상을 뒤집어 1:N 쿼리를 N:1 쿼리로 만들어 사용  다른 방식으로 해결을 할 수 있는데, 1:N의 관계에서 문제가 되지만 반대로 N:1로 반대로 쿼리를 사용하면 해결할 수 있습니다.\n  JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\r/*\r// DISTINCT 를 통해 테스트의 편의를 위해 주석\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\r*/\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m JOIN fetch m.team t\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.setFirstResult(0)\r.setMaxResults(1)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + member.getTeam().getName()+\u0026quot;, members \u0026quot;+member.getTeam().getMembers());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m JOIN\rfetch m.team t */ select\rmember0_.id as id1_0_0_,\rteam1_.id as id1_3_1_,\rmember0_.age as age2_0_0_,\rmember0_.TEAM_ID as team_id5_0_0_,\rmember0_.type as type3_0_0_,\rmember0_.username as username4_0_0_,\rteam1_.name as name2_3_1_ from\rMember member0_ inner join\rTeam team1_ on member0_.TEAM_ID=team1_.id limit ?\rresultCnt = 1\rHibernate: select\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.id as id1_0_0_,\rmembers0_.id as id1_0_1_,\rmembers0_.age as age2_0_1_,\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.type as type3_0_1_,\rmembers0_.username as username4_0_1_ from\rMember members0_ where\rmembers0_.TEAM_ID=?\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\r 2. Fetch를 제거하고, n+1을 @BatchSize로 해결   아까도 테스트 해서 보았지만, \u0026ldquo;SELECT t FROM Team t\u0026rdquo; Team만 조회한 후 Roof에서 Members를 호출하게 되면 지연로딩이 발생하며 N+1 문제가 발생합니다. 이러한 문제를 @BatchSize를 사용하여 해결 할 수 있습니다.\n   Fetch Join 제거, paging은 그대로 사용    JpqlMain.java - Fetch Join 제거\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\r/*\r// DISTINCT 를 통해 테스트의 편의를 위해 주석\rTeam team3 = new Team();\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\r*/\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member();\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t FROM Team t\u0026quot;; // Fetch 조인 제거\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.setFirstResult(0)\r.setMaxResults(2)\r.getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t */ select\rteam0_.id as id1_3_,\rteam0_.name as name2_3_ from\rTeam team0_ limit ?\rresultCnt = 2\rHibernate: select\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.id as id1_0_0_,\rmembers0_.id as id1_0_1_,\rmembers0_.age as age2_0_1_,\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.type as type3_0_1_,\rmembers0_.username as username4_0_1_ from\rMember members0_ where\rmembers0_.TEAM_ID=?\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rHibernate: select\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.id as id1_0_0_,\rmembers0_.id as id1_0_1_,\rmembers0_.age as age2_0_1_,\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.type as type3_0_1_,\rmembers0_.username as username4_0_1_ from\rMember members0_ where\rmembers0_.TEAM_ID=?\rTeam = 팀B, members [Member{id=5, username='회원3', age=33}]\r  결과를 확인해 보면, Team을 조회한 Select 문 1개, 조회된 Team을 Roof를 통해 getMembers() 를 했기 때문에 지연 로딩이 발생하며, Roof로 도는 Team의 수만큼 Select 문이 발생합니다.\n  @BatchSize 적용    하이버네이트가 제공하는 org.hibernate.annotations.BatchSize 어노테이션을 이용하면 연관된 엔티티를 조회할 때 지정된 size 만큼 SQL의 IN절을 사용해서 조회합니다.\n  만약 지정한 사이즈가 100이고, 150개의 데이터를 조회한다면 IN 절에 100개를 넣어 쿼리를 날리고, 나머지 IN절에 50개 를 넣은 쿼리를 실행하게 됩니다.\n  Team.java - @BatchSize 적용\n  ...\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\r@BatchSize(size = 100) // ** 1000 이하의 숫자에서 적절히 사용 private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r...\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t */ select\rteam0_.id as id1_3_,\rteam0_.name as name2_3_ from\rTeam team0_ limit ?\rresultCnt = 2\rHibernate: /* load one-to-many jpql.domain.Team.members */ select\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.id as id1_0_1_,\rmembers0_.id as id1_0_0_,\rmembers0_.age as age2_0_0_,\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.type as type3_0_0_,\rmembers0_.username as username4_0_0_ from\rMember members0_ where\rmembers0_.TEAM_ID in (\r?, ?\r)\rTeam = 팀A, members [Member{id=3, username='회원1', age=31}, Member{id=4, username='회원2', age=32}]\rTeam = 팀B, members [Member{id=5, username='회원3', age=33}]\r  N+1의 쿼리 실행에서 IN 절을 사용하여 1+1로 변경 된것을 확인 할 수 있습니다.\n @BatchSize의 설정 사이즈 초과   JpqlMain.java\n  Team team1 = new Team();\rteam1.setName(\u0026quot;팀A\u0026quot;);\rem.persist(team1);\rTeam team2 = new Team();\rteam2.setName(\u0026quot;팀B\u0026quot;);\rem.persist(team2);\rTeam team3 = new Team(); // ** 팀C 생성\rteam3.setName(\u0026quot;팀C\u0026quot;);\rem.persist(team3);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;회원1\u0026quot;);\rmember1.setAge(31);\rmember1.changeTeam(team1);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;회원2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team1);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rMember member3 = new Member();\rmember3.setUsername(\u0026quot;회원3\u0026quot;);\rmember3.setAge(33);\rmember3.changeTeam(team2);\rmember3.setType(MemberType.USER);\rem.persist(member3);\rMember member4 = new Member(); // ** 회원4 생성\rmember4.setUsername(\u0026quot;회원4\u0026quot;);\rmember4.setAge(34);\rmember4.changeTeam(team3); // ** 회원4 팀C로 변경\rmember4.setType(MemberType.USER);\rem.persist(member4);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t FROM Team t\u0026quot;; // Fetch 조인 제거\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.setFirstResult(0)\r.setMaxResults(3)\t// ** 페이징 MaxResults 3으로 하여 결과 3건 .getResultList();\rSystem.out.println(\u0026quot;resultCnt = \u0026quot; + resultList.size());\rfor(Team team : resultList){\rSystem.out.println(\u0026quot;Team = \u0026quot; + team.getName()+\u0026quot;, members \u0026quot;+team.getMembers());\r}\rtx.commit();\r  Team.java - @BatchSize(size = 2)\n  @OneToMany(mappedBy = \u0026quot;team\u0026quot;)\r@BatchSize(size = 2) // ** 배치사이즈 2로 수정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r  console\n Hibernate: /* SELECT\rt FROM\rTeam t */ select\rteam0_.id as id1_3_,\rteam0_.name as name2_3_ from\rTeam team0_ limit ?\rresultCnt = 3\rHibernate: /* load one-to-many jpql.domain.Team.members */ select\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.id as id1_0_1_,\rmembers0_.id as id1_0_0_,\rmembers0_.age as age2_0_0_,\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.type as type3_0_0_,\rmembers0_.username as username4_0_0_ from\rMember members0_ where\rmembers0_.TEAM_ID in (\r?, ?\r)\rTeam = 팀A, members [Member{id=4, username='회원1', age=31}, Member{id=5, username='회원2', age=32}]\rTeam = 팀B, members [Member{id=6, username='회원3', age=33}]\rHibernate: /* load one-to-many jpql.domain.Team.members */ select\rmembers0_.TEAM_ID as team_id5_0_1_,\rmembers0_.id as id1_0_1_,\rmembers0_.id as id1_0_0_,\rmembers0_.age as age2_0_0_,\rmembers0_.TEAM_ID as team_id5_0_0_,\rmembers0_.type as type3_0_0_,\rmembers0_.username as username4_0_0_ from\rMember members0_ where\rmembers0_.TEAM_ID=?\rTeam = 팀C, members [Member{id=7, username='회원4', age=34}]\r  @BatchSize의 설정된 size가 2이기 때문에 Team을 조회한 Select 문 1개와 팀A의 TEAM_ID, 팀B의 TEAM_ID를 IN 절을 이용한 Member Select 쿼리 1개 팀C의 TEAM_ID을 이용한 Member Select 쿼리 1개, 총 3개의 쿼리가 실행된 것을 볼 수 있습니다.\n 페치 조인의 특징과 한계 - 2    연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화 엔티티에직접 적용하는 글로벌 로딩 전략보다 우선함  @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략   실무에서 글로벌 로딩 전략은 모두 지연 로딩 최적화가 필요한 곳은 페치 조인 적용  N+1이 발생하는 곳은 Fetch 조인 N+1이 발생하며, 페이징이 필요하다 @BatchSize 설정     페치 조인 - 정리   모든 것을 페치 조인으로 해결할 수 는 없음 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적   페치 조인 이후 데이터를 담아 반환하는 방법 3가지   엔티티를 페치조인 해서 엔티티를 그대로 사용 페치 조인을 하여 조회 하고 애플리케이션에서 DTO로 변환해 사용 처음부터 JPQL에서 New 생성자를 통해서 DTO를 지정해서 DTO로 반환해서 사용   이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r'}';\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 페치 조인(Fetch Join)","id":30,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 페치 조인(Fetch Join)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-fetch-join/"},{"content":"JPQL 경로 표현식(PATH EXPRESSION)  경로 표현식   .(점|dot)을 찍어 객체를 탐색 하는 것\n SELECT m.username -\u0026gt; 상태 필드\rFROM m\rJOIN m.team t\t-\u0026gt; 단일 값 연관 필드\rJOIN m.order o -\u0026gt; 컬렉션 값 연관 필드\rWHERE t.name = 'team1'   .을 통해 상태 필드, 단일 값 연관 필드, 컬렉션 값 연관 필드를 탐색하느냐에 따라서 상태 필드 표현식, 단일 값 연관 필드 표현식, 콜렉션 값 연관 필드 표현식 3가지 표현식이 있으며 내부적으로 각각 다른 동작을 하게 됩니다. 그렇기 때문에 꼭 구분해서 이해해야 합니다.\n   식별 변수(별칭 alias) : JPA 표준 명세는 별칭을 식별 변수(Indeitification variale)로 정의     상태 필드(state field) : 엔티티의 필드(속성)이며, 다른 엔티티와 연관되지 않은 상태 필드     연관 필드(association field) : 연관 관계를 위한 필드     단일 값 연관 필드 : 엔티티에 다른 엔티티와 연관 관계가 설정된 필드 @ManyToOne, @OneToOne의 대상 엔티티 예) m.temm, m.team     컬렉션 값 연관 필드 : 엔티티에 다른 엔티티와 연관 관계가 설정된 필드 @OneToMany, @ManyToMany의 대상 엔티티 예) m.orders, t.members   경로 표현식 특징  상태 필드 표현식(state_field_path_expression)  경로 탐색의 끝, 이후 탐색 불가\n{식별 변수 | 단일 값 연관 필드 표현식}.상태 필드(state_field) 엔티티의 상태 필드를 .을 통해 상태 필드를 탐색 예) m(Member).id, m(Member).username, t(Team).name, m(Member).team.name\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m.username FROM Member m\u0026quot;;\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(sQuery, Member.class)\r.getResultList();\rfor(Member s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  상태 필드 표현식은 이후 .을 통해 탐색을 더 할 수 없습니다. 다른 엔티티와 연결된 필드가 아니기 때문입니다.\n 단일 값 연관 경로 표현식(single_valued_association_path_expression)  묵시적 내부 조인(INNER JOIN) 발생, 탐색 가능\n식별_변수.{.단일_값_연관_필드}.단일_값_연관_필드 식별 변수 또는 단일 값 연관 필드에서 .을 통해 단일 값 연관 필드를 탐색 예) m(Member).team(Team), o(Orders).member(Member).team(Team)\n  단일 값 연관 경로 표현식은 .을 통해 연관 필드의 상태 필드 또는 연관 필드를 탐색할 수 있습니다.\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m.team FROM Member m\u0026quot;;\r//String sQuery = \u0026quot;SELECT m.team.username FROM Member m\u0026quot;; // 단일 값 연관 경로 표현식에서 연관 상태 필드 탐색 가능\rList\u0026lt;Team\u0026gt; resultList = em.createQuery(sQuery, Team.class)\r.getResultList();\rfor(Team s : resultList){\rSystem.out.println(\u0026quot;result = \u0026quot;+s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm.team FROM\rMember m */ select\rteam1_.id as id1_3_,\rteam1_.name as name2_3_ from\rMember member0_ inner join // 내부 조인 발생\rTeam team1_ on member0_.TEAM_ID=team1_.id\rresult = Team{id=1, name='team1'}\r  Jpql 으로는 Member 엔티티를 조회하여 프로젝션에 m.team\n SELECT\rm.team FROM\rMember m   으로 호출 되었지만, 데이터베이스에서는 Team의 데이터를 가져오기 위하여 JOIN이 필요합니다.\n select\rteam1_.id as id1_3_,\rteam1_.name as name2_3_ from\rMember member0_ inner join // 내부 조인 발생\rTeam team1_ on member0_.TEAM_ID=team1_.id\r  TEAM 테이블의 데이터를 조회하기 위해 INNER JOIN이 발생하게 되는데 이것을 묵시적 조인이 발생 되었다고 합니다.\n  마냥 편해 보이지만, 실무에서 사용하기 위해서는 조심해서 사용해야합니다. 쿼리 튜닝에 어려움이 있습니다.\n  이후 설명을 추가로 하겠지만 이렇게 묵시적인 조인이 사용되게끔 코딩하면 안됩니다. 실무에서는 수백개의 쿼리가 호출되고, 100 라인이 넘어가는 쿼리도 종종 있습니다. 조인은 쿼리의 성능면에서 어마 어마한 영향을 미치기 때문에 테이블 하나 하나 고민을 해서 조인을 하게 됩니다. 그런데 막 조인이되어서 나가게 되면 성능에 문제가 됩니다.\n  또한 실제 JPQL과 SQL이 다르게 나가게 되면 직관적으로 튜닝하기 매우 어렵습니다. 그렇기 때문에 유지보수성이 매우 떨어지게 되고 잘못하다가 망합니다..\n  JPA를 잘아는 개발자라면 찾을 수 있겠지만, 잘 모르는 개발자가 유지보수를 한다면 DBA가 \u0026ldquo;여기 조인 쿼리 발생되는데, 이거 수정해 주세요\u0026rdquo; 라고 하면 Jpql과 Sql이 다르기 떄문에 미궁에 빠지게 됩니다.\n 컬렉션 값 연관 경로 표현식(collection_valued_path_expression)  묵시적 내부 조인(INNER JOIN) 발생, 이후 탐색 불가\n FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능\n식별_변수.{단일 값 연관 필드.}.콜렉션 값 연관 필드(collection_valued_association_field)\n엔티티에 다른 엔티티가 1:N의 연관 관계가 설정된 (컬렉션)필드\n예) m(Member).orders(List), t(Team).members(List)    Team 엔티티에서 t.members는 1:N으로 member를 담은 컬렉션입니다. memebers에서 .을 이용해 탐색을 시도해 보았지만 불가능하며 \u0026ldquo;제안이 없습니다. 라고\u0026rdquo; 탐색을 못한다는 것을 IDE에서 알려줍니다.\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;Member2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team);\rmember2.setType(MemberType.ADMIN);\rem.persist(member2);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t.members FROM Team t\u0026quot;;\rList resultList = em.createQuery(sQuery, Collection.class) //** List가 아니라 Collection 받을 수 있다.\r.getResultList();\rfor(Object s : resultList){\rSystem.out.println(\u0026quot;result = \u0026quot;+s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rt.members FROM\rTeam t */ select\rmembers1_.id as id1_0_,\rmembers1_.age as age2_0_,\rmembers1_.TEAM_ID as team_id5_0_,\rmembers1_.type as type3_0_,\rmembers1_.username as username4_0_ from\rTeam team0_ inner join\rMember members1_ on team0_.id=members1_.TEAM_ID\rresult = Member{id=2, username='Member1', age=30}\rresult = Member{id=3, username='Member2', age=32}\r  처음에 JPA를 사용하면서 맨탈을 탈탈 털어버릴 수 있는 몇가지중에\n \rSELECT t.name FROM Team t // \u0026lt;- 탐색가능 SELECT t.members. FROM Team t //members. \u0026lt;- 탐색 불가   members는 위에 예제에서 봤듯이 타입이 Collection입니다. 컬렉션에서 필드를 찍을 수 있는것도 아니고 컬렉션 자체이기 때문에 더 이상 탐색할 수 없습니다. 사용할 수 있는기능은 t.members.size 정도 입니다.\n 명시적 조인을 이용한 탐색  컬렉션 값 연관 경로 표현식을 이용하면 묵시적 조인이 발생하며 탐색이 불가능하지만, 명시적 조인을 통해서 탐색을 할 수 있다고 하였습니다. 이번에는 명시적 조인을 통한 예제를 테스트해 보겠습니다.\n  JqplMain.java\n Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;Member2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team);\rmember2.setType(MemberType.ADMIN);\rem.persist(member2);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m.username FROM Team t join t.members m\u0026quot;; // FROM 절에서 명시적 조인\rList resultList = em.createQuery(sQuery, Collection.class)\r.getResultList();\rfor(Object s : resultList){\rSystem.out.println(\u0026quot;result = \u0026quot;+s);\r}\rtx.commit();\r  FROM 절에서 명시적 조인을 사용하면 t.members의 식별 변수(Alias) m에 .을 사용해 Member의 필드를 조회할 수 있습니다.\n 결론   가급적 묵시적 조인 대신에 명시적 조인 사용 조인은 SQL 튜닝에 중요 포인트 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움 JPQL과 SQL이 같게 개발을 하여야 이후에 운영에서 유지보수가(쿼리 튜닝이) 어려워지는 문제를 막을 수 있다.   이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r'}';\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  참고   자바 ORM 표준 JPA - 김영한 Oracle - JPQL Language Reference   ","description":"JPQL 경로 표현식(PATH EXPRESSION)","id":31,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 경로 표현식(PATH EXPRESSION)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-path-expression/"},{"content":"JPQL 기본 함수(BASIC FUNCTION)  JPQL 기본 함수   JPQL에서 제공하는 표준함수로 DB에 상관없이 사용가능\n   CONCAT SUBSTRING TRIM LOWER, UPPER LENGTH LOCATE ABS, SQRT, MOD SIZE, INDEX(JPA 용도)   이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  CONCAT   입력받은 2개의 문자열을 합치는 함수 JPA는 \u0026lsquo;문자열\u0026rsquo; || \u0026lsquo;문자열\u0026rsquo; 도 사용 가능합니다.\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT concat(m.username , '(', m.age, '세)') FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rconcat(m.username ,\r' (',\rm.age,\r'세)') FROM\rMember m */ select\r(member0_.username||' ('||member0_.age||'세)') as col_0_0_ from\rMember member0_\r관리자 (30세)\r  || 으로 문자열 합치기\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT ('A'||'B') FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r Hibernate: /* SELECT\r'A' || 'B' FROM\rMember m */ select\r('A'||'B') as col_0_0_ from\rMember member0_\rAB\r  || 으로 문자열을 합칠때 인텔리제이에서 오류라고 나오지만\n  언어 또는 참조 삽입 취소 옵션을 선택하면 해당 오류라고 체크 되는 것을 해제 할 수있습니다.\n SUBSTRING   문자열을 필요한 필요한 만큼 잘러 문자열로 반환하는 함수\n  SUBSTRING(\u0026lsquo;원본\u0026rsquo;, 시작 위치, 길이)\n \tSELECT SUBSTRING(m.username, 2, 3) FROM Member m\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;관리자\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT SUBSTRING(m.username, 2, 3) FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rSUBSTRING(m.username,\r2,\r3) FROM\rMember m */ select\rsubstring(member0_.username,\r2,\r3) as col_0_0_ from\rMember member0_\r리자\r TRIM   문자열의 공백을 제거하는 함수 TRIM, LTRIM, RTRIM이 있습니다.\n SELECT TRIM(' 이름 ') FROM Member m // 결과 \u0026quot;이름\u0026quot;\rSELECT RTRIM(' 이름 ') FROM Member m // 결과 \u0026quot; 이름\u0026quot;\rSELECT LTRIM(' 이름 ') FROM Member m // 결과 \u0026quot;이름 \u0026quot;\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;관리자\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT TRIM(' 이름 ') FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* insert jpql.domain.Member\r*/ insert into\rMember\r(age, TEAM_ID, type, username, id) values\r(?, ?, ?, ?, ?)\rHibernate: /* SELECT\rLTRIM(' 이름 ') FROM\rMember m */ select\rltrim(' 이름 ') as col_0_0_ from\rMember member0_\r이름 // \u0026quot;이름\u0026quot; 공백 양쪽 제거됨\r LOWER, UPPER   문자열 전체 대문자 치환, 소문자 치환\n SELECT LOWER(m.username) FROM Member m // member1\rSELECT UPPER(m.username) FROM Member m // MEMBER1\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;); // ** 대소문자 섞인 문자열\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT UPPER(m.username) FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rUPPER(m.username) FROM\rMember m */ select\rupper(member0_.username) as col_0_0_ from\rMember member0_\rMEMBER1\r LENGTH   문자열의 길이\n SELECT LENGTH('Member1') FROM Member m // 7\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT LENGTH(m.username) FROM Member m\u0026quot;;\rList\u0026lt;Integer\u0026gt; resultList = em.createQuery(sQuery, Integer.class)\r.getResultList();\rfor(Integer s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rUPPER(m.username) FROM\rMember m */ select\rupper(member0_.username) as col_0_0_ from\rMember member0_\rMEMBER1\r LOCATE   문자열에서 검색할 문자의 위치를 숫자로 반환해 주는 함수\n SELECT LOCATE('mb', 'Member1') FROM Member m // 3\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT LOCATE('mb', m.username) FROM Member m\u0026quot;;\rList\u0026lt;Integer\u0026gt; resultList = em.createQuery(sQuery, Integer.class)\r.getResultList();\rfor(Integer s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rLOCATE('mb',\rm.username) FROM\rMember m */ select\rlocate('mb',\rmember0_.username) as col_0_0_ from\rMember member0_\r3\r ABS, SQRT, MOD   기본적으로 데이터베이스들에서 제공하는 수학관련 함수들\n   ABS(x) : x의 절대값을 구하는 함수입니다. SQRT(x) : 양수 x 에 대한 제곱근을 반환합니다. MOD(n, m) : n을 m으로 나눈 나머지를 반환합니다.    JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT \u0026quot; +\r\u0026quot;ABS(-120) AS x1\u0026quot; +\r\u0026quot;, SQRT(4) AS x2\u0026quot; +\r\u0026quot;, MOD(6,2) AS x3\u0026quot; +\r\u0026quot; FROM Member m\u0026quot;;\rList\u0026lt;Object[]\u0026gt; resultList = em.createQuery(sQuery)\r.getResultList();\rObject[] result = resultList.get(0);\rfor(Object o : result){\rSystem.out.println(o);\r}\rtx.commit();\r  console\n  /* SELECT\rABS(-120) AS x1,\rSQRT(4) AS x2,\rMOD(6,\r2) AS x3 FROM\rMember m */ select\rabs(-120) as col_0_0_,\rsqrt(4) as col_1_0_,\rmod(6,\r2) as col_2_0_ from\rMember member0_\r120 // x1\r2.0 // x2\r0 // x3\r SIZE, INDEX(JPA 용도)    SIZE : 1:N의 양방향 관계에서 컬렉션(엔티티 리스트)의 사이즈를 반환해 줍니다.   SELECT size(t.members) FROM Team t\rSELECT t.members.size FROM Team t\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT t.members.size FROM Team t\u0026quot;;\rList\u0026lt;Integer\u0026gt; resultList = em.createQuery(sQuery, Integer.class)\r.getResultList();\rfor(Integer s : resultList){\rSystem.out.println(s.intValue());\r}\rtx.commit();\r   INDEX : @OrderColumn에서만 지원되는 정렬된 목록 엘리먼츠(요소, 항목)의 위치 값   SELECT toDo FROM Employee e JOIN e.toDoList toDo WHERE INDEX(toDo) = 1\r  @OrderColumn 자체에도 문제가 있기 때문에 사용 비추천\n 중간에 리스트에서 데이터가 빠지거나 그러면 데이터가 Null로 들어오는 문제 등   사용자 정의 함수 호출    하이버네이트는 사용전 방언에 추가해야 한다.  사용하는 DB 방언을 상속받고, 사용자 정의 함수를 등록한다.     SELECT FUNCTION('group_concat', i.name) FROM Item i\rSELECT group_concat(m.username) FROM Member m // InteliJ에서 문법 오류가 나지만 하이버네이트에서 지원함\r  jpql.dialect.MyH2Dialect.java - H2Dialect를 상속 받는 새로운 H2Dialect 생성\n package jpql.dialect;\rimport org.hibernate.dialect.H2Dialect;\rimport org.hibernate.dialect.function.StandardSQLFunction;\rimport org.hibernate.type.StandardBasicTypes;\rpublic class MyH2Dialect extends H2Dialect{\rpublic MyH2Dialect(){\rregisterFunction(\u0026quot;group_concat\u0026quot;, new StandardSQLFunction(\u0026quot;group_concat\u0026quot;, StandardBasicTypes.STRING)); //H2Dialect가 미리 생성해둔 group_concat이라는 H2 함수 (MySql도 있는 함수)\r}\r}\r  persistence.xml -\n \u0026lt;!-- \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt; --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;jpql.dialect.MyH2Dialect\u0026quot;/\u0026gt; \u0026lt;!-- 새로 만든 H2Dialect 사용 --\u0026gt;\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member1\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;Member2\u0026quot;);\rmember2.setAge(32);\rmember2.changeTeam(team);\rmember2.setType(MemberType.USER);\rem.persist(member2);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT function('group_concat', m.username ) FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* insert jpql.domain.Member\r*/ insert into\rMember\r(age, TEAM_ID, type, username, id) values\r(?, ?, ?, ?, ?)\rHibernate: /* SELECT\rfunction('group_concat',\rm.username ) FROM\rMember m */ select\rgroup_concat(member0_.username) as col_0_0_ from\rMember member0_\rMember1,Member2\r  다행히 하이버네이트 구현체를 사용하게 되면, 예를 들어 MySQL dialect에는 MySQL에 종속적이긴 하지만 표준 함수에 포함되지 않는 함수들을 미리 만들어 두었습니다.\n  DB 종속적이다 보니 DB를 변경하면 지원이 안된다는 단점을 가지고 있습니다.\n InteliJ에서 Jpql 문법 오류날때  예\u0026gt; \u0026ldquo;SELECT m.id||\u0026lsquo;번\u0026rsquo; AS no FROM Member m\u0026rdquo;\n   Un-inject Language/Refference (언어 또는 참조 삽입 취소)    Inject language or refferenct (언어 삽입 설정)    ID(I): Hibernate query 선택\n  문법오류 안나는 것을 확인 할 수 있습니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 기본 함수(BASIC FUNCTION)","id":32,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 기본 함수(BASIC FUNCTION)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-basic-function/"},{"content":"JPQL 조건문(CONDITIONAL STATEMENT)  조건문    기본 CASE 문   SELECT CASE WHEN m.age \u0026lt;= 10 THEN '학생요금'\rWHEN m.age \u0026gt;= 60 THEN '경로요금'\rELSE '일반요금'\rEND\rFROM Member m    단순 CASE 문   SELECT CASE t.name\rWHEN '팀A' THEN '인센티브110%'\rWHEN '팀B' THEN '인센티브120%'\rELSE '인센티브105%'\rEND\rFROM Team t\t   COALESCE : 하나씩 조회해서 NULL이 아니면 반환 사용자 이름이 없으면 \u0026lsquo;이름 없는 회원\u0026rsquo;을 반환   SELECT COALESCE(m.username,'이름 없는 회원') FROM Member m\r   NULLIF : 두 값이 같으면 NULL 반환, 다르면 첫번째 값 반환 사용자 이름이 \u0026lsquo;관리자\u0026rsquo;면 NULL을 반환하고 나머지는 본인의 이름을 반환   SELECT NULLIF(m.username,'관리자') FROM Member m\r 이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  기본 CASE 문   JpqlMain.java\n Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT \u0026quot; +\r\u0026quot;CASE WHEN m.age \u0026lt;= 10 THEN '학생요금' \u0026quot;+\r\u0026quot;WHEN m.age \u0026gt;= 60 THEN '경로요금' \u0026quot;+\r\u0026quot;ELSE '일반요금' END \u0026quot; +\r\u0026quot;FROM Member m \u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\r  console\n Hibernate: /* SELECT\rCASE WHEN m.age \u0026lt;= 10 THEN '학생요금' WHEN m.age \u0026gt;= 60 THEN '경로요금' ELSE '일반요금' END FROM\rMember m */ select\rcase when member0_.age\u0026lt;=10 then '학생요금' when member0_.age\u0026gt;=60 then '경로요금' else '일반요금' end as col_0_0_ from\rMember member0_\r일반요금\r  쿼리가 문자열이기 때문에 띄어쓰기를 잘해야합니다. 라인의 마지막이 \u0026quot; \u0026quot; 공백이여야 다음 줄의 첫 문자와 연결되지 않습니다.\n 단순 CASE 문   JpqlMain.java\n \rTeam team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT \u0026quot; +\r\u0026quot;CASE t.name \u0026quot; +\r\u0026quot;WHEN 'team1' THEN '인센티브110' \u0026quot;+\r\u0026quot;WHEN 'team2' THEN '인센티브120' \u0026quot;+\r\u0026quot;ELSE '인센티브105%' END \u0026quot; +\r\u0026quot;FROM Team t \u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r Hibernate: /* SELECT\rCASE t.name WHEN 'team1' THEN '인센티브110' WHEN 'team2' THEN '인센티브120' ELSE '인센티브105%' END FROM\rTeam t */ select\rcase team0_.name when 'team1' then '인센티브110' when 'team2' then '인센티브120' else '인센티브105%' end as col_0_0_ from\rTeam team0_\r인센티브110\r COALESCE   JpqlMain.java\n \tTeam team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(null); // *** 이름을 NULL로 세팅\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT COALESCE(m.username, '이름 없는 회원') FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* insert jpql.domain.Member\r*/ insert into\rMember\r(age, TEAM_ID, type, username, id) values\r(?, ?, ?, ?, ?)\rHibernate: /* SELECT\rCOALESCE(m.username,\r'이름 없는 회원') FROM\rMember m */ select\rcoalesce(member0_.username,\r'이름 없는 회원') as col_0_0_ from\rMember member0_\r이름 없는 회원\r NULLIF   JpqlMain.java\n Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;관리자\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT NULLIF(m.username, '관리자') FROM Member m\u0026quot;;\rList\u0026lt;String\u0026gt; resultList = em.createQuery(sQuery, String.class)\r.getResultList();\rfor(String s : resultList){\rSystem.out.println(s);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rNULLIF(m.username,\r'관리자') FROM\rMember m */ select\rnullif(member0_.username,\r'관리자') as col_0_0_ from\rMember member0_\rnull\r 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 조건문(CONDITIONAL STATEMENT)","id":33,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 조건문(CONDITIONAL STATEMENT)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-conditional-statement/"},{"content":"JPA 서브 쿼리(Sub Query)  서브 쿼리    나이가 평균보다 많은 회원   SELECT m FROM Member m WHERE m.age \u0026gt; (SELECT AVG(m2.age) FROM Member m2)\r   한 건이라도 주문한 고객   SELECT m FROM Member m WHERE (SELECT COUNT(o) FROM Order o WHERE m = o.member) \u0026gt; 0\r  일반적인 SQL과 같이 서브 쿼리를 사용할 수 있습니다.\n 서브 쿼리 지원 함수    [NOT] EXISTS (subquery) : 서브쿼리에 결과가 존재하면 참  {ALL|ANY|SOME} (subquery) ALL 모두 만족하면 참 ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참   [NOT] IN (subquery) : 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참   서브 쿼리 지원 함수 - 예제   팀A 소속인 회원   SELECT m FROM Member m\rWHERE EXISTS (SELECT t FROM m.team t WHERE t.name = '팀A')\r   전체 상품 각각의 재고보다 주문량이 많은 주문들   SELECT o FROM Order o\rWHERE o.orderAmount \u0026gt; ALL (SELECT p.stockAmount FROM Product p)\r   어떤 팀이든 팀에 소속된 회원   SELECT m FROM Member m WHERE m.team = ANY(SELECT t FROM Team t)\r JPA 서브 쿼리 한계    JPA(표준스펙에서)는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능 SELECT 절도 가능(하이버네이트에서 지원)   SELECT m, (SELECT AVG(m2.age) FROM Member m2) AS AVG_AGE FROM Member m    FROM 절의 서브 쿼리는 현재 JPQL에서 불가능 1. 조인으로 풀 수 있으면 풀어서 해결 2. 애플리케이션 서비스에서 쿼리를 나누어 날리고 서비스에서 데이터 조합 3. Native Query로 작성    FROM 절의 서브 쿼리 예제 (JPA에서 지원 안됨)\n SELECT mm.age, mm.username FROM (SELECT m.age, m.username FROM Member m) mm\r  서브 쿼리를 이용해 데이터 타입을 변경하거나 뷰에 대한 로직이 있거나 뷰가 원하는 식으로 문자를 바꾸거나 그런 경우는 JPA를 사용하면 애플리케이션 서비스로 끌고가서 서비스에서 처리하는 것이 FROM 절의 서브 쿼리를 줄일 수 있는 방법입니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 서브 쿼리(Sub Query)","id":34,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 서브 쿼리(Sub Query)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/sub-query/"},{"content":"JPQL 타입 표현(Type Expression)  JPQL 타입 표현    문자 : \u0026lsquo;HELLO\u0026rsquo;, \u0026lsquo;She'\u0026rsquo;s\u0026rsquo;  따옴표(single quotation) 표현시 single quotation 2개 ''   숫자 : 10L(Long), 10D(Double), 10F(Float) Boolean : TRUE, FALSE ENUM : jpabook.MemberType.Admin (전체 패키지명 포함) 엔티티 타입 : TYPE(m) = Member (상속 관계에서 사용)   이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  문자, 숫자, Boolean 실습   JpqlMain.java - 문자, 숫자, Boolean\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rString teamName = \u0026quot;team1\u0026quot;;\rString sQuery = \u0026quot;SELECT m.username, 'HELLO SHE''s', TRUE, 10L FROM Member m LEFT OUTER JOIN m.team t on t.name = m.username\u0026quot;;\rList\u0026lt;Object[]\u0026gt; result = em.createQuery(sQuery)\r.getResultList();\rfor (Object[] objects : result){\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[0]);\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[1]);\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[2]);\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[3]);\r}\r  console\n Hibernate: /* SELECT\rm.username,\r'HELLO SHE''s',\rTRUE,\r10L FROM\rMember m LEFT OUTER JOIN\rm.team t on t.name = m.username */ select\rmember0_.username as col_0_0_,\r'HELLO SHE''s' as col_1_0_,\r1 as col_2_0_,\r10 as col_3_0_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.id and (\rteam1_.name=member0_.username\r)\robjects = member // 컬럼 - m.name\robjects = HELLO SHE's // 문자열 - 'HELLO SHE''s'\robjects = true // 불린 - TRUE\robjects = 10 // 숫자 - 10L\r Enum 실습   JpqlMain.java - Enum Jpql에서 사용\n  Member.java - MemberType 추가\n ...\r@Enumerated(EnumType.STRING) // 기본이 숫자 EnumType.ORDINAL 이기 때문에 String으로 필수로 세팅\rprivate MemberType type;\rpublic MemberType getType() {\rreturn type;\r}\rpublic void setType(MemberType type) {\rthis.type = type;\r}\r...\r  MemberType.java\n package jpql.domain;\rpublic enum MemberType {\rADMIN, USER\r}\r Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rmember1.setType(MemberType.USER); // *** Member 타입 추가\rem.persist(member1);\rem.flush();\rem.clear();\rString teamName = \u0026quot;team1\u0026quot;;\rString sQuery = \u0026quot;SELECT m.username, 'HELLO SHE''s', TRUE, 10L FROM Member m LEFT OUTER JOIN m.team t on t.name = m.username\u0026quot;\r+ \u0026quot; WHERE m.type = jpql.domain.MemberType.USER \u0026quot;; // *** Member 타입 조회 조건 추가\rList\u0026lt;Object[]\u0026gt; result = em.createQuery(sQuery)\r.getResultList();\rfor (Object[] objects : result){\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[0]);\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[1]);\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[2]);\rSystem.out.println(\u0026quot;objects = \u0026quot;+ objects[3]);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm.username,\r'HELLO SHE''s',\rTRUE,\r10L FROM\rMember m LEFT OUTER JOIN\rm.team t on t.name = m.username WHERE\rm.type = jpql.domain.MemberType.USER */ select\rmember0_.username as col_0_0_,\r'HELLO SHE''s' as col_1_0_,\r1 as col_2_0_,\r10 as col_3_0_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.id and (\rteam1_.name=member0_.username\r) where\rmember0_.type='USER' // *** MemberType 조건 추가\robjects = member\robjects = HELLO SHE's\robjects = true\robjects = 10\r  패키지 명은 길기 때문에 파라미터 바인딩을 통해 코드를 줄일 수 있습니다.\n  JpqlMain.java - MemberType 파라미터로 세팅\n String teamName = \u0026quot;team1\u0026quot;;\rString sQuery = \u0026quot;SELECT m.username, 'HELLO SHE''s', TRUE, 10L FROM Member m LEFT OUTER JOIN m.team t on t.name = m.username\u0026quot;\r+ \u0026quot; WHERE m.type = :userType \u0026quot;;\rList\u0026lt;Object[]\u0026gt; result = em.createQuery(sQuery)\r.setParameter(\u0026quot;userType\u0026quot;, MemberType.USER)\r.getResultList();\r Entity 타입 실습   예제를 진행하기 위해 실전 예제를 사용했던 프로젝트를 불러와 사용하겠습니다.\n 실전 예제 6 - 값 타입 매핑\n Item 같은 경우에 상속관계로 Album, Book, Movie 가 있는데, Book 관련 된것만 조회하고 싶을때\n  JpaMain.java\n  Book book = new Book();\rbook.setName(\u0026quot;JPA\u0026quot;);\rbook.setAuthor(\u0026quot;김영한\u0026quot;);\rem.persist(book);\rList\u0026lt;Item\u0026gt; result = em.createQuery(\u0026quot;SELECT i FROM Item i WHERE TYPE(i) = Book \u0026quot;, Item.class).getResultList(); // *** TYPE(i) = Book\rtx.commit();\r  console\n Hibernate: /* SELECT\ri FROM\rItem i WHERE\rTYPE(i) = Book */ select\ritem0_.ITEM_ID as item_id2_3_,\ritem0_.MOD_ID as mod_id3_3_,\ritem0_.MOD_DT as mod_dt4_3_,\ritem0_.REG_ID as reg_id5_3_,\ritem0_.REG_DT as reg_dt6_3_,\ritem0_.name as name7_3_,\ritem0_.price as price8_3_,\ritem0_.stockQuantity as stockqua9_3_,\ritem0_.author as author10_3_,\ritem0_.isbn as isbn11_3_,\ritem0_.artist as artist12_3_,\ritem0_.etc as etc13_3_,\ritem0_.actor as actor14_3_,\ritem0_.director as directo15_3_,\ritem0_.DTYPE as dtype1_3_ from\rItem item0_ where\ritem0_.DTYPE='B' // *** TYPE(i) = Book\r JPQL 기타 표현    SQL과 문법이 같음 EXISTS, IN AND, OR, NOT =, \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, \u0026lt;\u0026gt; BETWEEN, LIKE, IS NULL   참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL 타입 표현(Type Expression)","id":35,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL 타입 표현(Type Expression)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql-type-expression/"},{"content":"JPA 조인(JOIN)  조인    내부 조인   SELECT m from Member m JOIN m.team t\rSELECT m from Member m INNER JOIN m.team t\r  SQL과 비슷하지만 엔티티 중심으로 JPQL이 작성되며, Member의 Team 엔티티에 Alias를 t로 주어 조인 쿼리를 작성합니다.\n   외부 조인   SELECT m from Member m LEFT JOIN m.team t\rSELECT m from Member m LEFT OUTER JOIN m.team t\r   세타 조인 연관관계가 없는 조인, 관계 없는 컬럼끼리의 조인   SELECT count(m) from Member m, Team t WHERE m.username = t.name\r 이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  내부 조인  \tString sQuery = \u0026quot;SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName\u0026quot;;\rString sQuery = \u0026quot;SELECT m FROM Member m JOIN m.team t WHERE t.name = :teamName\u0026quot;; // INNER는 생략 가능\r  Member.java - 조인을 하기전 양방향 관계 설정 및 연관관계 편의 매소드 생성\n \t...\rpublic void changeTeam(Team team){\rthis.team = team;\rteam.getMembers().add(this); // Team을 세팅할때, Team에도 현재 Member 추가\r}\r...\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m JOIN m.team t\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(sQuery, Member.class).getResultList();\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m JOIN\rm.team t */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ inner join\rTeam team1_ on member0_.TEAM_ID=team1_.id\rHibernate: select\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\r  Member와 Team이 Inner Join된 SQL이 출력된 것을 확인 할 수 있습니다. 하지만 사용하지 않은 Team의 SELECT 쿼리가 하나 더 출력된 것이 보입니다.\n  @ManyToOne N:1 관계에서는 꼭 fetch= FetchType.Lazy 로 설정해 두어야 합니다.\n  Member.java - fetch = FetchType.LAZY 지정\n @ManyToOne(fetch = FetchType.LAZY)\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\r  다시 실행하면\n  console\n Hibernate: /* SELECT\rm FROM\rMember m JOIN\rm.team t */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ inner join\rTeam team1_ on member0_.TEAM_ID=team1_.id\r  Join 쿼리만 출력됩니다. 이후 t엔티티 객체를 사용할 수 있습니다. 예를 들면 t.name 을 파라미터로 조건을 걸어 쿼리를 조회할 수 있습니다.\n  String teamName = \u0026quot;team1\u0026quot;;\r//String sQuery = \u0026quot;SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName\u0026quot;; // INNER JOIN 으로도 사용가능\rString sQuery = \u0026quot;SELECT m FROM Member m JOIN m.team t WHERE t.name = :teamName\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;teamName\u0026quot;,teamName)\r.getResultList();\r 외부 조인  SELECT m FROM Member m LEFT OUTER JOIN m.team t WHERE t.name = :teamName\rSELECT m FROM Member m LEFT JOIN m.team t WHERE t.name = :teamName // OUTER는 생략가능\r  Jpql.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rString teamName = \u0026quot;team1\u0026quot;;\r// String sQuery = \u0026quot;SELECT m FROM Member m LEFT OUTER JOIN m.team t WHERE t.name = :teamName\u0026quot;;\rString sQuery = \u0026quot;SELECT m FROM Member m LEFT JOIN m.team t WHERE t.name = :teamName\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;teamName\u0026quot;,teamName)\r.getResultList();\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m LEFT JOIN\rm.team t WHERE\rt.name = :teamName */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.id where\rteam1_.name=?\r 세타 조인   MEMBER와 TEAM을 모두 불러와 m.username과 t.name이 같은 것을 조회 연관관계가 없는 것을 조회\n SELECT m FROM Member m, Team t WHERE m.username = t.name\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rString teamName = \u0026quot;team1\u0026quot;;\r// String sQuery = \u0026quot;SELECT m FROM Member m LEFT OUTER JOIN m.team t WHERE t.name = :teamName\u0026quot;;\rString sQuery = \u0026quot;SELECT m FROM Member m, Team t WHERE m.username = t.name\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(sQuery, Member.class)\r.getResultList();\rtx.commit();\r  console\n  /* SELECT\rm FROM\rMember m,\rTeam t WHERE\rm.username = t.name */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ cross join\rTeam team1_ where\rmember0_.username=team1_.name\r  cross join 이라고 나오는데 이것은 두개의 테이블을 곱해서 N*M의 결과를 보여주는 조인 이후 m.username=t.name 이 같은 결과만 나오게 조건을 적용\n 조인 - ON 절    ON절을 활용한 조인 (JPA 2.1 부터 지원)  조인 대상 필터링 연관관계가 없는 외부 조인(하이버네이트 5.1 부터) 연관관계 없는 조인은 과거 INNER JOIN만 가능해서 실제 현직에서는 Native로 쿼리를 작성하는 경우도 있었다고합니다.     조인 대상 필터링   예) 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인\n  JPQL :\n SELECT m, t FROM Member m LEFT OUTER JOIN m.team t on t.name = 'A'\r  SQL :\n SELECT m.*, t.* FROM MEMBER m\rLEFT OUTER JOIN Team T\rON m.TEAM_ID = t.id\rAND t.name = 'A'\r  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rString teamName = \u0026quot;team1\u0026quot;;\rString sQuery = \u0026quot;SELECT m FROM Member m LEFT OUTER JOIN m.team t on t.name = :teamName\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(sQuery, Member.class)\r.setParameter(\u0026quot;teamName\u0026quot;,teamName)\r.getResultList();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m LEFT OUTER JOIN\rm.team t on t.name = :teamName */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.id and (\rteam1_.name=?\r)\r 연관관계 없는 엔티티 외부 조인   예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인\n  JPQL :\n SELECT m, t FROM\rMember m LEFT JOIN Team on m.username = t.name\r  SQL :\n SELECT m.*, t.* FROM\rMember m LEFT JOIN Team t on m.username = t.name\r  세타 조인과 비슷하지만, LEFT OUTER JOIN에 on 절을 이용하여 연관관계가 없는 조인을 할 수 있습니다.\n  JpqlMain.java\n \tTeam team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;);\rmember1.setAge(30);\rmember1.changeTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rString sQuery = \u0026quot;SELECT m FROM Member m LEFT OUTER JOIN m.team t on t.name = m.username\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(sQuery, Member.class)\r.getResultList();\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m LEFT OUTER JOIN\rm.team t on t.name = m.username */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.id and (\rteam1_.name=member0_.username\r)\r 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 조인(JOIN)","id":36,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 조인(JOIN)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/join/"},{"content":"JPA Paging API  페이징 API   JPA는 페이징을 다음 두 API로 추상화\n   setFirstResult(int startPosition) : 조회 시작 위치 (0 부터 시작) setMaxResults(int maxResult) : 조회할 데이터 수    Oracle 또는 MySql에서 페이징을 구현하기 위해서는 rownum을 사용하고 정렬을 위해 order by를 적용하려면 또 한번 더 감싸서 페이징을 쿼리를 작성하게 되어 3뎁스 까지도 나오게 되어 지저분한 쿼리가 됩니다.\n  그런데 JPA는 2가지 API만 사용하면됩니다. 페이징은 단지 몇번째 부터 몇개 가져와야 하는지 밖에 없습니다. 이를 JPA는 추상화하여 API로 제공합니다.\n 이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  페이징 API - MySQL 방언  select\rM.id as ID,\rM.age as AGE,\rM.TEAM_ID as TEAM_ID,\rM.username as USERNAME from\rMember M order by\rM.age desc limit ?, ?   MySql에서는 몇번째 부터 몇개 가져올것을 JPA가 setFirstResult()와 setMaxResults()로 알아서 계산해줍니다.\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rfor(int i=0; i\u0026lt;100; i++){ // roof로 사용자 인서트\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member\u0026quot;+i);\rmember1.setAge(i);\rmember1.setTeam(team);\rem.persist(member1);\r}\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; result = em.createQuery(\u0026quot;SELECT m FROM Member m ORDER BY m.age desc\u0026quot;, Member.class)\r.setFirstResult(0)\r.setMaxResults(10)\r.getResultList();\rSystem.out.println(\u0026quot;result size = \u0026quot;+result.size());\rfor (Member mmber : result){\rSystem.out.println(\u0026quot;member = \u0026quot;+ mmber);\r}\rtx.commit();\r  console\n Hibernate: /* SELECT\rm FROM\rMember m ORDER BY\rm.age desc */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ order by\rmember0_.age desc limit ?\rHibernate: select\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\rresult size = 10\rmember = Member{id=101, username='member99', age=99}\rmember = Member{id=100, username='member98', age=98}\rmember = Member{id=99, username='member97', age=97}\rmember = Member{id=98, username='member96', age=96}\rmember = Member{id=97, username='member95', age=95}\rmember = Member{id=96, username='member94', age=94}\rmember = Member{id=95, username='member93', age=93}\rmember = Member{id=94, username='member92', age=92}\rmember = Member{id=93, username='member91', age=91}\rmember = Member{id=92, username='member90', age=90}\r  나이 많은 순으로 정렬 후 10명 가져오는 것을 확인 할 수 있습니다.\n  limit ?, limit ? offset ?은 MySql 페이징 문법이며, persistence.xml에서 hibernate.dialect를 오라클로 변경하고 다시 실행해 보겠습니다.\n 페이징 API - Oracle 방언  \tSELECT * FROM\r( SELECT ROW_.*, ROWNUM ROWNUM_ FROM\r( SELECT\rM.ID AS ID,\rM.AGE AS AGE,\rM.TEAM_ID AS TEAM_ID,\rM.USERNAME AS USERNAME FROM\rMEMBER M ORDER BY M.AGE DESC )ROW_ WHERE ROWNUM \u0026lt;= ?\r)\rWHERE ROWNUM_ \u0026lt;= ?\r \u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r console\nHibernate: /* SELECT\rm FROM\rMember m ORDER BY\rm.age desc */ select\r* from\r( select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ order by\rmember0_.age desc ) where\rrownum \u0026lt;= ?\rHibernate: select\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\rresult size = 10\rmember = Member{id=101, username='member99', age=99}\rmember = Member{id=100, username='member98', age=98}\rmember = Member{id=99, username='member97', age=97}\rmember = Member{id=98, username='member96', age=96}\rmember = Member{id=97, username='member95', age=95}\rmember = Member{id=96, username='member94', age=94}\rmember = Member{id=95, username='member93', age=93}\rmember = Member{id=94, username='member92', age=92}\rmember = Member{id=93, username='member91', age=91}\rmember = Member{id=92, username='member90', age=90}\r  오라클로 변경하여 실행하였더니, rownum을 이용한 3뎁스 sql로 쿼리가 생성되어 실행되는 것이 보입니다.\n \u0026lt;!--\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r  스프링 데이터 JPA에서도 페이징 기능이 매우 편리하게 되어있는데, 결과적으로 JPA에서 제공하는 표준 스펙 기능입니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA Paging API","id":37,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA Paging API","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/paging-api/"},{"content":"JPA Projection(SELECT)  셀렉션과 프로젝션 셀렉션  데이터베이스에서 행단위로 데이터를 조회하는 방식 예) SELECT m.* FROM MEMBER m\n 프로젝션  데이터베이스에서 열단위로 데이터를 조회하는 방식 예) SELECT m.username, m.age FROM MEMBER m\n   프로젝션과 셀렉션 동시 사용 가능   이전 소스   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\r//private Team team = new Team();\rprivate Team team;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rTeam team1 = new Team();\rteam1.setName(\u0026quot;팀1\u0026quot;);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;오과장\u0026quot;);\rmember1.setAge(35);\rmember1.setTeam(team1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;육대리\u0026quot;);\rmember2.setAge(28);\rmember2.setTeam(team1);\rem.persist(team1);\rem.persist(member1);\rem.persist(member2);\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  Projection(SELECT)    SELECT 절에 조회할 대상을 지정하는 것 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입) 엔티티 프로젝션 -\u0026gt; SELECT m FROM Member m 엔티티 프로젝션 (조인) -\u0026gt; SELECT m.team FROM Member m 임베디드 타입 프로젝션 -\u0026gt; SELECT m.address FROM Member m 스칼라 타입 프로젝션 -\u0026gt; SELECT m.username, m.age FROM Member m DISTINCT로 중복 제거   엔티티 프로젝션  엔티티 프로젝션에서 또 깊이 생각해 볼것은 조회한 엔티티가 과연 영속성 컨텍스트에서 관리가 되는지 입니다.\n  엔티티를 추가하고 플러시, 클리어 후 조회한 엔티티(findMember)를 수정하였을 때, Update 문이 실행되는지 확인해 보겠습니다.\n  JpqlMain.java\n ...\rTeam team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member1\u0026quot;);\rmember1.setAge(35);\rmember1.setTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; result = em.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class)\r.getResultList();\rMember findMember = result.get(0);\rfindMember.setAge(28);\r...\r  강의를 따라 실습하던 도중 예기치 않은 오류를 만나게 되었습니다.\n org.hibernate.TransientPropertyValueException: object references an unsaved transient instance - save the transient instance before flushing\r  더보기 \robject references an unsaved transient instance - save the transient instance before flushing 에러 \n 간략하게 말씀드리면 flush 할때, Member와 N:1 연관관계에 있는 Team 의 FK를 먼저 영속화 하지 않고 Member를 영속화 하는 것이 문제라고 오류를 발생시킵니다.\n  이에 대한 해결은\n   CascadeType 지정 FK를 가지는 엔티티를 먼저 영속화 후 엔티티 영속화    ~하지만, 저장 시 강사님의 결과와 달라 문의를 남겨 두었습니다. ~\n  연관관계 매핑시 제가 잘못한 것이 있어 수정을 합니다.    Member.java\n  @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\r  수업을 충분히 정리하며 들으셨던 분들은 한눈에 눈치채셨겠지만, N:1 관계에서 1의 입장에서 예를 들어 Team.java에서는 private List members = new ArrayList\u0026lt;\u0026gt;(); 이렇게 배열을 미리 생성해두지만, Member.java 입장에서는 선언만 해두면 되는것을 = new Team()으로 생성을 해두었던것이 잘못이였습니다.\n  Team team = new Team(); 으로 생성을 해두면 생성시 Team의 PK인 TEAM_ID를 JPA에서 Member를 영속화할때 필요로 하기 때문에 오류를 발생하게 됩니다.\n  @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\r 인프런 QnA : org.hibernate.TransientPropertyValueException 질문드립니다.\n 답변이 달리는 대로 정리하여 수정하겠습니다.\n \r 테스트 결과 놀라운 사실을 알게 되었습니다. 영속화 이후 flush와 clear 이후 조회해온 값을 수정한다면 과연\n  console\n Hibernate: /* insert jpql.domain.Team\r*/ insert into\rTeam\r(name, id) values\r(?, ?)\rHibernate: /* insert jpql.domain.Member\r*/ insert into\rMember\r(age, TEAM_ID, username, id) values\r(?, ?, ?, ?)\rHibernate: /* SELECT\rm FROM\rMember m */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_\rHibernate: select\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\rHibernate: /* update\rjpql.domain.Member */ update\rMember set\rage=?,\rTEAM_ID=?,\rusername=? where\rid=?\r  최초 나이를 35로 생성했다가, 28로 수정한 것을 확인 할 수 있습니다.\n 엔티티 프로젝션 (조인)  또한 조회한 Member에서 Team 객체를 얻어와 Team을 수정한 다면 과연 어떻게 될까 테스트 해 보았습니다.\n  JpqlMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;team1\u0026quot;);\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member1\u0026quot;);\rmember1.setAge(35);\rmember1.setTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; result = em.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class)\r.getResultList();\rMember findMember = result.get(0);\rfindMember.setAge(28);\rTeam findTeam = findMember.getTeam();\rfindTeam.setName(\u0026quot;team2\u0026quot;);\rtx.commit();\r  console\n Hibernate: /* insert jpql.domain.Team\r*/ insert into\rTeam\r(name, id) values\r(?, ?)\rHibernate: /* insert jpql.domain.Member\r*/ insert into\rMember\r(age, TEAM_ID, username, id) values\r(?, ?, ?, ?)\rHibernate: /* SELECT\rm FROM\rMember m */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_\rHibernate: select\rteam0_.id as id1_3_0_,\rteam0_.name as name2_3_0_ from\rTeam team0_ where\rteam0_.id=?\rHibernate: /* update\rjpql.domain.Member */ update\rMember set\rage=?,\rTEAM_ID=?,\rusername=? where\rid=?\rHibernate: /* update\rjpql.domain.Team */ update\rTeam set\rname=? where\rid=?\r  놀랍게도 조회한 Member 뿐만 아니라 Team까지 영속성 컨텍스트에서 관리가 되어, 수정을 하여도 업데이트 문이 발생되었고 원하는 결과 수정한 Team의 이름이 team2로 수정된 것을 확인 할 수 있었습니다.\n  또한 Team 엔티티를 조회하는 다른 방법이 있습니다.\n \tTypedQuery\u0026lt;Team\u0026gt; query = em.createQuery(\u0026quot;SELECT m.team FROM Member m\u0026quot;, Team.class)\r  Member의 team을 조회하여 Team 객체로 반환하는 것입니다. 이럴 경우 JPA에서 자동적으로 조인 쿼리로 실행해 줍니다.\n  console\n Hibernate: /* SELECT\rm.team FROM\rMember m */ select\rteam1_.id as id1_3_,\rteam1_.name as name2_3_ from\rMember member0_ inner join\rTeam team1_ on member0_.TEAM_ID=team1_.id\r  JPQL에서는 SELECT m.team FROM Member로 간단히 나오지만 SQL은 INNER JOIN이 적용되어 나간 것을 확인 할 수 있습니다. 이후 경로 표현식에서 다루겠지만 JPQL와 SQL 최대한 비슷하게 생성되고 동작하는 것이 좋습니다. 성능의 문제가 될때 쿼리 튜닝을 진행하면 JPQL과 SQL이 같아야 가독성과 유지보수성이 높아집니다.\n  그래서 위의 코드를 JPQL로 다시 작성하면\n \tTypedQuery\u0026lt;Team\u0026gt; query = em.createQuery(\u0026quot;SELECT t FROM Member m JOIN m.team t\u0026quot;, Team.class)\r  위와 동일한 결과지만 JPQL과 SQL이 같아 소스를 이해하는데 큰 도움이 됩니다.\n Hibernate: /* SELECT\rt FROM\rMember m JOIN\rm.team t */ select\rteam1_.id as id1_3_,\rteam1_.name as name2_3_ from\rMember member0_ inner join\rTeam team1_ on member0_.TEAM_ID=team1_.id\r 임베디드 프로젝션  또한 Order 안에 있는 값타입 orderAddress를 조회할 때도 아래와 같은 방법으로 값을 조회하면 됩니다. orderAddress는 Order안에 포함되어있기 때문에 SELECT 문으로 Address 의 속성들을 조회할 수 있습니다.\n  이를 임베디드 프로젝션이라고 합니다.\n  em.createQuery(\u0026quot;SELECT O.orderAddress from Order O\u0026quot;, Address.class).getResultList();\r  console\n Hibernate: /* SELECT\rO.orderAddress from\rOrder O */ select\rorder0_.city as col_0_0_,\rorder0_.street as col_0_1_,\rorder0_.zipcode as col_0_2_ from\rORDERS order0_\r  값 타입이 가지고 있는 한계는\n em.createQuery(\u0026ldquo;SELECT a from Address a\u0026rdquo;, Address.class).getResultList();\n 값 타입은 다른 엔티티에 소속되어있기 때문에 위와 같이 Address를 주체로 사용 할 수 없습니다.\n 스칼라 타입 프로젝션  스칼라 타입 프로젝션은 SQL 작성하듯 원하는 컬럼들을 막가져 오는 것입니다.\n  em.createQuery(\u0026quot;SELECT m.username, m.username FROM Member m\u0026quot;)\r.getResultList();\r  console\n Hibernate: /* SELECT\rm.username,\rm.username FROM\rMember m */ select\rdistinct member0_.username as col_0_0_,\rmember0_.username as col_1_0_ from\rMember member0_\r  스칼라 프로젝션은 일반 SQL 문과 거의 똑같다고 보시면 됩니다.\n  이러한 경우 궁금증이 발생하는데, String username과 int age 타입이 다른데 어떻게 가져와야 할까요\n 프로젝션 - 여러 값 조회   SELECT m.username, m.age FROM Meber m  Query 타입으로 조회 Object[] 타입으로 조회 new 명령어로 조회 - 단순 값을 DTO로 바로 조회 SELECT new jpql.MemberDto(m.username, m.age) FROM Memver m - 패키지 명을 포함한 전체 클래스 명 입력 - 순서와 타입이 일치하는 생성자 필요     쿼리 타입으로 조회  이전에 정리하였던 반환 타입이 명확하지 않을때 사용하는 Query 타입 (Query query \u0026hellip;)\n \tQuery query = em.createQuery(\u0026quot;SELECT m.username, m.username FROM Member m\u0026quot;);\r Object[]로 조회  하나의 로우를 오브젝트 리스트로 변환하여 받을 수 있습니다.\n  List resultList = em.createQuery(\u0026quot;SELECT m.username, m.age FROM Member m\u0026quot;).getResultList();\rObject obj = resultList.get(0);\rObject[] result = (Object[]) obj;\r  console\n Hibernate: /* SELECT\rm.username,\rm.age FROM\rMember m */ select\rmember0_.username as col_0_0_,\rmember0_.age as col_1_0_ from\rMember member0_\rmember1\r35\r  이러한 불편함이 있기 때문에 TypeQuery를 이용하여 Object를 명시하여 받아 오는 방식도 있습니다\n  List\u0026lt;Object[]\u0026gt; resultList = em.createQuery(\u0026quot;SELECT m.username, m.age FROM Member m\u0026quot;).getResultList();\rObject[] result = resultList.get(0);\rfor (Object o : result){\rSystem.out.println(o);\r}\r  이렇게 하면 리스트 타입을 Obejct로 캐스팅 하는 1스탭을 줄일 수 있지만 불편한것은 비슷합니다.\n new 명령어로 조회   단순 값을 DTO로 바로 조회 패키지 명을 포함하는 전체 클래스 명 입력 순서와 타입이 일치하는 생성자 필요    src/main/java/jpql/dto/MemberDTO.java\n  MemberDTO \rpackage jpql.dto;\rpublic class MemberDTO {\rpublic MemberDTO(String ussername, int age) {\rthis.ussername = ussername;\rthis.age = age;\r}\rprivate String ussername;\rprivate int age;\rpublic String getUssername() {\rreturn ussername;\r}\rpublic void setUssername(String ussername) {\rthis.ussername = ussername;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r}\r \rem.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class).getResultList();\r  위와 같이 m 처럼 엔티티 자체를 조회할 때가 아니라면\n  new 오퍼레이션을 사용해야 합니다. 생성자를 호하듯이 경로를 다 적어 사용합니다.\n  List\u0026lt;MemberDTO\u0026gt; resultList = em.createQuery(\u0026quot;SELECT new jpql.dto.MemberDTO(m.username, m.age) FROM Member m\u0026quot;, MemberDTO.class).getResultList();\rfor(MemberDTO m : resultList){\rSystem.out.println(m.getUssername());\rSystem.out.println(m.getAge());\r}\r console\nHibernate: /* SELECT\rnew jpql.dto.MemberDTO(m.username,\rm.age) FROM\rMember m */ select\rmember0_.username as col_0_0_,\rmember0_.age as col_1_0_ from\rMember member0_\rmember1\r35\r  훨씬 깔끔해 지지만 JPQL 자체가 문자열이다 보니 패키지 명이 길어지면 다 적어줘야 하는 단점이 있습니다.\n  그렇다면 패키지명을 문자열 변수로 받아서 매핑해 주는 방법은 과연\n  String memberDtoPath = \u0026quot;jpql.dto.MemberDTO\u0026quot;;\rList\u0026lt;MemberDTO\u0026gt; resultList = em.createQuery(\u0026quot;SELECT new \u0026quot;+memberDtoPath+\u0026quot; (m.username, m.age) FROM Member m\u0026quot;, MemberDTO.class).getResultList();\r  console\n \rHibernate: /* SELECT\rnew jpql.dto.MemberDTO (m.username,\rm.age) FROM\rMember m */ select\rmember0_.username as col_0_0_,\rmember0_.age as col_1_0_ from\rMember member0_\rmember1\r35\r  이후에는 QueryDSL에서는 패키지명을 임포트 해서 사용할 수 있기 때문에 굳이 JPQL에서 패키지 경로를 문자열 변수로 더해주는 작업은 불필요 할꺼같네요.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"Projection(SELECT)","id":38,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA Projection(SELECT)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/projection/"},{"content":"object references an unsaved transient instance - save the transient instance before flushing 에러 오류 org.hibernate.TransientPropertyValueException: object references an unsaved transient instance - save the transient instance before flushing\r 원인   @ManyToOne 또는 @OneToMany 매핑을 사용 할때 부모 엔티티에 포함된 FK가 아직 영속되지 않아 생긴 영속성 전이(CASCADE)에 대한 오류 발생    N:1 관계시 양방향 설정시, 연결된 엔티티 객체를 생성 시 FK가 필수로 필요   @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team(); // \u0026lt;\u0026lt;   Member를 생성할 때, Team이 필수 값이 아니라면, new Team() 으로 미리 생성해 둘 필요가 없다.\n  만일 필수인 경우 validation 겸 null 시 Exception을 제어하기 위해 추가해도 괜찮다.\n @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\r 문제가된 소스 설명   Member 엔티티는 id, username, team 을 가지고 있다. Team은 id 와 name 을 가지고 있다. Member에 Team은 ManyToOne으로 연관되어있다. Team에 Member는 OneToMany로 연관되어있다.   \rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member1\u0026quot;);\rmember1.setAge(35);\rem.persist(member1);\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; result = em.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class)\r.getResultList();\rMember findMember = result.get(0);\rfindMember.setAge(28);\rtx.commit();\r  이러한 경우 Member를 영속화 할때, 연관된 Team의 PK가 아직 영속화 되지 않아 오류를 발생하게 됩니다.\n 해결책 1. CascadeType 지정  Member 엔티티에 @ManyToOne(cascade = CascadeType. ) 옵션 추가\n   CascadeType.ALL : 모두 적용 CascadeType.PERSIST : 영속 CascadeType.MERGE : 병합 CascadeType.REMOVE : 삭제 CascadeType.REFRESH : REFRESH CascadeType.DETACH : DETACH   @Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne(cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\r 2. FK를 가지는 엔티티를 먼저 영속화 후 엔티티 영속화  Member 엔티티에 CascadeType를 지정 하지 않아도, FK 즉 Team 엔티티를 영속화 후 member.setTeam(team)으로 영속화된 Team을 추가하면 오류가 발생 되지 않습니다.\n  Team team = new Team(); team.setName(\u0026quot;team1\u0026quot;);\rem.persist(team); // ** Team 엔티티를 생성 후 영속화\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;member1\u0026quot;);\rmember1.setAge(35);\rmember1.setTeam(team); // ** member1에 team 추가\rem.persist(member1);\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; result = em.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class)\r.getResultList();\rMember findMember = result.get(0);\rfindMember.setAge(28);\rtx.commit();\r 참조 object references an unsaved transient instance - save the transient instance before flushing : Spring Data JPA \n","description":"object references an unsaved transient instance - save the transient instance before flushing 에러","id":39,"section":"blog","tags":["Troubleshooting","자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"object references an unsaved transient instance - save the transient instance before flushing 에러","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/jpa/object-references-an-unsaved-transient-instance-save-the-transient-instance-before-flushing/"},{"content":"JPQL(Java persistence Query Language)  JPQL - 기본 문법과 기능  JPA에서 제공되는 다양한 쿼리 방법    JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리 하는 것이 아니라 엔티티를 대상으로 쿼리 한다. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다. JPQL은 결국 SQL로 변환된다.    객체모델\n  DB모델\n  JPQL을 예제 작성을 위한 Maven 프로젝트를 생성 하겠습니다.\n  jpa-basic\\jpql\n  pom.xml\n  pom.xml \r\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jpql\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- JPA 하이버네이트 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.4.22.Final\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- H2 데이터베이스 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/project\u0026gt;\r \r /resources/META-INF/persistence.xml 추가\n  persistence.xml \r\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;jpql\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;!--\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.MySQL5Dialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert relativemapping.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r   src/main/java/jpql/domain/Member.java\n  Member.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String username;\rprivate int age;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team = new Team();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\rpublic jpql.domain.Team getTeam() {\rreturn team;\r}\rpublic void setTeam(jpql.domain.Team team) {\rthis.team = team;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, age=\u0026quot; + age +\r'}';\r}\r}\r \r src/main/java/jpql/domain/Team.java\n  Team.java \rpackage jpql.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\r}\r   src/main/java/jpql/domain/Order.java\n  Order.java \rpackage jpql.domain;\rimport javax.persistence.*;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) //ORDER 가 예약어라 ORDERS로 테이블 명칭 지정\rpublic class Order {\rpublic Order() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate int orderAmount;\r@Embedded\rprivate Address orderAddress;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderAmount() {\rreturn orderAmount;\r}\rpublic void setOrderAmount(int orderAmount) {\rthis.orderAmount = orderAmount;\r}\rpublic Address getOrderAddress() {\rreturn orderAddress;\r}\rpublic void setOrderAddress(Address orderAddress) {\rthis.orderAddress = orderAddress;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\r}\r   src/main/java/jpql/domain/Address.java\n  Address.java \rpackage jpql.domain;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (!(o instanceof Address)) return false;\rAddress address = (Address) o;\rreturn Objects.equals(getCity(), address.getCity()) \u0026amp;\u0026amp; Objects.equals(getStreet(), address.getStreet()) \u0026amp;\u0026amp; Objects.equals(getZipcode(), address.getZipcode());\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(getCity(), getStreet(), getZipcode());\r}\r}\r   src/main/java/jpql/domain/Product.java\n  Product.java \rpackage jpql.domain;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\rpublic Product() {\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockAmount;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockAmount() {\rreturn stockAmount;\r}\rpublic void setStockAmount(int stockAmount) {\rthis.stockAmount = stockAmount;\r}\r}    src/main/java/jpql/JpqlMain.java\n  JpqlMain.java \rpackage jpql;\rimport jpql.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpqlMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpql\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rTeam team1 = new Team();\rteam1.setName(\u0026quot;팀1\u0026quot;);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;오과장\u0026quot;);\rmember1.setAge(35);\rmember1.setTeam(team1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;육대리\u0026quot;);\rmember2.setAge(28);\rmember2.setTeam(team1);\rem.persist(team1);\rem.persist(member1);\rem.persist(member2);\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  JPQL 문법  SELECT_문 :: =\rSELECT_절\rFROM_절\r[WHERE_절]\r[GROUP BY_절]\r[HAVING_절]\r[ORDER BY_절]\rUPDATE_문 ::\rUPDATE_절 [WHERE_절]\rDELETE_문 ::\rDELETE_절 [WHERE_절]\r  SQL 문법과 동일 하다고 보시면 됩니다.  UPDATE 문은 뒤에 벌크 연산이라는 새로운 기능 전 사원 10% 연봉 인상 등 내용 설명 예정\n JPQL 문법    SELECT M FROM Member as m WHERE m.age \u0026gt; 18 엔티티 속성은 대소문자 구분 O (Member, age) JPQL 키워드는 대소문자 구분 X (SELECT, FROM, where) 엔티티 이름 사용, 테이블 이름이 아님 (Member) (컬럼명 대신 엔티티 속성명) 별칭은 필수(m) (as는 생략 가능)   JPQL 집합과 정렬   ansi 표준 SQL의 기능과 사용법 동일\n SELECT COUMT(m) // 회원수\r, SUM(m.aget) // 나이 합\r, AVG(m.aget) // 나이 평균\r, MAX(m.aget) // 최대 나이 , MIN(m.aget) // 최소 나이 FROM Member m\r   GROUP BY, HAVING ORDER BY   TypeQuery, Query    TypeQuery : 반환 타입이 명확할 떄 사용 Query : 반환 타입이 명확하지 않을 때 사용    TypeQuery\n \tTypeQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class);\r  Query\n \tQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m.username, m.age FROM Member m\u0026quot;);\r  인텔리 제이에서\n \tem.createQuery(\u0026quot;SELECT m from Member m\u0026quot;, Member.class);\r  이 로우를 블록으로 잡고 Ctrl + Alt + V 를 누르면, 아래와 같이 메서드 콜하는 구문에서 자동으로 리턴값 변수 생성해준다.\n  createQuery에 2번째 파라미터를 넣으면 반환 타입은 자동으로 TypedQuery 으로 설정 해 주는것을 알 수 있습니다.\n  반면에 createQuery에 2번째 파라미터를 안넣으면 반환 타입은 자동으로 Query로 설정 해 주는것을 알 수 있습니다.\n  그리고 하나의 값을 반환 받고자 할때,\n TypedQuery\u0026lt;String\u0026gt; query = em.createQuery(\u0026quot;SELECT m.username from Member m\u0026quot;, String.class);\r  이런식으로 문자열로 이름을 반환 타입을 지정해 받을 수 있지만, 이름과, 나이 복합적인 값을 받아와 타입이 불명확한 경우 Query로 반환 타입을 지정하여 사용합니다.\n Query query = em.createQuery(\u0026quot;SELECT m.username, m.age from Member m\u0026quot;);\r 결과 조회 API    query.getResultList() : 결과가 하나 이상일 때, 리스트 반환  결과가 없으면 빈 리스트 반환       query.getSingleResult() : 결과가 정확히 하나일 때, 단일 객체 반환  결과가 없으면 : javax.persistence.NoResultException 둘 이상이면 : javax.persistence.NonUniqueResultException      query.getResultList();\n  TypedQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m\u0026quot;, Member.class);\rList\u0026lt;Member\u0026gt; resultList = query.getResultList();\r//iter + tab 자동 이터레이터 생성\rfor (Member member : resultList) {\rSystem.out.println(member);\r}\r  query.getSingleResult();\n \tTypedQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m WHERE m.id = 1L\u0026quot;, Member.class);\rMember singleResult = query.getSingleResult();\rSystem.out.println(singleResult);\r  getSingleResult()는 값 1건이 정확히 있을 때 사용\n  1건 이상일 때 javax.persistence.NonUniqueResultException는 것은 그래도 괜찮지만, 결과가 없을 때도 Exception 터지기 때문에 Try Catch로 예외처리를 각각 해줘야 하기 때문에 불편한 점이 있습니다. 그래서 논란이 많은데\n  Spring Date JPA 를 사용하게 되면은 여기에서는 추상화 되어, Null을 반환 하거나 Optional을 반환하게 되어있습니다. Spring Date JPA와 헤깔리면 안됩니다.\n 파라미터 바인딩 - 이름 기준, 위치 기준   이름 기준 매핑\n TypedQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m WHERE m.username= :username); query.setParameter(\u0026quot;username\u0026quot;, usernameParam);\r  Member.java\n  TypedQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m WHERE m.username = :username\u0026quot;, Member.class);\rquery.setParameter(\u0026quot;username\u0026quot;, \u0026quot;오과장\u0026quot;);\rMember singleResult = query.getSingleResult();\rSystem.out.println(singleResult.toString());\r  console\n Hibernate: /* SELECT\rm FROM\rMember m WHERE\rm.username = :username */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ where\rmember0_.username=?\rMember{id=2, username='오과장', age=35, team=jpql.domain.Team@c7a977f}\r  순서 기준 매핑\n TypedQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m WHERE m.username= ?1); query.setParameter(1, usernameParam);\r  Member.java\n  TypedQuery\u0026lt;Member\u0026gt; query = em.createQuery(\u0026quot;SELECT m FROM Member m WHERE m.username = ?1\u0026quot;, Member.class);\rquery.setParameter(1, \u0026quot;오과장\u0026quot;);\rMember singleResult = query.getSingleResult();\rSystem.out.println(singleResult.toString());\r  console\n Hibernate: /* SELECT\rm FROM\rMember m WHERE\rm.username = ?1 */ select\rmember0_.id as id1_0_,\rmember0_.age as age2_0_,\rmember0_.TEAM_ID as team_id4_0_,\rmember0_.username as username3_0_ from\rMember member0_ where\rmember0_.username=?\rMember{id=2, username='오과장', age=35, team=jpql.domain.Team@c7a977f}\r  위치 기준 보다 이름 기준을 권장합니다. 위치 기반이면, 중간에 하나가 끼어들면 다 수정해야하며, 잘못 매핑되면 장애로 이어질 가능성이 다분합니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPQL(Java persistence Query Language)","id":40,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPQL(Java persistence Query Language)","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql/"},{"content":"객체지향 쿼리 언어 (JPQL)  목차    객체지향 커리 언어 소개 JPQL 기본 문법과 기능 패치 조인 경로 표현식 다형성 쿼리 엔티티 직접 사용 Named 쿼리 벌크 연산   객체지향 쿼리 언어 소개  JPA에서 제공되는 다양한 쿼리 방법   JPA에서는 실무에서 사용하기 위한 다양한 검색 조건과 Join을 사용하여 조회 등 복잡한 쿼리를 구현할 수 있도록 기능 다양한 쿼리 방법을 제공합니다.\n   JPQL 엔티티 객체를 조회하는 객체지향 쿼리다.     JPA Criteria QueryDSL Java로 코드를 작성하여 JPQL로 제너레이션 하여 빌드하게 도와주는 클래스의 모음입니다.     네이티브 SQL JPQL 외에 특정 데이터베이스에 종속적인 쿼리를 작성하고 사용해야할때 사용(MySql, Oracle.. 쿼리)     JDBC API 직접사용, Mybatis, SpringJdbcTemplate 함께 사용   JPQL  JPQL 소개   가장 단순한 조회 방법  EntityManager.find() 객체 그래프 탐색 (a.getB().getC())   나이가 18살 이상인 회원을 모두 검색 하고 싶다면 ?   JPQL -1   JPA를 사용하면 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 에플리케이션이 필요한 데이터만 DB에서 불러오면 결국 검색 조건이 포함된 SQL이 필요   JPQL -2   JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공 SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원 JPQL은 엔티티 객체를 대상으로 쿼리 SQL은 데이터베이스 테이블을 대상으로 쿼리   JPQL - 예제 \tString jpql = \u0026quot;select m from Member m where m.name like '김%'\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(jpql, Member.class).getResultList();\r 이전 소스  Address.java \r package relativemapping;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic Address() {\r}\rpublic Address(String city, String street, String zipcode) {\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (o == null || getClass() != o.getClass()) return false;\rAddress address = (Address) o;\rreturn Objects.equals(city, address.city) \u0026amp;\u0026amp; Objects.equals(street, address.street) \u0026amp;\u0026amp; Objects.equals(zipcode, address.zipcode);\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(city, street, zipcode);\r}\r}\r \r AddressEntity.java \rpackage relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\rimport javax.persistence.Table;\rimport java.security.PrivateKey;\r@Entity\r@Table(name = \u0026quot;ADDRESS\u0026quot;)\rpublic class AddressEntity {\rpublic AddressEntity() {\r}\rpublic AddressEntity(String city, String street, String zipcode) {\rthis.address = new Address(city,street,zipcode);\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate Address address;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Address getAddress() {\rreturn address;\r}\rpublic void setAddress(Address address) {\rthis.address = address;\r}\r}\r \r Album.java \rpackage relativemapping;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;)\rpublic class Album extends Item{\rprivate String artist;\rpublic String getArtist() {\rreturn artist;\r}\rpublic void setArtist(String artist) {\rthis.artist = artist;\r}\r}\r \r BaseEntity.java \rpackage relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.MappedSuperclass;\rimport java.time.LocalDateTime;\r@MappedSuperclass\rpublic abstract class BaseEntity {\r@Column(name = \u0026quot;REG_ID\u0026quot;)\rprivate String createBy;\r@Column(name = \u0026quot;REG_DT\u0026quot;)\rprivate LocalDateTime createDate;\r@Column(name = \u0026quot;MOD_ID\u0026quot;)\rprivate String LastModifiedBy;\r@Column(name = \u0026quot;MOD_DT\u0026quot;)\rprivate LocalDateTime LastModifiedDate;\rpublic String getCreateBy() {\rreturn createBy;\r}\rpublic void setCreateBy(String createBy) {\rthis.createBy = createBy;\r}\rpublic LocalDateTime getCreateDate() {\rreturn createDate;\r}\rpublic void setCreateDate(LocalDateTime createDate) {\rthis.createDate = createDate;\r}\rpublic String getLastModifiedBy() {\rreturn LastModifiedBy;\r}\rpublic void setLastModifiedBy(String lastModifiedBy) {\rLastModifiedBy = lastModifiedBy;\r}\rpublic LocalDateTime getLastModifiedDate() {\rreturn LastModifiedDate;\r}\rpublic void setLastModifiedDate(LocalDateTime lastModifiedDate) {\rLastModifiedDate = lastModifiedDate;\r}\r}\r \r Book.java \rpackage relativemapping;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;)\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic String getIsbn() {\rreturn isbn;\r}\rpublic void setIsbn(String isbn) {\rthis.isbn = isbn;\r}\r}\r \r Child.java \rpackage relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Child {\rpublic Child() {\r}\r@Id\r@GeneratedValue\rprivate Long id;\rprivate String name;\r@ManyToOne\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Parent parent;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Parent getParent() {\rreturn parent;\r}\rpublic void setParent(Parent parent) {\rthis.parent = parent;\r}\r}\r \r Item.java \rpackage relativemapping;\rimport javax.persistence.*;\r@Entity\r@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\rpublic abstract class Item {\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\r}\r \r Member.java \rpackage relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.HashSet;\rimport java.util.List;\rimport java.util.Set;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String name;\r@Embedded\rprivate Address homeAddress;\r@ElementCollection\r@CollectionTable(name = \u0026quot;FAVORITE_FOOD\u0026quot;, joinColumns =\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;) // JoinColumn을 세팅하면 해당 키를 외래키로 사용합니다.\r)\r@Column(name = \u0026quot;FOOD_NAME \u0026quot;)\rprivate Set\u0026lt;String\u0026gt; favoriteFoods = new HashSet\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\r/*\r@OrderColumn(name = \u0026quot;address_history_order\u0026quot;)\r@ElementCollection\r@CollectionTable(name = \u0026quot;ADDRESS\u0026quot; , joinColumns =\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\r)\rprivate List\u0026lt;Address\u0026gt; addressHistory = new ArrayList\u0026lt;\u0026gt;();\r*/\r@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate List\u0026lt;AddressEntity\u0026gt; addressHistory = new ArrayList\u0026lt;\u0026gt;();\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Address getHomeAddress() {\rreturn homeAddress;\r}\rpublic void setHomeAddress(Address homeAddress) {\rthis.homeAddress = homeAddress;\r}\rpublic Set\u0026lt;String\u0026gt; getFavoriteFoods() {\rreturn favoriteFoods;\r}\rpublic void setFavoriteFoods(Set\u0026lt;String\u0026gt; favoriteFoods) {\rthis.favoriteFoods = favoriteFoods;\r}\rpublic List\u0026lt;AddressEntity\u0026gt; getAddressHistory() {\rreturn addressHistory;\r}\rpublic void setAddressHistory(List\u0026lt;AddressEntity\u0026gt; addressHistory) {\rthis.addressHistory = addressHistory;\r}\r}\r \r MemberProduct.java \rpackage relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;)\rpublic class MemberProduct {\r@Id @GeneratedValue\rprivate Long id;\r@ManyToOne\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Member member;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\r@Column(name = \u0026quot;ORDERAMOUNT\u0026quot;)\rprivate int orderAmount;\r@Column(name = \u0026quot;ORDERCOUNT\u0026quot;)\rprivate int orderCount;\rpublic Member getMember() {\rreturn member;\r}\r@Column(name = \u0026quot;ORDERDATE\u0026quot;)\rprivate LocalDate orderDate;\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r \r Movie.java \rpackage relativemapping;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;)\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\rpublic String getDirector() {\rreturn director;\r}\rpublic void setDirector(String director) {\rthis.director = director;\r}\rpublic String getActor() {\rreturn actor;\r}\rpublic void setActor(String actor) {\rthis.actor = actor;\r}\r}\r \r Parent.java \rpackage relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Parent {\rpublic Parent() {\r}\r@Id\r@GeneratedValue\r@Column(name = \u0026quot;parent_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;, orphanRemoval = true)\rprivate List\u0026lt;Child\u0026gt; childList = new ArrayList\u0026lt;\u0026gt;();\rpublic void addChild(Child child){\rchildList.add(child);\rchild.setParent(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Child\u0026gt; getChildList() {\rreturn childList;\r}\rpublic void setChildList(List\u0026lt;Child\u0026gt; childList) {\rthis.childList = childList;\r}\r}\r \r Period.java \rpackage relativemapping;\rimport javax.persistence.Embeddable;\rimport java.time.LocalDateTime;\r@Embeddable\rpublic class Period {\rprivate LocalDateTime startDate;\rprivate LocalDateTime endDate;\rpublic Period() {\r}\rpublic Period(LocalDateTime startDate, LocalDateTime endDate) {\rthis.startDate = startDate;\rthis.endDate = endDate;\r}\rpublic Boolean isIncumbent(){\rLocalDateTime today = LocalDateTime.now();\r/*\rSystem.out.println(this.startDate);\rSystem.out.println(today);\rSystem.out.println(this.startDate.isEqual(today)); // 주어진 시간과 같은지\rSystem.out.println(this.startDate.isBefore(today)); // 주어진 시간보다 이전인지\rSystem.out.println(this.startDate.isAfter(today)); // 주어진 시간보다 이후인지\rSystem.out.println(this.endDate);\rSystem.out.println(today);\rSystem.out.println(this.endDate.isEqual(today)); // 주어진 시간과 같은지\rSystem.out.println(this.endDate.isBefore(today)); // 주어진 시간보다 이전인지\rSystem.out.println(this.endDate.isAfter(today)); // 주어진 시간보다 이후인지\r*/\rif( ! this.startDate.isAfter(today) \u0026amp;\u0026amp; this.endDate.isAfter(today)){\rreturn true;\r}else{\rreturn false;\r}\r}\rpublic LocalDateTime getStartDate() {\rreturn startDate;\r}\rprivate void setStartDate(LocalDateTime startDate) {\rthis.startDate = startDate;\r}\rpublic LocalDateTime getEndDate() {\rreturn endDate;\r}\rprivate void setEndDate(LocalDateTime endDate) {\rthis.endDate = endDate;\r}\r}\r \r Product.java \rpackage relativemapping;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\r@OneToMany(mappedBy = \u0026quot;product\u0026quot;)\rprivate List\u0026lt;MemberProduct\u0026gt; memberProducts;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r \r Team.java \rpackage relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team extends BaseEntity{\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r \r JpaMain.java \rpackage relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rimport java.util.Set;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rMember member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\r/* member.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));*/\rmember.getAddressHistory().add(new AddressEntity(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new AddressEntity(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\r// home1 -\u0026gt; new1\r//findMember.getHomeAddress().setCity(\u0026quot;new1\u0026quot;); // 값 타입의 set은 사이드이펙트가 발생할 문제가 있어 set X\r/*Address oldAddress = findMember.getHomeAddress();\rfindMember.setHomeAddress(new Address(\u0026quot;new1\u0026quot;, oldAddress.getStreet(), oldAddress.getZipcode()));*/\r// 치킨 -\u0026gt; 한식\r/*findMember.getFavoriteFoods().remove(\u0026quot;치킨\u0026quot;);\rfindMember.getFavoriteFoods().add(\u0026quot;한식\u0026quot;);*/\r/*findMember.getAddressHistory().remove(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rfindMember.getAddressHistory().add(new Address(\u0026quot;new2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));*/\r/*\rremove 내부에서 equals()를 통하여 값이 완전 똑같은 객체를 지우게 되는데, equals와 hashcode를\r== 비교에서, 값 전체를 비교해 같은 값을 가지는 지로 변경하지 않으면 값이 삭제 되지 않고\r계속 추가가 되는 버그를 발생시킬 수 있습니다.\r*/\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r \r JpaMain.java\n \t...\rMember member1 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember1.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember1.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember1.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember1.getAddressHistory().add(new AddressEntity(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember1.getAddressHistory().add(new AddressEntity(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member1);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rList\u0026lt;Member\u0026gt; members = em.createQuery(\r\u0026quot;select m from Member m where m.name like '%m%' \u0026quot;\r, Member.class\r).getResultList();\rfor (Member member: members){\rSystem.out.println(\u0026quot;member \u0026quot;+ member);\r}\rtx.commit();\r...\r  테이블을 대상으로 쿼리를 작성하는게 아니라 엔티티를 대상으로 쿼리를 작성하기 때문에, 컬럼의 username이 아니라 엔티티의 name 으로 조건을 작성, 결과는 테이블의 컬럼명 username 으로 만들어짐.\n  console\n Hibernate: /* select\rm from\rMember m where\rm.name like '%김%' */ select\rmember0_.id as id1_6_,\rmember0_.city as city2_6_,\rmember0_.street as street3_6_,\rmember0_.zipcode as zipcode4_6_,\rmember0_.USERNAME as username5_6_ from\rMember member0_ where\rmember0_.USERNAME like '%m%'\r  문법이 sql과 거의 비슷, * 대신 객체의 Alias인 m 으로 전체 조회를 할 수 있습니다. 또 m.name, m.id \u0026hellip; 등 각각 접근하여 사용할 수 있습니다.\n JPQL과 실행된 SQL \tString jpql = \u0026quot;select m from Member m where m.age \u0026gt; 18\u0026quot;;\rList\u0026lt;Member\u0026gt; result = em.createQuery(jpql, Member.class).getResultList();\r 실행된 SQL\rselect m.id as id,\rm.age as age,\rm.username as username,\rm.TEAM_ID as TEAM_ID\rfrom Member m\rwhere m.age \u0026gt; 18\r Criteria  Criteria 소개  JPQL은 단순한 String 이기 때문에 동적 쿼리를 생성하기 힘이 듭니다.\n  예를 들면\n \tString jpql = \u0026quot;select m from Member\u0026quot;;\rString username; if(username != null){\rString sWhere = \u0026quot;where m.name like '%m%'\u0026quot;;\rjpql += sWhere;\r}\rList\u0026lt;Member\u0026gt; result = em.createQuery(jpql, Member.class).getResultList();\r  간단한 조건 하나 추가하여도, 지저분해지는 것을 알 수 있습니다. 실무에서 사용하기에 버그도 많이 발생하고 불편한 점이 있습니다.\n  Ibatis나 MyBatis는 동적쿼리를 작성하는데 장점이 있습니다.\n  그래서 동적쿼리 뿐만 아니지만, 대안으로 자바 표준으로 Criteria가 나오게 되었습니다.\n // Criteria 사용 준비\rCriteriaBuilder cb = em.getCriteriaBuilder();\rCriteriaQuery\u0026lt;Member\u0026gt; query = cb.createQuery(Member.class);\r// 루트 클래스 조회 (조회를 시작할 클래스)\rRoot\u0026lt;Member\u0026gt; m = query.from(Member.class);\r// 쿼리 생성 CriteriaQuery\u0026lt;Member\u0026gt; cq = query.select(m).where(cb.equal(m.get(\u0026quot;name\u0026quot;), \u0026quot;kim hun\u0026quot;)); // 엔티티의 속성명 name\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(cq).getResultList();\r  JpaMain.java - Criteria 사용\n  // Criteria 사용 준비\rCriteriaBuilder cb = em.getCriteriaBuilder();\rCriteriaQuery\u0026lt;Member\u0026gt; query = cb.createQuery(Member.class);\r// 루트 클래스 조회 (조회를 시작할 클래스)\rRoot\u0026lt;Member\u0026gt; m = query.from(Member.class);\r// 쿼리 생성\rCriteriaQuery\u0026lt;Member\u0026gt; cq = query.select(m).where(cb.equal(m.get(\u0026quot;name\u0026quot;), \u0026quot;member1\u0026quot;));\rList\u0026lt;Member\u0026gt; resultList = em.createQuery(cq).getResultList();\rtx.commit();\r  console\n Hibernate: /* select\rgeneratedAlias0 from\rMember as generatedAlias0 where\rgeneratedAlias0.name=:param0 */ select\rmember0_.id as id1_6_,\rmember0_.city as city2_6_,\rmember0_.street as street3_6_,\rmember0_.zipcode as zipcode4_6_,\rmember0_.USERNAME as username5_6_ from\rMember member0_ where\rmember0_.USERNAME=?\r  자바 소스로 쿼리를 작성하기 때문에 오타로 인한 오류는 IDE에서 알려주거나 오류로 알 수 있는 장점이 있고 또한 동적쿼리를 작성할때 편리함을 얻을 수 있습니다.\n  하지만 Criteria 방식은 복잡해 지면 좀더 분석하기 어려워집니다.\n  CriteriaQuery\u0026lt;Member\u0026gt; cq = query.select(m);\rString username = \u0026quot;member1\u0026quot;;\rif (!username.equals(null)){\rcq.where(cb.equal(m.get(\u0026quot;name\u0026quot;), username));\r}\r  실무에서는 쿼리를 작성했던 사람도 보기 힘들 정도로 직관성이 떨어지고, 유지 보수가 힘들어지기 때문에 사용하지 않는다고 합니다.\n Criteria 정리   문자가 아닌 자바 코드로 JPQL을 작성할 수 있음 JPQL 빌더 역활 JPA 공식 기능 단점 : 너무 복잡하고 실용성이 없다. Criteria 대신에 QueryDSL 사용 권장   QueryDSL  QueryDSL 소개 // JPQL\r// select m from Member m where m.age \u0026gt; 18\rJPAFactoryQuery query = new JPAFactoryQuery(em);\rQMember m = QMember.member;\rList\u0026lt;Member\u0026gt; list =\rquery.selectFrom(m)\r.where(m.age.gt(18))\r.orderBy(m.name.desc())\r.fetch();\r  SQL과 비슷한 형태로 되어있는 것을 확인 할 수 있습니다.    문자가 아닌 나바코드로 JPQL을 작성할 수 있음 JPQL 빌더 역할 컴파일 시점에 문법 오류를 찾을 수 있음 동적쿼리 작성 편함 단순하고 쉬움 실무 사용 권장    queryDSL은 설정이 힘든만큼 SQL과 비슷하여 작성이 쉽고 오류도 컴파일러에서 검출해주며, 동적쿼리에도 강력한 기능을 보여줍니다.\n이후 queryDSL 강의에서 좀더 깊이 배우고 정리하도록 하겠습니다.\n Native SQL  Native SQL 소개   JPA가 제공하는 SQL을 직접 사용하는 기능 JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 문법   String sql = \u0026quot;SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'Kim'\u0026quot;; // ** 엔티티를 대상으로 쿼리 작성이 아닌 테이블 대상으로 쿼리를 하기때문에 테이블 컬럼명을 사용합니다.\rList\u0026lt;Member\u0026gt; resultList = em.createNativeQuery(sql, Member.class)\r.getResultList();\r  console\n Hibernate: /* dynamic native SQL query */ select\r* from\rMember where\rusername like '%m%' relativemapping.Member@4cafa9aa\r  네이티브 쿼리를 사용한다면, 네이티브 쿼리를 사용하는 것보다 다음 SpringJdbcTemplate 를 사용하거나 마이바티스 사용 추천\n JDBC 직접사용, SpringJdbcTemplate 등  JDBC 직접사용, SpringJdbcTemplate 등 소개   JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스 등을 함께 사용가능 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요 예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시    주의해야 할 사항으로는 이런 JDBC나 Template, 마이바티스 같은 라이브러리들은 JPA와 관련이 없기 때문에 영속성 컨텍스트의 기능과 별개, 그렇기 때문에 commit 된 상태가 되어야 데이터를 조회할 수 있어서 영속성 컨텍스트를 플러시 해줘야 등록된 데이터가 사용가능하다.\n  커밋을 하거나, JPA의 기능을 이용한 쿼리(JPQL, Criteria, NativeQuery\u0026hellip;) 등은 자동 플러시\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"객체지향 쿼리 언어 소개","id":41,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 객체지향 쿼리 언어 소개","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/object-oriented-query-language/"},{"content":"실전 예제 6 - 값 타입 매핑  값 타입 추가    city, street, zipcode 는 Address 값 타입으로 변경   값 타입 추가 순서    값 타입 클래스 추가 - Address.java    @Embeddable 어노테이션 추가    불변 객체로 생성 3.1. 필드(맴버 변수) 추가 3.2. getter 추가 3.3. setter private로 생성 또는 생성 X   값 타입은 공유해서 사용시 변경이 되면 같이 사용하는 값 모두 변경되므로 주의 값 타입은 변경하지 말고 객체를 새로 생성해서 갈아껴야함. 3.4. .equals()와 hashcode() 오버라이딩 == 비교에서 값 전체 비교로 변경    값 타입을 사용(Embedded)할 엔티티에 생성한 값 타입 추가    Address.java - value type\n package jpabasic.jpashop.domain;\rimport javax.persistence.Embeddable;\r@Embeddable\rpublic class Address {\r@Column(length = 10)\rprivate String cicy;\r@Column(length = 30)\rprivate String street;\r@Column(length = 5) private String zipcode;\r// Address 를 사용하는 곳에서 같이 사용할 수 있는 메소드\rpublic String fullAddress(){\rreturn getCicy() +\u0026quot; \u0026quot;+ getStreet() +\u0026quot; (\u0026quot;+getZipcode()+\u0026quot;)\u0026quot;;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rprivate void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r}\r  code generation 할때, 아래 옵션을 선택하면, 필드에 직접 접근하는게 아니라 클래스의 Getter 메서드를 사용.\n  프록시일 경우 필드에 직접 접근하면 계산이 안되기 때문에 getter 메소드를 이용해서 equals()와 hashcode()를 오버라이딩해야함.\n 수정된 소스  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member extends BaseEntity{\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r// ***\r@Embedded // Address 에서 @Embeddable 추가시 생략가능\rprivate Address address;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Order\u0026gt; getOrders() {\rreturn orders;\r}\rpublic void setOrders(List\u0026lt;Order\u0026gt; orders) {\rthis.orders = orders;\r}\rpublic Address getAddress() {\rreturn address;\r}\rpublic void setAddress(Address address) {\rthis.address = address;\r}\r}\r  Delivery.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Delivery extends BaseEntity{\r@Id @GeneratedValue\r@Column(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Long id;\r@Embedded\rprivate Address address;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status;\r@OneToOne(mappedBy = \u0026quot;delivery\u0026quot; , fetch = FetchType.LAZY)\rprivate Order order;\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic DeliveryStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(DeliveryStatus status) {\rthis.status = status;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\rpublic Address getAddress() {\rreturn address;\r}\rpublic void setAddress(Address address) {\rthis.address = address;\r}\r}\r 이전과 동일 소스  Album.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;)\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\rpublic String getArtist() {\rreturn artist;\r}\rpublic void setArtist(String artist) {\rthis.artist = artist;\r}\rpublic String getEtc() {\rreturn etc;\r}\rpublic void setEtc(String etc) {\rthis.etc = etc;\r}\r}\r  BaseEntity.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.Column;\rimport javax.persistence.MappedSuperclass;\rimport java.time.LocalDateTime;\r@MappedSuperclass\rpublic abstract class BaseEntity {\r@Column(name = \u0026quot;REG_ID\u0026quot;)\rprivate String createBy;\r@Column(name = \u0026quot;REG_DT\u0026quot;)\rprivate LocalDateTime createDate;\r@Column(name = \u0026quot;MOD_ID\u0026quot;)\rprivate String LastModifiedBy;\r@Column(name = \u0026quot;MOD_DT\u0026quot;)\rprivate LocalDateTime LastModifiedDate;\rpublic String getCreateBy() {\rreturn createBy;\r}\rpublic void setCreateBy(String createBy) {\rthis.createBy = createBy;\r}\rpublic LocalDateTime getCreateDate() {\rreturn createDate;\r}\rpublic void setCreateDate(LocalDateTime createDate) {\rthis.createDate = createDate;\r}\rpublic String getLastModifiedBy() {\rreturn LastModifiedBy;\r}\rpublic void setLastModifiedBy(String lastModifiedBy) {\rLastModifiedBy = lastModifiedBy;\r}\rpublic LocalDateTime getLastModifiedDate() {\rreturn LastModifiedDate;\r}\rpublic void setLastModifiedDate(LocalDateTime lastModifiedDate) {\rLastModifiedDate = lastModifiedDate;\r}\r}\r  Book.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;)\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic String getIsbn() {\rreturn isbn;\r}\rpublic void setIsbn(String isbn) {\rthis.isbn = isbn;\r}\r}\r  Category.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Category extends BaseEntity{\r@Id @GeneratedValue\r@Column(name = \u0026quot;CATEGORY_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToOne(fetch = FetchType.LAZY)\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent; // 상위 카테고리\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;(); // 자식 카테고리\r@ManyToMany\r@JoinTable(name = \u0026quot;CATEGORY_ITEM\u0026quot;,\rjoinColumns = @JoinColumn(name = \u0026quot;CATEGORY_ID\u0026quot;),\rinverseJoinColumns = @JoinColumn(name =\u0026quot;ITEM_ID\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r  DeliveryStatus.java\n package jpabasic.jpashop.domain;\rpublic enum DeliveryStatus {\rORDER, CANCEL\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic abstract class Item extends BaseEntity{\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r  Movie.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;)\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\rpublic String getDirector() {\rreturn director;\r}\rpublic void setDirector(String director) {\rthis.director = director;\r}\rpublic String getActor() {\rreturn actor;\r}\rpublic void setActor(String actor) {\rthis.actor = actor;\r}\r}\r  Order.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order extends BaseEntity{\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne(fetch = FetchType.LAZY)\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r@JoinColumn(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Delivery delivery;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\rpublic void addOrderItem(OrderItem orderItem) {\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r}\r  OrderItem.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem extends BaseEntity{\rpublic OrderItem(){\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne(fetch = FetchType.LAZY)\rprivate Order order;\r@ManyToOne(fetch = FetchType.LAZY)\rprivate Item item;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\rpublic Item getItem() {\rreturn item;\r}\rpublic void setItem(Item item) {\rthis.item = item;\r}\r}\r  OrderStatus.java\n package jpabasic.jpashop.domain;\rpublic enum OrderStatus {\rORDER, CANCEL\r}\r  JpaMain.java\n package jpabasic.jpashop;\rimport jpabasic.jpashop.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpashop\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rBook book = new Book();\rbook.setName(\u0026quot;JPA\u0026quot;);\rbook.setAuthor(\u0026quot;김영한\u0026quot;);\rem.persist(book);\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  JpaMain.java - 애플리케이션 재시작\n  console\n Hibernate: create table Delivery (\rDELIVERY_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rcicy varchar(10),\rstreet varchar(30),\rzipcode varchar(5),\rstatus varchar(255),\rprimary key (DELIVERY_ID)\r)\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rcicy varchar(10),\rstreet varchar(30),\rzipcode varchar(5),\rname varchar(255),\rprimary key (MEMBER_ID)\r)\r 값 타입의 장점    공통 메소드 같이 사용 컬럼의 길이 등 옵션 동일 적용 제약조건 동일 적용   참고- 자바 ORM 표준 JPA - 김영한 ","description":"값 타입 매핑","id":42,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 실전 예제 6 - 값 타입 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-6/"},{"content":"값 타입 컬렉션 (Value Type Collection)  값 타입 컬렉션   값 타입 컬렉션이란 값타입을 컬렉션에 담아서 사용하는 것을 의미 합니다.\n  Member가 faviriteFoods와 addressHistory 라는 두가지 컬렉션을 가지고 있습니다.\n  DB 테이블로 구현할때 문제가 됩니다. 값 타입이 하나 일때는 필드 속성으로 해서 Member 테이블에 넣으면 되었는데\n  관계형 DB에는 컬렉션을 담을 수 있는 구조가 없습니다. 요즘에서야 JSON 타입을 지원하는 데이터베이스도 있긴합니다.\n  관계형 DB에서 이런 구조를 사용하기 위해 1:N 관계의 각 테이블을 생성하여야 합니다.\n  아래 FAVORITE_FOOD 와 ADDRESS에 식별자 없이 MEMBER_ID와 각 테이블의 PK와 결합하여 복합키로 사용합니다. 여기에 시퀀스를 추가하게 되면, 값 타입이 아닌 엔티티가 되어버리기 때문에 시퀀스를 사용 할 수 없습니다.\n  Member.java - favoriteFoods와 addressHistory를 추가\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.HashSet;\rimport java.util.List;\rimport java.util.Set;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String name;\r@Embedded\rprivate Address homeAddress;\r//*****************************************************************\r@ElementCollection // 컬렉션 객체임을 알려주는 어노테이션\r@CollectionTable(name = \u0026quot;FAVORITE_FOOD\u0026quot;, joinColumns = @JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;) // JoinColumn을 세팅하면 해당 키를 외래키로 사용합니다.\r)\r@Column(name = \u0026quot;FOOD_NAME \u0026quot;)\rprivate Set\u0026lt;String\u0026gt; favoriteFoods = new HashSet\u0026lt;\u0026gt;();\r@ElementCollection\r@CollectionTable(name = \u0026quot;ADDRESS\u0026quot; , joinColumns =\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\r)\rprivate List\u0026lt;Address\u0026gt; addressHistory = new ArrayList\u0026lt;\u0026gt;();\r//*****************************************************************\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Address getHomeAddress() {\rreturn homeAddress;\r}\rpublic void setHomeAddress(Address homeAddress) {\rthis.homeAddress = homeAddress;\r}\rpublic Set\u0026lt;String\u0026gt; getFavoriteFoods() {\rreturn favoriteFoods;\r}\rpublic void setFavoriteFoods(Set\u0026lt;String\u0026gt; favoriteFoods) {\rthis.favoriteFoods = favoriteFoods;\r}\rpublic List\u0026lt;Address\u0026gt; getAddressHistory() {\rreturn addressHistory;\r}\rpublic void setAddressHistory(List\u0026lt;Address\u0026gt; addressHistory) {\rthis.addressHistory = addressHistory;\r}\r}\r  Address.java\n package relativemapping;\rimport javax.persistence.Embeddable;\rimport java.util.Objects;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic Address() {\r}\rpublic Address(String city, String street, String zipcode) {\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r@Override\rpublic boolean equals(Object o) {\rif (this == o) return true;\rif (o == null || getClass() != o.getClass()) return false;\rAddress address = (Address) o;\rreturn Objects.equals(city, address.city) \u0026amp;\u0026amp; Objects.equals(street, address.street) \u0026amp;\u0026amp; Objects.equals(zipcode, address.zipcode);\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hash(city, street, zipcode);\r}\r}\r  JpaMain.java - 애플리케이션 재시작\n package relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  console\n Hibernate: create table ADDRESS (\rMEMBER_ID bigint not null, // *** Member의 키가 외래키로 세팅\rcity varchar(255),\rstreet varchar(255),\rzipcode varchar(255)\r)\rHibernate: create table FAVORITE_FOOD (\rMEMBER_ID bigint not null,\rFOOD_NAME varchar(255)\r)\rHibernate: create table Member (\rid bigint not null,\rcity varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rUSERNAME varchar(255),\rTEAM_ID bigint,\rprimary key (id)\r)  값 타입 컬렉션의 설명    값 타입을 하나 이상 저장할 때 사용 @ElementCollection, @CollectionTable 사용 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다. 그렇기 때문에 1:N의 테이블로 별도로 생성해 줘야 하며, 조인을 위한 외래키(연결할 테이블의 PK키)를 추가해 줘야한다. 컬렉션을 저장하기 위한 별도의 테이블이 필요함   값 타입 컬렉션의 사용  값 타입 저장  JpaMain.java\n \t...\rMember member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rtx.commit();\r...\r  console\n Hibernate: call next value for hibernate_sequence\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, USERNAME, id) values\r(?, ?, ?, ?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.addressHistory */ insert into\rADDRESS\r(MEMBER_ID, city, street, zipcode) values\r(?, ?, ?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.addressHistory */ insert into\rADDRESS\r(MEMBER_ID, city, street, zipcode) values\r(?, ?, ?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\r  흥미로운 점은 Member만 Persist()를 통해 저장했을 뿐인데, 값 타입 컬렉션인 favoriteFoods와 addressHistory도 저장된 것을 확인 할 수 있습니다.\n  Embedded 타입인 homeAddress는 그렇다 쳐도 다른 테이블인 값 타입 컬렉션들 모두 저장이 되었습니다.\n  크게 보면, Member의 name, homeAddress, favoriteFoods, addressHistory 모두 값 타입으로 볼 수 있기 때문에 Member의 라이프사이클에 따라 값 타입들도 관리되는 것도 당연한 것입니다.\n 값 타입 조회  JpaMain.java\n  Member member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\rtx.commit();\r  console\n ===================================\rHibernate: select\rmember0_.id as id1_6_0_,\rmember0_.city as city2_6_0_,\rmember0_.street as street3_6_0_,\rmember0_.zipcode as zipcode4_6_0_,\rmember0_.USERNAME as username5_6_0_ from\rMember member0_ where\rmember0_.id=?\r  Member만 조회된 것을 확인 할 수 있습니다. Member에 포함된 city, street, zipcode 는 함께 불러옵니다.\n 값 타입 컬렉션에서도 지연 로딩 전략 사용  JpaMain.java\n Member member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\rfindMember.getFavoriteFoods();\rList\u0026lt;Address\u0026gt; addressHistory = findMember.getAddressHistory();\rfor (Address address : addressHistory){\rSystem.out.println(\u0026quot;address_city = \u0026quot;+address.getCity());\r}\rSet\u0026lt;String\u0026gt; favoritFoods = findMember.getFavoriteFoods();\rfor (String favoritFood : favoritFoods){\rSystem.out.println(\u0026quot;favoritFood = \u0026quot;+favoritFood);\r}\rtx.commit();\r  console\n Hibernate: select\rmember0_.id as id1_6_0_,\rmember0_.city as city2_6_0_,\rmember0_.street as street3_6_0_,\rmember0_.zipcode as zipcode4_6_0_,\rmember0_.USERNAME as username5_6_0_ from\rMember member0_ where\rmember0_.id=?\rHibernate: select\raddresshis0_.MEMBER_ID as member_i1_0_0_,\raddresshis0_.city as city2_0_0_,\raddresshis0_.street as street3_0_0_,\raddresshis0_.zipcode as zipcode4_0_0_ from\rADDRESS addresshis0_ where\raddresshis0_.MEMBER_ID=?\raddress_city = old1\raddress_city = old2\rHibernate: select\rfavoritefo0_.MEMBER_ID as member_i1_4_0_,\rfavoritefo0_.FOOD_NAME as food_nam2_4_0_ from\rFAVORITE_FOOD favoritefo0_ where\rfavoritefo0_.MEMBER_ID=?\rfavoritFood = 치킨\rfavoritFood = 햄버거\rfavoritFood = 피자\r 값 타입 수정  JpaMain.java - homeAddress 수정\n \rMember member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\r// home1 -\u0026gt; new1\r//findMember.getHomeAddress().setCity(\u0026quot;new1\u0026quot;); // 값 타입의 set은 사이드이펙트가 발생할 문제가 있어 set X\rAddress oldAddress = findMember.getHomeAddress();\rfindMember.setHomeAddress(new Address(\u0026quot;new1\u0026quot;, oldAddress.getStreet(), oldAddress.getZipcode()));\r  이전 시간에서 Address의 set을 private로 변경하여 외부에서 사용 못하게 처리하였습니다. set을 통해 수정하면, 참조하고 있는 모든 곳에서 Update문이 발생할 수 있기 때문입니다.\n  그렇기 때문에 new 를 통해 새로운 객체를 생성해 갈아껴 주는 작업을 합니다.\n  console\n Hibernate: /* update\rrelativemapping.Member */ update\rMember set\rcity=?,\rstreet=?,\rzipcode=?,\rUSERNAME=? where\rid=?\r  다음은 Set을 사용하는 값 타입 컬렉션 favoriteFoods의 \u0026ldquo;치킨\u0026quot;의 값을 \u0026ldquo;한식\u0026quot;으로 변경해 보겠습니다.\n  JpaMain.java - favoriteFoods의 Elements 수정\n \rMember member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\r// home1 -\u0026gt; new1\r//findMember.getHomeAddress().setCity(\u0026quot;new1\u0026quot;); // 값 타입의 set은 사이드이펙트가 발생할 문제가 있어 set X\rAddress oldAddress = findMember.getHomeAddress();\rfindMember.setHomeAddress(new Address(\u0026quot;new1\u0026quot;, oldAddress.getStreet(), oldAddress.getZipcode()));\r// 치킨 -\u0026gt; 한식\rfindMember.getFavoriteFoods().remove(\u0026quot;치킨\u0026quot;);\rfindMember.getFavoriteFoods().add(\u0026quot;한식\u0026quot;);\r  console\n Hibernate: /* delete collection row relativemapping.Member.favoriteFoods */ delete from\rFAVORITE_FOOD where\rMEMBER_ID=? and FOOD_NAME=?\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\r  값 타입 컬렉션의 값만 수정하여도 어떤 것이 변경되었는지 JPA가 분석하여 수정해 줍니다.\n  마치 영속성 전이가 이루어지는 것처럼 동작합니다.\n  JpaMain.java\n Member member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\rmember.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\r// home1 -\u0026gt; new1\r//findMember.getHomeAddress().setCity(\u0026quot;new1\u0026quot;); // 값 타입의 set은 사이드이펙트가 발생할 문제가 있어 set X\r/*Address oldAddress = findMember.getHomeAddress();\rfindMember.setHomeAddress(new Address(\u0026quot;new1\u0026quot;, oldAddress.getStreet(), oldAddress.getZipcode()));*/\r// 치킨 -\u0026gt; 한식\r/*findMember.getFavoriteFoods().remove(\u0026quot;치킨\u0026quot;);\rfindMember.getFavoriteFoods().add(\u0026quot;한식\u0026quot;);*/\rfindMember.getAddressHistory().remove(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rfindMember.getAddressHistory().add(new Address(\u0026quot;new2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\r/*\rremove 내부에서 equals()를 통하여 값이 완전 똑같은 객체를 지우게 되는데, equals와 hashcode를\r== 비교에서, 값 전체를 비교해 같은 값을 가지는 지로 변경하지 않으면 값이 삭제 되지 않고\r계속 추가가 되는 버그를 발생시킬 수 있습니다.\r*/\r  remove 내부에서 equals()를 통하여 값이 완전 똑같은 객체를 지우게 되는데, equals와 hashcode를 == 비교에서, 값 전체를 비교해 같은 값을 가지는 지로 변경하지 않으면 값이 삭제 되지 않고 계속 추가가 되는 버그를 발생시킬 수 있습니다.\n  console\n Hibernate: /* delete collection relativemapping.Member.addressHistory */ delete from\rADDRESS where\rMEMBER_ID=?\rHibernate: /* insert collection\rrow relativemapping.Member.addressHistory */ insert into\rADDRESS\r(MEMBER_ID, city, street, zipcode) values\r(?, ?, ?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.addressHistory */ insert into\rADDRESS\r(MEMBER_ID, city, street, zipcode) values\r(?, ?, ?, ?)\r  실행 후 결과를 보면 수정하려는 값만, 지우고 새로 추가한 값만 인서트 하는 것을 예상했겠지만 다르게 수행하는 것을 확인 할 수 있습니다.\n  from\rADDRESS where\rMEMBER_ID=?\r  Member의 id에 해당하는 모든 주소를 지우고\n insert into\rADDRESS\r(MEMBER_ID, city, street, zipcode) values\r(?, ?, ?, ?)\r  삭제된 new Address(\u0026ldquo;old1\u0026rdquo;, \u0026ldquo;street1\u0026rdquo;, \u0026ldquo;10000\u0026rdquo;) 의 해당하는 값 이외의 Address를 다시 인서트 하고\n insert into\rADDRESS\r(MEMBER_ID, city, street, zipcode) values\r(?, ?, ?, ?)\r  추가된 new Address(\u0026ldquo;new2\u0026rdquo;, \u0026ldquo;street1\u0026rdquo;, \u0026ldquo;10000\u0026rdquo;) 의 Address가 다시 인스트 됩니다.\n  수정 후 결과를 보면, 잘 수정되어있는 결과를 볼 수 있습니다.\n 참고  값 타입 컬렉션은 영속성 전이(Cascade)+ 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.\n 값 타입 컬렉션의 제약사항    값 타입은 엔티티와 다르게 식별자 개념이 없다. 값은 변경하면 추적이 어렵다. 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야함 (null 입력 x, 중복저장x)    Jpa가 생성한 ADDRESS 를 보면 기본 키를 사용할 컬럼이 존재 하지 않기 때문에 모든 키를 복합키로 사용해야 하는데, 그렇게 되면 null 입력이 되지 않기 때문에 문제가 발생.\n  console - ADDRESS DDL\n Hibernate: create table ADDRESS (\rMEMBER_ID bigint not null,\rcity varchar(255),\rstreet varchar(255),\rzipcode varchar(255)\r)\r List + @OrderColumn  @OrderColumn을 추가하면 테이블에 Order 번호가 컬럼이 생성되며 JPA 값 타입 컬렉션에서도 순서가 있는 컬렉션으로 FK + OrderColumn 으로 키를 매핑하게 됩니다.\n @OrderColumn(name = \u0026quot;address_history_order\u0026quot;)\r@ElementCollection\r@CollectionTable(name = \u0026quot;ADDRESS\u0026quot; , joinColumns =\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\r)\rprivate List\u0026lt;Address\u0026gt; addressHistory = new ArrayList\u0026lt;\u0026gt;();\r  위에서 말했던 특정할 만한 컬럼이 없어, 외래키와 모든 컬럼을 PK로 잡던 문제점을 해결할 수 있지만.\n  실제로 @OrderColumn은 실무에서 사용하기에는 단점이 너무 많습니다. 원하는 대로 동작하지 않는게 많고 순서대로 0, 1,2,3 인데 중간에 2 하나를 빼먹은 경우 2가 null 로 들어오는 등 문제가 있어 사용하지 않는것이 바람직합니다.\n  이렇게 값 타입 컬렉션을 복잡하게 사용할 경우 다른 방식으로 풀어서 개발해야 합니다.\n 값 타입 컬렉션의 대안사항    실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용 영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용 AddressEntity로 만들어 내부에 값 타입을 임베디드 하여 엔티티로 승급시킴    AddressEntity.java\n package relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\rimport javax.persistence.Table;\rimport java.security.PrivateKey;\r@Entity\r@Table(name = \u0026quot;ADDRESS\u0026quot;)\rpublic class AddressEntity {\rpublic AddressEntity() {\r}\rpublic AddressEntity(String city, String street, String zipcode) {\rthis.address = new Address(city,street,zipcode);\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate Address address;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Address getAddress() {\rreturn address;\r}\rpublic void setAddress(Address address) {\rthis.address = address;\r}\r}\r  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.HashSet;\rimport java.util.List;\rimport java.util.Set;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String name;\r@Embedded\rprivate Address homeAddress;\r@ElementCollection\r@CollectionTable(name = \u0026quot;FAVORITE_FOOD\u0026quot;, joinColumns =\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;) // JoinColumn을 세팅하면 해당 키를 외래키로 사용합니다.\r)\r@Column(name = \u0026quot;FOOD_NAME \u0026quot;)\rprivate Set\u0026lt;String\u0026gt; favoriteFoods = new HashSet\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\r/*\r@OrderColumn(name = \u0026quot;address_history_order\u0026quot;)\r@ElementCollection\r@CollectionTable(name = \u0026quot;ADDRESS\u0026quot; , joinColumns =\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\r)\rprivate List\u0026lt;Address\u0026gt; addressHistory = new ArrayList\u0026lt;\u0026gt;();\r*/\r@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate List\u0026lt;AddressEntity\u0026gt; addressHistory = new ArrayList\u0026lt;\u0026gt;();\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Address getHomeAddress() {\rreturn homeAddress;\r}\rpublic void setHomeAddress(Address homeAddress) {\rthis.homeAddress = homeAddress;\r}\rpublic Set\u0026lt;String\u0026gt; getFavoriteFoods() {\rreturn favoriteFoods;\r}\rpublic void setFavoriteFoods(Set\u0026lt;String\u0026gt; favoriteFoods) {\rthis.favoriteFoods = favoriteFoods;\r}\r}\r  JpaMain.java\n package relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rimport java.util.Set;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rMember member = new Member();\rmember.setName(\u0026quot;member1\u0026quot;);\rmember.setHomeAddress(new Address(\u0026quot;home1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getFavoriteFoods().add(\u0026quot;치킨\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;피자\u0026quot;);\rmember.getFavoriteFoods().add(\u0026quot;햄버거\u0026quot;);\r/* member.getAddressHistory().add(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new Address(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));*/\r// *** Entity로 변경\rmember.getAddressHistory().add(new AddressEntity(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rmember.getAddressHistory().add(new AddressEntity(\u0026quot;old2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rem.persist(member);\rem.flush();\rem.clear();\rSystem.out.println(\u0026quot;===================================\u0026quot;);\rMember findMember = em.find(Member.class, member.getId());\r// home1 -\u0026gt; new1\r//findMember.getHomeAddress().setCity(\u0026quot;new1\u0026quot;); // 값 타입의 set은 사이드이펙트가 발생할 문제가 있어 set X\r/*Address oldAddress = findMember.getHomeAddress();\rfindMember.setHomeAddress(new Address(\u0026quot;new1\u0026quot;, oldAddress.getStreet(), oldAddress.getZipcode()));*/\r// 치킨 -\u0026gt; 한식\r/*findMember.getFavoriteFoods().remove(\u0026quot;치킨\u0026quot;);\rfindMember.getFavoriteFoods().add(\u0026quot;한식\u0026quot;);*/\r/*findMember.getAddressHistory().remove(new Address(\u0026quot;old1\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));\rfindMember.getAddressHistory().add(new Address(\u0026quot;new2\u0026quot;, \u0026quot;street1\u0026quot;, \u0026quot;10000\u0026quot;));*/\r/*\rremove 내부에서 equals()를 통하여 값이 완전 똑같은 객체를 지우게 되는데, equals와 hashcode를\r== 비교에서, 값 전체를 비교해 같은 값을 가지는 지로 변경하지 않으면 값이 삭제 되지 않고\r계속 추가가 되는 버그를 발생시킬 수 있습니다.\r*/\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  console\n  /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, USERNAME, id) values\r(?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.AddressEntity\r*/ insert into\rADDRESS\r(city, street, zipcode, id) values\r(?, ?, ?, ?)\rHibernate: /* insert relativemapping.AddressEntity\r*/ insert into\rADDRESS\r(city, street, zipcode, id) values\r(?, ?, ?, ?)\rHibernate: /* create one-to-many row relativemapping.Member.addressHistory */ update\rADDRESS set\rMEMBER_ID=? where\rid=?\rHibernate: /* create one-to-many row relativemapping.Member.addressHistory */ update\rADDRESS set\rMEMBER_ID=? where\rid=?\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\rHibernate: /* insert collection\rrow relativemapping.Member.favoriteFoods */ insert into\rFAVORITE_FOOD\r(MEMBER_ID, FOOD_NAME) values\r(?, ?)\r===================================\rHibernate: select\rmember0_.id as id1_6_0_,\rmember0_.city as city2_6_0_,\rmember0_.street as street3_6_0_,\rmember0_.zipcode as zipcode4_6_0_,\rmember0_.USERNAME as username5_6_0_ from\rMember member0_ where\rmember0_.id=?\r  ADDRESS 테이블에 Update로 MEMBER_ID를 업데이트 하게 되는것은 1:N 관계에서 양방향 관계가 아닐 시 외래키가 다른 테이블에 있기 때문에 업데이트함.\n  연관관계 강의 1:N를 보면 알 수 있습니다.\n JPA 다양한 연관관계 매핑\n 독자적인 PK를 가지는 순간 값 타입이 아니라 엔티티가 됩니다.\n  엔티티로 변경 하였기 때문에 수정을 하여도 문제가 없습니다 !!\n  값 타입을 엔티티로 래핑 하여, 엔티티로 사용하는 것을 값 타입을 승급한다 라고 합니다.\n  실무에서 이런 방식을 사용하여, 값 타입을 많이 사용한다고 합니다.\n 값 타입 컬렉션을 언제 쓰는가 ?  진짜 간단한 콤보박스의 옵션 값 정도의 기능 개발할때 사용.\n  값을 추적할 일이 없고 변경되어도 문제가 없을때 사용.\n 정리   엔티티의 타입의 특징  식별자O 생명 주기 관리 공유       값 타입의 특징  식별자X 생명 주기를 엔티티에 의존 공유 하지 않는 것이 안전(복사해서 사용) 불변 객체로 만드는 것이 안전      값 타입은 정말 값 타입이라 판단될 때만 사용 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것은 값 타입이 아닌 엔티티\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 값 타입 비교","id":43,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 값 타입 컬렉션","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/value-type-collection/"},{"content":"값 타입과 불변 객체  값 타입   값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.\n  값 타입 공유 참조     임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함 부작용(side effect) 발생    회원 1과 회원 2가 같은 값 타입인 주소를 바라보고 있는데 NewCity로 값을 바꾸면, 회원1과 회원2의 주소가 모두 NewCity로 변경됩니다.\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r// 기간\r//private LocalDateTime startDate;\r//private LocalDateTime endDate;\r@Embedded\rprivate Period workPeriod;\r// 주소\r//private String city;\r//private String street;\r//private String zipcode;\r@Embedded\rprivate Address homeAddress;\r@Embedded\r@AttributeOverrides({\r@AttributeOverride(name = \u0026quot;city\u0026quot;, column = @Column(name = \u0026quot;work_city\u0026quot;)),\r@AttributeOverride(name = \u0026quot;street\u0026quot;, column = @Column(name = \u0026quot;work_street\u0026quot;)),\r@AttributeOverride(name = \u0026quot;zipcode\u0026quot;, column = @Column(name = \u0026quot;work_zipcode\u0026quot;))\r})\rprivate Address workAddress;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Period getWorkPeriod() {\rreturn workPeriod;\r}\rpublic void setWorkPeriod(Period workPeriod) {\rthis.workPeriod = workPeriod;\r}\rpublic Address getHomeAddress() {\rreturn homeAddress;\r}\rpublic void setHomeAddress(Address homeAddress) {\rthis.homeAddress = homeAddress;\r}\r}\r  JpaMain.java - 둘다 같은 Address의 값 타입을 사용해서 값을 저장\n \rAddress address = new Address(\u0026quot;OldCity\u0026quot;, \u0026quot;street\u0026quot;, \u0026quot;10000\u0026quot;);\rMember member1 = new Member();\rMember member2 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(address);\rem.persist(member1);\rmember2.setName(\u0026quot;member2\u0026quot;);\rmember2.setHomeAddress(address);\rem.persist(member2);\rtx.commit();\r Hibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, work_city, work_street, work_zipcode, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, work_city, work_street, work_zipcode, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\r  테이블을 조회해 보면 member1과 member2가 같은 주소로 저장되어 있는것을 확인 할 수 있습니다.\n  JpaMain.java - member1, member2 저장 이후 member1의 HomeAddress를 조회하여, city를 NewCity로 변경\n  Address address = new Address(\u0026quot;OldCity\u0026quot;, \u0026quot;street\u0026quot;, \u0026quot;10000\u0026quot;);\rMember member1 = new Member();\rMember member2 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(address);\rem.persist(member1);\rmember2.setName(\u0026quot;member2\u0026quot;);\rmember2.setHomeAddress(address);\rem.persist(member2);\rmember1.getHomeAddress().setCity(\u0026quot;NewCity\u0026quot;);\r  console\n Hibernate: call next value for hibernate_sequence\rHibernate: call next value for hibernate_sequence\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, work_city, work_street, work_zipcode, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, work_city, work_street, work_zipcode, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\rHibernate: /* update\rrelativemapping.Member */ update\rMember set\rcity=?,\rstreet=?,\rzipcode=?,\rname=?,\rwork_city=?,\rwork_street=?,\rwork_zipcode=?,\rendDate=?,\rstartDate=? where\rid=?\rHibernate: /* update\rrelativemapping.Member */ update\rMember set\rcity=?,\rstreet=?,\rzipcode=?,\rname=?,\rwork_city=?,\rwork_street=?,\rwork_zipcode=?,\rendDate=?,\rstartDate=? where\rid=?\r  업데이트 쿼리가 2번 실행되는것을 확인할 수 있습니다.\n  member1의 주소만 변경하기 위해 member1의 HomeAddress를 조회하여 city를 수정했지만, 원치 않는 결과가 나오게 됩니다.\n  이러한 사이트 이펙트로 생겨난 오류는 찾기가 매우 어렵습니다.\n  만일 하나의 값을 공유하여 사용하고자 할때는 값 타입이 아니라 엔티티를 사용하여 개발해야합니다.\n 값 타입 복사    값 타입의 실제 인스턴스(생성된 address)를 공유하는 것은 위험 대신 값(인스턴스의 값, new Address(address.getCity(), address.getStreet(), address.getZipcode()); )를 복사해서 사용    JpaMain.java - member2는 Address의 값들 (city, street, zipcode의 값)을 복사해 새로운 newAddress로 세팅합니\n \tAddress address = new Address(\u0026quot;OldCity\u0026quot;, \u0026quot;street\u0026quot;, \u0026quot;10000\u0026quot;);\rMember member1 = new Member();\rMember member2 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(address);\rem.persist(member1);\rAddress newAddress = new Address(address.getCity(), address.getStreet(), address.getZipcode());\rmember2.setName(\u0026quot;member2\u0026quot;);\rmember2.setHomeAddress(newAddress);\rem.persist(member2);\rmember1.getHomeAddress().setCity(\u0026quot;NewCity\u0026quot;);\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, work_city, work_street, work_zipcode, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, work_city, work_street, work_zipcode, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\rHibernate: /* update\rrelativemapping.Member */ update\rMember set\rcity=?,\rstreet=?,\rzipcode=?,\rname=?,\rwork_city=?,\rwork_street=?,\rwork_zipcode=?,\rendDate=?,\rstartDate=? where\rid=?\r 객체 타입의 한계    항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다. 자바 기본타입(primitive type)은 대입하면 항상 복사되기 때문에 공유하여 사용할 수 없습니다. 자바의 기본타입에 값을 대입하면 값을 복사한다. 객체 타입은 참조 값(reference)을 직접 대입하는 것을 막을 방법이 없다. 객체의 공유 참조는 피할 수 없다.     기본 타입(primitive type)   \tint a = 10;\rint b = a; //기본 타입은 값을 복사\rb = 4;\r   객체 타입   \tAddress a = new Address(\u0026quot;OldCity\u0026quot;);\rAddress b = a; //객체 타입은 참조를 전달\rb.setCity(\u0026quot;NewCity\u0026quot;)\r   잘못된 사용 예제 1   \tAddress newAddress = new Address(address.getCity(), address.getStreet(), address.getZipcode());\rmember2.setName(\u0026quot;member2\u0026quot;);\rmember2.setHomeAddress(member1.getHomeAddress()); // ** 이 처럼 개발을 하다 잘못해서 member2의 SetHomeAddress에 newAddress가 아닌 em.persist(member2); // member1.getHomeAddress()를 집어 넣을때 컴파일 레벨에서 막을 방법이 없다.\r   잘못된 사용 예제 2    Address address = new Address(\u0026quot;OldCity\u0026quot;, \u0026quot;street\u0026quot;, \u0026quot;10000\u0026quot;);\rMember member1 = new Member();\rMember member2 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(address);\rem.persist(member1);\rAddress newAddress = address;\rmember2.setName(\u0026quot;member2\u0026quot;);\rmember2.setHomeAddress(newAddress);\rem.persist(member2);\rmember1.getHomeAddress().setCity(\u0026quot;NewCity\u0026quot;);\r  그래서 객체타입을 수정할 수 없게 만들면 부작용을 막을 수 있습니다.\n 불변 객체    객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단 값 타입은 불변 객체(immutable object)로 설계해야함 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체 불변 객체로 만드는 방법  생성자로만 값을 설정하고 수정자(setter)를 만들지 않음 setter를 private로 생성하여 외부에서 접근을 막음 속성에 final 키워드 추가 객체 필드 참조 초기화 unmodifiableList 사용       참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체   package relativemapping;\rimport javax.persistence.Embeddable;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic Address() {\r}\rpublic Address(String city, String street, String zipcode) {\rthis.city = city;\rthis.street = street;\rthis.zipcode = zipcode;\r}\rpublic String getCity() {\rreturn city;\r}\rprivate void setCity(String city) { // *** 접근제어자를 private로 변경 또는 삭제\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rprivate void setStreet(String street) { // *** 접근제어자를 private로 변경 또는 삭제\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rprivate void setZipcode(String zipcode) { // *** 접근제어자를 private로 변경 또는 삭제\rthis.zipcode = zipcode;\r}\r}\r  만일 setter를 private로 변경했을 시 이런 컴파일러 레벨에서 오류를 내어 수정을 할 수 없게 만든다.\n  불변이라는 작은 제약으로 부작용(side effect)이라는 큰 재앙을 막을 수 있다.\n 불변 객체지만 실제로 값을 바꾸고 싶은 경우   JpaMain.java - 새로 Address를 만들고 변경할 값을 넣고 복사할 값은 address.getZipcode() 등 getter 메소드로 가져와 사용    Address address = new Address(\u0026quot;OldCity\u0026quot;, \u0026quot;street\u0026quot;, \u0026quot;10000\u0026quot;);\rMember member1 = new Member();\rMember member2 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(address);\rem.persist(member1);\r//member1.getHomeAddress().setCity(\u0026quot;NewCity\u0026quot;);\rAddress newAddress = new Address(\u0026quot;NewCity\u0026quot;, address.getStreet(), address.getZipcode());\rmember1.setHomeAddress(newAddress);\r  새로 객체를 생성하여 갈아껴 교체를 하거나, Address 내부에 copy 메소드를 제공하여 편의를 제공해서 사용\n 정리 : 값 타입은 꼭 불변 객체로 만들어 사용해야 부작용을 겪지 않을 수 있습니다. 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 값 타입과 불변 객체","id":44,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 값 타입과 불변 객체","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/immutable-object/"},{"content":"임베디드 타입  임베디드(복합 값) 타입    새로운 값 타입을 정의할 수 있음 JPA는 임베디드 타입(embedded type)이라 함 주로 기본 값 타임을 모아 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입 (엔티티 아님)   임베디드 타입   회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다.\n  회원 엔티티는 이름, 근무 기간, 집 주소를 가진다.\n   Period는 startDate와 endDate를 가지게 클래스로 만들어 값 타입을 만듭니다. Address는 city, street, zipCode를 묶어서 클래스로 만들어 값 타입을 만듭니다.   임베디드 타입 사용법    @Embeddable : 값을 타입을 정의하는 곳에서 표시 @Embedded : 값 타입을 사용하는 곳에 표시 기본 생성자 필수   임베디드 타입 장점    재사용 높은 응집도 Period.isWork() 처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함   임베디드 타입과 테이블 매핑   임베디드 타입을 사용하던 안하던 회원테이블은 변화가 없습니다. 테이블은 데이터를 잘 관리하기 위한 것이고, 객체는 행위까지 고려해야 하기때문에 임베디드 타입으로 묶었을때 얻을 수 있는 이득이 많습니다.\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r// 기간\rprivate LocalDateTime startDate;\rprivate LocalDateTime endDate;\r// 주소\rprivate String city;\rprivate String street;\rprivate String zipcode;\r}\r  JpaMain.java - 애플리케이션 재시작\n  console\n  create table Member (\rid bigint not null,\rcity varchar(255),\rendDate timestamp,\rname varchar(255),\rstartDate timestamp,\rstreet varchar(255),\rzipcode varchar(255),\rprimary key (id)\r)\r  MEMBER 테이블이 생성된 것을 확인 할 수 있습니다. Member 엔티티에 속성들을 workPeriod와 homeAddress 임베디드 타입으로 변경해 보도록 하겠습니다.\n  Period.java\n package relativemapping;\rimport javax.persistence.Embeddable;\rimport java.time.LocalDateTime;\r@Embeddable\rpublic class Period {\rprivate LocalDateTime startDate;\rprivate LocalDateTime endDate;\rpublic LocalDateTime getStartDate() {\rreturn startDate;\r}\rpublic void setStartDate(LocalDateTime startDate) {\rthis.startDate = startDate;\r}\rpublic LocalDateTime getEndDate() {\rreturn endDate;\r}\rpublic void setEndDate(LocalDateTime endDate) {\rthis.endDate = endDate;\r}\r}\r  Address.java\n package relativemapping;\rimport javax.persistence.Embeddable;\r@Embeddable\rpublic class Address {\rprivate String city;\rprivate String street;\rprivate String zipcode;\rpublic String getCity() {\rreturn city;\r}\rpublic void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r}\r  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r// 기간\r//private LocalDateTime startDate;\r//private LocalDateTime endDate;\r@Embedded\rprivate Period workPeriod;\r// 주소\r//private String city;\r//private String street;\r//private String zipcode;\r@Embedded\rprivate Address homeAddress;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Period getWorkPeriod() {\rreturn workPeriod;\r}\rpublic void setWorkPeriod(Period workPeriod) {\rthis.workPeriod = workPeriod;\r}\rpublic Address getHomeAddress() {\rreturn homeAddress;\r}\rpublic void setHomeAddress(Address homeAddress) {\rthis.homeAddress = homeAddress;\r}\r}\r  @Embeddable과 @Embedded는 한쪽만 설정해 두어도 되지만, 양쪽다 추가하길 권장합니다.\n  JpaMain.java - 애플리케이션 재시작\n  console\n  create table Member (\rid bigint not null,\rcity varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rname varchar(255),\rendDate timestamp,\rstartDate timestamp,\rprimary key (id)\r)\r  Create SQL은 이전과 똑같습니다. 테이블 구조는 변함 없지만, Member 엔티티는 좀더 객체지향 적으로 사용할 수 있습니다.\n  예를 들면 현재시간이 workPeriod에 시작과 끝에 포함된다면, isIncumbent()를 통해 재직중인지 확인하는 메소드를 만들어 사용할 수 도 있습니다.\n package relativemapping;\rimport javax.persistence.Embeddable;\rimport java.time.LocalDateTime;\r@Embeddable\rpublic class Period {\rprivate LocalDateTime startDate;\rprivate LocalDateTime endDate;\rpublic Period() {\r}\rpublic Period(LocalDateTime startDate, LocalDateTime endDate) {\rthis.startDate = startDate;\rthis.endDate = endDate;\r}\rpublic Boolean isIncumbent(){\rLocalDateTime today = LocalDateTime.now();\r/*\rSystem.out.println(this.startDate);\rSystem.out.println(today);\rSystem.out.println(this.startDate.isEqual(today)); // 주어진 시간과 같은지\rSystem.out.println(this.startDate.isBefore(today)); // 주어진 시간보다 이전인지\rSystem.out.println(this.startDate.isAfter(today)); // 주어진 시간보다 이후인지\rSystem.out.println(this.endDate);\rSystem.out.println(today);\rSystem.out.println(this.endDate.isEqual(today)); // 주어진 시간과 같은지\rSystem.out.println(this.endDate.isBefore(today)); // 주어진 시간보다 이전인지\rSystem.out.println(this.endDate.isAfter(today)); // 주어진 시간보다 이후인지\r*/\rif( ! this.startDate.isAfter(today) \u0026amp;\u0026amp; this.endDate.isAfter(today)){\rreturn true;\r}else{\rreturn false;\r}\r}\rpublic LocalDateTime getStartDate() {\rreturn startDate;\r}\rpublic void setStartDate(LocalDateTime startDate) {\rthis.startDate = startDate;\r}\rpublic LocalDateTime getEndDate() {\rreturn endDate;\r}\rpublic void setEndDate(LocalDateTime endDate) {\rthis.endDate = endDate;\r}\r}\r  JpaMain - Member 추가\n package relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rMember member1 = new Member();\rmember1.setName(\u0026quot;member1\u0026quot;);\rmember1.setHomeAddress(new Address(\u0026quot;서울\u0026quot;,\u0026quot;영등포\u0026quot;,\u0026quot;00000\u0026quot;));\rmember1.setWorkPeriod(new Period(LocalDateTime.of(2021,01,01,1,12,0),LocalDateTime.of(2023,01,01,1,12,0)));\rem.persist(member1);\rSystem.out.println(\u0026quot;isIncumbent \u0026quot;+member1.getWorkPeriod().isIncumbent());\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  console\n isIncumbent true\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(city, street, zipcode, name, endDate, startDate, id) values\r(?, ?, ?, ?, ?, ?, ?)\r 임베티드 타입의 장점    임베디드 타입은 엔티티의 값일 뿐이다. 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다. 객체와 테이블은 아주 세밀하게(find-grained) 매핑하는 것이 가능 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음 용어도 공통화 되고, 코드도 공통화 된다. 도메인의 언어로 맞출수 있는 언어들도 많이 나올 수 있음.   임베디드 타입과 연관관계   JPA 표준 스펙에 있는 내용으로, Member엔티티가 Adress와 PhoneNumber라는 임베디드 값 타입을 가지고 있습니다.\n  Address는 Zipcode를 가질 수 있는데, 임베디드 타입은 임베디드 타입을 가질수 있습니다.\n  그리고 재미있는 사실이 PhoneNumber라는 임베디드 타입이 PhoneEntity를 가질 수 있습니다. PhoneNumber 입장에서 PhoneEntity의 외래키를 가지고 있으면 되므로 어렵운 개념은 아닙니다.\n @AttributeOverride: 속성 재정의    한 엔티티에서 같은 값 타입을 사용하면? 컬럼명이 중복됨 @AttributeOverrides, @AttributeOverride를 사용해서 컬럼명 속성을 재정의    Member.java - Address workAddress 추가\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\r// 기간\r//private LocalDateTime startDate;\r//private LocalDateTime endDate;\r@Embedded\rprivate Period workPeriod;\r// 주소\r//private String city;\r//private String street;\r//private String zipcode;\r@Embedded\rprivate Address homeAddress;\r@Embedded\rprivate Address workAddress; // ** 추가\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Period getWorkPeriod() {\rreturn workPeriod;\r}\rpublic void setWorkPeriod(Period workPeriod) {\rthis.workPeriod = workPeriod;\r}\rpublic Address getHomeAddress() {\rreturn homeAddress;\r}\rpublic void setHomeAddress(Address homeAddress) {\rthis.homeAddress = homeAddress;\r}\r}\r  JpaMain.java - 애플리케이션 재시작\n  console\n Exception in thread \u0026quot;main\u0026quot; javax.persistence.PersistenceException: [PersistenceUnit: relativemapping] Unable to build Hibernate SessionFactory\rat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.persistenceException(EntityManagerFactoryBuilderImpl.java:1336)\rat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1262)\rat org.hibernate.jpa.HibernatePersistenceProvider.createEntityManagerFactory(HibernatePersistenceProvider.java:56)\rat javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:79)\rat javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:54)\rat relativemapping.JpaMain.main(JpaMain.java:12)\rCaused by: org.hibernate.MappingException: Repeated column in mapping for entity: relativemapping.Member column: city (should be mapped with insert=\u0026quot;false\u0026quot; update=\u0026quot;false\u0026quot;)\rat org.hibernate.mapping.PersistentClass.checkColumnDuplication(PersistentClass.java:862)\rat org.hibernate.mapping.PersistentClass.checkPropertyColumnDuplication(PersistentClass.java:880)\rat org.hibernate.mapping.PersistentClass.checkPropertyColumnDuplication(PersistentClass.java:876)\rat org.hibernate.mapping.PersistentClass.checkColumnDuplication(PersistentClass.java:902)\rat org.hibernate.mapping.PersistentClass.validate(PersistentClass.java:634)\rat org.hibernate.mapping.RootClass.validate(RootClass.java:267)\rat org.hibernate.boot.internal.MetadataImpl.validate(MetadataImpl.java:354)\rat org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:465)\rat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259)\r... 4 more\r  오류없이 속성을 재정의 하여 사용하고 싶을때, @AttributeOverrides 와 @AttributeOverride를 사용합니다.\n  @Embedded\r@AttributeOverrides({\r@AttributeOverride(name = \u0026quot;city\u0026quot;, column = @Column(name = \u0026quot;work_city\u0026quot;)),\r@AttributeOverride(name = \u0026quot;street\u0026quot;, column = @Column(name = \u0026quot;work_street\u0026quot;)),\r@AttributeOverride(name = \u0026quot;zipcode\u0026quot;, column = @Column(name = \u0026quot;work_zipcode\u0026quot;))\r})\rprivate Address workAddress;\r  @AttributeOverrides({\r@AttributeOverride(\rname = \u0026quot;city\u0026quot;\r, column = @Column(\rname = \u0026quot;work_city\u0026quot;\r)\r)\r})\r  JpaMain.java - 애플리케이션 재시작\n  console\n Hibernate: create table Member (\rid bigint not null,\rcity varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rname varchar(255),\rwork_city varchar(255),\rwork_street varchar(255),\rwork_zipcode varchar(255),\rendDate timestamp,\rstartDate timestamp,\rTEAM_ID bigint,\rprimary key (id)\r)\r 임베디드 타입과 null   임베디드 타입의 값이 null 이면 매핑한 컬럼 값은 모두 null\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 임베디드 타입","id":45,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 임베디드 타입","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/embedded-type/"},{"content":"값 타입  목차    기본값 타입 임베디드 타입(복합 값 타입) 값 타입과 불변 객체 값 타입의 비교 값 타입 컬렉션   기본값 타입  JPA의 데이터 타입 분류   엔티티 타입  @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적 가능 예) 회원의 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능       값 타입  int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경시 추적불가 예)숫자 100을 200으로 변경하면 완전히 다른 값으로 대체     값 타입 분류   기본값 타입  자바 기본 타입(int, double) 래퍼 클래스(Integer, Long) String   임베디드 타입(embedded type, 복합 값 타입) 예) 좌표 X,Y 묶어서 Position 객체 하나로 사용     컬렉션 값 타입(collection value type) 자바 컬렉션 객체안에 기본값 타입 혹은 임베디드 타입 등을 추가해 사용   기본값 타입    예) String name, int age 생명주기를 엔티티에 의존  예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제   값 티입은 공유하면 안됨(사이드 이팩트, 부수효과 조심)  예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨     참고 : 자바의 기본 타입은 절대 공유 X   int, double 같은 기본 타입(primitive type)은 절대 공유 되면 안됨 기본 타입은 항상 값을 복사함 Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경X    ValueMain.java\n package relativemapping;\rpublic class ValueMain {\rpublic static void main(String[] args) {\rint a = 10;\rint b = a; // 참조가 아니라, a의 값 세팅\ra = 20;\rSystem.out.println(\u0026quot;a = \u0026quot; + a); // a = 20\rSystem.out.println(\u0026quot;b = \u0026quot; + b); // b = 10\r}\r}\r  ValueMain.java\n package relativemapping;\rpublic class ValueMain {\rpublic static void main(String[] args) {\rInteger a = new Integer(10);\rInteger b = a;\r//a.setValue(20); //만약 Integer를 수정할 수 있는 함수가 있었다면, a와 b 모두 20으로 수정될 것입니다.\rSystem.out.println(\u0026quot;a = \u0026quot; + a);\rSystem.out.println(\u0026quot;b = \u0026quot; + b);\r}\r}\r  자바의 기본값 타입을 썻을때 사이드 이펙트 없이 안전하게 개발할 수 있는 이유였습니다.\n  여기까지는 자바 기초에서 다루었던 내용인데 왜 또 다룰까 하겠지만 JPA에서는 이것이 당연하지 않고 매우 중요합니다.  참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 값 타입","id":46,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 값 타입","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/value-type/"},{"content":"실전 예제 5 - 연관관계 관리  글로벌 페치 전략 설정    모든 연관관계를 지연로딩으로 @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 지연로딩으로 변경하길 권장   글로벌 페치 전략 예제소스에 적용   기존 작성했던 엔티티중 @ManyToOne, @OneToOne에는 (fetch = FetchType.LAZY)를 추가한다.\n  Album.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;)\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\rpublic String getArtist() {\rreturn artist;\r}\rpublic void setArtist(String artist) {\rthis.artist = artist;\r}\rpublic String getEtc() {\rreturn etc;\r}\rpublic void setEtc(String etc) {\rthis.etc = etc;\r}\r}\r  BaseEntity.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.Column;\rimport javax.persistence.MappedSuperclass;\rimport java.time.LocalDateTime;\r@MappedSuperclass\rpublic abstract class BaseEntity {\r@Column(name = \u0026quot;REG_ID\u0026quot;)\rprivate String createBy;\r@Column(name = \u0026quot;REG_DT\u0026quot;)\rprivate LocalDateTime createDate;\r@Column(name = \u0026quot;MOD_ID\u0026quot;)\rprivate String LastModifiedBy;\r@Column(name = \u0026quot;MOD_DT\u0026quot;)\rprivate LocalDateTime LastModifiedDate;\rpublic String getCreateBy() {\rreturn createBy;\r}\rpublic void setCreateBy(String createBy) {\rthis.createBy = createBy;\r}\rpublic LocalDateTime getCreateDate() {\rreturn createDate;\r}\rpublic void setCreateDate(LocalDateTime createDate) {\rthis.createDate = createDate;\r}\rpublic String getLastModifiedBy() {\rreturn LastModifiedBy;\r}\rpublic void setLastModifiedBy(String lastModifiedBy) {\rLastModifiedBy = lastModifiedBy;\r}\rpublic LocalDateTime getLastModifiedDate() {\rreturn LastModifiedDate;\r}\rpublic void setLastModifiedDate(LocalDateTime lastModifiedDate) {\rLastModifiedDate = lastModifiedDate;\r}\r}\r  Book.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;)\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic String getIsbn() {\rreturn isbn;\r}\rpublic void setIsbn(String isbn) {\rthis.isbn = isbn;\r}\r}\r  Category.java - fetch = FetchType.LAZY 적용\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Category extends BaseEntity{\r@Id @GeneratedValue\r@Column(name = \u0026quot;CATEGORY_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToOne(fetch = FetchType.LAZY) // **\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent; // 상위 카테고리\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;(); // 자식 카테고리\r@ManyToMany\r@JoinTable(name = \u0026quot;CATEGORY_ITEM\u0026quot;,\rjoinColumns = @JoinColumn(name = \u0026quot;CATEGORY_ID\u0026quot;),\rinverseJoinColumns = @JoinColumn(name =\u0026quot;ITEM_ID\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r  Delivery.java - fetch = FetchType.LAZY 적용\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Delivery extends BaseEntity{\r@Id @GeneratedValue\r@Column(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Long id;\rprivate String city;\rprivate String street;\rprivate String zipcode;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status;\r@OneToOne(mappedBy = \u0026quot;delivery\u0026quot; , fetch = FetchType.LAZY) // **\rprivate Order order;\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic String getCity() {\rreturn city;\r}\rpublic void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic DeliveryStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(DeliveryStatus status) {\rthis.status = status;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\r}\r  DeliveryStatus.java\n package jpabasic.jpashop.domain;\rpublic enum DeliveryStatus {\rORDER, CANCEL\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic abstract class Item extends BaseEntity{\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member extends BaseEntity{\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rpublic void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic List\u0026lt;Order\u0026gt; getOrders() {\rreturn orders;\r}\rpublic void setOrders(List\u0026lt;Order\u0026gt; orders) {\rthis.orders = orders;\r}\r}\r  Movie.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;)\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\rpublic String getDirector() {\rreturn director;\r}\rpublic void setDirector(String director) {\rthis.director = director;\r}\rpublic String getActor() {\rreturn actor;\r}\rpublic void setActor(String actor) {\rthis.actor = actor;\r}\r}\r  Order.java - fetch = FetchType.LAZY 적용\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order extends BaseEntity{\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne(fetch = FetchType.LAZY) // **\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\r@OneToOne(fetch = FetchType.LAZY) // **\r@JoinColumn(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Delivery delivery;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\rpublic void addOrderItem(OrderItem orderItem) {\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r}\r  OrderItem.java - fetch = FetchType.LAZY 적용\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem extends BaseEntity{\rpublic OrderItem(){\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne(fetch = FetchType.LAZY) // **\rprivate Order order;\r@ManyToOne(fetch = FetchType.LAZY) // **\rprivate Item item;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\rpublic Item getItem() {\rreturn item;\r}\rpublic void setItem(Item item) {\rthis.item = item;\r}\r}\r  OrderStatus.java\n package jpabasic.jpashop.domain;\rpublic enum OrderStatus {\rORDER, CANCEL\r}\r  JpaMain.java - 애플리케이션 재시작\n package jpabasic.jpashop;\rimport jpabasic.jpashop.domain.*;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpashop\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rBook book = new Book();\rbook.setName(\u0026quot;JPA\u0026quot;);\rbook.setAuthor(\u0026quot;김영한\u0026quot;);\rem.persist(book);\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r 영속성 전이 설정   주문(Order)을 생성할 당시 배송정보(Delivery), 그리고 주문상품(OrderItem)을 같이 생성한다는 뜻\n   Order -\u0026gt; Delivery를 영속성 전이 ALL 설정 Order -\u0026gt; OrderItem을 영속성 전이 ALL 설정   package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order extends BaseEntity{\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne(fetch = FetchType.LAZY)\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;, cascade = CascadeType.ALL) // **\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\r@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL) // **\r@JoinColumn(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Delivery delivery;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\rpublic void addOrderItem(OrderItem orderItem) {\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r} public void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r}\r  설계시 Delivery의 라이프 사이클을 따로 관리 해야하는 것도 고민을 해볼 필요가 있습니다. 복잡성이나, 비즈니스 상황에 따라 Cascade를 적용할지 뺄지 정해야 합니다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"연관관계 관리","id":47,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 실전 예제 5 - 연관관계 관리","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-5/"},{"content":"영속성 전이(CASCADE)와 고아 객체  목록    영속성 전이 고아 객체   영속성 전이  앞에서 나온 즉시 로딩, 지연 로딩, 연관관계 세팅 이 세가지와 완전 별개의 개념\n   특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때 예 : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.   영속성 전이: 저장  @OneToMany(mappedBy=\u0026quot;parent\u0026quot;, cascade=CasecadeType.PERSIST)\r  Parent.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Parent {\rpublic Parent() {\r}\r@Id\r@GeneratedValue\r@Column(name = \u0026quot;parent_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Child\u0026gt; childList = new ArrayList\u0026lt;\u0026gt;();\rpublic void addChild(Child child){\rchildList.add(child);\rchild.setParent(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\r}\r  Child.java\n \rpackage relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Child {\rpublic Child() {\r}\r@Id\r@GeneratedValue\rprivate Long id;\rprivate String name;\r@ManyToOne\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Parent parent;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic Parent getParent() {\rreturn parent;\r}\rpublic void setParent(Parent parent) {\rthis.parent = parent;\r}\r}\r   JpaMain.java - 자식 2개와 부모 객체 1개 생성   \rpackage relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rChild child1 = new Child();\rChild child2 = new Child();\rParent parent = new Parent();\rparent.addChild(child1);\rparent.addChild(child2);\rem.persist(parent);\rem.persist(child1);\rem.persist(child2);\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\rprivate static void printMember(Member member){\rSystem.out.println(\u0026quot;username = \u0026quot;+member.getUsername());\r}\rprivate static void printMemberAndTeam(Member member){\rString username = member.getUsername();\rSystem.out.println(\u0026quot;username = \u0026quot;+username);\rTeam team = member.getTeam();\rSystem.out.println(\u0026quot;team = \u0026quot;+team.getName());\r}\r}\r  console\n Hibernate: /* insert relativemapping.Parent\r*/ insert into\rParent\r(name, parent_id) values\r(?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\r  간략하게 부모 엔티티 1개와 자식 엔티티 2개를 한번에 저장하기 위한 예제를 작성했고 저장을 위해서 em.persist()가 각각 3번 사용된 것을 확인할 수 있다. 현재 개발은 Parent 중심으로 개발하고 싶은데, 부모를 저장할때 자식까지 같이 관리해 주었으면 좋겠다. 라고 할때 만약 부모 이외에 em.persist() 를 지우면\n   JpaMain.java - 자식 2개와 부모 객체 1개 생성   \rpackage relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rChild child1 = new Child();\rChild child2 = new Child();\rParent parent = new Parent();\rparent.addChild(child1);\rparent.addChild(child2);\rem.persist(parent);\r//em.persist(child1); // ** 제거\r//em.persist(child2); // ** 제거\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\rprivate static void printMember(Member member){\rSystem.out.println(\u0026quot;username = \u0026quot;+member.getUsername());\r}\rprivate static void printMemberAndTeam(Member member){\rString username = member.getUsername();\rSystem.out.println(\u0026quot;username = \u0026quot;+username);\rTeam team = member.getTeam();\rSystem.out.println(\u0026quot;team = \u0026quot;+team.getName());\r}\r}\r  console\n Hibernate: call next value for hibernate_sequence\rHibernate: /* insert relativemapping.Parent\r*/ insert into\rParent\r(name, parent_id) values\r(?, ?)\r  부모의 엔티티만 저장한 것을 확인할 수 있습니다.\n  Parent.java - @OneToMany(mappedBy = \u0026ldquo;parent\u0026rdquo;, cascade = CascadeType.ALL)\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Parent {\rpublic Parent() {\r}\r@Id\r@GeneratedValue\r@Column(name = \u0026quot;parent_id\u0026quot;)\rprivate Long id;\rprivate String name;\r//@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;, cascade = CascadeType.ALL) // **\rprivate List\u0026lt;Child\u0026gt; childList = new ArrayList\u0026lt;\u0026gt;();\rpublic void addChild(Child child){\rchildList.add(child);\rchild.setParent(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\r}\r  JpaMain.java - 애플리케이션 재시작\n  console\n Hibernate: /* insert relativemapping.Parent\r*/ insert into\rParent\r(name, parent_id) values\r(?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\r  Parent를 포함한 Child 객체 2개 모두 저장된것을 확인할 수 있습니다.  영속성 전이: CASCADE - 주의!    영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐 참조하는 곳이 하나일 때 사용해야함! 특정 엔티티가 독점 소유할 때 사용   영속성 전이: CascadeType    ALL PERSIST MERGE REMOVE REFRESH DETACH   CascadeType 종류    CascadeType 설명     CascadeType.ALL 부모 엔터티에서 자식 엔터티로 모든 작업을 전파   CascadeType.PERSIST 자식 엔티티까지 영속성 전달, 부모 엔티티를 저장하면 자식 엔티티도 저장   CascadeType.MERGE 자식 엔티티까지 병합 작업을 지속, 부모 엔티티와 자식 엔티티를 조회 후 업데으트   CascadeType.REMOVE 자식 엔티티까지 제거 작업을 지속, 연결된 자식 엔티티까지 엔티티 제거   CascadeType.REFRESH 데이터베이스로부터 인스턴스 값을 다시 읽어 오기(새로고침), 연결된 하위 엔티티까지 인스턴스 값 다시 읽어옴   CascadeType.DETACH 영속성 컨텍스트에서 엔티티 제거, 연결된 하위 엔티티까지 영속성 제거    고아 객체  고아 객체 제거   부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제\n   orphanRemoval = true Parent parent1 = em.find(Parent.class, id); parent1.getChildList().remove(0); // 자식 엔티티를 컬렉션에서 제거     DELETE FROM CHILD WHERE ID = ?    Parent.java - @OneToMany(mappedBy = \u0026ldquo;parent\u0026rdquo;, cascade = CascadeType.ALL, orphanRemoval = true)\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Parent {\rpublic Parent() {\r}\r@Id\r@GeneratedValue\r@Column(name = \u0026quot;parent_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;, cascade = CascadeType.ALL, orphanRemoval = true)\rprivate List\u0026lt;Child\u0026gt; childList = new ArrayList\u0026lt;\u0026gt;();\rpublic void addChild(Child child){\rchildList.add(child);\rchild.setParent(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Child\u0026gt; getChildList() {\rreturn childList;\r}\rpublic void setChildList(List\u0026lt;Child\u0026gt; childList) {\rthis.childList = childList;\r}\r}\r  JpaMain.java\n  Child child1 = new Child();\rChild child2 = new Child();\rParent parent = new Parent();\rparent.addChild(child1);\rparent.addChild(child2);\rem.persist(parent);\rem.flush();\rem.clear();\rParent findParent = em.find(Parent.class, parent.getId());\rfindParent.getChildList().remove(0);\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Parent\r*/ insert into\rParent\r(name, parent_id) values\r(?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\rHibernate: select\rparent0_.parent_id as parent_i1_7_0_,\rparent0_.name as name2_7_0_ from\rParent parent0_ where\rparent0_.parent_id=?\rHibernate: select\rchildlist0_.parent_id as parent_i3_2_0_,\rchildlist0_.id as id1_2_0_,\rchildlist0_.id as id1_2_1_,\rchildlist0_.name as name2_2_1_,\rchildlist0_.parent_id as parent_i3_2_1_ from\rChild childlist0_ where\rchildlist0_.parent_id=?\rHibernate: /* delete relativemapping.Child */ delete from\rChild where\rid=?\r  orphanRemoval = true를 해두면, 영속성 컨텍스트의 객체 컬렉션에서 제거된 객체는 자동적으로 Delete 문으로 제거되는 것을 볼 수 있습니다.\n 고아 객체 - 주의    참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능 참조하는 곳이 하나일 때 사용해야함! 특정 엔티티가 독점 소유할 때 사용 @OneToOne, @OneToMany만 사용가능     참고 : 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제가할 때 자식도 함께 제거된다. 이것은 CasecadeType.REMOVE처럼 동작한다.    Parent.java - cascade = CascadeType.ALL 제거 @OneToMany(mappedBy = \u0026ldquo;parent\u0026rdquo;, orphanRemoval = true)\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Parent {\rpublic Parent() {\r}\r@Id\r@GeneratedValue\r@Column(name = \u0026quot;parent_id\u0026quot;)\rprivate Long id;\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;, orphanRemoval = true)\rprivate List\u0026lt;Child\u0026gt; childList = new ArrayList\u0026lt;\u0026gt;();\rpublic void addChild(Child child){\rchildList.add(child);\rchild.setParent(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic List\u0026lt;Child\u0026gt; getChildList() {\rreturn childList;\r}\rpublic void setChildList(List\u0026lt;Child\u0026gt; childList) {\rthis.childList = childList;\r}\r}\r  JpaMain.java casecadeType가 지워졌기 때문에 child1,2 em.persist()로 저장, em.remove(findParent); 를 통하여 부모 삭제\n \rChild child1 = new Child();\rChild child2 = new Child();\rParent parent = new Parent();\rparent.addChild(child1);\rparent.addChild(child2);\rem.persist(parent);\rem.persist(child1); // **\rem.persist(child2); // **\rem.flush();\rem.clear();\rParent findParent = em.find(Parent.class, parent.getId());\rem.remove(findParent); // ** tx.commit();\r  console\n Hibernate: /* insert relativemapping.Parent\r*/ insert into\rParent\r(name, parent_id) values\r(?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\rHibernate: /* insert relativemapping.Child\r*/ insert into\rChild\r(name, parent_id, id) values\r(?, ?, ?)\rHibernate: select\rparent0_.parent_id as parent_i1_7_0_,\rparent0_.name as name2_7_0_ from\rParent parent0_ where\rparent0_.parent_id=?\rHibernate: select\rchildlist0_.parent_id as parent_i3_2_0_,\rchildlist0_.id as id1_2_0_,\rchildlist0_.id as id1_2_1_,\rchildlist0_.name as name2_2_1_,\rchildlist0_.parent_id as parent_i3_2_1_ from\rChild childlist0_ where\rchildlist0_.parent_id=?\rHibernate: /* delete relativemapping.Child */ delete from\rChild where\rid=?\rHibernate: /* delete relativemapping.Child */ delete from\rChild where\rid=?\rHibernate: /* delete relativemapping.Parent */ delete from\rParent where\rparent_id=?\r  부모를 지웠기 때문에 부모를 잃은 고아 객체들도 자동으로 삭제가 된 것을 확인할 수 있습니다.\n 영속성 전이 + 고아 객체, 생명주기    CascadeType.ALL + orphanRemoval=true 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음  부모가 생성주기를 관리하기 때문에 DAO나 Repository를 생성안해도됨   도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용   참고   자바 ORM 표준 JPA - 김영한     https://www.baeldung.com/cascade-types   ","description":"JPA 영속성 전이(CASCADE)와 고아 객체","id":48,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 영속성 전이(CASCADE)와 고아 객체","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/cascade/"},{"content":"프록시와 연관관계 관리  즉시 로딩과 지연로딩  지연 로딩  Member를 조회할때 Team도 함께 조회해야 할까?  단순히 Member 정보만 사용하는 비지니스 로직 println(member.getName()); 연관관계가 등록되어 있어도 지금처럼 member만 사용하면 손해일 수 있습니다.\n ![contact](/images/develop/backend/orm-jpa-basic/eager-loading-and-lazy-loading/im g-001.png)\n지연 로딩 LAZY을 사용해서 프록시로 조회 \t@Entity\rpublic class Member {\r@Id @generatedValue\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String name;\r@ManyToOne(fetch = FetchType.LAZY)\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\r}\r  Member.java\n @Entity\rpublic class Member extends BaseEntity{\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne(fetch = FetchType.LAZY) //Team 객체를 프록시 객체로 조회\r@JoinColumn\rprivate Team team;\r...\r}\r  JpaMain.java - 애플리케이션 재시작\n package relativemapping;\rimport org.hibernate.Hibernate;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberA\u0026quot;);\rmember2.setCreateBy(\u0026quot;kim\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(team);\rem.persist(member2);\rem.flush();\rem.clear();\rMember m1 = em.find(Member.class, member1.getId());\rSystem.out.println(\u0026quot;m1 = \u0026quot; + m1.getClass());\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\rprivate static void printMember(Member member){\rSystem.out.println(\u0026quot;username = \u0026quot;+member.getUsername());\r}\rprivate static void printMemberAndTeam(Member member){\rString username = member.getUsername();\rSystem.out.println(\u0026quot;username = \u0026quot;+username);\rTeam team = member.getTeam();\rSystem.out.println(\u0026quot;team = \u0026quot;+team.getName());\r}\r}\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_ from\rMember member0_ where\rmember0_.MEMBER_ID=?\rm1 = class relativemapping.Member\r  Member 엔티티 조회시 Member만 조회 된 것을 확인\n  JpaMain.java - m1.getTeam().getClass()로 team을 조회 후 Lazy로 가져온 객체 클래스 테스트\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rMember m1 = em.find(Member.class, member1.getId());\rSystem.out.println(\u0026quot;m1 = \u0026quot; + m1.getClass());\rSystem.out.println(\u0026quot;m1.getTeam().getClass() = \u0026quot; + m1.getTeam().getClass());\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, team_TEAM_ID, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?, ?)\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.team_TEAM_ID as team_tea7_3_0_,\rmember0_.USERNAME as username6_3_0_ from\rMember member0_ where\rmember0_.MEMBER_ID=?\rm1 = class relativemapping.Member\rHibernate: select\rteam0_.TEAM_ID as team_id1_7_0_,\rteam0_.MOD_ID as mod_id2_7_0_,\rteam0_.MOD_DT as mod_dt3_7_0_,\rteam0_.REG_ID as reg_id4_7_0_,\rteam0_.REG_DT as reg_dt5_7_0_,\rteam0_.NAME as name6_7_0_ from\rTeam team0_ where\rteam0_.TEAM_ID=?\rm1.getTeam().getClass() = class relativemapping.Team$HibernateProxy$2xzHCXZv\rProcess finished with exit code 0\r 지연 로딩 지연 로딩 LAZY를 사용해서 프록시로 조회 Member와 Team을 자주 함께 사용한다면 ?  Member와 Team을 자주 함께 사용하는 경우 Lazy 로딩을 하게되면 Member한번 Team 한번 쿼리를 각각 계속 호출하기 때문에 비효율적일 수 있습니다. 상황에 맞게 적절히 적용하는게 중요합니다.\n 즉시 로딩 EAGER를 사용해서 함께조회  Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member extends BaseEntity{\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne(fetch = FetchType.EAGER) //**\r@JoinColumn\rprivate Team team;\r...\r  JpaMain.java - 애플리케이션 재시작\n  console\n Hibernate: call next value for hibernate_sequence\rHibernate: call next value for hibernate_sequence\rHibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, team_TEAM_ID, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?, ?)\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.team_TEAM_ID as team_tea7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.team_TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rm1 = class relativemapping.Member\rm1.getTeam().getClass() = class relativemapping.Team\r  Team과 Member가 조인해서 한방 쿼리로 가져오기 때문에 프록시로 가져올 필요가 없기 때문에 일반 엔티티 객체로 가져오게 됩니다.\n 즉시 로딩 즉시 로딩(EAGER), Member조회시 항상 Team도 조회  JPA 구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회\n 프록시와 즉시로딩 주의    가급적 지연 로딩만 사용(특히 실무에서) 즉시 로딩을 적용하면 예상치 못한 SQL이 발생 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. @ManyToOne은 기본이 즉시 로딩 -\u0026gt; LAZY로 설정 @OneToMany, @ManyToMany는 기본이 지연 로딩   즉시 로딩을 적용하면 예상치 못한 SQL이 발생  Member.java\n \t@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne(fetch = FetchType.EAGER) //**\r@JoinColumn\rprivate Team team;\r  JpaMain - Jpql 예제, console\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rem.flush();\rem.clear();\rList\u0026lt;Member\u0026gt; result = em.createQuery( \u0026quot;select m from Member m\u0026quot;, Member.class) //JPQL이란 SQL 그대로 번역하여 Member만 조회, EAGER로 되어있어 Team도 따로 가져와 영속성 컨텍스트 1차 캐시 로딩\r.getResultList();\r// SQL : select * from Member\r// Member.java 의 Team Fetch 타입이 EAGER이기 때문에 Member 객체는 모든 값이 있어야함.\r\u0026gt; SQL : select * from Team where TEAM_ID = m.id\rtx.commit();\r------------------\rHibernate: /* select\rm from\rMember m */ select\rmember0_.MEMBER_ID as member_i1_3_,\rmember0_.MOD_ID as mod_id2_3_,\rmember0_.MOD_DT as mod_dt3_3_,\rmember0_.REG_ID as reg_id4_3_,\rmember0_.REG_DT as reg_dt5_3_,\rmember0_.team_TEAM_ID as team_tea7_3_,\rmember0_.USERNAME as username6_3_ from\rMember member0_\rHibernate: select\rteam0_.TEAM_ID as team_id1_7_0_,\rteam0_.MOD_ID as mod_id2_7_0_,\rteam0_.MOD_DT as mod_dt3_7_0_,\rteam0_.REG_ID as reg_id4_7_0_,\rteam0_.REG_DT as reg_dt5_7_0_,\rteam0_.NAME as name6_7_0_ from\rTeam team0_ where\rteam0_.TEAM_ID=?\r 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.  Member.java - FetchType EAGER\n \t...\r@ManyToOne(fetch = FetchType.EAGER)\r@JoinColumn\rprivate Team team;\r...\r  JpaMain.java - 2개의 팀과 각각 팀의 Member 생성\n  Team teamA = new Team();\rteamA.setName(\u0026quot;TeamA\u0026quot;);\rteamA.setCreateBy(\u0026quot;kim\u0026quot;);\rteamA.setCreateDate(LocalDateTime.now());\rem.persist(teamA);\rTeam teamB = new Team();\rteamB.setName(\u0026quot;TeamB\u0026quot;);\rteamB.setCreateBy(\u0026quot;Park\u0026quot;);\rteamB.setCreateDate(LocalDateTime.now());\rem.persist(teamB);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(teamA);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberB\u0026quot;);\rmember2.setCreateBy(\u0026quot;Park\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(teamB);\rem.persist(member2);\r  console\n Hibernate: /* select\rm from\rMember m */ select\rmember0_.MEMBER_ID as member_i1_3_,\rmember0_.MOD_ID as mod_id2_3_,\rmember0_.MOD_DT as mod_dt3_3_,\rmember0_.REG_ID as reg_id4_3_,\rmember0_.REG_DT as reg_dt5_3_,\rmember0_.team_TEAM_ID as team_tea7_3_,\rmember0_.USERNAME as username6_3_ from\rMember member0_\rHibernate: select\rteam0_.TEAM_ID as team_id1_7_0_,\rteam0_.MOD_ID as mod_id2_7_0_,\rteam0_.MOD_DT as mod_dt3_7_0_,\rteam0_.REG_ID as reg_id4_7_0_,\rteam0_.REG_DT as reg_dt5_7_0_,\rteam0_.NAME as name6_7_0_ from\rTeam team0_ where\rteam0_.TEAM_ID=?\rHibernate: select\rteam0_.TEAM_ID as team_id1_7_0_,\rteam0_.MOD_ID as mod_id2_7_0_,\rteam0_.MOD_DT as mod_dt3_7_0_,\rteam0_.REG_ID as reg_id4_7_0_,\rteam0_.REG_DT as reg_dt5_7_0_,\rteam0_.NAME as name6_7_0_ from\rTeam team0_ where\rteam0_.TEAM_ID=?\r  N+1 문제란 Member 1과 Team이 10 개면 10개의 쿼리가 발생, 100개의 Team이면 100개의 쿼리가 각각 실행 실행한 1개의 쿼리 때문에 N개의 쿼리가 나가게 된다고 하여 N+1 문제라고 합니다.\n  Member.java - FetchType LAZY\n \t...\r@ManyToOne(fetch = FetchType.LAZY)\r@JoinColumn\rprivate Team team;\r...\r  console - Member만 조회하는 쿼리 1개 나옴\n Hibernate: /* select\rm from\rMember m */ select\rmember0_.MEMBER_ID as member_i1_3_,\rmember0_.MOD_ID as mod_id2_3_,\rmember0_.MOD_DT as mod_dt3_3_,\rmember0_.REG_ID as reg_id4_3_,\rmember0_.REG_DT as reg_dt5_3_,\rmember0_.team_TEAM_ID as team_tea7_3_,\rmember0_.USERNAME as username6_3_ from\rMember member0_\r2월 03, 2022 11:22:39 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PoolState stop\rINFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]\rProcess finished with exit code 0\r  Team을 사용하지 않기 때문에 Proxy로 Member만 조회합니다. 물론 Team을 루프로 돌리게 되면 각 각 Team을 모두 조회하게 됩니다.   N+1의 대안은 첫번째는 모두 LAZY로 세팅, 뒤에 JPQL에서 배우게 될 Fetch 조인이라는게 있습니다.\n  Member만 사용할때는 지금과 같이 사용하다가 Team과 같이 사용할땐 Fetch 조인을 하여 한방쿼리로 가져와서 사용합니다.\n  JpaMain.java - fetch 조인\n \t...\rList\u0026lt;Member\u0026gt; result = em.createQuery( \u0026quot;select m from Member m join fetch m.team\u0026quot;, Member.class)\r.getResultList();\r...   console\n Hibernate: /* select\rm from\rMember m join\rfetch m.team */ select\rmember0_.MEMBER_ID as member_i1_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.team_TEAM_ID as team_tea7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ inner join\rTeam team1_ on member0_.team_TEAM_ID=team1_.TEAM_ID\r  또다른 방법은 EntityGraph 라는 어노테이션을 사용하는 방법과 Batch size 방식이 있습니다.\n @ManyToOne 은 기본이 즉시 로딩 EAGER  기본이 즉시 로딩이기 때문에 모두 @ManyToOne(fetch = FetchType.LAZY) 를 추가해줘야한다 !!!\n 지연 로딩 활용   이론적으로는\n   Member와 Team은 자주 함께 사용 -\u0026gt; 즉시 로딩 Member와 Order은 가끔 사용 -\u0026gt; 지연 로딩 Order와 Product는 자주 함께 사용 -\u0026gt; 즉시 로딩    실무에서는 지연로딩으로 무조건 다 세팅해두어야 합니다\u0026hellip;\n  em.find(Member.class, member1.getId()); 를 통해 조회시 team과는 Join한 한방 쿼리로 조회됩니다.\n  orders는 지연 로딩을 이용해서 프록시로 들어오게 됩니다.\n  orders를 사용하여 프록시를 초기화 하게되면\n 지연 로딩 - 실무    모든 연관관계에 지연 로딩을 사용해라! 실무에서 즉시 로딩을 사용하지 마라 JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라! 즉시 로딩은 상상하지도 못한 쿼리가 나간다.   참고- 자바 ORM 표준 JPA - 김영한 ","description":"즉시 로딩과 지연로딩","id":49,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 즉시 로딩과 지연로딩","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/eager-loading-and-lazy-loading/"},{"content":"프록시와 상속관계  목차    프록시 즉시 로딩과 지연 로딩 지연 로딩 활용 영속성 전이 : CASCADE 고아 객체 영속성 전이 + 고아객체, 생명주기   프록시  Member를 조회할때 Team도 함께 조회해야 할까?  JpaMain.java\n  private static void printMember(Member member){\rSystem.out.println(\u0026quot;username = \u0026quot;+member.getUsername());\r}\rprivate static void printMemberAndTeam(Member member){\rString username = member.getUsername();\rSystem.out.println(\u0026quot;username = \u0026quot;+username);\rTeam team = member.getTeam();\rSystem.out.println(\u0026quot;team = \u0026quot;+team.getName());\r}\r  Member객체를 출력하는 메서드와 Member객체와 Member가 가지는 Team 객체를 출력하는 메서드가 있을때, Member만 조회하는 쿼리를 수행할때 Team까지 Join을 통하여 조회 쿼리를 수행한다면 자원낭비이다.\nJPA는 지연로딩과 Proxy를 이용하여 이것을 해결합니다.\n 프록시 기초   em.find() vs em.getRefernce() em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 em.getRefernce() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회    Member.java - Team 이외의 다른 연관관계 제거\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member extends BaseEntity{\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn\rprivate Team team;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\r}\r  JpaMain.java\n package relativemapping;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rimport java.time.LocalDateTime;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relativemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\rmember.setCreateBy(\u0026quot;kim\u0026quot;);\rmember.setCreateDate(LocalDateTime.now());\rmember.setTeam(team);\rem.persist(member);\rem.flush();\rem.clear();\rMember findMember = em.find(Member.class, member.getId());\rtx.commit();\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\rprivate static void printMember(Member member){\rSystem.out.println(\u0026quot;username = \u0026quot;+member.getUsername());\r}\rprivate static void printMemberAndTeam(Member member){\rString username = member.getUsername();\rSystem.out.println(\u0026quot;username = \u0026quot;+username);\rTeam team = member.getTeam();\rSystem.out.println(\u0026quot;team = \u0026quot;+team.getName());\r}\r}\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rfindMember.id = 2\rfindMember.userName = MemberA\r  Member와 Team이 Join된 쿼리로 Select 되어 나오는 것을 확인 할 수 있다.\n  JpaMain.java - em.find() -\u0026gt; em.getReference(),\n//System.out.println(\u0026ldquo;findMember.id = \u0026ldquo;+findMember.getId()); // 주석처리 //System.out.println(\u0026ldquo;findMember.userName = \u0026ldquo;+findMember.getUsername()); // 주석처리\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\rmember.setCreateBy(\u0026quot;kim\u0026quot;);\rmember.setCreateDate(LocalDateTime.now());\rmember.setTeam(team);\rem.persist(member);\rem.flush();\rem.clear();\r//Member findMember = em.find(Member.class, member.getId());\rMember findMember = em.getReference(Member.class, member.getId());\r//System.out.println(\u0026quot;findMember.id = \u0026quot;+findMember.getId());\r//System.out.println(\u0026quot;findMember.userName = \u0026quot;+findMember.getUsername());\r//printMemberAndTeam(findMember);\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\r  Select Sql이 실행되지 않는것을 확인 할 수 있습니다.\n  JpaMain.java - em.find() -\u0026gt; em.getReference(),\nSystem.out.println(\u0026ldquo;findMember.id = \u0026ldquo;+findMember.getId()); // 주석해제 System.out.println(\u0026ldquo;findMember.userName = \u0026ldquo;+findMember.getUsername()); // 주석해제\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\rmember.setCreateBy(\u0026quot;kim\u0026quot;);\rmember.setCreateDate(LocalDateTime.now());\rmember.setTeam(team);\rem.persist(member);\rem.flush();\rem.clear();\r//Member findMember = em.find(Member.class, member.getId());\rMember findMember = em.getReference(Member.class, member.getId());\rSystem.out.println(\u0026quot;findMember.class = \u0026quot;+findMember.getClass()); // 클래스 확인\rSystem.out.println(\u0026quot;findMember.id = \u0026quot;+findMember.getId()); // 주석해제 System.out.println(\u0026quot;findMember.userName = \u0026quot;+findMember.getUsername()); // 주석해제 //printMemberAndTeam(findMember);\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rfindMember.class = class relativemapping.Member$HibernateProxy$kQ2LbNHi\rfindMember.id = 2\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rfindMember.userName = MemberA\rProcess finished with exit code 0\r  getReferance()를 수행하는 시점에는 Select 쿼리를 날리지 않음. 이 값이 실제 사용되는 시점에 Select 쿼리를 수행해 DB메서 데이터를 가져옴. findMember.class = class relativemapping.Member$HibernateProxy$kQ2LbNHi Member.java가 아니라 HibernateProxy 인것으로 확인됨 JPA에서 만든 가상의 프록시 Class\n 프록시 기초  em.getRefence() 를 수행하면 하이버네이트는 프록시라는 가짜 엔티티 객체를 넘겨줍니다. 껍데기는 똑같은데 텅텅 빈 객체로 넘겨줍니다. 그리고 target이라는 속성이 있는데 이게 진짜 레퍼런스 입니다.\n 프록시 특징   실제 클래스를 상속받아서 만들어짐 실제 클레스와 겉 모양이 같다. 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분 하지 않고 사용하면 됨(이론상)     프록시 객체는 실제 객체의 참조(target)를 보관 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출   프록시 객체의 초기화 Member member = em.getReference(Member.class, 1L);\rmember.getName();\r  JpaMain.java -\n Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\rmember.setCreateBy(\u0026quot;kim\u0026quot;);\rmember.setCreateDate(LocalDateTime.now());\rmember.setTeam(team);\rem.persist(member);\rem.flush();\rem.clear();\r//Member findMember = em.find(Member.class, member.getId());\rMember findMember = em.getReference(Member.class, member.getId());\rSystem.out.println(\u0026quot;findMember.class = \u0026quot;+findMember.getClass()); System.out.println(\u0026quot;findMember.id = \u0026quot;+findMember.getId()); System.out.println(\u0026quot;findMember.userName = \u0026quot;+findMember.getUsername()); // getUsername() 호출\rSystem.out.println(\u0026quot;findMember.userName = \u0026quot;+findMember.getUsername()); // getUsername() 호출 2\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rfindMember.class = class relativemapping.Member$HibernateProxy$kQ2LbNHi\rfindMember.id = 2\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rfindMember.userName = MemberA\rfindMember.userName = MemberA\rProcess finished with exit code 0\r  프록시 생성후 findMember.userName()를 위해 select SQL을 호출하지만, 2번째 findMember.userName() 호출할땐 target에 값이 있고 이미 초기화가 되어 있는 프록시 이기 때문에 조회없이 값을 출력하게 됩니다.\n 프록시의 특징   프록시 객체는 처음 사용할 때 한 번만 초기화 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능   프록시 객체가 실제 엔티티로 바뀌는 것은 아님  JpaMain.java - findMember.getUsername() 전후로 findMember.getClass() 객체 타입 확인\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\rmember.setCreateBy(\u0026quot;kim\u0026quot;);\rmember.setCreateDate(LocalDateTime.now());\rmember.setTeam(team);\rem.persist(member);\rem.flush();\rem.clear();\r//Member findMember = em.find(Member.class, member.getId());\rMember findMember = em.getReference(Member.class, member.getId());\rSystem.out.println(\u0026quot;findMember.class before = \u0026quot;+findMember.getClass());\rSystem.out.println(\u0026quot;findMember.userName = \u0026quot;+findMember.getUsername());\rSystem.out.println(\u0026quot;findMember.class after = \u0026quot;+findMember.getClass());\r//printMemberAndTeam(findMember);\rtx.commit();\r  console\n Hibernate: call next value for hibernate_sequence\rHibernate: call next value for hibernate_sequence\rHibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rfindMember.class before = class relativemapping.Member$HibernateProxy$uziW0Tt8\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rfindMember.userName = MemberA\rfindMember.class after = class relativemapping.Member$HibernateProxy$uziW0Tt8\rProcess finished with exit code 0\r   프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (==비교 실패, 대신 instance of 사용)     영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환 (반대로 em.getReference()로 조회 후 엔티티를 조회하면 프록시 객체로 반환) 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화 하면 문제 발생 (하이버네이트는 org.hivernate.LazyInitializationException 예외룰 터트림)   엔티티 객체 == 비교  JpaMain.java - em.find(), em.find() 타입비교\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberA\u0026quot;);\rmember2.setCreateBy(\u0026quot;kim\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(team);\rem.persist(member2);\rem.flush();\rem.clear();\rMember m1 = em.find(Member.class, member1.getId());\rMember m2 = em.find(Member.class, member2.getId());\rSystem.out.println(\u0026quot;m1 == m2 \u0026quot; + (m1.getClass() == m2.getClass())); // m1 == m2true\r 엔티티 객체, 프록시 객체 == 비교  JpaMain.java - em.find(), em.getReference() 타입비교\n \tMember m1 = em.find(Member.class, member1.getId());\rMember m2 = em.getReference(Member.class, member2.getId());\rSystem.out.println(\u0026quot;m1 == m2 \u0026quot; + (m1.getClass() == m2.getClass()));\r// m1 == m2 false\r  비교한 em.find로 가져온 엔티티 객체와 getReference를 통해 만든 프록시 객체는 == 비교를 하면 false로 나옵니다. 지금이야 같은 JpaMain에서 보면 쉽겠지만 아래와 같은 메소드를 사용한다면 함수 내부에서 어떤 객체가 넘어오는지 알기 힘듭니다.\n  JpaMain.java - 메소드를 생성하고 내부에서 객체 == 비교\n \t...\rlogic(m1,m2);\r...\rprivate static void logic(Member m1, Member m2) {\rSystem.out.println(\u0026quot;m1 == m2 \u0026quot; + (m1.getClass() == m2.getClass())); }\r 프록시 객체 instanceof 체크  JpaMain.java - 메소드를 생성하고 내부에서 객체 instanceof로 체크\n  ...\rlogic(m1,m2);\r...\rprivate static void logic(Member m1, Member m2) {\rSystem.out.println(\u0026quot;m1 instanceof Member \u0026quot; + (m1 instanceof Member));\rSystem.out.println(\u0026quot;m2 instanceof Member \u0026quot; + (m2 instanceof Member));\r}\r 영속성 컨텍스트(1차 캐시)에 찾는 엔티티가 있으면 em.getReference()를 호출해도 실제 엔티티 반환  JpaMain.java - 영속성 컨텍스트에 엔티티 추가 후 em.getReference()\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberA\u0026quot;);\rmember2.setCreateBy(\u0026quot;kim\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(team);\rem.persist(member2);\rem.flush();\rem.clear();\rMember r1 = em.getReference(Member.class, member1.getId());\rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\rMember r2 = em.getReference(Member.class,member1.getId());\rSystem.out.println(\u0026quot;r2 = \u0026quot; + r2.getClass());\rSystem.out.println(\u0026quot;r1 == r2 \u0026quot; + (r1 == r2));\rtx.commit();\r  console\n  select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rm1 = class relativemapping.Member\rr1 = class relativemapping.Member\rm1 == r1 true\r  m1과 r1 모두 Member 엔티티 객체 클래스로 나오는 것을 확인할 수 있습니다. 두가지 이유가 있는데 하나는 영속성 컨텍스트에 이미 있는데 프록시로 가져 와봐야 이점이 없는데 프록시로 가져올 필요가 없습니다. 원본인 엔티티 객체를 반환하는게 더 성능 최적화에 도움이 됩니다.\n  또한 JPA에서는 영속성 컨텍스트 안에서 같은 Member를 엔티티에서 조회하거나, 레퍼런스로 조회해 와도 컬렉션에서 == 비교한 것처럼 같은 값으로 인식해 줍니다.\n  JPA는 한 트랜젝션 안에서 같은 객체에 대한 보장을 해줍니다.\n  r1 과 r2 둘다 레퍼런스면 두개의 프록시 객체는 동일하고, == 비교시 true 를 반환 합니다.\n  Member r1 = em.getReference(Member.class, member1.getId());\rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\rMember r2 = em.getReference(Member.class,member1.getId());\rSystem.out.println(\u0026quot;r2 = \u0026quot; + r2.getClass());\rSystem.out.println(\u0026quot;r1 == r2 \u0026quot; + (r1 == r2));\r  console\n \tr1 = class relativemapping.Member$HibernateProxy$3dvhAszH\rr2 = class relativemapping.Member$HibernateProxy$3dvhAszH\rr1 == r2 true\r  JpaMain.java - 레퍼런스로 조회 후 일반 엔티티 조회 시\n \tMember r1 = em.getReference(Member.class, member1.getId());\rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\rMember m1 = em.find(Member.class,member1.getId());\rSystem.out.println(\u0026quot;m1 = \u0026quot; + m1.getClass());\rSystem.out.println(\u0026quot;r1 == m1 \u0026quot; + (r1 == m1));\r  console\n r1 = class relativemapping.Member$HibernateProxy$vH2td1yz\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\rm1 = class relativemapping.Member$HibernateProxy$vH2td1yz\rr1 == m1 true\r  em.getReference() 이후 em.find()또한 proxy로 조회된것을 확인할 수 있습니다. 이는 같은 컨텍스트 안에서 같은 객체로 반환해 주는 JPA의 특징입니다.\n 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생  JpaaAin.java - 영속성 컨텍스트에서 제거된 경우 getReference() 후 getUsername()을 통해 초기화\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberA\u0026quot;);\rmember2.setCreateBy(\u0026quot;kim\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(team);\rem.persist(member2);\rem.flush();\rem.clear();\rMember r1 = em.getReference(Member.class, member1.getId());\rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\rem.detach(r1); // 영속성 컨텍스트에서 r1을 제거\r// em.clear();\rr1.getUsername(); //컨텍스트에서 제거된 경우\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rr1 = class relativemapping.Member$HibernateProxy$Sq3ipbiV\rorg.hibernate.LazyInitializationException: could not initialize proxy [relativemapping.Member#2] - no Session //영속성 컨텍스트 없다는 이야기\rat org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:170)\rat org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:310)\rat org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:45)\rat org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95)\rat relativemapping.Member$HibernateProxy$Sq3ipbiV.getUsername(Unknown Source)\rat relativemapping.JpaMain.main(JpaMain.java:52)\r  JpaaAin.java - 영속성 컨텍스트가 종료된경우 getReference() 후 getUsername()을 통해 초기화\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberA\u0026quot;);\rmember2.setCreateBy(\u0026quot;kim\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(team);\rem.persist(member2);\rem.flush();\rem.clear();\rMember r1 = em.getReference(Member.class, member1.getId());\rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\rem.close(); // 컨텍스트 종료\rr1.getUsername(); //컨텍스트 종료된 이후 프록시 객체 초기화\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Team\r*/ insert into\rTeam\r(MOD_ID, MOD_DT, REG_ID, REG_DT, NAME, TEAM_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rr1 = class relativemapping.Member$HibernateProxy$t0KzgTxZ\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\r1월 26, 2022 10:57:16 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PoolState stop\rINFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]\rProcess finished with exit code 0\r  강의에 의하면 LazyInitializationException( \u0026ldquo;could not initialize proxy - the owning Session was closed\u0026rdquo; ) exception이 나와야 하지만,   5.4.0.Final 버전까지는 예외가 발생하는데 5.4.1.Final 버전부터 예외가 발생하지 않습니다.   트랜잭션을 종료하지 않은 상태에서 세션(엔티티메니져)을 닫았기 때문에 아직 트랜잭션이 살아있습니다.\n 프록시 확인   프록시 인스턴스 초기화 여부 확인 PersistenceUnitUtil.isLoaded(Object entity)     프록시 클래스 확인 방법 entity.getClass().getName() 출력 (\u0026hellip;javasist\u0026hellip;or HibernateProxy..)     프록시 강제 초기화 org.hibernate.initialize(entity);    참고 :JPA 표준은 강제 초기화 없음 강제 호출 : member.getName()\n 프록시 인스턴스 초기화 여부 확인  JpaMain.java - emf.getPersistenceUnitUtil().isLoaded() 사용\n \rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.setCreateBy(\u0026quot;kim\u0026quot;);\rteam.setCreateDate(LocalDateTime.now());\rem.persist(team);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;MemberA\u0026quot;);\rmember1.setCreateBy(\u0026quot;kim\u0026quot;);\rmember1.setCreateDate(LocalDateTime.now());\rmember1.setTeam(team);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setUsername(\u0026quot;MemberA\u0026quot;);\rmember2.setCreateBy(\u0026quot;kim\u0026quot;);\rmember2.setCreateDate(LocalDateTime.now());\rmember2.setTeam(team);\rem.persist(member2);\rem.flush();\rem.clear();\rMember r1 = em.getReference(Member.class, member1.getId());\rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\r//엔티티 매니저 팩토리에서 PersistenceUnitUtil를 받아와 사용\rSystem.out.println(\u0026quot;isLoaded = \u0026quot;+ emf.getPersistenceUnitUtil().isLoaded(r1) );\rr1.getUsername();\rSystem.out.println(\u0026quot;isLoaded = \u0026quot;+ emf.getPersistenceUnitUtil().isLoaded(r1) );\rtx.commit();\r  console\n \rHibernate: /* insert relativemapping.Member\r*/ insert into\rMember\r(MOD_ID, MOD_DT, REG_ID, REG_DT, USERNAME, MEMBER_ID) values\r(?, ?, ?, ?, ?, ?)\rr1 = class relativemapping.Member$HibernateProxy$qay0PhKw //프록시 생성\risLoaded = false // 프록시 초기화전 false\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\risLoaded = true // 프록시 초기화전 true\r 프록시 확인 방법  JpaMain.java\n \rSystem.out.println(\u0026quot;r1 = \u0026quot; + r1.getClass());\r console\n\rr1 = class relativemapping.Member$HibernateProxy$qay0PhKw\r 프록시 강제 초기화  JpaMain.java\n \rr1.getUsername(); // 프록시 강제 초기화 (하이버네이트, 표준 JPA)\r//Hibernate.initialize(r1); //하이버네이트 only\rSystem.out.println(\u0026quot;isLoaded = \u0026quot;+ emf.getPersistenceUnitUtil().isLoaded(r1) );\r console\n\rHibernate: select\rmember0_.MEMBER_ID as member_i1_3_0_,\rmember0_.MOD_ID as mod_id2_3_0_,\rmember0_.MOD_DT as mod_dt3_3_0_,\rmember0_.REG_ID as reg_id4_3_0_,\rmember0_.REG_DT as reg_dt5_3_0_,\rmember0_.TEAM_ID as team_id7_3_0_,\rmember0_.USERNAME as username6_3_0_,\rteam1_.TEAM_ID as team_id1_7_1_,\rteam1_.MOD_ID as mod_id2_7_1_,\rteam1_.MOD_DT as mod_dt3_7_1_,\rteam1_.REG_ID as reg_id4_7_1_,\rteam1_.REG_DT as reg_dt5_7_1_,\rteam1_.NAME as name6_7_1_ from\rMember member0_ left outer join\rTeam team1_ on member0_.TEAM_ID=team1_.TEAM_ID where\rmember0_.MEMBER_ID=?\risLoaded = true\r 참고- 자바 ORM 표준 JPA - 김영한 ","description":"프록시와 연관간계","id":50,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 프록시와 연관관계","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/proxy-and-relation/"},{"content":"실전 예제 4 - 상속관계 매핑  요구사항 추가    상품의 종류는 음반, 도서, 영화가 있고 이후 더 확장될 수 있다. 모든 데이터는 등록일과 수정일이 필수다.   도메인 모델  도메인 모델 상세  테이블 설계 상속관계 매핑 추가  Item.java\n   Item.java를 abstract로 바꾼다. 단일 테이블 전략이기 때문에 Item.java에 @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 를 추가한다. @DiscriminatorColumn를 추가하여 DTYPE를 추가한다.   package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic abstract class Item {\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r  Album.java Item을 상속받는다.\n @DiscriminatorValue(\u0026ldquo;A\u0026rdquo;)를 추가하여, 구분값을 코드로 관리   package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;)\rpublic class Album extends Item{\rprivate String artist;\rprivate String etc;\rpublic String getArtist() {\rreturn artist;\r}\rpublic void setArtist(String artist) {\rthis.artist = artist;\r}\rpublic String getEtc() {\rreturn etc;\r}\rpublic void setEtc(String etc) {\rthis.etc = etc;\r}\r}\r  Movie.java Item을 상속받는다.\n @DiscriminatorValue(\u0026ldquo;A\u0026rdquo;)를 추가하여, 구분값을 코드로 관리   package jpabasic.jpashop.domain;\rimport javax.persistence.DiscriminatorValue;\rimport javax.persistence.Entity;\r@Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;)\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\rpublic String getDirector() {\rreturn director;\r}\rpublic void setDirector(String director) {\rthis.director = director;\r}\rpublic String getActor() {\rreturn actor;\r}\rpublic void setActor(String actor) {\rthis.actor = actor;\r}\r}\r  console\n Hibernate: create table Item (\rDTYPE varchar(31) not null,\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rauthor varchar(255),\risbn varchar(255),\rartist varchar(255),\retc varchar(255),\ractor varchar(255),\rdirector varchar(255),\rprimary key (ITEM_ID)\r)\r  JpaMain.java - Book 객체 추가\n  Book book = new Book();\rbook.setName(\u0026quot;JPA\u0026quot;);\rbook.setAuthor(\u0026quot;김영한\u0026quot;);\rem.persist(book);\rtx.commit();\r  console\n Hibernate: call next value for hibernate_sequence\rHibernate: /* insert jpabasic.jpashop.domain.Book\r*/ insert into\rItem\r(name, price, stockQuantity, author, isbn, DTYPE, ITEM_ID) values\r(?, ?, ?, ?, ?, 'B', ?)\r  Joined로 변경해서 다시 애플리케이션을 재시작 해보겠습니다.\n  Item.java - @Inheritance(strategy = InheritanceType.JOINED)\n \r@Entity\r@Inheritance(strategy = InheritanceType.JOINED)\r@DiscriminatorColumn\rpublic abstract class Item {\r  create table Item (\rDTYPE varchar(31) not null,\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rprimary key (ITEM_ID)\r)\rHibernate: create table Album (\rartist varchar(255),\retc varchar(255),\rITEM_ID bigint not null,\rprimary key (ITEM_ID)\r)\rHibernate: create table Book (\rauthor varchar(255),\risbn varchar(255),\rITEM_ID bigint not null,\rprimary key (ITEM_ID)\r)\rHibernate: create table Movie (\ractor varchar(255),\rdirector varchar(255),\rITEM_ID bigint not null,\rprimary key (ITEM_ID)\r)\rHibernate: /* insert jpabasic.jpashop.domain.Book\r*/ insert into\rItem\r(name, price, stockQuantity, DTYPE, ITEM_ID) values\r(?, ?, ?, 'B', ?)\rHibernate: /* insert jpabasic.jpashop.domain.Book\r*/ insert into\rBook\r(author, isbn, ITEM_ID) values\r(?, ?, ?)\r  ITEM과 BOOK 모두 ITEM_ID가 들어가며, DTYPE가 B로 들어간다.\n  TABLE_PER_CLASS로 변경해서 다시 애플리케이션을 재시작 해보겠습니다.\n  Item.java - @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n \r@Entity\r@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\r@DiscriminatorColumn\rpublic abstract class Item {\r Hibernate: create table Album (\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rartist varchar(255),\retc varchar(255),\rprimary key (ITEM_ID)\r)\rHibernate: create table Book (\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rauthor varchar(255),\risbn varchar(255),\rprimary key (ITEM_ID)\r)\rHibernate: create table Movie (\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\ractor varchar(255),\rdirector varchar(255),\rprimary key (ITEM_ID)\r)\rHibernate: call next value for hibernate_sequence\rHibernate: /* insert jpabasic.jpashop.domain.Book\r*/ insert into\rBook\r(name, price, stockQuantity, author, isbn, ITEM_ID) values\r(?, ?, ?, ?, ?, ?)\r  Item.java는 생성안되는것과 Item.java의 속성들이 Album.java, Book.java, Movie.java 들에 추가된 것을 확인할 수 있습니다.\n  InheritanceType.TABLE_PER_CLASS은 사용하면 안되는것을 다시 상기시키고, 소스는 설계와 같이 InheritanceType.SINGLE_TABLE 로 수정해둡니다.\n  Item.java - @Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n \r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic abstract class Item {\r @MappedSuperclass를 추가  BaseEntity를 추가하고 @MappedSuperclass를 추가해보겠습니다.\n  BaseEntity.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.Column;\rimport javax.persistence.MappedSuperclass;\rimport java.time.LocalDateTime;\r@MappedSuperclass\rpublic abstract class BaseEntity {\r@Column(name = \u0026quot;REG_ID\u0026quot;)\rprivate String createBy;\r@Column(name = \u0026quot;REG_DT\u0026quot;)\rprivate LocalDateTime createDate;\r@Column(name = \u0026quot;MOD_ID\u0026quot;)\rprivate String LastModifiedBy;\r@Column(name = \u0026quot;MOD_DT\u0026quot;)\rprivate LocalDateTime LastModifiedDate;\rpublic String getCreateBy() {\rreturn createBy;\r}\rpublic void setCreateBy(String createBy) {\rthis.createBy = createBy;\r}\rpublic LocalDateTime getCreateDate() {\rreturn createDate;\r}\rpublic void setCreateDate(LocalDateTime createDate) {\rthis.createDate = createDate;\r}\rpublic String getLastModifiedBy() {\rreturn LastModifiedBy;\r}\rpublic void setLastModifiedBy(String lastModifiedBy) {\rLastModifiedBy = lastModifiedBy;\r}\rpublic LocalDateTime getLastModifiedDate() {\rreturn LastModifiedDate;\r}\rpublic void setLastModifiedDate(LocalDateTime lastModifiedDate) {\rLastModifiedDate = lastModifiedDate;\r}\r}\r  모든 엔티티에 extends BaseEntity를 추가합니다.\n  Category.Java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Category extends BaseEntity{\r@Id @GeneratedValue\r@Column(name = \u0026quot;CATEGORY_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToOne\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent; // 상위 카테고리\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;(); // 자식 카테고리\r@ManyToMany\r@JoinTable(name = \u0026quot;CATEGORY_ITEM\u0026quot;,\rjoinColumns = @JoinColumn(name = \u0026quot;CATEGORY_ID\u0026quot;),\rinverseJoinColumns = @JoinColumn(name =\u0026quot;ITEM_ID\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r  Delivery.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Delivery extends BaseEntity{\r@Id @GeneratedValue\r@Column(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Long id;\rprivate String city;\rprivate String street;\rprivate String zipcode;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status;\r@OneToOne(mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic String getCity() {\rreturn city;\r}\rpublic void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic DeliveryStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(DeliveryStatus status) {\rthis.status = status;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic abstract class Item extends BaseEntity{\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member extends BaseEntity{\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rpublic void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic List\u0026lt;Order\u0026gt; getOrders() {\rreturn orders;\r}\rpublic void setOrders(List\u0026lt;Order\u0026gt; orders) {\rthis.orders = orders;\r}\r}\r  Order.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order extends BaseEntity{\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\r@OneToOne\r@JoinColumn(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Delivery delivery;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\rpublic void addOrderItem(OrderItem orderItem) {\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r}\r  OrderItem.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem extends BaseEntity{\rpublic OrderItem(){\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne\rprivate Order order;\r@ManyToOne\rprivate Item item;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\rpublic Item getItem() {\rreturn item;\r}\rpublic void setItem(Item item) {\rthis.item = item;\r}\r}\r  Album.java, Book.java, Movie.java는 Item을 상속받기 때문에 BaseEntity를 상속 받을 필요가 없습니다.\n  JpaMain.java 애플리케이션 재시작\n  console - 모든 테이블에 추가한 BaseEntity의 속성들 확인\n create table Category (\rCATEGORY_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rname varchar(255),\rparent_id bigint,\rprimary key (CATEGORY_ID)\r)\rHibernate: create table CATEGORY_ITEM (\rCATEGORY_ID bigint not null,\rITEM_ID bigint not null\r)\rHibernate: create table Delivery (\rDELIVERY_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rcity varchar(255),\rstatus varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rprimary key (DELIVERY_ID)\r)\rHibernate: create table Item (\rDTYPE varchar(31) not null,\rITEM_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rauthor varchar(255),\risbn varchar(255),\rartist varchar(255),\retc varchar(255),\ractor varchar(255),\rdirector varchar(255),\rprimary key (ITEM_ID)\r)\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rcicy varchar(255),\rname varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rprimary key (MEMBER_ID)\r)\rHibernate: create table OrderItem (\rOFDER_ITEM_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rcount integer not null,\rorderPrice integer not null,\ritem_ITEM_ID bigint,\rorder_ORDER_ID bigint,\rprimary key (OFDER_ITEM_ID)\r)\rHibernate: create table ORDERS (\rORDER_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rorderDate timestamp,\rstatus varchar(255),\rDELIVERY_ID bigint,\rmember_MEMBER_ID bigint,\rprimary key (ORDER_ID)\r)\rHibernate: call next value for hibernate_sequence\rHibernate: /* insert jpabasic.jpashop.domain.Book\r*/ insert into\rItem\r(MOD_ID, MOD_DT, REG_ID, REG_DT, name, price, stockQuantity, author, isbn, DTYPE, ITEM_ID) values\r(?, ?, ?, ?, ?, ?, ?, ?, ?, 'B', ?)\r  Book을 넣고 나머지 Null이 되어있는 데이터들은 추후 스프링데이터와 JPA를 이용해 Persist 전에 추가하는 추가하는 방법이 있다고 합니다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"상속관계 매핑","id":51,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 실전 예제 4 - 상속관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-4/"},{"content":"상속관계 매핑  목차    상속관계 매핑 @MappedSuperclass   MappedSuperclass  @MappedSuperclass  예를 들어 이전의 상속관계 매핑을 사용하지 않고 단순하게 객체의 입장에서 id와 name이 계속 나오게 되는데 매번 만들기 귀찮아서 부모 클래스에 두고 속성만 상속받아서 사용하고 싶을때 사용.   DB에서는 각각 테이블에 id, name을 포함하며 DB와 구조가 다르지만, 매번 추가 해야하는 속성을 엔티티마다 추가해야 하는 불편함을 줄여보자 해서 나오게 된 기능입니다.\n @MappedSuperclass 예제  DBA의 요청으로 엔티티 마다 생성한 사람의 ID, 생성한 시간, 마지막 수정한 사람 ID, 마지막 수정한 시간을 각각 추가하려 합니다.\n  private String createBy;\rprivate LocalDateTime createDate;\rprivate String LastModifiedBy;\rprivate LocalDateTime LastModifiedDate;\r  개발된 모든 Entity에 위의 소스를 모두 복사/붙여넣기를 하게 되는 개발자 입장에서는 중복소스 같기도 하고 반복작업을 하게되어 마음이 불편하게 느껴질 겁니다. 이런 경우에 @MapeedSuperclass 를 사용할 수 있습니다.\n  BaseEntity.java 추가\n package relativemapping;\rimport java.time.LocalDateTime;\r@MappedSuperclass\rpublic class BaseEntity {\rprivate String createBy;\rprivate LocalDateTime createDate;\rprivate String LastModifiedBy;\rprivate LocalDateTime LastModifiedDate;\rpublic String getCreateBy() {\rreturn createBy;\r}\rpublic void setCreateBy(String createBy) {\rthis.createBy = createBy;\r}\rpublic LocalDateTime getCreateDate() {\rreturn createDate;\r}\rpublic void setCreateDate(LocalDateTime createDate) {\rthis.createDate = createDate;\r}\rpublic String getLastModifiedBy() {\rreturn LastModifiedBy;\r}\rpublic void setLastModifiedBy(String lastModifiedBy) {\rLastModifiedBy = lastModifiedBy;\r}\rpublic LocalDateTime getLastModifiedDate() {\rreturn LastModifiedDate;\r}\rpublic void setLastModifiedDate(LocalDateTime lastModifiedDate) {\rLastModifiedDate = lastModifiedDate;\r}\r}\r  Member.java - extends BaseEntity 추가\n @Entity\rpublic class Member extends BaseEntity{\rpublic Member(){\r}\r  Team.java - extends BaseEntity 추가\n @Entity\rpublic class Team extends BaseEntity{\rpublic Team(){\r}\r  JpaMain.java\n  Member member = new Member();\rmember.setUsername(\u0026quot;MemberA\u0026quot;);\rmember.setCreateBy(\u0026quot;kim\u0026quot;);\rmember.setCreateDate(LocalDateTime.now());\rem.persist(member);\rem.flush();\rem.clear();\rtx.commit();\r  console\n  Hibernate: create table Member (\rMEMBER_ID bigint not null,\rLastModifiedBy varchar(255),\rLastModifiedDate timestamp,\rcreateBy varchar(255),\rcreateDate timestamp,\rUSERNAME varchar(255),\rLOCKER_ID bigint,\rTEAM_ID bigint,\rprimary key (MEMBER_ID)\r)\rHibernate: create table Team (\rTEAM_ID bigint not null,\rLastModifiedBy varchar(255),\rLastModifiedDate timestamp,\rcreateBy varchar(255),\rcreateDate timestamp,\rNAME varchar(255),\rprimary key (TEAM_ID)\r)\r @Column(name=\u0026ldquo;변경 컬럼명\u0026rdquo;)을 사용하여 일괄 컬럼명 수정  BaseEntity.java - Column(name=\u0026ldquo;변경 컬럼명\u0026rdquo;) 추가\n @MappedSuperclass\rpublic class BaseEntity {\r@Column(name = \u0026quot;REG_ID\u0026quot;)\rprivate String createBy;\r@Column(name = \u0026quot;REG_DT\u0026quot;)\rprivate LocalDateTime createDate;\r@Column(name = \u0026quot;MOD_ID\u0026quot;)\rprivate String LastModifiedBy;\r@Column(name = \u0026quot;MOD_DT\u0026quot;)\rprivate LocalDateTime LastModifiedDate;\r  JpaMain.java - 애플리케이션 재시작\n \tHibernate: create table Member (\rMEMBER_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rUSERNAME varchar(255),\rLOCKER_ID bigint,\rTEAM_ID bigint,\rprimary key (MEMBER_ID)\r)\rHibernate: create table Team (\rTEAM_ID bigint not null,\rMOD_ID varchar(255),\rMOD_DT timestamp,\rREG_ID varchar(255),\rREG_DT timestamp,\rNAME varchar(255),\rprimary key (TEAM_ID)\r)\r  이후에 Hibernate 뿐만 아니라 Jpa와 SpringData를 같이 사용하면 BaseEntity의 속성들을 어노테이션을 통해 간편하게 자동으로 현재 세션 ID와 현재 시간을 넣어줄 수 있습니다.\n @MappedSuperclass   상속관계 매핑X 엔티티X, 테이블과 매핑X 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공 조회, 검색 불가(em.find(BaseEntity) 불가) 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장    BaseEntity.java\n   @MappedSuperclass\rpublic abstract class BaseEntity {\r   테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑정보를 모으는 역할     주로 등록일, 수정일, 등록자, 수정자 등과 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용     참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능   참고- 자바 ORM 표준 JPA - 김영한 ","description":"상속관계 매핑","id":52,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA @MappedSuperclass","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapped-superclass/"},{"content":"상속관계 매핑  목차    상속관계 매핑 @MappedSuperclass   상속관계 매핑    객체는 상속관계가 있지만, 관계형 데이터베이스에는 상속 관계 없음 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 관계를 매핑    음반, 영화, 책의 공통 속성은 물품에 두고, 각각의 속성들을 밑의 서브 타입에 지정하여 논리 모델을 구성합니다.\n  객체는 Item이라는 추상 클래스를 만들고 Item을 상속받는 Album, Movie, Book 객체를 구성할 수 있습니다.\n 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법   각각 테이블로 변환 -\u0026gt; 조인전략 통합 테이블로 변환 -\u0026gt; 단일 테이블 전략 서브타입 테이블로 변환 -\u0026gt; 구현 클래스마다 테이블 전략   1. 조인전략  ITEM, ALBUM, MOVIE, BOOK 테이블을 만들고, JOIN으로 이를 구성.  ALBUM의 데이터를 추가하면, ITEM에 이름, 가격을 넣고 ALBUM에는 아티스트 같은 데이터는 ALBUM에 넣습니다.  ITEM과 ALBUM 두번의 인서트와 조회는 ITEM_ID로 조인을 해서 가져옴  어떤 타입의 서브타입 테이블을 사용하는지(어떤 데이터 인지) 구분하기 위해서 구분 컬럼을(DTYPE) 추가\n 2. 단일(통합) 테이블 전략  JPA Default  3. 구현 클래스 마다 테이블 전략  ITEM의 속성들을 각각 가진 ALBUM, MOVIE, BOOK 생성\n  하나의 테이블 ITEM에 속성들을 모두 모아놓고 PK와 DTYPE로 구분하여 하용하는 방식\n  객체 입장에서는 상속 관계를 지원하기 때문에 어떤것을 사용해도 똑같으며, JPA에서는 모두 매핑 가능합니다.\n 주요 어노테이션    @Inhritance(strategy=InheritanceType.XXX)  SINGLE_TABLE : 단일 테이블 전략 JOINED : 조인전략 TABLE_PER_CLASS : 구현 클래스 마다 테이블 전략   @DiscriminatorColumn(name=\u0026ldquo;DTYPE\u0026rdquo;) @DiscriminaterValue(\u0026ldquo;XXX\u0026rdquo;)   상속관계 구현  Item.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\r@Inheritance(strategy = InheritanceType.JOINED)\rpublic class Item {\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rprivate int price;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\r}\r  Album.java - extends Item\n package relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Album extends Item{\rprivate String artist;\rpublic String getArtist() {\rreturn artist;\r}\rpublic void setArtist(String artist) {\rthis.artist = artist;\r}\r}\r  Movie.java - extends Item\n package relativemapping;\rimport javax.persistence.Entity;\r@Entity\rpublic class Movie extends Item{\rprivate String director;\rprivate String actor;\rpublic String getDirector() {\rreturn director;\r}\rpublic void setDirector(String director) {\rthis.director = director;\r}\rpublic String getActor() {\rreturn actor;\r}\rpublic void setActor(String actor) {\rthis.actor = actor;\r}\r}\r  Book.java - extends Item\n package relativemapping;\rimport javax.persistence.Entity;\r@Entity\rpublic class Book extends Item{\rprivate String author;\rprivate String isbn;\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic String getIsbn() {\rreturn isbn;\r}\rpublic void setIsbn(String isbn) {\rthis.isbn = isbn;\r}\r}\r  JpaMain.java 애플리케이션 재시작\n Hibernate: drop table if exists Item CASCADE Hibernate: drop table if exists Locker CASCADE Hibernate: drop table if exists Member CASCADE Hibernate: drop table if exists ORDERS CASCADE Hibernate: drop table if exists Product CASCADE Hibernate: drop table if exists Team CASCADE Hibernate: drop sequence if exists hibernate_sequence\rHibernate: create sequence hibernate_sequence start with 1 increment by 1\rHibernate: create table Item (\rDTYPE varchar(31) not null,\rid bigint not null,\rname varchar(255),\rprice integer not null,\rartist varchar(255),\rauthor varchar(255),\risbn varchar(255),\ractor varchar(255),\rdirector varchar(255),\rprimary key (id)\r)\rHibernate: create table Locker (\rLOCKER_ID bigint not null,\rname varchar(255),\rprimary key (LOCKER_ID)\r)\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rUSERNAME varchar(255),\rLOCKER_ID bigint,\rTEAM_ID bigint,\rprimary key (MEMBER_ID)\r)\rHibernate: create table ORDERS (\rid bigint not null,\rORDERAMOUNT integer,\rORDERCOUNT integer,\rORDERDATE date,\rMEMBER_ID bigint,\rPRODUCT_ID bigint,\rprimary key (id)\r)\rHibernate: create table Product (\rid bigint not null,\rname varchar(255),\rprimary key (id)\r)\rHibernate: create table Team (\rTEAM_ID bigint not null,\rNAME varchar(255),\rprimary key (TEAM_ID)\r)\rHibernate: alter table Member add constraint FK332130jlg9s5hyeuk7gfgi052 foreign key (LOCKER_ID) references Locker\rHibernate: alter table Member add constraint FKl7wsny760hjy6x19kqnduasbm foreign key (TEAM_ID) references Team\rHibernate: alter table ORDERS add constraint FKh0db7kqr88ed8hqtcqw3jkcia foreign key (MEMBER_ID) references Member\rHibernate: alter table ORDERS add constraint FKtlx3qxs8vwir2b80i3oumx2qm foreign key (PRODUCT_ID) references Product\rProcess finished with exit code 0\r  따로 설정을 하지 않으니 단일(통합) 테이블 전략을 사용하여, ITEM 하나의 테이블에 모든 속성들이 생성되는것을 확인할 수 있습니다.\n 1. 조인전략 - 예제  부모 클래스(Item.java)에서 @Inheritance(strategy = InheritanceType.JOINED) 추가\n @Entity\r@Inheritance(strategy = InheritanceType.JOINED)\rpublic class Item {\r  JpaMain.java 애플리케이션 재시작\n  console\n Hibernate: create table Album (\rartist varchar(255),\rid bigint not null,\rprimary key (id)\r)\rHibernate: create table Book (\rauthor varchar(255),\risbn varchar(255),\rid bigint not null,\rprimary key (id)\r)\rHibernate: create table Movie (\ractor varchar(255),\rdirector varchar(255),\rid bigint not null,\rprimary key (id)\r)\rHibernate: create table Item (\rid bigint not null,\rname varchar(255),\rprice integer not null,\rprimary key (id)\r)\r 조인전략 - Insert  JpaMain.java - Movie 객체 생성\n  Movie movie = new Movie();\rmovie.setDirector(\u0026quot;감독A\u0026quot;);\rmovie.setActor(\u0026quot;베우A\u0026quot;);\rmovie.setName(\u0026quot;영화A\u0026quot;);\rmovie.setPrice(50000);\rem.persist(movie);\rtx.commit();\r  console\n Hibernate: /* insert relativemapping.Movie\r*/ insert into\rItem\r(name, price, id) values\r(?, ?, ?)\rHibernate: /* insert relativemapping.Movie\r*/ insert into\rMovie\r(actor, director, id) values\r(?, ?, ?)\r 조인전략 - Select  JpaMain.java - Movie 객체 생성 후 flush()와 clear() 후 조회 추가\n \tMovie movie = new Movie();\rmovie.setDirector(\u0026quot;감독A\u0026quot;);\rmovie.setActor(\u0026quot;베우A\u0026quot;);\rmovie.setName(\u0026quot;영화A\u0026quot;);\rmovie.setPrice(50000);\rem.persist(movie);\rem.flush();\rem.clear();\rMovie findMovie = em.find(Movie.class, movie.getId());\rSystem.out.println(findMovie);\rtx.commit();\r  console\n Hibernate: select\rmovie0_.id as id1_2_0_,\rmovie0_1_.name as name2_2_0_,\rmovie0_1_.price as price3_2_0_,\rmovie0_.actor as actor1_5_0_,\rmovie0_.director as director2_5_0_ from\rMovie movie0_ inner join\rItem movie0_1_ on movie0_.id=movie0_1_.id where\rmovie0_.id=?\r 부모 클래스에서 하위 클래스를 구분  실제로 부모 테이블만 조회 하였을때, 어떤 자식의 테이블과 조인을 해야 하는지 알 수 없는 경우 자식 테이블들을 각각 조회해 봐야 하는 불편함이 있습니다. 이러한 문제에 도움을 주고자 JPA에서는 Discriminator 라는 어노테이션들을 지원하여 어떤 하위 테이블의 데이터인지 구분해 줍니다.\n  dtype을 추가하고자 한다면 부모 클래스(Item.java)에서 @DiscriminatorColumn를 추가\n @Entity\r@Inheritance(strategy = InheritanceType.JOINED)\r@DiscriminatorColumn\rpublic class Item {\r  JpaMain.java 애플리케이션 재시작\n  console\n Hibernate: /* insert relativemapping.Movie\r*/ insert into\rItem\r(name, price, DTYPE, id) values\r(?, ?, 'Movie', ?)\rHibernate: /* insert relativemapping.Movie\r*/ insert into\rMovie\r(actor, director, id) values\r(?, ?, ?)\r  DTYPE 가 추가된 것을 확인할 수 있습니다.\n  DTYPE가 Movie로 저장된것이 보이는데, Default는 자식 클래스의 Entity명입니다.\n  하지만, 회사의 Rule이나 DBA 의견에 따라 숫자, 문자 또는 코드로 관리하게 된다면\n DTYPE 구분값 지정  자식 클래스에서 각각 @DiscriminatorValue(\u0026ldquo;anything\u0026rdquo;)\n  Album.java - @DiscriminatorValue 추가\n @Entity\r@DiscriminatorValue(\u0026quot;A\u0026quot;)\rpublic class Album extends Item{\r  Movie.java - @DiscriminatorValue 추가\n @Entity\r@DiscriminatorValue(\u0026quot;M\u0026quot;)\rpublic class Movie extends Item{\r  Book.java - @DiscriminatorValue 추가\n @Entity\r@DiscriminatorValue(\u0026quot;B\u0026quot;)\rpublic class Book extends Item{\r  JpaMain.java 애플리케이션 재시작\n 2. 단일 테이블 전략 - 예제  단일 테이블 전략은 테이블을 나누지 않고 하나의 테이블로 통합하여 사용하는 전략입니다. 상속전략을 변경만 해도 빠르게 적용됩니다.\n  JpaMain.java - @Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n @Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r@DiscriminatorColumn\rpublic class Item {\r  console - create table\n  create table Item (\rDTYPE varchar(31) not null,\rid bigint not null,\rname varchar(255),\rprice integer not null,\rartist varchar(255),\rauthor varchar(255),\risbn varchar(255),\ractor varchar(255),\rdirector varchar(255),\rprimary key (id)\r)\r  console - insert\n  /* insert relativemapping.Movie\r*/ insert into\rItem\r(name, price, actor, director, DTYPE, id) values\r(?, ?, ?, ?, 'M', ?)\r  console - select\n Hibernate: select\rmovie0_.id as id2_0_0_,\rmovie0_.name as name3_0_0_,\rmovie0_.price as price4_0_0_,\rmovie0_.actor as actor8_0_0_,\rmovie0_.director as director9_0_0_ from\rItem movie0_ where\rmovie0_.id=? and movie0_.DTYPE='M'\r  단일 테이블 전략은 @DiscriminatorColumn를 넣지 않는다 하여도 DTYPE가 포함되어 생성\n  Item.java - @DiscriminatorColumn 제거후 테스트\n @Entity\r@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\rpublic class Item {\r  JpaMain.java 애플리케이션 재시작\n Hibernate: create table Item (\rDTYPE varchar(31) not null,\rid bigint not null,\rname varchar(255),\rprice integer not null,\rartist varchar(255),\rauthor varchar(255),\risbn varchar(255),\ractor varchar(255),\rdirector varchar(255),\rprimary key (id)\r)\rHibernate: call next value for hibernate_sequence\rHibernate: /* insert relativemapping.Movie\r*/ insert into\rItem\r(name, price, actor, director, DTYPE, id) values\r(?, ?, ?, ?, 'M', ?)\rHibernate: select\rmovie0_.id as id2_0_0_,\rmovie0_.name as name3_0_0_,\rmovie0_.price as price4_0_0_,\rmovie0_.actor as actor8_0_0_,\rmovie0_.director as director9_0_0_ from\rItem movie0_ where\rmovie0_.id=? and movie0_.DTYPE='M'   하나의 테이블에 들어가기 때문에 어떤 자식 테이블의 데이터 인지 구분하기 위해 DTYPE가 필수로 생성됩니다.\n  JPA에서 Joined 전략도 필수지만, Hibernate에서는 생략되어있습니다.\n  Joined 전략에서 SINGLE_TABLE으로 변경하며 테이블 구조를 변경해 보았는데, 전략만 설정만 했을 뿐인데 잘 변경되는 것을 확인할 수 있습니다.\n  Jpa를 사용하지 않는다면 많은 소스코드들과 쿼리 들을 수정했어야 했을 것입니다.\n 3. 구현 클래스마다 테이블 전략 - 예제  Joined 속성과 똑같지만, ITEM 테이블을 없애고(추상클래스로 변경) ITEM의 속성을 밑의 자식 테이블에 위치 시키는 전략입니다.\n  Item.java \u0026ndash; abstract 키워드를 추가하고, strategy = InheritanceType.TABLE_PER_CLASS\n @Entity\r@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\rpublic abstract class Item {\r  console - create table\n Hibernate: create table Album (\rid bigint not null,\rname varchar(255),\rprice integer not null,\rartist varchar(255),\rprimary key (id)\r)\rHibernate: create table Book (\rid bigint not null,\rname varchar(255),\rprice integer not null,\rauthor varchar(255),\risbn varchar(255),\rprimary key (id)\r)\rHibernate: create table Movie (\rid bigint not null,\rname varchar(255),\rprice integer not null,\ractor varchar(255),\rdirector varchar(255),\rprimary key (id)\r)\r  ITEM TABLE이 생성 안된 것을 볼 수 있습니다.\n  console - Insert\n Hibernate: /* insert relativemapping.Movie\r*/ insert into\rMovie\r(name, price, actor, director, id) values\r(?, ?, ?, ?, ?)\r  console - Select\n Hibernate: select\rmovie0_.id as id1_2_0_,\rmovie0_.name as name2_2_0_,\rmovie0_.price as price3_2_0_,\rmovie0_.actor as actor1_5_0_,\rmovie0_.director as director2_5_0_ from\rMovie movie0_ where\rmovie0_.id=?\r  Movie 테이블에만 데이터가 들어간 것을 확인 할 수 있습니다.\n  구현 클래스마다 테이블 전략에서는 @DiscriminatorColumn를 추가해도 적용되지 않습니다. 각각의 자식 테이블에서 관리하여 사용되기 때문입니다.\n  단순하게 이것까지만 보면 좋아보이는데 단점이 있습니다.\n  JpaMain.java - 부모 객체 Item으로 조회\n  Movie movie = new Movie();\rmovie.setDirector(\u0026quot;감독A\u0026quot;);\rmovie.setActor(\u0026quot;베우A\u0026quot;);\rmovie.setName(\u0026quot;영화A\u0026quot;);\rmovie.setPrice(50000);\rem.persist(movie);\rem.flush();\rem.clear();\rItem findMovie = em.find(Item.class, movie.getId());\rSystem.out.println(findMovie);\rtx.commit();\r  console\n \rHibernate: select\ritem0_.id as id1_2_0_,\ritem0_.name as name2_2_0_,\ritem0_.price as price3_2_0_,\ritem0_.artist as artist1_0_0_,\ritem0_.author as author1_1_0_,\ritem0_.isbn as isbn2_1_0_,\ritem0_.actor as actor1_5_0_,\ritem0_.director as director2_5_0_,\ritem0_.clazz_ as clazz_0_ from\r( select\rid,\rname,\rprice,\rartist,\rnull as author,\rnull as isbn,\rnull as actor,\rnull as director,\r1 as clazz_ from\rAlbum union\rall select\rid,\rname,\rprice,\rnull as artist,\rauthor,\risbn,\rnull as actor,\rnull as director,\r2 as clazz_ from\rBook union\rall select\rid,\rname,\rprice,\rnull as artist,\rnull as author,\rnull as isbn,\ractor,\rdirector,\r3 as clazz_ from\rMovie ) item0_ where\ritem0_.id=?\r  Item에서 조회할 경우 union all 을 통해 자식 테이블들을 모두 합쳐서 조회하게 됩니다. 조회시 어떤 테이블에 값이 있을 지 모르기 때문에 전체 테이블을 조회합니다.\n 각각 전략들의 장단점  조인 전략의 장/단점   장점  테이블 정규화 외래 키 참조 무결설 제약조건 활용가능 저장공간 효율화       단점  조회시 조인을 많이 사용, 성능 저하 조회 쿼리가 복잡함 데이터 저장시 Insert SQL 2번 호출     단일 테이블 전략 장/단점   장점  조인이 필요 없으므로 일반적으로 조회 성능이 빠름 조회 쿼리가 단순함       단점  자식 엔티티가 매핑한 컬럼은 모두 null 허용 단일 테이블에 모든 것을 저장하므로 테이블이 커질수 있고, 상황에 따라서 조회 성능이 오히려 느려질 수 있다.     구현 클래스마다 테이블 전략 장/단점  이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않음\n   장점  서브 타입을 명확하게 구분해서 처리할때 효과적 not null 제약조건 사용가능       단점  여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION ALL)       자식 테이블을 통합해서 쿼리하기 어려움    ALBUM, MOVIE, BOOK을 모두 정산을 할 경우, 각각 정산을 해서 통합하여야 하고, 자식 클래스가 추가될 경우 수정이 필요합니다.\n  하지만 조인전략과 단일테이블 전략에서는 ITEM만 사용하기 때문에 구현 클래스마다 전략은 매우 큰 단점을 가지고 있는것을 알 수 있습니다.\n 상속관계 매핑 정리  기본적으로 조인전략을 가져가고 설계나 구조 상황에 따라 조인전략과 단일 테이블 전략에서 고민 비즈니스 적으로 중요하지 않고 데이터가 그리 많지 않다면 단일테이블 전략을 선택해 시간과 일정을 절약 비즈니스 적으로 중요하고 정교한 테이블 구조가 필요하다면 조인전략으로 선택\n  테이블마다 전략은 고려대상 아님\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"상속관계 매핑","id":53,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 상속관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/inheritance-mapping/"},{"content":"실전 예제 3 - 다양한 연관관계 매핑  요구사항 분석  배송, 카테고리 추가 - 엔티티    주문과 뱌송은 1:1(@OneToOne) 상품과 카테고리는 N:M(@ManyToMany)   배송, 카테고리 추가 - ERD   Delivery.java 와 Category.java를 생성합니다.\n 일대일 양방향 관계 Order.java - Delivery.java   주 객체은 외래키를 가지고 있는 Order.java  @OneToOne @JoinColumn(name = \u0026ldquo;DELIVERY_ID\u0026rdquo;) private Delivery delivery;       대상 객체는 상대 객체인 Delivery.java  @OneToOne(mappedBy = \u0026ldquo;delivery\u0026rdquo;)\tprivate Order order;      Order.java - Delivery 객체 추가 외래키를 가지고 있는 주 객체\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\r@OneToOne\r@JoinColumn(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Delivery delivery;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\rpublic void addOrderItem(OrderItem orderItem) {\rthis.orderItems.add(orderItem);\rorderItem.setOrder(this);\r}\rpublic void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r}\r  Delivery.java - 대상 테이블 @OneToOne(mappedBy = \u0026ldquo;delivery\u0026rdquo;)\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Delivery {\r@Id @GeneratedValue\r@Column(name = \u0026quot;DELIVERY_ID\u0026quot;)\rprivate Long id;\rprivate String city;\rprivate String street;\rprivate String zipcode;\r@Enumerated(EnumType.STRING)\rprivate DeliveryStatus status;\r@OneToOne(mappedBy = \u0026quot;delivery\u0026quot;)\rprivate Order order;\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic String getCity() {\rreturn city;\r}\rpublic void setCity(String city) {\rthis.city = city;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic DeliveryStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(DeliveryStatus status) {\rthis.status = status;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\r}\r  console - ORDERS - Delivery\n \tcreate table ORDERS (\rORDER_ID bigint not null,\rorderDate timestamp,\rstatus varchar(255),\rDELIVERY_ID bigint,\rmember_MEMBER_ID bigint,\rprimary key (ORDER_ID)\r)\rcreate table Delivery (\rDELIVERY_ID bigint not null,\rcity varchar(255),\rstatus varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rprimary key (DELIVERY_ID)\r)\ralter table ORDERS add constraint FKdbs21f1yi0coxy9y0kxw4g9jf foreign key (DELIVERY_ID) references Delivery\r 다대다 양방향 관계 Category.java - Item.java   주 객체은 외래키를 가지고 있는 Category.java  @ManyToMany @JoinTable( name = \u0026ldquo;CATEGORY_ITEM\u0026rdquo;, joinColumns = @JoinColumn(name = \u0026ldquo;CATEGORY_ID\u0026rdquo;), inverseJoinColumns = @JoinColumn(name =\u0026ldquo;ITEM_ID\u0026rdquo;) ) private List items = new ArrayList\u0026lt;\u0026gt;();       대상 객체는 상대 객체인 Item.java  @ManyToMany(mappedBy = \u0026ldquo;items\u0026rdquo;) private List categories = new ArrayList\u0026lt;\u0026gt;();     부모 자식 구조의 연관관계 Category.java - Item.java   부모  @ManyToOne @JoinColumn(name = \u0026ldquo;parent_id\u0026rdquo;) private Category parent; // 상위 카테고리       자식  @OneToMany(mappedBy = \u0026ldquo;parent\u0026rdquo;) private List child = new ArrayList\u0026lt;\u0026gt;(); // 자식 카테고리      Category.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Category {\r@Id @GeneratedValue\r@Column(name = \u0026quot;CATEGORY_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r@ManyToOne\r@JoinColumn(name = \u0026quot;parent_id\u0026quot;)\rprivate Category parent; // 상위 카테고리\r@OneToMany(mappedBy = \u0026quot;parent\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; child = new ArrayList\u0026lt;\u0026gt;(); // 자식 카테고리\r@ManyToMany\r@JoinTable(name = \u0026quot;CATEGORY_ITEM\u0026quot;,\rjoinColumns = @JoinColumn(name = \u0026quot;CATEGORY_ID\u0026quot;),\rinverseJoinColumns = @JoinColumn(name =\u0026quot;ITEM_ID\u0026quot;)\r)\rprivate List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Item {\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r@ManyToMany(mappedBy = \u0026quot;items\u0026quot;)\rprivate List\u0026lt;Category\u0026gt; categories = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r  console\n  create table Category (\rCATEGORY_ID bigint not null,\rname varchar(255),\rparent_id bigint,\rprimary key (CATEGORY_ID)\r)\rcreate table CATEGORY_ITEM (\rCATEGORY_ID bigint not null,\rITEM_ID bigint not null\r)\rcreate table Item (\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rprimary key (ITEM_ID)\r)\ralter table Category add constraint FK5s5t2pfpxo0vnd1ihc43721ty foreign key (parent_id) references Category\ralter table CATEGORY_ITEM add constraint FKf1uerpnmn49vl1spbbplgxaun foreign key (ITEM_ID) references Item\ralter table CATEGORY_ITEM add constraint FKjip0or3vemixccl6vx0kluj03 foreign key (CATEGORY_ID) references Category\r 참고- 자바 ORM 표준 JPA - 김영한 ","description":"다양한 연관관계 매핑","id":54,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 실전 예제 3 - 다양한 연관관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-3/"},{"content":"다양한 연관관계 매핑  목차    연관관계 매핑시 고려사항 3가지 다대일 [N:1] 일대다 [1:N] 일대일 [1:1] 다대다 [N:M]   연관관계 매핑시 고려사항 3가지    다중성 단방향, 양방향 연관관계의 주인   다중성    다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany (실무에서 사용X)    애매한 경우 반대의 경우를 생각해 보면 된다. 다대일의 반대는 일대다, 일대일의 반대는 일대일, 다대다의 반대는 다대다.  단방향, 양방향    테이블  외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음   객체  참조용 필드가 있는 쪽으로 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향     연관관계의 주인   테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A-\u0026gt;B, B-\u0026gt;A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래 키를 관리할 곳을 지정해야함 연관관계의 주인 : 외래 키를 관리하는 참조 주인의 반대편 : 외래 키에 영향을 주지않음, 단순 조회만   다대일 [N:1]  다대일 단방향   Member랑 Team이 있다면 1:N중 N인 Member에 외래 키가 있어야합니다.\n 다대일 단방향 정리   가장 많이 사용하는 연관관계 다대일의 반대는 일대다    Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\rpublic void changeTeam(Team team) {\rthis.team = team;\rteam.getMembers().add(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Team.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 다대일 양방향   Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\rpublic void changeTeam(Team team) {\rthis.team = team;\rteam.getMembers().add(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Team.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;) // 1:N 관계에서 상대편(Member)에 team으로 매핑이 되어있는 것 이라고 지정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic void addMember(Member member){\rmember.setTeam(this);\rmembers.add(member);\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 다대일 양방향 정리   외래 키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발   일대다 [1:N]  일대다 단방향   밑밥을 깔자면 강의를 하시는 김영한님은 이 모델을 추천하지 않는다고 하며, 표준에서 제공하기 때문에 강의에 포함시켰다 하였습니다.\n  팀과 맴버가 있는데 팀을 중심으로 연관관계를 작성하겠다 하는 것입니다. 이전에 N에 연관관계의 주인을 둔다고 하였지만 반대가 되는 상황입니다.\n  팀은 맴버를 알고 싶은테, 맴버는 팀을 알고 싶지 않을때. 개발하다 보면 언젠가는 만나 볼 수 있는 모델입니다.\n  테이블 설계를 보면 N에 무조건 외래 키를 가지게 됩니다. 생각해 보면 팀에 외래 키가 있는 순간 1:N이 아니게 됩니다.\n  Team의 members가 연관관계의 주인이 된다면, Team을 수정하게되면 Member 또한 수정하게 됩니다.\n  Team.java - 연관관계의 주인을 여기에 둠\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '}';\r}\r}\r  Member.java - id, name 이외 소스 정리\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  JpaMain.java\n  Member member = new Member();\rmember.setUsername(\u0026quot;member1\u0026quot;);\rem.persist(member);\rTeam team = new Team();\rteam.setName(\u0026quot;teamA\u0026quot;);\rteam.getMembers().add(member); //팀의 members에 member를 추가\rem.persist(team);\rtx.commit();\r  Team 저장할때, TEAM_ID와 NANE은 저장하면 되지만, 외래 키는 TEAM이 아닌 MEMBER에 있기 때문에, 저장할 방법이 없기 때문에 MEMEBER 테이블을 업데이트 하는 수 밖에 없습니다. 업데이트 문을 한번더 실행하기에 성능상에 이슈는 아니여도 조금의 불이익은 있습니다.\n  실무에서 이 모델을 사용하게되면 실제 Member 테이블에 저장만 했을 뿐인데 내가 수정하지 않은 테이블에 Update Sql이 찍히게 되고 혼돈에 빠지게 됩니다.\n  만약 지금처럼 Team에서 Member로 접근이 필요한 경우 다대일의 양방향 연관관계 매핑 사용을 추천드립니다.\n 일대다 단방향 정리   일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조 @JoinColumn을 꼭 하용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함) 일대다 단방향 매핑의 단점  엔티티가 관리하는 외래 키가 다른 테이블에 있음 연관관계 관리를 위해 추가로 Update sql 실행   일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자   일대다 양방향    이런 매핑은 공식적으로 없다. @JoinColumn(insertable=false, updateable=false) 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 다대일 양방향을 사용하자    Team.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\t// 연관관계의 주인\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  Member.java\n @Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false) // 연관관계의 주인과 같지만, 인서트, 업데이트 사용안함으로 읽기전용으로 사용\rprivate Team team;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r 일대일 [1:1]  일대일 관계    일대일 관계는 그 반대도 일대일 주 테이블이나 대상 테이블 중에 외래 키 선택 가능  주 테이블에 외래 키 대상 테이블에 외래 키   외래 키에 데이터베이스 유니크 제약조건 추가   일대일 : 주 테이블에 외래 키 단방향   회원은 사물함 하나를 가질 수 있고 그리고 사물함도 하나의 맴버를 가질 수 있습니다. 이런 룰을 가지고 있을 때, Member 테이블을 주 테이블로 생각하고 연관관계의 주인을 Member로 지정.\n 일대일 : 주 테이블에 외래 키 단방향 정리   다대일(@ManyToOne) 단방향 매핑과 유사    Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Locker.java\n package relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Locker {\r@Id @GeneratedValue\r@Column(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  JpaMain.java 은 지우고 애플리케이션을 실행한다.\n 일대일 : 주 테이블에 외래 키 양방향   Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Locker.java\n package relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Locker {\r@Id @GeneratedValue\r@Column(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r@OneToOne(mappedBy=\u0026quot;locker\u0026quot;)\rprivate Member member;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 일대일 : 주 테이블에 외래 키 양방향 정리   다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인 반대편은 mappedBy 적용   일대일 : 대상 테이블에 외래 키 단방향   Member 객체를 연관관계의 주인으로 두고 Locker객체를 가지고 LOCKER 테이블에 MEMBER_ID를 관리 하는 방법은 없고 지원도 안해줍니다.\n 일대일 : 대상 테이블에 외래 키 단방향 정리   단방향 관계는 JPA에서 지원안함 양방향 관계는 지원   일대일 : 대상 테이블에 외래 키 양방향   주 테이블을 Member로 생각하지만, 외래 키는 대상 테이블에 있는경우. 외래 키가 있는 대상 테이블을 주 테이블로 매핑\n  이것을 반대로 뒤집은 것과 같음. 1:1 관계를 정리하면 내것은 내가 관리\n 일대일 : 외래키는 어떤 객체가 가져야 할까  매우 민감한 주제이며 DBA와 싸울수도있음. 일대일 관계는 MEMBER에 외래 키가 있든 LOCKER에 있든 어떠한 방법을 써도 연관관계가 유효 합니다.   DBA이라면, DB 설계를 쉽게 바꿀 수 없기 때문에 미래를 대비해서 Locker에 외래 키를 두어 나중에 유니크 제약조건만 제거하면, 한명의 회원이 여러 개의 Locker를 가질 수 있도록 설계를 생각할 것입니다.\n  만약 반대로 MEMBER에 외래 키가 있는 경우 한명의 MEMBER가 여러 Locker를 가질 수 있도록 설계를 변경 한다면 LOCKER에 컬럼을 추가하고 코드 수정이 필요합니다 또한 MEMBER의 외래 키는 의미가 없으니 지워지게 됩니다.\n  또 비즈니스 로직 상에 Locker에 여러명의 Member가 있을 수 있다면, Member에 외래키가 있는 상태가 맞게 됩니다.\n  여기 까지가 DBA가 비즈니스 로직에 변경 또는 미래의 변화에 대비하기 위해 이렇게 생각할 수 있다면 ORM을 사용하는 개발자 입장에서는 Member에 Locker가 있는것이 성능에서나 여러가지 측면에서 장점이 있습니다. 어떠한 장점이 있냐면,\n  Member가 Locker를 가지고 있지 않으면 Null 아니면 Locker가 있는것이고 Member를 더 많이 조회하기 때문에 Locker가 Member를 가지는 것보다 좋습니다.\n  Member를 조회할때 Locker에 의해 분기 되는 로직이 있을때, 대부분 Member를 조회하여야 되기 때문에 이미 Locker를 가지고 있기 때문에 DB쿼리 하나로 Member를 가져왔을때 이미 Locker까지 조회가 됩니다.\n  이런 모든 것을 고려하여 설계를 해야합니다.\n 일대일 정리   주 테이블에 외래 키  주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자 선호 JPA 매칭 편리 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점 : 값이 없으면 외래 키에 null 허용       대상 테이블에 외래 키  대상 테이블에 외래 키가 존재 전통적인 DBA 선호 장점 : 주 테이블과 대상 테아블을 일대일에서 다대다 관계로 변경할 때 테이블 구조 유지 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 (추후 설명)      ORM 개발자 입장에서는 주 테이블에 외래 키가 있는 것이 바람직하지만, DBA와 협의가 잘되어야 한다.\n 다대다 [N:M]   실무에서는 쓰면 안된다고 보면 됩니다. JPA가 매핑을 지원하기 때문에 정리\n 다대다    괸계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계룰 표현할 수 없음 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함 @ManyToMany 사용 @JoinTable로 연결 테이블 지정 다대다 매핑 : 단방향, 양방향 가능    다대다 테이블 관계\n  객체인 Member는 ProductList를 가질 수 있고 Product는 MemberList를 가질 수 있음 그렇기 때문에 딜레마가 생김.\n  객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능\n  중간에 조인 테이블을 사용하여 사용\n  Product.java\n package relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.List;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\r@ManyToMany\r@JoinTable(name=\u0026quot;MEMBER_PRODUCT\u0026quot;)\rprivate List\u0026lt;Product\u0026gt; products;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  JpaMain - 내용지우고 애플리케이션 재시작\n  PRODUCT 테이블과 MEMBER_PRODUCT 테이블이 생성되는걸 확인 할 수 있습니다.\n  단방향을 양방향으로 바꾸려면, Product에 members를 추가하면 됩니다.\n  Product.java\n package relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\rimport javax.persistence.ManyToMany;\rimport java.util.List;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\r@ManyToMany(mappedBy = \u0026quot;products\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 다대다 매핑의 한계   편리해 보이지만 실무에서 사용X 연결 테이블이 단순히 연결만 하고 끝나지 않음 주문시간, 수량 같은 데이터가 들어 올 수 있음    중간 테이블 사용시 조인 쿼리도 예상치 못하게 잘못된 쿼리도 나갈 수 있음\n 다대다 한계 극복   연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) 비즈니스로직상 복잡하기 때문에 연결용 테이블을 쓰기는 불편함과 어려움이 있어 엔티티로 만들어 사용하는 것이 그나마 좋은 방법입니다.     ManyToMany -\u0026gt; @OneToMany, @ManyToOne    중간에 엔티티를 하나더 생성. 예를 들면 MemberProduct.java를 만들어 보겠습니다.\n  MemberProduct.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;)\rpublic class MemberProduct {\r@Id @GeneratedValue\rprivate Long id;\r@ManyToOne\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Member member;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\r@Column(name = \u0026quot;ORDERAMOUNT\u0026quot;)\rprivate int orderAmount;\r@Column(name = \u0026quot;ORDERCOUNT\u0026quot;)\rprivate int orderCount;\rpublic Member getMember() {\rreturn member;\r}\r@Column(name = \u0026quot;ORDERDATE\u0026quot;)\rprivate LocalDate orderDate;\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r  @ManyToOne으로 Member와 Product를 생성합니다.\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;MemberProduct\u0026gt; memberProducts = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Member에서는 @OneToMany로 mappedBy = \u0026ldquo;member\u0026rdquo; 옵션을 지정한 List memberProducts 를 추가 합니다.\n  Product.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\r@OneToMany(mappedBy = \u0026quot;product\u0026quot;)\rprivate List\u0026lt;MemberProduct\u0026gt; memberProducts;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  Product에도 @OneToMany로 mappedBy = \u0026ldquo;member\u0026rdquo; 옵션을 지정한 List memberProducts 를 추가 합니다.\n  JpaMember.java - 애플리케이션을 재시작 해봅니다.\n N:M 관계는 1:N, N:1로   테이블의 N:M 관계는 중간 테이블을 이용해서 1:N, N:1 실전에서는 중간 테이블이 단순하지 않다. @ManyToMany는 제약 : 필드 추가X, 엔티티 테이블 불일치 실전에서는 @ManyToMany 사용X   @JoinColumn  외래 키를 매핑할 때 사용\n 속성\t|\t설명\t|\t기본값 \u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; name\t|\t매핑할 외래 키 이름\t|\t필드명 + _ + 참조하는 테이블의 기본 키 컬럼명 referencedColumnName\t|\t외래 키가 참조하는 대상 테이블의 컬럼명\t|\t참조하는 테이블의 기본 키 컬럼명 foreignKey(DDL)\t|\t외래 키 제약조건을 직접 지정할 수 있다.\n이 속성은 테이블을 생성할 때만 사용한다.\t|\tunique\nnullable\ninsertable\nupdatable\ncolumnDefinition\ntable\t|\t@Column의 속성과 같다\t|\n@ManyToOne - 주요속성  다대일 관계 매핑 (다대일은 연관관계의 주인 mappedBy 가 없다.) (억지라도 연관관계의 주인이 아니게 사용하려면, insertable=false, updatable=false)\n 속성\t|\t설명\t|\t기본값 \u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; optional\t|\tfalse로 설정하면 연관된 엔티티가 항상 있어야 한다.\t|\ttrue fetch\t|\t글로벌 페치 전략을 설정한다.\t|\t@ManyToOne=FetchType.EAGER @ManyToOne=FetchType.EAGER OneToMany=FetchType.LAZY cascade | 영속성 전이 기능을 사용한다. | targetEntity | 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다. |\n@OneToMany - 주요속성  일대다 관계 매핑\n 속성\t|\t설명\t|\t기본값 \u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; mappedBy\t|\t연관관계의 주인 필드를 선택한다.\t|\tfetch\t|\t글로벌 페치 전략을 설정한다.\t|\t@ManyToOne=FetchType.EAGER @ManyToOne=FetchType.EAGER OneToMany=FetchType.LAZY cascade | 영속성 전이 기능을 사용한다. | targetEntity | 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다. |\n참고- 자바 ORM 표준 JPA - 김영한 ","description":"다양한 연관관계 매핑","id":55,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 다양한 연관관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapping-various-associations/"},{"content":"실전 예제 2 - 연관관계 매핑 시작 요구사항 분석   실전 예제 1 요구사항 분석과 기본 매핑에서 테이블에 맞춘 설계를 했던 것에 연관 관계 매핑을 적용 시켜 보도록 하겠습니다.\n 테이블 구조   테이블 구조는 이전과 같다.\n 객체 구조   참조를 사용하도록 변경\n  OrderItem과 Item에서 N:1이면서 화살표가 OrderItem에서 Item으로 단방향인 것을 알 수 있는데, 이는 주문된 아이템(OrderItem) 입장에서는 어떠한 아이템(Item)인지 알아야하지만, 아이템 입장에서는 통계 같은 프로그램을 하지 않는 이상 이 아이템이 어떠한 아이템 주문이 되었는지 알 필요가 없습니다.\n  또한 실제 개발을 할때는 Member에 굳이 Orders를 가지지 않는 것이 바람직하다고 합니다. 객체 지향적으로는 Member에 Orders가 있는게 맞지만, Member에 Orders 그리고 Orders에서 Member와 OrderItem을 참조하며 모든 연관관계를 추가 하지 말고 (추가 하다보면 끝이 없습니다.) 적절하게 관심사를 분리하여 Order에 Member를 파라미터로 바로 Order에서 Member와 OrderItem을 참조하면 됩니다.\n  현재는 예제이기 때문에, Member에 Orders를 추가하여 앙뱡향 연관관계를 실습해 보겠습니다.\n 단방향 매핑 추가  우선 단방향 연관관계 매핑부터 진행 하도록 하겠습니다.\n  Order.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne\rprivate Member member;\r}\r  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member {\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\r}\r  OrderItem.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem {\rpublic OrderItem(){}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne\rprivate Order order;\r@ManyToOne\rprivate Item item;\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Item {\rpublic Item(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r}\r 양방향 매핑 추가  단방향 매핑을 하였으니 Member에서 Order로 Order에서 OrderItem 으로 역방향 매핑을 추가하도록 하겠습니다. 그리고 setter와 getter 또한 추가 하도록 하겠습니다.\n  Order.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\r}\r  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member {\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rpublic void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic List\u0026lt;Order\u0026gt; getOrders() {\rreturn orders;\r}\rpublic void setOrders(List\u0026lt;Order\u0026gt; orders) {\rthis.orders = orders;\r}\r}\r  OrderItem.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem {\rpublic OrderItem(){\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne\rprivate Order order;\r@ManyToOne\rprivate Item item;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\rpublic Item getItem() {\rreturn item;\r}\rpublic void setItem(Item item) {\rthis.item = item;\r}\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Item {\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r 연관관계 편의 메소드 추가  JpaMain.java 에서\n  메소드 생성을 하여 Order의 addOrderItem 편의 메소드 작성\n  Order.java\n \t...\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\r...\r  Order.java\n \t...\rpublic void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r...\r  할 수 있다면 최대한 단방향으로 개발하여도 상관은 없으나 이후 복잡한 JPQL등 사용할때 그때 가서 고려해도 상관 없다. 그렇기 때문에 단방향 설계를 잘하는 것이 중요하다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"연관관계 매핑 시작","id":56,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 실전 예제 2 - 연관관계 매핑 시작","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-2/"},{"content":"연관관계 매핑   테이블에 맞춰서 외래키를 가져오면서 설계하는 방식이 아닌 order.getMember()이런식으로 연관관계를 맺어서 좀더 객체지향 식으로 설계할 수 있는지 알아보겠습니다. 여태 까지는 어려움이 없었겠지만, 관계형 DB와 객체지향 사이에서 오는 간극이 크고 각각의 패러다임이 다르기 때문에 어려움이 있습니다.\n 목표    객체와 테이블 연관관계 차이를 이해 객체의 참조와 테이블의 외래 키를 매핑 용어 이해  방향(Direction) : 단방향, 양방향 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)의 이해 연관관계의 주인(Owner) : 객체의 양방향 관계는 괸리 주인이 필요     목차    연관관계가 필요한 이유 단방향 연관관계 양방향 연관관계와 연관관계의 주인 실전예제 - 2. 연관관계 매핑 시작   연관관계가 필요한 이유  예제 시나리오   회원과 팀이 있다. 회원은 하나의 팀에만 소속 될 수 있다. 회원과 팀은 다대일 관계다. 회원(n:1)팀   객체를 테이블에 맞추어 모델링  (연관관계가 없는 객체)\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long teamId;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic Long getTeamId() {\rreturn teamId;\r}\rpublic void setTeamId(Long teamId) {\rthis.teamId = teamId;\r}\r}\r  Team.java\n package relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  JpaMain.java\n package relativemapping;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relavicemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;relativemapping\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;!--\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.MySQL5Dialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert relativemapping.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r  console\n Hibernate: drop table Member if exists\rHibernate: drop table Team if exists\rHibernate: drop sequence if exists hibernate_sequence\rHibernate: create sequence hibernate_sequence start with 1 increment by 1\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rTEAM_ID bigint,\rUSERNAME varchar(255),\rprimary key (MEMBER_ID)\r)\rHibernate: create table Team (\rTEAM_ID bigint not null,\rNAME varchar(255),\rprimary key (TEAM_ID)\r)\r  테이블 구조를 따라 객체를 만들면 외래키를 포함하게 되는 것을 볼 수있습니다. 문제점이 무엇이냐면,\n  JpaMain.java\n \t...\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeamId(team.getId());\rem.persist(member);\rtx.commit();\r...\r  member.setTeamId()가 member.setTeam()으로 객체 자체를 참조하여 가져올 수 있다면 좀더 객체지향적인 방법이 될꺼같습니다.\n  지금 상황은 외래키 식별자를 직접 다루게 되는데 조회할때도 이슈가 있습니다.\n  JpaMAin.Java\n \t...\rMember findMember = em.find(Member.class, member.getId());\rLong findTeamId = findMember.getTeamId();\rTeam findTeam = em.find(Team.class, findTeamId);\r...\r  맴버를 조회하고 그 맴버가 속한 팀을 가져오고 싶을때 찾은 맴버에서 TeamId를 이용해 Team을 찾아야 하는 번잡스러움이 있습니다.\n 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력관계를 만들 수 없다.   테이블은 외래키 키로 조인 을 사용해서 연관된 테이블을 찾는다. 객체는 참조를 사용해서 연관된 객체를 찾는다. 테이블과 객체 사이에는 이런 큰 간격이 있다.   단방향 연관관계  객체 지향 모델링  (객체 연관관계 사용)\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r//@Column(name = \u0026quot;TEAM_ID\u0026quot;)\r//private Long teamId;\r@ManyToOne //Member 입장에서 Member가 N 팀이 1, 1팀에 여러 맴버가 있을 수 있다.\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;) // 조인할 컬럼 명\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  관계가 먼지  @ManyToOne //Member 입장에서 Member가 N 팀이 1, 1팀에 여러 맴버가 있을 수 있다. 조인하려는 컬럼은  @JoinColumn(name = \u0026ldquo;TEAM_ID\u0026rdquo;) // 조인할 컬럼 명\n 객체 지향 모델링  (ORM 매핑)\n 객체 지향 모델링  (연관관계 저장)\n  JpaMain.java\n  // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 단방향 연관관계 설정, 참조 저장\r// 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\r// 조회 Member findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r  findMember.getTeam(); 을 이용하여 Team을 객체 지향 답게 레퍼런스 들을 가져 올수 있는것을 확인 할 수 있었습니다.\n  영속성 컨텍스트 1차 캐시에 추가되어있기 때문에 select 하는 쿼리가 보이지 않지만, select 하는 쿼리도 보고싶다면\n  // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 단방향 연관관계 설정, 참조 저장\r// 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\r// 조회 Member findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r  Jpa가 Member와 Team을 조인하여 한번에 가져온것을 알 수 있습니다.\n  Member.java\n \t...\r@ManyToOne(fetch = FetchType.LAZY) //default : fetch = FetchType.EAGER\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\r...\r  ManyToOne의 fetch default 옵션은 FetchType.EAGER 이지만, fetch = FetchType.LAZY 로 변경하면\n  select 문을 분리하여, 각각 조회해 오는 것을 알 수 있습니다.\n  만약 Team을 변경한다면\n  JpaMain.java\n // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rTeam teamB = new Team();\rteamB.setName(\u0026quot;TeamB\u0026quot;);\rem.persist(teamB);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\rmember.setTeam(teamB);\rem.persist(member);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\r// 조회\rMember findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r  Update 문을 통해 Member의 TEAM_ID 즉 외래키가 업데이트 되는 것을 확인할 수 있습니다.\n 양방향 연관관계  양방향 연관관계와 연관관계의 주인 1 - 기본 양방향 매핑  Member에서 Team을 불러올수 있지만 Team에서 Member를 가져올 수는 없습니다. 현재 Team의 속성에도 추가 되어있지 않고, 연관관계도 없기 때문에 데이터 또한 없습니다. 양방향 매핑 이미지를 보면 Member에서 Team으로 Team에서 Member로 레퍼런스만 넣어둔 다면 가능한데 이런것을 양방향 연관관계 라고 합니다.\n  양방향 객체 연관관계는 변화가 있었지만 테이블 연관관계는 변함이 없습니니다.\n  MEMBER입장에서 TEAM을 가져올때는 MEMBER의 TEAM_ID로 TEAM을 조인해서 가져오면 되고 TEAM입장에서 MEMBER을 가져올때는 MEMBER의 TEAM_ID 중 나의 TEAM_ID를 가지고 있는 회원들만 조인하여 가져오면 됩니다.\n  테이블의 연관관계는 TEAM_ID 라는 외래키 하나로 양방향 연관관계가 됩니다. 테이블에선 양방향이라는 개념이 없고 외래키를 사용하여 양쪽의 연관을 다 알수 있는 것입니다.\n  문제는 객체입니다. Member는 Team을 가지고 있고 Team에서 Member로 갈 수 있는 방법이 없었습니다.\n  Team에 List 타입의 members를 넣어줘야 양쪽으로 참조하여 갈 수 있습니다.\n  테이블은 외래키 하나로 양쪽을 참조할 수 있지만, 객체는 Team team과 List members를 추가해 줘야 양쪽을 참조할 수 있는것이 테이블과 객체의 가장큰 차이점 입니다.\n  Team.java - members 추가\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;) // 1:N 관계에서 상대편(Member)에 team으로 매핑이 되어있는 것 이라고 지정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  JpaMain.java - Team에 2명의 유저를 넣고, Team을 조회해서 Team의 모든 유저들을 조회\n  // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member2\u0026quot;);\r//member.setTeamId(team.getId());\rmember1.setTeam(team); // 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member1);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\r// 해당 소스가 없으면, 영속 컨텍스트의 1차 캐시에서 바로 가져오기 때문에 select 쿼리가 나오지 안습니다.\rMember findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;findUser = \u0026quot;+m.getUsername());\r}\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r 양방향 매핑  (반대 방향으로 객체 그래프 탐색)\n \t// 조회\rTeam findTeam = em.find(Team.class, team.getId());\rint memberSize = findTeam.getMembers().size() //역방향 조회\r  작성했던 코드를 보며 궁금증이 생기는데\n  Member.java\n  @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\r  Team.java\n  @OneToMany(mappedBy = \u0026quot;team\u0026quot;) private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r  둘의 차이는 멀까 어떠한 것은 JoinCoulmn이고 어떠한것은 mappedBy를 쓰는걸까\n 연관관계의 주인과 mappedBy   mappedBy = JPA의 첫번째 시련(C의 포인터 같은..) mappedBy는 처음에는 이해하기 어렵다. 객체와 테이블간에 연관관계를 맺는 차이를 이해해야한다.   객체와 테이블의 관계를 맺는 차이   객체 연관관계 = 2개  회원 -\u0026gt; 팀 연관관계 1개 (단방향) 팀 -\u0026gt; 회원 연관관계 1개 (단방향)       Member 에서 Team team(참조)을 이용해 Team으로 가는 연관관계 1개 Team 에서 List Members(참조)를 이용해 Member로 가는 연관관계 1개     테이블 연관관계 = 1개  회원 \u0026lt;-\u0026gt; 팀의 연관관계 1개 (양방향)      TEAM_ID를 이용해 조인을 하면 MEMBER에서 TEAM을 알 수 있고, TEAM에서도 팀에 포함된 MEMBER들을 알 수 있습니다.\n 객체의 양방향 관계   객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다. 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 반들어야 한다.   테이블의 양방향 연관관계   테이블은 외래 키 하나로 두 테이블의 연관관계를 관리 MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐 (양쪽으로 조인할 수 있다.)   -- MEMBER 관점\rSELECT * FROM MEMBER M\rJOIN TEAM T ON M.MEMBER_ID = T.MEMBER_ID;\r-- TEAM 관점\rSELECT * FROM TEAM T\rJOIN MEMBER M ON T.MEMBER_ID = M.MEMBER_ID;\r 둘 중 하나로 외래 키를 관리해야 한다.  테이블의 MEMBER의 TEAM_ID를 변경하기 위해서 Member 객체의 team 을 수정해야 할지, Team객체의 members를 수정해야할지 애매한 점이 생깁니다. 테이블 입장에서는 어떠한 객체에서 TEAM_ID 외래키를 Update를 해도 다르지 않으니까요. 이러한 아이러니한 점을 해결하기 위해 연관관계의 주인이라는 개념이 사용됩니다.\n 연관관계의 주인  양방향 매핑 규칙\n 객체의 두 관계중 하나를 연관관계의 주인으로 지정 연관관계의 주인만이 외래 키를 관리 (등록, 수정) 주인이 아닌 쪽은 읽기만 가능 주인은 mappedBy(수동적) 속성 사용하지 않는다. 주인이 아니면 mappedBy 속성으로 상대 객체를 주인으로 지정   누구를 주인으로 해야할까 ?   외래 키가 있는 곳을 주인으로 정해라 여기서는 Member.team이 연관관계의 주인 ManyToOne 에서 Many 쪽이 연관관계의 주인 (OneToOne에서도 와래 키 있는곳이 주인)    Member.java\n  @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;) //연관관계를 여기서 관리하겠다.\rprivate Team team;\r  Team.java\n  @OneToMany(mappedBy = \u0026quot;team\u0026quot;) // 1:N 관계에서 상대편(Member)에 team으로 매핑이 되어있는 것 이라고 지정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r 만일 외래 키가 없는 테이블을 주인으로 지정할 때의 문제점  만일 외래 키가 없는 객체를 주인으로 설정할 경우 값을 변경한다면\n외래 키가 있는 테이블을 수정하기 때문에 내가 수정한 객체는 Team 이지만, Member의 객체 Update Sql이 나가는 황당한 경우가 있을 수 있습니다.\n  1:N에서 1이 연관관계의 주인일때 1을 수정하면 N의 수정이 일어나기 때문에 성능 이슈가 발생할 수 있습니다.\n 양방향 매핑시 가장 많이 하는 실수  (연관관계의 주인에 값을 입력하지 않음)\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member()\rmember.setName(\u0026quot;member1\u0026quot;);\r//역방향 (주인이 아닌 방향)만 값 세팅\rteam.getMembers().add(member);\tem.persist(member)\r  JpaMain.java\n  Member member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rem.persist(member);\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.getMembers().add(member);\rem.persist(team);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\rtx.commit();\r  Insert SQL은 2건이 나갔고, DB에서 확인해보면\n  Member와 Team이 저장되었지만, MEMBER의 MEMBER_ID는 null 인것을 확인 할 수 있습니다.\nTeam의\n @OneToMany(mappedBy = \u0026quot;team\u0026quot;) private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r  은 가짜 매핑이기 때문에 저장, 수정은 안되고 조회만 가능 !\n  JpaMain.java\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\r//team.getMembers().add(member);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\rtx.commit();\r  연관관계의 주인인 Member에 Team 값을 넣고 저장을 하게 되면 TEAM_ID의 값에 1로 저장되는 것을 확인할 수 있습니다.\n 그러면 연관관계의 주인에만 데이터를 넣으면 될까 ?  JPA 입장에서는 연관관계의 주인에만 데이터를 입력하면 되지만..\n  JpaMain.java\n \rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\r//team.getMembers().add(member); // 안넣어도 된다.\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\rTeam findTeam = em.find(Team.class, team.getId());\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rtx.commit();\r  당연히 getMembers로 가져온 Member들에도 추가한 member가 있습니다. JPA 지연로딩의 기능인데 Team을 조회하고 Member를 한번더 조회하는것을 볼 수 있습니다.\n  실제 members를 사용하는 시점에 조회 SQL을 수행하게 됩니다.\n  //team.getMembers().add(member); // 안넣어도 된다. team의 getMembers()에 새로운 member를 추가 하지 않아도 문제가 없었지만 em.flush();과 em.clear();를 제거 한다면\n  JpaMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member);\r//em.flush(); // 영속성 컨텍스트 플러시\r//em.clear(); // 영속성 컨텍스트 초기화\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  Insert문 이후에 아까와 달리 Select 문을 수행하지 않으며, members 루프를 수행하지 않는 것을 확인 할 수 있습니다.\n  Member의 값이 DB에 저장되기 전이며, 현재 Team이 가지고 있는 members에는 추가한 member의 값이 없기 때문에 출력해도 아무 것도 나오지 않는다.\n  이러한 문제점이 있을 수 있고, 객체 지향적으로 생각을 해보면 Team 또한 team.getMembers().add(member); 를 이용해 값을 세팅해 주는것이 맞다.\n  그리고 테스트케이스 작성중 JPA 없이도 순수하게 자바 코드 상태로도 테스트케이스를 수행하게 되는데 member.getTeam()은 되는데 team.getMembers() 할경우 null로 이상하게 동작하게 됩니다.\n  JpaMain.java \u0026ndash; Team.getMembers()에 member 추가\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rteam.getMembers().add(member);\r//em.flush(); // 영속성 컨텍스트 플러시\r//em.clear(); // 영속성 컨텍스트 초기화\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  members에 추가한 member가 있는것을 확인할 수 있다.\n  결론은 양쪽 객체에 값을 세팅하는 것이 맞습니다.\n 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.  (순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야한다.)\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rteam.getMembers().add(member); // 값 설정 **\rmember.setTeam(team); // 연관관계 주인에 값 설정 ***\rem.persist(member);\r 양방향 연관관계 주의 - 실습   순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 1차 캐시에는 값이 없는 상태이므로 최악의 경우 버그가 발생할 수있습니다.    연관관계 편의 메소드를 생성하자    Member.java \u0026ndash; setTeam에서 getMemebers().add(this)를 추가\n \t...\rpublic void changeTeam(Team team) {\rthis.team = team;\rteam.getMembers().add(this); // 자기 자신(Member)를 team의 members에 추가\r}\r...\r  JpaMain.java \u0026ndash; team.getMembers().add(member); 는 삭제\n Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeam(team); // ***\rmember.changeTeam(team); // ***\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member); // **\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  이 연관관계 편의 메소드를 이용하면 한쪽만 세팅해도, 양쪽으로 데이터가 들어가 관리가 편하게 됩니다.\n  또 setTeam이라는 setter의 관습적인 네이밍 말고, changeTeam으로 만들어 단순히 set 하는 메소드가 아닌 다른 비지니스로직이 포함된 메소드라는 것을 명시합니다.\n  chageTeam을 실제로 개발하여 사용하면 딥하게 생각해서 team안에 추가하는 member가 있는지 체크하거나 team이 null인지도 체크 해야하고 신경써야 할 부분도 있고 Member를 수정한다면, 기존의 member를 제거하고 수정한 member로 세팅하는 그런 로직도 필요합니다.\n  Team에서도 연관관계 편의 메소드를 이용해 Member를 세팅할 수가 있는데,\n  Team.java\n  public void addMember(Member member){\rmember.setTeam(this);\rmembers.add(member);\r}\r  JpaMain.java\n \rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.changeTeam(team); // ***\rteam.addMember(member); // ***\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member); // **\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  양쪽에서 편의 메소드를 이용해 값을 설정할 수 있지만 최악의 경우 무한루프에 걸릴 수도 있으니 한쪽을 정해서 한쪽에서만 사용하는게 좋습니다.\n  양방향 매핑시에 무한 루프를 조심하자 - 예) toString(), lombok, Json 생성 라이브러리    Member.java \u0026ndash; toString() 추가\n  @Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username \u0026quot;, team=\u0026quot; + team +\t// team.toString() 과 같음 양방향 매핑시에 무한 루프\r'}';\r}\r  Team.java \u0026ndash; toString() 추가\n  @Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r\u0026quot;, members=\u0026quot; + members + // members의 앨리먼츠들 모두 출력함.\r'}';\r}\r  JpaMain Team을 출력해봄 (.toString())\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.changeTeam(team); // ***\rteam.addMember(member); // ***\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member); // **\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\r//System.out.println(\u0026quot;findTeam = \u0026quot;+ findTeam.toString()); //아래와 동일\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+ findTeam);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  또한 lombok에서 자동으로 toString()을 생성하거나, Json 생성라이브러리에서 객체를 쭉 읽어오면서 무한루프에 갇히게 되면 어마 어마한 장애로 이어질 수 있습니다. 실제 Json 생성라이브러리는 컨트롤러에서 엔티티를 직접 리스폰스로 보내게 되면 양방향으로 연관관계가 설정되어있으면 그때 Json으로 생성시 Member를 보며 Team이 있네 하고 Team으로 가서 Member가 있네 하고 또 다시 Member로 계속 타고 들어가게 됩니다.\n 무한루프를 최대한 피할 수 있는 방법   lombok에서 toString 만드는거 쓰지마라. 쓰려면 객체 레퍼런스 빼고 사용해야 한다. API 컨트롤러에서는 엔티티를 바로 반환하지 마라. DTO로 변환해서 반환하여 사용해야 한다.    이러한 무한루프에 빠질 수 있다.    엔티티가 변경될 수 있는데 변경하게 되면 API SPEC이 변경된다. (사용하는 입장에서는 논의 없던 컬럼이 추가/삭제에 고통받을 수 있습니다.)       양방향 매핑 정리   단방향 매핑만으로도 이미 연관관계 매핑은 완료 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐 JPQL에서 역방향으로 탐색할 일이 많음 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)    최초 개발을 하게되면 단방향 매핑부터 설계를 끝내놓고 양방향에 대해서 작업을 해야합니다. Jpa에서 단방향 매핑만으로 객체와 테이블 매핑하는 것은 완료가 된것입니다. 객체 입장에서는 양방향 매핑을 추가하면 연관관계 편의 메소드나 생각해야 할 것이 많아집니다. 그러면 언제 양방향 매핑을 추가해야 하냐면 JPQL에서 역방향으로 탐색할 일이 많아질때 필요할 때 추가하면 됩니다.   추후 추가를 하여도 자바 코드 추가되는 것도 많지 않으며, 제일 중요한 테이블에 변화가 없기 때문에 개발하다 진짜 필요할때 아니면 단방향으로 개발을 진행하여도 문제가 없습니다.\n 연관관계의 주인을 정하는 기준   비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함   참고- 자바 ORM 표준 JPA - 김영한 ","description":"연관관계 매핑","id":57,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 연관관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/relation-mapping/"},{"content":"Database C:/Users/user/dbname not found, either pre-create it or allow remote database creation 오류 발생 문제  H2 데이터베이스 신규 생성 및 연결시 아래 오류가 나오며 생성이 안되는 경우\n Database `C:/Users/user/dbname` not found, either pre-create it or allow remote database creation\r 해결방법   C:/Users/user/ 경로에 dbname.mv.db 파일을 생성 jdbc:h2:~/dbname을 입력후 연결을 해본다.(처음 생성시에만)\n- 이후 jdbc:h2:tcp://localhost/~/dbname 으로 접속   ","description":"Database `C:/Users/offetuoso/jpashop` not found, either pre-create it or allow remote database creation","id":58,"section":"blog","tags":["Troubleshooting"],"title":"Database `C:/Users/user/dbname` not found, either pre-create it or allow remote database creation","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/database/h2/h2-create-db/"},{"content":"기본키 매핑  기본 키 매핑 어노테이션    @Id @GeneratedValue   @Id @GeneratedValue(strategy = GenerationTpye.AUTO)\rprivate Long id;\r 기본 키 매핑 방법    직접 할당 : @Id 만 사용 자동 생성(@GeneratedValue)  IDENTITY : 데이터베이스에 위임, MySLQ) SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE  @SequenceGenerator 필요     TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용  @TableGenerator 필요   AUTO: 방언에 따라 자동 지정, 기본값   Id 직접할당 - @Id 사용   Member.java 기본 키 매핑에 좀더 집중하기 위해 Memeber의 Id를 String 으로 변경하고, Id, name을 제외한 나머지를 일단 제거합니다.\n  package hellojpa;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\rprivate String id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) private String userName;\rpublic Member() {\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getUserName() {\rreturn userName;\r}\rpublic void setUserName(String userName) {\rthis.userName = userName;\r}\r}\r  JpaMain.java\n \tMember member1 = new Member();\rmember1.setId(\u0026quot;USER_A\u0026quot;); // 아이디 채번을 직접하여 할당\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setId(\u0026quot;USER_B\u0026quot;);\rmember2.setUserName(\u0026quot;유저B\u0026quot;);\rem.persist(member2);\rtx.commit();\r Id 자동할당 - @GeneratedValue   GeneratedValue의 전략은 AUTO, IDENTITY, SEQUENCE, TABLE가 있으며, AUTO는 방언에 따라 다르게 생성\n  @GeneratedValue(strategy = GenerationType.AUTO) @GeneratedValue(strategy = GenerationType.IDENTITY) 위임함\r@eneratedValue(strategy = GenerationType.SEQUENCE) @GeneratedValue(strategy = GenerationType.TABLE)  GenerationType.IDENTITY  GenerationType.IDENTITY - 특징   기본 키 생성을 데이터베이스에 위임 주로 MySQL, PostgreSQL, SQL Server. DB2에서 사용 예) MySQL의 AUTO_INCREMENT JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행 AUTO_INCREMENMT는 데이터베이스에 INSERT SQL을 실헹한 이후에 ID 값을 알 수 있음 IDENTITY 전략은 em.persist() 시점에 즉시 INSERT_SQL 실행하고 DB에서 식별자를 조회    @Id\r@GeneratedValue(strategy = GenerationType.IDENTITY) private String id;\r Hibernate: drop table Member if exists\rHibernate: create table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r)\r12월 26, 2021 10:48:37 오후 org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection\rINFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@2a2da905] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.\r12월 26, 2021 10:48:37 오후 org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection\rINFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@1b11ef33] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.\r12월 26, 2021 10:48:37 오후 org.hibernate.tool.schema.internal.ExceptionHandlerLoggedImpl handleException\rWARN: GenerationTarget encountered exception accepting command : Error executing DDL \u0026quot;\rcreate table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r)\u0026quot; via JDBC Statement\rorg.hibernate.tool.schema.spi.CommandAcceptanceException: Error executing DDL \u0026quot;\rcreate table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r)\u0026quot; via JDBC Statement\rat org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:67)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.applySqlString(SchemaCreatorImpl.java:440)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.applySqlStrings(SchemaCreatorImpl.java:424)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.createFromMetadata(SchemaCreatorImpl.java:315)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.performCreation(SchemaCreatorImpl.java:166)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.doCreation(SchemaCreatorImpl.java:135)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.doCreation(SchemaCreatorImpl.java:121)\rat org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:155)\rat org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:72)\rat org.hibernate.internal.SessionFactoryImpl.\u0026lt;init\u0026gt;(SessionFactoryImpl.java:310)\rat org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:467)\rat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:939)\rat org.hibernate.jpa.HibernatePersistenceProvider.createEntityManagerFactory(HibernatePersistenceProvider.java:56)\rat javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:79)\rat javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:54)\rat hellojpa.JpaMain.main(JpaMain.java:12)\rCaused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: \u0026quot;CHARACTER VARYING(255)\u0026quot;; SQL statement:\rcreate table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r) [50100-202]\rat org.h2.message.DbException.getJdbcSQLException(DbException.java:556)\rat org.h2.message.DbException.getJdbcSQLException(DbException.java:477)\rat org.h2.message.DbException.get(DbException.java:223)\rat org.h2.message.DbException.get(DbException.java:199)\rat org.h2.message.DbException.getUnsupportedException(DbException.java:287)\rat org.h2.command.ddl.SequenceOptions.getBounds(SequenceOptions.java:313)\rat org.h2.command.ddl.SequenceOptions.getBounds(SequenceOptions.java:244)\rat org.h2.schema.Sequence.\u0026lt;init\u0026gt;(Sequence.java:101)\rat org.h2.table.Column.initializeSequence(Column.java:459)\rat org.h2.command.ddl.CommandWithColumns.generateSequences(CommandWithColumns.java:103)\rat org.h2.command.ddl.CreateTable.update(CreateTable.java:110)\rat org.h2.command.CommandContainer.update(CommandContainer.java:173)\rat org.h2.command.Command.executeUpdate(Command.java:247)\rat org.h2.server.TcpServerThread.process(TcpServerThread.java:413)\rat org.h2.server.TcpServerThread.run(TcpServerThread.java:190)\rat java.base/java.lang.Thread.run(Thread.java:834)\rat org.h2.message.DbException.getJdbcSQLException(DbException.java:507)\rat org.h2.engine.SessionRemote.done(SessionRemote.java:611)\rat org.h2.command.CommandRemote.executeUpdate(CommandRemote.java:237)\rat org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:228)\rat org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:201)\rat org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:54)\r... 15 more\r12월 26, 2021 10:48:37 오후 org.hibernate.tool.schema.internal.SchemaCreatorImpl applyImportSources\rINFO: HHH000476: Executing import script 'org.hibernate.tool.schema.internal.exec.ScriptSourceInputNonExistentImpl@1eba372c'\r  Member.java\n  persistence.xml에서 MySQL 방언으로 다시 실행\n  AUTO_INCREMENT로 키를 생성하겠다 설정이 된것을 볼 수 있습니다.\n  H2 1.4.202 버전을 사용하고 있는데, @GeneratedValue(strategy = GenerationType.IDENTITY) 가 적용이 안되고, ERROR: NULL not allowed for column \u0026ldquo;ID\u0026rdquo;; SQL statement: /* insert hellojpa.Member */ insert into Member (id, name) values (null, ?) [23502-200] 오류가 발생하여 검색을 해보니 최신 H2 DB에 버그라고 하네요.\n h2 데이터베이스는 꼭 다음 링크에 들어가서 1.4.200 버전을 설치해주세요.\r최근에 나온 2.0.202 버전을 설치하면 일부 기능이 정상 동작하지 않습니다\r\r 2.0.200 버전으로 다시 설치 하였습니다.\n Hibernate: /* insert hellojpa.Member\r*/ insert into\rMember\r(id, name) values\r(null, ?)\r12월 26, 2021 11:09:52 오후 org.hibernate.engine.jdbc.spi.SqlExceptionHelper logExceptions\rWARN: SQL Error: 23502, SQLState: 23502\r12월 26, 2021 11:09:52 오후 org.hibernate.engine.jdbc.spi.SqlExceptionHelper logExceptions\rERROR: NULL not allowed for column \u0026quot;ID\u0026quot;; SQL statement:\r/* insert hellojpa.Member */ insert into Member (id, name) values (null, ?) [23502-200]\r12월 26, 2021 11:09:52 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl stop\rINFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]\rProcess finished with exit code 0\r IDENTITY 전략 애매한점  strategy = GenerationType.IDENTITY를 사용할 경우 Key를 Null로 하여 DB에 인서트할 당시에 키가 생성하게됩니다. 영속성 컨텍스트에서 관리를 하기 위해서는 PK값이 있어야 합니다. 하지만 이 전략은 DB에 들어가봐야 PK를 알 수 있습니다. 그래서 제약이 생기게 됩니다.\n  GeneratedValue 전략을 다시 GenerationType.IDENTITY로 바꿔서 테스트 해보겠습니다.\n  Memeber.java\n @Entity\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.IDENTITY)\rprivate Long id;\r  JpaMain.java\n  System.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rSystem.out.println(\u0026quot;member1.id : \u0026quot; +member1.getId());\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member2);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  persist() 시점에 Insert SQL 이 날라가게 됩니다. 그리고 바로 영속성 컨텍스트의 1차 캐시에 Id 값을 가져올 수 있는 것 을 확인 할 수 있습니다.\n GenerationType.SEQUENCE  GenerationType.SEQUENCE - 특징   데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트( 예) 오라클 시퀀스) 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용    Member.java GeneratedValue 전략을 GenerationType.SEQUENCE 로 변경\n  @Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE)\rprivate String id;\r  GeneratedValue(strategy = GenerationType.SEQUENCE) 적용시 오류 발생이 되었고 오류는 아래와 같습니다.\n \rjavax.persistence.PersistenceException: org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:154)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:181)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:188)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:807)\rat org.hibernate.internal.SessionImpl.persist(SessionImpl.java:785)\rat hellojpa.JpaMain.main(JpaMain.java:22)\rCaused by: org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String\rat org.hibernate.id.IdentifierGeneratorHelper.getIntegralDataTypeHolder(IdentifierGeneratorHelper.java:224)\rat org.hibernate.id.enhanced.SequenceStructure$1.getNextValue(SequenceStructure.java:98)\rat org.hibernate.id.enhanced.NoopOptimizer.generate(NoopOptimizer.java:40)\rat org.hibernate.id.enhanced.SequenceStyleGenerator.generate(SequenceStyleGenerator.java:482)\rat org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:119)\rat org.hibernate.event.internal.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:192)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:135)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:62)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:800)\r... 2 more\r  Caused by: org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String\n  알 수 없는 정수 데이터 유형 : String\n  Member.java의 Id 가 현재 String이라 나오던 문제였습니다.\n  Member.java - String Id -\u0026gt; Long Id로 변경\n package hellojpa;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE)\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) // 엔티티 명은 userName으로, DB 컬럼명을 name으로 매핑하여 사용 지정\rprivate String userName;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUserName() {\rreturn userName;\r}\rpublic void setUserName(String userName) {\rthis.userName = userName;\r}\r}\r  call next value for hibernate_sequence 기본 시퀀스를 사용해서 새로운 키값을 생성하게 되는데, 테이블 마다 시퀀스를 따로 관리하고 싶다면 @SequnceGenerator를 사용하면 됩니다.\n Sequence 전략 - 매핑  Member.java\n @Entity\r@SequenceGenerator(\rname = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;\r, sequenceName = \u0026quot;MEMBER_SEQ\u0026quot; // 매핑할 데이터베이스 시퀀스 이름\r, initialValue = 1, allocationSize = 1\r)\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE\r, generator = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;) //사용할 Generator 매핑\rprivate Long id;\r SEQUENCE - @SequenceGenerator   주의 allocationSize 기본 값 = 50      속성 설명 기본값     name 식별자 생성기 이름 필수   sequenceName 데이터베이스에 등록되어있는 시퀀스 이름 hibernate_sequence   initialValue DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 시작하는 수를 1로 지정한다. 1   allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨) 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다 50   catalog, schema 데이터베이스 catalog, schema 이름     SEQUENCE - 추가 설명  GeneratedValue의 전략을 GenerationType.SEQUENCE로 사용하게 되면 sequence를 생성하게 되는데\n Hibernate: drop table Member if exists\rHibernate: drop sequence if exists MEMBER_SEQ\rHibernate: create sequence MEMBER_SEQ start with 1 increment by 1 // 1부터 시작하여, 1씩 증가한다.\rHibernate:   JpaMain.java\n  System.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rSystem.out.println(\u0026quot;member1.id : \u0026quot; +member1.getId());\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member2);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  SEQUECE 전략도 영속성 컨텍스트에 저장할 당시 PK 값이 필요하기 때문에,\n ----------- 0\rHibernate: call next value for MEMBER_SEQ\rmember1.id : 1\r----------- 1\r  \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 0 과 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 1 사이에서 call next value for MEMBER_SEQ 시퀀스 nextVal으로 키값을 받아, 영속성 컨텍스트의 1차 캐시에 이미 id와 userName이 들어간 상태이고 2번째 유저 또한 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 1 과 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 2 영속성 컨텍스트에 저장됩니다. 이후 commit()을 하게되면 Insert를 하게됩니다.\n  IDENTITY에서는 안되지만, SEQUENCE에서는 JDBC BATCH를 이용한 버퍼를 이용할 수 있습니다.\n  이렇게 보다보니 성능에 한번에 인서트 하는게 아니라 seq 얻어올때, Insert 할때 자꾸 DB에 네트워킹을 통해 성능적으로 떨어지는 것 아닌가 싶기도합니다. 그래서 성능 최적화를 위하여 JPA에 allocationSize로 성능을 최적화 하는 방법이 있습니다. 자세한 설명은 뒤에서 하겠습니다.\n GenerationType.TABLE  GenerationType.TABLE - 특징   키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략 장점 : 모든 데이터베이스에 적용 가능 단점 : 성능   Table 전략 - 매핑  Member.java\n @Entity\r@TableGenerator(\rname = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;\r, table = \u0026quot;MY_SEQUENCE\u0026quot; // 매핑할 테이블명\r, pkColumnValue = \u0026quot;MEMBER_SEQ\u0026quot; , allocationSize = 1)\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.TABLE\r, generator = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;) //사용할 Generator 매핑\rprivate Long id;\r ctrate table MY_SEQUENCE (\rsequence_name varchar(255) not null,\rnext_val bigint,\rprimary ket (sequence_name)\r)\r  수정하고 애플리케이션 재시작 하면, JPA가 자동으로 MY_SEQUENCE 테이블을 생성해준다.\n @TableGenerator - 속성    속성 설명 기본값     name 식별자 생성기 이름 필수   table 키 생성 테이블 이름 hibernate_sequences   pkColumnName 시퀀스 컬럼명 sequence_name   valueColumnName 시퀀스 값 컬럼명 next_val   pkColumnValue 키로 사용할 값 이름 엔티티 이름   initalValue 초기 값, 마지막으로 생성된 값이 기준이다. 0   allocationSize 시퀀스 한 번 호출에 증가하는 수 50   catalog, schema 데이터베이스 catalog, schema 이름    uniqueConstains(DDL) 유니크 제약 조건을 지정할 수 있다.      운영에서는 table 전략을 사용하기는 부담스럽고 각 테이블의 sequence를 사용한 sequence 전략을 적극 채용하여 사용한다고 합니다.\n 권장하는 식별자 생성 전략    기본 키 제약 조건 : null 아님, 유일, 변하면 안된다. 미래까지 이 조건을 만족하는 자연키를 찾기 어렵다. 대리키(대체키)를 사용하자. ( 비즈니스와 상관없는 랜덤키) 예를 들어 주민등록번호도 기본 키로 적절하지 않다. 권장 : Long형 + 대체키 + 카 생성전략 사용    10억이 넘어도 동작해야 하니까 Long형, 시퀀스를 쓴다던가, uuid를 쓴다던가 대체키를 쓰시고, 카생성 전략들을 조합해서 사용하는 것을 권장\nAUTO-INCREMENT나 SEQUENCE Object 둘중 하나를 사용하시고 아니면 때에 따라서 uuid, 랜덤 값을 조합한 회사내의 룰을 따르길 권장. 절대 비즈니스 로직을 키로 끌고 오는것을 권장하지는 않는다고 합니다.\n allocationSize를 이용한 성능향상   allocationSize를 1로 설정하여 1씩 증가하게 세팅을 해두었는데, 기본 값은 50 입니다. 기본 값이 50인 이유는 JPA는 새로운 키 50개를 한번에 만들어 놓고, DB에 50으로 세팅하고 메모리 상에서 1부터 50 까지 순차적으로 사용합니다. 이후 50개를 모두 사용하면, call next를 하여 51 부터 100까지 미리 만들어 사용합니다.\n또 대단한 것이 어떤 DB를 사용해도 이슈 없이 동작한다고 합니다.\n @Entity\r@SequenceGenerator(\rname = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;\r, sequenceName = \u0026quot;MEMBER_SEQ\u0026quot; // 매핑할 데이터베이스 시퀀스 이름\r, initialValue = 1, allocationSize = 50)\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE,\rgenerator = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;)\rprivate Long id;\r  현재 값은 -1이고 증가는 50 인것을 볼 수 있습니다.\n  JpaMain.java는 객체 생성 및 persist() 모두 삭제\n call next value for MEMBER_SEQ;\r  위 SQL을 통항 next value를 가져오면 1이 되길 원하는 것입니다.\n  JpaMain.java\n  System.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rSystem.out.println(\u0026quot;member1.id : \u0026quot; +member1.getId());\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저B\u0026quot;);\r//em.persist(member2);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rMember member3 = new Member();\rmember3.setUserName(\u0026quot;유저C\u0026quot;);\r//em.persist(member3);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 3\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  처음 call next value for MEMBER_SEQ;를 호출하고 1이면 50개의 키를 메모리로 가져온 것이 아니기 때문에 1번더 호출합니다.\n  다시 JpaMain에 persist를 추가하여 테스트 해보면\n \tSystem.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저B\u0026quot;);\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rMember member3 = new Member();\rmember3.setUserName(\u0026quot;유저C\u0026quot;);\rSystem.out.println(\u0026quot;----------- 3\u0026quot;);\rem.persist(member1); // call next value for MEMBER_SEQ; DB SEQ = 1 , Key = 1\rem.persist(member2); // call next value for MEMBER_SEQ; DB SEQ = 51 , Key = 2\rem.persist(member3); // memory; DB SEQ = 51 , Key = 3\rSystem.out.println(\u0026quot;----------- 4\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  allocationSize를 크게 잡아 메모리에 두고 사용할 수 있지만, 애플리케이션이 내려가게 되면 사용하지 않았던 Id 값들의 구멍이 생겨 낭비가 될 수 있기 때문에 50 ~ 100 정도가 적당합니다.\n  Table 전략 또한 동일하며, 테이블의 데이터를 미리 설정한 값 만큼 미리 세팅하고 키를 메모리에서 생성하여 사용합니다. 물론 서버가 여러대인 경우에도 서버 각각 중복되지 않고 호출한 순서대로 1~50 , 50 ~100 씩 할당받아 메모리에 키를 두고 사용합니다. 때문에 동시성 문제가 발생하지 않고 문제없이 동작합니다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"기본키 매핑","id":59,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 기본키 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/primary-key-mapping/"},{"content":"실전 예제 1 - 요구사항 분석과 기본 매핑  요구사항 분석    회원은 상품을 주문할 수 있다. 주문 시 여러 종류의 상품을 선택할 수 있다.   기능 목록    회원 기능  회원등록 회원조회       상품 기능  상품등록 상품수정 상품조회       주문 기능  상품주문 주문내역조회 주문취소     도메인 모델 분석    회원과 주문의 관계 : 회원은 여러 번 주문할 수 있다. (1:n)     주문과 상품의 관계 : 주문할 때 여러 상품을 선택할 수 있다. 반대로 같은 상픔도 여러번 주문될 수 있다. 주문상품 이라는 모델을 만들어서 다대다 관계를 일대다, 다대일 괸계로 풀어냄   테이블 설걔  엔티티 설계와 매핑  Maven Project 생성  pom.xml - 수정 depency 추가\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;jpa-basic\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jpa-shop\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- JPA 하이버네이트 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.3.10.Final\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- H2 데이터베이스 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/project\u0026gt;\r  jpashop \u0026gt; src \u0026gt; main \u0026gt; resources \u0026gt; persistence.xml 생성\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;jpashop\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/jpashop\u0026quot;/\u0026gt;\r\u0026lt;!--\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.MySQL5Dialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r```\r\u0026gt; jpa-shop \u0026gt; src \u0026gt; java \u0026gt; jpabasic \u0026gt; jpashop \u0026gt; domain - 패키지 생성\r\u0026gt; domain 패키지 안에 엔티티 추가 \u0026gt; Member.java 생성\r```\rpackage jpabasic.jpashop.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rpublic void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r}\r```\r\u0026gt; Order.java\r```\rpackage jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.Date;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){\r}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long memberId;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getMemberId() {\rreturn memberId;\r}\rpublic void setMemberId(Long memberId) {\rthis.memberId = memberId;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\r}\r```\r\u0026gt; OrderStatus.java\r package jpabasic.jpashop.domain;\npublic enum OrderStatus { ORDER, CANCEL }\n\r\u0026gt; Item.java\r```\rpackage jpabasic.jpashop.domain;\rimport javax.persistence.Column;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Item {\rpublic Item(){\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r```\r\u0026gt; OrderItem.java\r package jpabasic.jpashop.domain;\nimport javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id;\n@Entity public class OrderItem { public OrderItem(){ }\n@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;ORDER_ID\u0026quot;)\rprivate Long orderId;\r@Column(name = \u0026quot;ITEM_ID\u0026quot;)\rprivate Long itemId;\rprivate int orderPrice;\rprivate int count;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getOrderId() {\rreturn orderId;\r}\rpublic void setOrderId(Long orderId) {\rthis.orderId = orderId;\r}\rpublic Long getItemId() {\rreturn itemId;\r}\rpublic void setItemId(Long itemId) {\rthis.itemId = itemId;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\r }\n\r\u0026gt; jpashop \u0026gt; src \u0026gt; main \u0026gt; java \u0026gt; jpabasic \u0026gt; jpashop \u0026gt; JpaMain.java 생성 ```\rpackage jpabasic.jpashop;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpashop\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r```\r\u0026gt; 애플리케이션 재시작 ```\rHibernate: drop table Item if exists\rHibernate: drop table Member if exists\rHibernate: drop table OrderItem if exists\rHibernate: drop table ORDERS if exists\rHibernate: drop sequence if exists hibernate_sequence\rHibernate: create sequence hibernate_sequence start with 1 increment by 1\rHibernate: create table Item (\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rprimary key (ITEM_ID)\r)\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rcicy varchar(255),\rname varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rprimary key (MEMBER_ID)\r)\rHibernate: create table OrderItem (\rOFDER_ITEM_ID bigint not null,\rcount integer not null,\rITEM_ID bigint,\rORDER_ID bigint,\rorderPrice integer not null,\rprimary key (OFDER_ITEM_ID)\r)\rHibernate: create table ORDERS (\rORDER_ID bigint not null,\rMEMBER_ID bigint,\rorderDate timestamp,\rstatus varchar(255),\rprimary key (ORDER_ID)\r)\rProcess finished with exit code 0\r```\r\u0026gt; 엔티티 매핑을 하고 이상한 점을 발견하게 되었는데 Order에서 주문한 memberId를 조회하려면 \u0026gt; JpaMain.java\r```\r...\rOrder order = em.find(Order.class, 1L); //오더를 찾고 Long memberId = order.getMemberId();\t//오더에서 memberId를 찾아서\rMember member = em.find(Member.class, memberId); //member를 찾는다. ... ```\r\u0026gt; 뭔가 복잡하고 객체지향적이지 않습니다.\r\u0026gt; Order.java\r```\r...\rprivate Member member; public Member getMember() {\rreturn member;\r}\r...\r```\r\u0026gt; JpaMain.java\r```\r...\rOrder order = em.find(Order.class, 1L); //오더를 찾고 Member member = order.getMember(); //member를 찾는다. Long memberId = member.getMemberId();\r... ```\r\u0026gt; 이런 설계를 데이터 중심 설계라고 합니다.\r### 데이터 중심 설계의 문제점\r---------------------\r\u0026gt; - 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식\r\u0026gt; - 테이블의 외래키 객체에 그대로 가져옴\r\u0026gt; - 객체 그래프 탐색이 불가능\r\u0026gt; - 참조가 없으므로 UML도 잘못됨\r### 해결법\r\u0026gt; 이것을 해결하기 위해 연관관계 매핑을 사용하게 됩니다.\r#### 참고- \u0026lt;a href=\u0026quot;https://www.inflearn.com/course/ORM-JPA-Basic\u0026quot;\u0026gt;자바 ORM 표준 JPA - 김영한\u0026lt;/a\u0026gt; ","description":"요구사항 분석과 기본 매핑","id":60,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 실전 예제 1 - 요구사항 분석과 기본 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-1/"},{"content":"객체와 매핑  객체와 테이블 매핑  목차    객체와 테이블 매핑 필드와 컬럼 매핑 기본 키 매핑 실전 예제 - 1. 요구사항 분석과 기본 매핑   엔티티 매핑 소개    객체와 테이블 매핑 : @Entity, @Table 필드와 컬럼 매핑 : @Column 기본키 매핑 : @Id 연관관계 매핑 : @ManyToOne, @JoinColumn   객체와 테이블 매핑  @Entity    @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 부른다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의  기본 생성자 필수 (파라미터가 없는 public 또는 proteted 생성자) final 클래스, enum, interface, inner 클래스 사용 X 저장할 필드에 final 사용 X     @Entity 속성 정리   속성 : name  JPA에서 사용할 엔티티 이름을 지정한다. 기본값 : 클래스 이름을 그대로 사용 같은 클래스 이름이 없으면 가급적 기본값을 사용한다.     package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity //JPA가 관리하는 객체 Entity\r//@Entity(name=\u0026quot;Member\u0026quot;) //기본 값이 아닌 다른 이름으로 Entity 명을 지정할때 사용\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r @Table    @Table은 엔티티와 매핑할 테이블 지정      속성 기능 기본값     name 매핑할 이름 엔티티 이름을 사용   catalog 데이터베이스 catalog 매핑    schema 데이터베이스 schema 매핑    uniqueConstraints(DDL) DDL 생성시에 유니크 제약조건 생성      JpaMain.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity @Table(name=\u0026quot;MBR\u0026quot;) //데이터베이스의 MBR 테이블로 매핑하여, SQL이 MBR로 생성\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 데이터베이스 스키마 자동 생성    DDL을 애플리케이션 실행 시점에 자동 생성 테이블 중심 -\u0026gt; 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 이렇게 생성된 DDL은 개발장비에서만 사용 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용   데이터베이스 스키마 자동 생성 - 속성   persistence.xml 옵션   \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r    옵션 설명     create 기존테이블 삭제 후 다시 생성 (Drop + Create)   create-drop create와 같으나 종료시점에 테이블 Drop   update 변경분만 반영(운영 DB에는 사용하면 안됨)   validation 엔티티와 테이블이 정상 매핑되어있는지만 확인   none 사용하지 않음    Create  persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r  Member 테이블을 먼저 drop하고 create 문을 실행\n Create - 컬럼 추가 후 애플리케이션 재실행  Member.Java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rprivate int age; // 추가된 컬럼\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name, int age){\rthis.id = id;\rthis.name = name;\rthis.age = age;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r}\r  이후 다시 애플리케이션을 다시 실행시켜보면,\n  추가된 컬럼을 포함하여 Member 테이블이 다시 생성된다.\n create-drop  create와 같지만 종료시점에 생성한 테이블 모두 drop, 예를들어 테스트 케이스 수행후 삭제할때 사용가능\n  persistence.xml\n ...\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create-drop\u0026quot; /\u0026gt;\r...\r  종료시에 drop을 하는것을 볼 수 있다.\n update  추가 했던 age를 잠깐 다시 돌려두고, create 후 update를 실행해 보겠습니다.\n  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r  Member.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  다시 update로 수정후 애플리케이션 재시작\n  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;update\u0026quot; /\u0026gt;\r  Member.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rprivate int age;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name, int age){\rthis.id = id;\rthis.name = name;\rthis.age = age;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r}\r  추가된 컬럼만 alter table을 통하여 스키마 수정됩니다.\n  만약, 컬럼을 삭제한 뒤의 update 상태에서 애플리케이션 재시작할 경우에는\n  Memeber.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  삭제된 컬럼은 update 옵션에 의해 alter table로 수정되지 않습니다. H2 데이터베이스에서 확인하면\n  변경이 안된 테이블을 확인 할 수 있습니다.\n  실수라도 테이블 컬럼을 삭제하여, 데이터가 날아갈 수 있기 때문에 컬럼 삭제는 update 옵션에서 변경을 지원하지 않습니다.\n validate  테이블과 entity가 정상 매핑되어있는지 확인해 줍니다.\n  새로운 컬럼을 추가하고\n  Memeber.java\n  private String address;\r  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;validate\u0026quot; /\u0026gt;\r  애플리케이션 재시작\n  Schema-validation: missing column [address] in table [Member] MEMBER 테이블에 address가 없다고 오류가 발생하게 됩니다.\n none  스키마 자동 생성 사용안함으로 설정\n주석으로 해두는 것과 비슷하며, create, create-drop, update, validate가 아닌 어떤 문자열이 들어가 있어도 none과 같음\n 데이터베이스 방언 별로 달라지는것 확인 (varchar)  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r  create로 스키마 자동생성 옵션을 설정해 두고 재실행\n  persistence.xml - H2 방언 설정\n \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r  persistence.xml - Oracle 방언 설정\n \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r  방언에 따라서 적절하게 데이터베이스에 맞게 해석을 해서 실행을 해주는 것을 확인 할 수 있습니다. 다시 H2로 되돌려둠\n  persistence.xml - H2 방언 설정\n \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r 데이터베이스 스키마 자동 생성 - 주의   운영 장비에는 절대 create, create-drop, update 사용하면 안된다. 개발 초기 단계는 create 또는 update 테스트 서버는 update 또는 validate 스테이징과 운영 서버는 validate 또는 none   DDL 생성 기능  DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.\n  제약조건 추가 : 회원 이름은 필수, 10자 초과 X\n @Column(nullable = false, length = 10)     유니크 제약조건 추가  @Table(uniqueConstraints = {@UniqueConstraint( name = \u0026ldquo;NAME_AGE_UNIQUE\u0026rdquo;, columnNames = {\u0026ldquo;NAME\u0026rdquo;, \u0026ldquo;AGE\u0026rdquo;} )})   제약조건 추가  Member.java\n  @Column(unique = true, length = 10)\rprivate String name;\r  Member entity의 name 사이즈가 varchar(10)으로 생성되고, alter table을 통해 제약조건을 추가한 것을 확인 할 수 있습니다.\n 필드와 컬럼 매핑  요청사항 추가   회원은 일반 회원과 관리자로 구분해야 한다. 회원 가입일과 수정일이 있어야 한다. 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.    Member.java\n package hellojpa;\rimport javax.persistence.*;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) // 엔티티 명은 userName으로, DB 컬럼명을 name으로 매핑하여 사용 지정\rprivate String userName;\rprivate Integer age; // Integer 타입으로 생성하면 DB에서도 가장 Integer랑 가장 적절한 컬럼으로 숫자 타입 생성\r@Enumerated(EnumType.STRING) // 객체에서 ENUM 타입을 쓰고싶을때, DB에는 이넘 타입이 없음(비슷한 것이 있는 DB도 있음)\rprivate RoleType roleType;\r@Temporal(TemporalType.TIMESTAMP) // 날짜타입생성 Date, Time, Timestamp 3가지 타입이 있음\rprivate Date createdDate;\r@Temporal(TemporalType.TIMESTAMP)\rprivate Date modifiedDate;\r@Lob // DB에 varchar를 넘어서는 문자를 넣고 싶을때, 예를 들면 게시판 contents, 파일 바이너리 등\rprivate String description;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\r}\r  RoleType.java\n package hellojpa;\rpublic enum RoleType {\rUSER, ADMIN\r}\r  JpaMain.java 의 tx.transaction 내부 소스를 지우고 실행한다.\n 매핑 어노테이션 정리 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-ㄴ\n   어노테이션 설명     @Column 컬럼 매핑   @Temporal 날짜 타입 매핑   @Enumerated enum 타입 매핑   @Lob BLOB, CLOB 매핑   @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)    @Column 옵션 정리     속성 설명 기본값     name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름   inertable 등록 가능여부 Ture   updatable 변경 가능여부 Ture   nullable(DDL) null 값의 허용 여부 설정. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.    unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용 한다.    columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다. ex) varchar(100) default \u0026lsquo;EMPTY\u0026rsquo; 필드의 자바 타입과 방언 정보를 사용   length(DDL) 문자 길이 제약조건, String 타입에만 사용 255   percision,\nscale(DDL) BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다).\nprecision은 소수점을 포함한 전체 자릿수를, scale은 소수의 자리수다. 참고로 double, float 타입에는 적용되지 않는다. 정밀한 소수를 다루어야 할 때만 사용한다.      insertable과 updateable은 기본적으로 True로 되어있으며, updateable = false 라면, JPA를 통하여 inesert를 하지만, 변경에 대해서 update를 하지 않는다.   nullable은 기본적으로 true이며, false로 설정하면, name varchar(255) not null DDL에 not null 제약조건이 걸린다.\n  unique는 잘 사용하지 않는다. 제약조건 생성시 alter table Member add constraint UK_ektea8vp6e3low620iewuxhlq unique (name) 이런식으로 임의의 유니크 키가 생성되어 오류가 났을때 바로 알아보기가 힘들기 때문. 그래서 @Table를 사용해 제약조건을 지정하여 사용합니다.\n \u0026gt; - @Table(uniqueConstraints = {@UniqueConstraint( name = \u0026quot;NAME_AGE_UNIQUE\u0026quot;,\rcolumnNames = {\u0026quot;NAME\u0026quot;, \u0026quot;AGE\u0026quot;} )})\r @Enumerated   자바 enum 타입을 매피할 때 사용\n  주의 ! ORDINAL 사용 X\n    속성 설명 기본값     value EnumType.ORDINAL : enum 순서를 데이터 베이스에 저장 EnumType.ORDINAL   value EnumType.STRING : enum 이름를 데이터 베이스에 저장 EnumType.ORDINAL    EnumType.ORDINAL 와 EnumType.STRING 비교 EnumType.ORDINAL 일때  Member.java - EnumType.ORDINAL으로 설정 (Setter Getter 추가)\n package hellojpa;\rimport javax.persistence.*;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) // 엔티티 명은 userName으로, DB 컬럼명을 name으로 매핑하여 사용 지정\rprivate String userName;\rprivate Integer age; // Integer 타입으로 생성하면 DB에서도 가장 Integer랑 가장 적절한 컬럼으로 숫자 타입 생성\r@Enumerated(EnumType.ORDINAL) // Enum의 인덱스가 들어감\r//@Enumerated(EnumType.STRING) // 객체에서 ENUM 타입을 쓰고싶을때, DB에는 이넘 타입이 없음(비슷한 것이 있는 DB도 있음)\rprivate RoleType roleType;\r@Temporal(TemporalType.TIMESTAMP) // 날짜타입생성 Date, Time, Timestamp 3가지 타입이 있음\rprivate Date createdDate;\r@Temporal(TemporalType.TIMESTAMP)\rprivate Date modifiedDate;\r@Lob // DB에 varchar를 넘어서는 문자를 넣고 싶을때, 예를 들면 게시판 contents, 파일 바이너리 등\rprivate String description;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUserName() {\rreturn userName;\r}\rpublic void setUserName(String userName) {\rthis.userName = userName;\r}\rpublic Integer getAge() {\rreturn age;\r}\rpublic void setAge(Integer age) {\rthis.age = age;\r}\rpublic RoleType getRoleType() {\rreturn roleType;\r}\rpublic void setRoleType(RoleType roleType) {\rthis.roleType = roleType;\r}\rpublic Date getCreatedDate() {\rreturn createdDate;\r}\rpublic void setCreatedDate(Date createdDate) {\rthis.createdDate = createdDate;\r}\rpublic Date getModifiedDate() {\rreturn modifiedDate;\r}\rpublic void setModifiedDate(Date modifiedDate) {\rthis.modifiedDate = modifiedDate;\r}\rpublic String getDescription() {\rreturn description;\r}\rpublic void setDescription(String description) {\rthis.description = description;\r}\r}\r  JpaMain.java\n \rMember member = new Member();\rmember.setId(21L);\rmember.setAge(27);\rmember.setUserName(\u0026quot;테스트 A\u0026quot;);\rmember.setRoleType(RoleType.ADMIN);\rem.persist(member);\rtx.commit();\r  roleType가 Integer로 생성된 것이 확인 됩니다. DB에 어떻게 저장되었는지 확인 해보겠습니다.\n  EnumType.ORDINAL 로 설정시 DB에는 roleType enum의 인덱스가 들어갑니다. EnumType.ORDINAL을 사용하면 안되는 점이 요구사항으로 Guest가 추가되었다고 생각하게 되면 일반적으로 권한의 중요도에 따라 Guest, User, Admin 순으로 수정을 하였다고 생각하면, DB에 저장되어있는 roleType은 User가 0, Admin이 1인 상태라 데이터의 매핑이 잘못된 데이터가 생기게 됩니다.\n  RoleType.java\n package hellojpa;\rpublic enum RoleType {\rGUEST, USER, ADMIN\r}\r  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;update\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r  JpaMain.java\n  Member member3 = new Member();\rmember3.setId(23L);\rmember3.setAge(29);\rmember3.setUserName(\u0026quot;테스트 C\u0026quot;);\rmember3.setRoleType(RoleType.GUEST);\rem.persist(member3);\rtx.commit();\r  enum의 0번째 인덱스에 GUEST가 추가되면서 DB의 RoleType이 3번째 사용자 빼고 전부 잘못된 것을 확인할 수 있습니다.\n EnumType.STRING 일때  persistence.xml - 다시 create로 바꿔 설정\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r  Memeber.java - EnumType.STRING 으로 설정\n  // 객체에서 ENUM 타입을 쓰고싶을때, DB에는 이넘 타입이 없음(비슷한 것이 있는 DB도 있음)\r//@Enumerated(EnumType.ORDINAL) // Enum의 인덱스가 들어감\r@Enumerated(EnumType.STRING)\rprivate RoleType roleType;\r  재실행\n  roleType 가 varchar(255)로 생성된 것을 확인\n  roleType의 데이터가 GUEST로 들어간 것을 확인할 수 있습니다. 몇자 아끼려다 큰 장애를 경험할 수 있기 때문에 ORDINAL이 아니라 STRING으로 사용하길 권장드립니다.\n @Temporal   날짜 타입(java.util.Date, java.util.Canendar)를 매핑할 때 사용   참고 : LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)\n  Member.java\n  private LocalDate createdAt;\rprivate LocalDate modifiedAt;\rprivate LocalDateTime createdTime;\rprivate LocalDateTime modifiedTime;\r  createdAt, modifiedAt 은 DATE 타입으로 생성되었고, createdTime, modifiedTime은 TIMESTAMP로 생성된 것을 확인 할 수 있습니다.\n @Lob   데이터베이스 BLOB, CLOB 타입과 매핑\n @Lob에는 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑  CLOB : String, char[], java.sql.CLOB BLOB : byte[], java.sql.BLOB     @Transient    필드 매핑 사용 X 데이터베이스에 저장X, 조회X 주로 메모리상에서만 임시로 어떤 값을 보관하고 싶을 때 사용   \t@Transient\rprivate Integer temp;\r 참고   자바 ORM 표준 JPA - 김영한   ","description":"객체와 매핑","id":61,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 객체와 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/entity-mapping/"},{"content":"JPA 영속성 관리 - 내부 동작 방식  영속성 컨텍스트  JPA에서 가장 중요한 2가지    객체와 관계형 데이터베이트 매핑하기 (Object Relational Mapping) 영속성 컨텍스트   엔티티 매니저 팩토리와 앤티티 매니저   요청이 오면 앤티티 매니저 팩토리를 통해 엔티티 매니저를 생성하고, 앤티티 매니저는 커넥션풀을 이용해 DB에 접근 합니다.\n 영속성 컨텍스트    JPA를 이해하는데 가장 중요한 용어 \u0026ldquo;엔티티를 영구 저장하는 환경\u0026quot;이라는 뜻 EntitiyManager.persist(entity); // persist 메소드는 DB에 저장하는게 아니라 entity를 영속성 컨텍스트에 저장한다는 것   엔티티 매니저? 영속성 컨텍스트?    영속성 컨텍스트는 논리적인 개념 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근   J2SE 환경  엔티티 매니저와 영속성 컨텍스트가 1:1  J2EE, 스프링 프레임워크 같은 컨테이너 환경  엔티티 매니저와 영속성 컨텍스트가 N:1  엔티티의 생명주기    비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태     영속 (managed) 영속성 컨텍스트에 관리되는 상태     준영속 (datached) 영속성 컨텍스트에 저장되었다가 분리된상태     삭제 (removed) 삭제된 상태   비영속 (new/transient)  객체만 생성하고 세팅한 상태\n  JpaMain.java\n ...\r// 객체를 생성한 상태(비영속)\rMember member = new Mamber();\rmember.setId(2L);\rmember.setName(\u0026quot;회원2\u0026quot;)\r...\r 영속 (managed)  객체만 생성하고 세팅한 상태\n  JpaMain.java\n // 객체를 생성한 상태(비영속)\rMember member = new Mamber();\rmember.setId(2L);\rmember.setName(\u0026quot;회원2\u0026quot;)\rEntitiyManager em = emf.createEntityManager();\rem.getTransaction().begin();\r// 객체를 저장한 상태(영속)\rem.persist(member);\r// 객체를 비영속 상태로 변경\r//em.detach(member) // 객체를 DB에서 삭제\r//em.remove(member) tx.commit(); // 실제 쿼리가 실행되는 지점\r 영속성 컨텍스트의 이점   영속성 컨텍스트는 객체와 DB 사이에 하나의 계층이 있는것\n   1차 캐시 동일성(identity) 보장 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 변경 감지(dirty checking) 지연 로딩(lazy loading)   엔티티 조회, 1차 캐시  영속성 컨텍스트는 내부에 1차 캐시를 가지고 있습니다. @Id가 키가 되고 값은 member객체 자체인 Map이라 생각하면 됩니다.\n  JpaMain.java\n // 엔티티를 생성한 상태(비영속)\rMember member = new Member();\rmember.setId(3L);\rmember.setName(\u0026quot;회원3\u0026quot;);\r// 엔티티를 영속\rem.persist(member);\r 1차 캐시에서 조회  JpaMain.java\n // 엔티티를 생성한 상태(비영속)\rMember member = new Member();\rmember.setId(3L);\rmember.setName(\u0026quot;회원3\u0026quot;);\r// 1차 캐시에 저장됨\rem.persist(member);\rMember findMemeber = em.find(Member.class, \u0026quot;3L\u0026quot;);\r  조회를 실행시 우선적으로 1차 캐시에 값으로 객체가 있는지 확인 후 있으면 캐시에서 바로 가져오고, 없는 경우 DB에서 조회를 하여 1차 캐시에 저장하고 객체를 가져오게 됩니다.\n DB에서 조회  JpaMain.java\n ...\rMember findMemeber = em.find(Member.class, \u0026quot;10L\u0026quot;);\r...\r  commit()이후에 Insert를 하지만, Select문이 나오지 않는다. 이미 1차 캐시에서 조회하여 커밋 이전에 출력한다.\n  같은 객체를 여러번 조회를 하면, 1번만 Select 문을 날리고 이후 1차 캐시에서 조회\n 영속 엔티티의 동일성 보장   JpaMain.java\n  Member findMember1 = em.find(Member.class, 10L);\rMember findMember2 = em.find(Member.class, 10L);\rSystem.out.println(findMember1 == findMember2);\r  같은 트랜잭션 안에서는 조회한 같은 객체는 동일한 객체로 인식 보장\n 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연   JpaMain.java\n  EntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rMember meber1 = new Member();\rMember meber2 = new Member();\rmeber1.setId(11L);\rmeber1.setName(\u0026quot;회원11\u0026quot;);\rmeber2.setId(12L);\rmeber2.setName(\u0026quot;회원12\u0026quot;);\r// 영속\rSystem.out.println(\u0026quot;=== BEFORE ===\u0026quot;);\rem.persist(meber1);\rem.persist(meber2);\rSystem.out.println(\u0026quot;=== AFTER ===\u0026quot;);\r// 여기까지 DB에 Insert 하지 않는다.\rtx.commit(); // [트랜잭션] 카밋\r  em.persist()로 memberA와 memberB를 저장할때, 영속 컨텍스트안의 쓰기지연 SQL 저장소에 memberA를 Insert SQL을 저장하고\n그리고 이후에 memberB에 대한 Insert SQL을 쓰기지연 SQL 저장소에 저장합니다. 여기 까지 DB에 저장하지 않고 commit과 함께 DB에 저장합니다.\n transaction.commit();  트랜잭션이 커밋될때 좀더 자세히 그림으로 설명하면 아래와 같습니다.\n  커밋을 하게되면 쓰기지연 저장소에 있는 SQL들을 flush하며, DB에 SQL문들을 DB에 커밋하게 됩니다.\n  Member.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  굳이 하나씩 보내도 되는데 왜 커밋과 함께 DB에 Insert 하느냐 하면 성능을 위해 설정하여 튜닝할 수 있는 여지를 주기 위함이라 합니다.   JPA의 옵션중\n  persistence.xml - hibernate.jdbc.batch_size\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r...\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r...\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r  옵션 하나로 JPA의 성능에 대한 이점을 챙길 수 있습니다.\n 엔티티 수정 - 변경 감지(dirty checking)   JPA에서는 컬렉션에서 값을 수정하는 것처럼 따로 저장하지 않아도 변경 감지를 통해 commit시 Update 문을 자동으로 수행\n  JpaMain.java\n EntityMananger em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\r// 영속 엔티티 조회\rMember MemberA = em.find(Member.class, 10L);\r// 영속 엔티티 데이터 수정\rMemberA.setName(\u0026quot;사용자10\u0026quot;);\r// 이런 코드가 필요하지 않을까?\r//em.update(member);\rtx.commit(); // [트랜잭션] 커밋\r  DB에서 값을 Select 하고 값을 수정만 하고 저장을 따로 하지 않았지만, Update 쿼리까지 실행됩니다.\n 변경 감지(dirty checking)  커밋하는 시점에 변경 감지를 통해 벌어지는 일을 그림으로 그리면 아래와 같습니다.\n커밋을 하게 되면 내부적으로 flush()를 실행하게 되고, 엔티티와 스냅샷을 비교하게됩니다. 스냅샷은 객체를 읽어올 당시의 값을 스냅샷으로 저장합니다. 트랜잭션에서 커밋하는 시점에 플러시가 호출되며 엔티티와 스냅샷을 비교하여, 변경사항을 쓰기 지연 SQL 저장소에 Update SQL을 저장합니다. 그리고 DB에 Update SQL을 반영하고 commit()을 수행합니다.\n 엔티티 삭제   JpaMain.java\n // 삭제할 대상 엔티티 조회\rMember memberA = em.find(Member.class, 11L);\rem.remove(memberA); // 엔티티 삭제\r 플러시   영속성 컨텍스트의 변경내용을 데이터베이스에 반영\n 플러시 발생   트랜잭션이 커밋되면 자동적으로 플로시가 발생되며, 1차 캐시의 변동없음(다른 flush의 비우는 기능과 다름.)\n   변경감지(dirty checking) 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터 베이스에 전송(등록, 수정, 삭제 쿼리)   영속성 컨텍스트를 플러시 하는 방법    em.flush() - 직접 호출 (잘 사용은 안되지만, 테스트 시 알아두면 유용) 트랜잭션 커밋 - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출    다른 예제들과 다르게 라인 \u0026ldquo;===========\u0026rdquo; 보다 이전에 flush()를 실행항 당시 변경 사항의 SQL이 로그에 찍히게됨.\n JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유   JpaMain.java\n em.persist(memberA);\rem.persist(memberB);\rem.persist(memberC);\r//중간에 JPQL 실행 query = em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class);\rList\u0026lt;Member\u0026gt; members = query.getResultList();\r  만일 memberA, memberB, memberC를 영속화 하고, Member 테이블의 전체 리스트를 조회하면 아무 결과가 안나올 것입니다. 아직 commit()을 통한 flush()가 실행 되기 이전이기 떄문입니다. 이러한 문제점을 해결하기 위해 JPA에서는 JPQL을 실행할 때 우선 flush()를 실행합니다.\n 플러시 모드 옵션   JpaMain.java\n em.setFlushMode(FlushModeType.COMMIT);\r   FlushModeType.AUTO - 트랜잭션 커밋이나 쿼리(JPQL)를 실행할 때 플러시(기본값) FlushModeType.COMMIT - 커밋할 때만 플러시   플러시는 !    영속성 컨텍스트를 비우지 않음 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 트랜잭션이라는 작업 단위가 중요 -\u0026gt; 커밋 직전에만 동기화하면 됨   준영속 상태    영속 -\u0026gt; 준영속 1차 캐시에 있고 JPA가 관리하는 상태     영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 영속성 컨텍스트가 제공하는 기능을 사용 못함   준영속 상태로 만드는 방법    em.detach(entity) - 특정 엔티티만 준영속 상태로 전환 em.claer() - 영속성 컨텍스트를 완전히 초기화 em.close() - 영속성 컨텍스트를 종료   참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 내부 동작 방식","id":62,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 영속성 관리","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/persistence-manage/"},{"content":"JPA 시작하기  Hello JPA - 프로젝트 생성  H2 Database 설치   H2 홈페이지에서 OS에 맞는 설치 파일을 다운로드한다.\n  C:\\Program Files (x86)\\H2\\bin\\h2.bat 실행\n  jdbc:h2:~/jpashop (최초 1회, 세션키 유지한 상태로 실행)\n  이후 부터는 jdbc:h2:tcp://localhost/~/jpashop 으로 접속\n  http://localhost:8082/login.jsp 에서 연결버튼 클릭\n SpringBoot 프로젝트 생성  pom.xml  hibernate와 h2database dependency 추가\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;jpa-basic\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;ex1-hello-jpa\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- JPA 하이버네이트 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.6.1.Final\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- H2 데이터베이스 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt; \u0026lt;!-- 설치한 H2 database 버전과 동일, 202 버전 설치 하였지만 202 버전은 없어 200으로 설치 --\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/project\u0026gt;\r 스프링부트에 맞는 Dependency 버전확인  JPA 설정하기 - persistence.xml    JPA 설정 파일 /META-INF/persistence.xml 위치 /ex1-hello-jpa/src/main/resources/META-INF/persistence.xml     persistence-unit name으로 이름 지정 javax.persistence로 시작: JPA 표준 속성 hibernate로 시작: 하이버네이트 전용 속성    persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;persistence version=\u0026quot;2.2\u0026quot; xmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt; \u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 필수 속성 --\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt; \u0026lt;!-- 옵션 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/persistence-unit\u0026gt; \u0026lt;/persistence\u0026gt;  데이터베이스 방언   SQL 표준을 지치지 않는 특정 데이터베이스의 고유한 기능\n   JPA는 특정 데이터베ㅔ이스에 종속 X 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름 \u0026gt; - 가변 문자 : MySQL은 VARCHAR, Oracle은 Varchar2 \u0026gt; - 문자열을 자르는 함수 : SQL 표준은 SUBSTRING(), Oracle은 SUBSTR() \u0026gt; - 페이지 : MySQL은 LIMIT, Oracle은 ROWNUM   데이터베이스 방언 옵션   hibernate.dialect 속성에 지정 H2 : org.hibernate.dialect.H2Dialect Oracle 10g : org.hibernate.dialect.Oracle10gDialect MySQL : org.hibernate.dialect.MySQL5InnoDBDialect 하이버네이트는 40가지 이상의 데이터베이스 방언 지원   JPA 구동 방식  실습 - JPA 동작 확인    JpaMain 클래스 생성 JPA 동작 확인    persistence.xml 설정이 잘되어 있어야 Persistence. 했을때 뜸, PersistenceUnitName은 persistence.xml에 설정된 persistence-unit의 name\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;--\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r EntitiyManagerFactory 생성 후 실행  JpaMain.java\n \rpackage hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\r// 실제 구현 위치\r// 사용 후 닫아줘야한다 em.close();\temf.close(); }\r}\r 객체 테이블을 생성하고 매핑하기    @Entity : JPA가 관리할 객체 @Id : 데이터베이스 PK와 패밍    Member.java\n package hellojpa; import javax.persistence.Entity; // 비슷한게 나오면 javax import javax.persistence.Id; @Entity // 중요\rpublic class Member { @Id private Long id; private String name; //Getter, Setter … } create table Me\r  MEMBER CREATE SQL\n create table Member ( id bigint not null, name varchar(255), primary key (id) )\r H2 Database에서 SQL 실행 Member.java 생성  main과 같은 경로에 생성\n Member에 데이터 Insert   Member.java 생성후 실행\n  Id를 추가 하지 않았기 때문에 JPA에서 Id를 포함하라고 오류를 발생\n Exception in thread \u0026quot;main\u0026quot; javax.persistence.PersistenceException: org.hibernate.id.IdentifierGenerationException: ids for this class must be manually assigned before calling save(): hellojpa.Member\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:154)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:181)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:188)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:807)\rat org.hibernate.internal.SessionImpl.persist(SessionImpl.java:785)\rat hellojpa.JpaMain.main(JpaMain.java:16)\rCaused by: org.hibernate.id.IdentifierGenerationException: ids for this class must be manually assigned before calling save(): hellojpa.Member\rat org.hibernate.id.Assigned.generate(Assigned.java:33)\rat org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:119)\rat org.hibernate.event.internal.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:192)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:135)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:62)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:800)\r... 2 more\r  JpaMain.java - member.id, memeber.name 세팅\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rMember member = new Member();\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rem.close();\remf.close();\r}\r}\r  하지만 그래도 오류가 발생..\n \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_271\\bin\\java.exe\u0026quot; \u0026quot;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\lib\\idea_rt.jar=52200:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\bin\u0026quot; -Dfile.encoding=UTF-8 -classpath \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\rt.jar;C:\\develop\\Git\\jpa-basic\\ex1-hello-jpa\\target\\classes;C:\\Users\\offetuoso\\.m2\\repository\\org\\hibernate\\hibernate-entitymanager\\5.3.10.Final\\hibernate-entitymanager-5.3.10.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\jboss\\logging\\jboss-logging\\3.3.2.Final\\jboss-logging-3.3.2.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\hibernate\\hibernate-core\\5.3.10.Final\\hibernate-core-5.3.10.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\javassist\\javassist\\3.23.2-GA\\javassist-3.23.2-GA.jar;C:\\Users\\offetuoso\\.m2\\repository\\antlr\\antlr\\2.7.7\\antlr-2.7.7.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\jboss\\jandex\\2.0.5.Final\\jandex-2.0.5.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\com\\fasterxml\\classmate\\1.3.4\\classmate-1.3.4.jar;C:\\Users\\offetuoso\\.m2\\repository\\javax\\activation\\javax.activation-api\\1.2.0\\javax.activation-api-1.2.0.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\dom4j\\dom4j\\2.1.1\\dom4j-2.1.1.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\hibernate\\common\\hibernate-commons-annotations\\5.0.4.Final\\hibernate-commons-annotations-5.0.4.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\javax\\persistence\\javax.persistence-api\\2.2\\javax.persistence-api-2.2.jar;C:\\Users\\offetuoso\\.m2\\repository\\net\\bytebuddy\\byte-buddy\\1.9.5\\byte-buddy-1.9.5.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\jboss\\spec\\javax\\transaction\\jboss-transaction-api_1.2_spec\\1.1.1.Final\\jboss-transaction-api_1.2_spec-1.1.1.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\com\\h2database\\h2\\1.4.200\\h2-1.4.200.jar\u0026quot; hellojpa.JpaMain\r12월 19, 2021 9:58:07 오후 org.hibernate.jpa.internal.util.LogHelper logPersistenceUnitInformation\rINFO: HHH000204: Processing PersistenceUnitInfo [\rname: hello\r...]\r12월 19, 2021 9:58:07 오후 org.hibernate.Version logVersion\rINFO: HHH000412: Hibernate Core {5.3.10.Final}\r12월 19, 2021 9:58:07 오후 org.hibernate.cfg.Environment \u0026lt;clinit\u0026gt;\rINFO: HHH000206: hibernate.properties not found\r12월 19, 2021 9:58:08 오후 org.hibernate.annotations.common.reflection.java.JavaReflectionManager \u0026lt;clinit\u0026gt;\rINFO: HCANN000001: Hibernate Commons Annotations {5.0.4.Final}\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl configure\rWARN: HHH10001002: Using Hibernate built-in connection pool (not for production use!)\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator\rINFO: HHH10001005: using driver [org.h2.Driver] at URL [jdbc:h2:tcp://localhost/~/test]\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator\rINFO: HHH10001001: Connection properties: {user=sa}\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator\rINFO: HHH10001003: Autocommit mode: false\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PooledConnections \u0026lt;init\u0026gt;\rINFO: HHH000115: Hibernate connection pool size: 20 (min=1)\r12월 19, 2021 9:58:09 오후 org.hibernate.dialect.Dialect \u0026lt;init\u0026gt;\rINFO: HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\r12월 19, 2021 9:58:10 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl stop\rINFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]\rProcess finished with exit code 0\r  JPA에서는 Transaction이 매우 중요한데, JPA의 모든 작업은 Transaction 안에서 이루어져야한다.\n EntityTransaction 추가  JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // 트랜잭션 시작\rMember member = new Member();\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit(); // 트랜잭션 커밋\rem.close();\remf.close();\r}\r}\r  Transaction을 추가후 실행\n  persistence.xml 옵션 설명\n  \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r  그래고 H2 DataBase에 어떠한 테이블로 저장하겠다 설정을 하지 않았지만, 관례에 따라 @Entity의 Class명에 Insert 합니다. 또한 테이블 명을 지정하고 싶다면 @Table(name = \u0026ldquo;테이블명\u0026rdquo;)을 이용해 저장될 테이블을 세팅할 수 있습니다. 그리고 @Column(name=\u0026ldquo;컬럼명\u0026rdquo;)을 통해 저장할 컬럼을 매핑 할 수도 있습니다.\n  Member.java\n \r@Entity\r@Table(name = \u0026quot;Member\u0026quot;)\rpublic class Member {\r@Id\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;)\rprivate String name;\r  그리고 문제가 있을때를 대비해서 Try Catch문도 포함해 줍니다.\n  JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rMember member = new Member();\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\rem.find(Member.class, 1L);\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r Member 데이터 Select   JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rMember member = new Member();\r/*\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(\u0026quot;findMember.id = \u0026quot; + findMember.getId());\rSystem.out.println(\u0026quot;findMember.name = \u0026quot; + findMember.getName());\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r Member 데이터 Update   JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rMember member = new Member();\r/*\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(\u0026quot;findMember.id = \u0026quot; + findMember.getId());\rSystem.out.println(\u0026quot;findMember.name = \u0026quot; + findMember.getName());\rfindMember.setName(\u0026quot;김철수\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;findMember.id = \u0026quot; + findMember.getId());\rSystem.out.println(\u0026quot;findMember.name = \u0026quot; + findMember.getName());\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  변경된 것을 확인 할 수 있습니다. commit을 할때 set()을 통해 변경사항이 있는경우 JPA가 자동으로 Update를 해준다.\n 주의    엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유 엔티티 매니저는 쓰레드간 공유하면 절대 안됨 (사용하고 버려야한다.) JPA는 모든 데이터 변경은 트랜잭션 안에서 실행   JPQL 소개   간단 조회는 키값을 넣고 findMember하고 데이터 불러다 사용하면 되는데, 조건을 사용한 검색을 해야할때 어떻게 해야할까? 나이가 18살 이상인 회원을 모두 검색하고 싶다면?\n   가장 단순한 조회 방법 \u0026gt; - EntityManager.find() \u0026gt; - 객체 그래프 탐색 (a.getB().getC())   실습 - JPQL 소개    JPQL로 전체 회원 검색 JPQL로 ID가 2개 이상인 회원만 검색 JPQL로 이름이 같은 회원만 검색 JPQL에 대해 자세한 내용은 객체지향 쿼리에서 학습   실습  JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rList\u0026lt;Member \u0026gt; resultList = em.createQuery(\u0026quot;select m from Member as m\u0026quot;, Member.class).getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;member.name = \u0026quot; + member.getName());\r}\r/*\r// Insert\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\r/*\r// Select\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r/*\r//Update\rfindMember.setName(\u0026quot;김철수\u0026quot;);\rtx.commit();\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r 결과 Hibernate: /* select\rm -- member 엔티티\rfrom\rMember as m */ select\rmember0_.id as id1_0_,\rmember0_.name as name2_0_ from\rMember member0_\rmember.name = 김철수\r  추가로 페이징을 추가할 경우\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rList\u0026lt;Member \u0026gt; resultList = em.createQuery(\u0026quot;select m from Member as m\u0026quot;, Member.class)\r.setFirstResult(1) // 로우 1 부터\r.setMaxResults(8)\t// 로우 8 까지\r.getResultList();\rfor(Member member : resultList ){\rSystem.out.println(\u0026quot;member.name = \u0026quot; + member.getName());\r}\r/*\r// Insert\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\r/*\r// Select\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r/*\r//Update\rfindMember.setName(\u0026quot;김철수\u0026quot;);\rtx.commit();\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r 페이징 추가 결과 Hibernate: /* select\rm from\rMember as m */ select\rmember0_.id as id1_0_,\rmember0_.name as name2_0_ from\rMember member0_ limit ? offset ?\r  H2 SQL로 결과가 나오지만, persistence.xml의 hibernate.dialect를 오라클로 변경하면\n  persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;--\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r 결과  oracle 방언으로 변경된 SQL이 나온다.\n Hibernate: /* select\rm from\rMember as m */ select\r* from\r( select\rrow_.*,\rrownum rownum_ from\r( select\rmember0_.id as id1_0_,\rmember0_.name as name2_0_ from\rMember member0_ ) row_ ) where\rrownum_ \u0026lt;= ? and rownum_ \u0026gt; ?\r JPQL    JPA를 사용하면, 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 검색을 할 때에도 테이블이 아닌 엔티티 객체를 대상으로 검색 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요   JPQL    JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공 SQL과 문법 유사, Select, From, Where, Group By, Having, Join 지원 JPQL은 엔티티 객체를 대상으로 쿼리 SQL을 추상화해서 특정 데이터베이스 SQL에 의존X 테이블이 아닌 객체를 대상으로 검색하는 객체 지향쿼리 JPQL을 한마디로 정의하면 객체 지향 SQL \u0026lt;\u0026ndash;\u0026gt; SQL은 데이터베이스 테이블 대상으로 쿼리   참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 시작","id":63,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 시작","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/start-jpa/"},{"content":"JPA 애플리케이션   지금 시대는 객체를 관계형 DB에 관리 객체 지향 언어를 사용한 프로젝트라고 하여도 결국엔 SQL이 제일 중요할 수 밖에 없다. 관계형 DB가 알아 들을 수 있는 것은 SQL이니까\n SQL 중심적인 개발의 문제점    무한 반복, 지루한 코드   CRUD    INSERT UPDATE SELECT DELETE 자바 객체를 SQL로 .. SQL을 자바 객체로 ..   객체 CRUD   간단히 Member라는 객체를 생성하고, sql로 CRUD를 개발하였다고 생각하자.\n public class Member {\rprivate Long memberId;\rprivate String name;\r...\r}\rINSERT INTO MEMBER(MEMBER_ID, NAME) VALUES // 인서트 쿼리 변경\rSELECT MEMBER_ID, NAME FROM MEMBER M // 셀렉트 쿼리 변경\rUPDATE MEMBER SET … // 업데이트 쿼리 변경\r 객체 CRUD - 필드추가   개발이 끝났을때, 기획에서 연락처를 추가해 달라는 요청이 왔다\n public class Member {\rprivate Long memberId;\rprivate String name;\r/* 신규추가 tel */\rprivate String tel; ...\r}\r/*\rINSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUES -- 신규추가 tel\rSELECT MEMBER_ID, NAME, TEL FROM MEMBER M -- 신규추가 tel\rUPDATE MEMBER SET … , TEL = ? -- 신규추가 tel\r*/\r SQL에 의존적인 개발을 피하기 어렵다.   관계형 DB를 사용하는 이상 SQL에 의존적이며, DB의 테이블 또는 컬럼에 따라 SQL을 계속 수정하고 작성하게 되어있다.\n 패러다임의 불일치   관계형 데이터베이스의 사상과 객체 지향의 사상이 매우 다름\n 객체 VS 관계형 데이터베이스  관계형 데이터베이스  데이터를 잘 정규화 해서 보관\n 객체  속성과 기능을 묶어서 캡슐화 하여 객체간 유기적으로 사용\n 객체를 영구 보관하는 다양한 저장소    RDB NoSql File etc    현실적 대안은 RDB\n 객체를 관계형 데이터베이스에 저장  객체 -\u0026gt; SQL 변환 -\u0026gt; RDB   이렇게 객체를 SQL로 변환하여 주는 업무를 개발자가 한다. 출근해서 SQL을 하루종일 작성하고 있는것이.. SQL 매퍼의 일을 개발자가 하고 있다.\n 객체와 관계형 데이터베이스의 차이    상속 객체의 상속관계 같은 것은 없고 유사한 것은 있지만, 없다고 본다.      연관관계 객체 참조와 RDB의 PK, FK를 이용해 조인하여 연관관계를 찾을 수 있음      데이터 타입 데이터 식별 방법   상속 Album 저장   객체 분해 INSERT INTO ITEM \u0026hellip; INSERT INTO ALBUM ..   Album 조회   각각의 테이블에 따른 조인 SQL 작성 상속 관계에 따라 각각 객체 생성 SQL 조회결과에 따라 각각 객체에 데이터 세팅.. 등 복잡 그래서 DB에 저장할 객체에는 상속 관계 안쓴다   자바 컬렉션에 저장하면?  객체를 담을 수 있는 특별한 컬렉션이 있다고 가정하면 !\n list.add(album);\r 자바 컬렉션에서 조회하려면? Album album = list.get(albumId);\r//보모 타입으로 조회 후 다형성 활용\rItem item = list.get(albumId);\r  컬렉션에 넣고 빼는 것은 심플하지만, 관계형 DB에 넣고 빼는 순간 중간에서 SQL 매핑작업을 개발자가 손수 작업을 해줘야 한다.\n 연관관계   객체는 참조를 사용 : member.getTeam() 테이블은 외래 키를 사용 : JOIN ON M.TEAM_ID = T.TEAM_ID   객체를 테이블에 맞추어 모델링 class Member {\rLong id; // MEMBER_ID 컬럼 사용\rLong teamId;\t// TEAM_ID FK 컬럼 사용\rString username; // USERNAME 컬럼 사용\r}\rclass Team {\rLong id;\t// TEAM_ID PK 사용\rString name; // NAME 컬럼 사용\r}\r 테이블에 맞춘 객체 저장 객체다운 모델링 class Member {\rLong id; // MEMBER_ID 컬럼 사용\rTeam team;\t// 참조로 연관관계를 맺는다.\rString username; // USERNAME 컬럼 사용\rTeam getTeam(){\rreturn team;\r}\r}\rclass Team {\rLong id;\t// TEAM_ID PK 사용\rString name; // NAME 컬럼 사용\r}\r 객체 모델링 저장 객체 모델링 조회 --select.member.info\rSELECT M.*, T.*\rFROM MEMBER M\rJOIN TEAM T ON M.TEAM_ID = T.TEAM_ID\rpublic Member find(Long memberId){\r// SQL 실행\rMap result = sql.executeQuery(\u0026quot;select.member.info\u0026quot;);\r// 데이터베이스에서 조회한 회원 관련 정보 세팅\rMeber member = new Member();\rmember.set(\u0026quot;id\u0026quot;, result.get(\u0026quot;id\u0026quot;));\r...\r...\r// 데이터베이스에서 조회한 팀관련 정보를 모두 입력\rTeam team = new Team();\rteam.set(\u0026quot;id\u0026quot;, result.get(\u0026quot;teamId\u0026quot;));\r...\r...\r// 회원과 팀 관계 설정\rmember.setTeam(team);\r// 회원 객체 반환\rreturn member;\r}\r  이러한 번잡함을 해결하기 위해 Meber와 Team을 모두 포괄하는 SuperDto(MemberTeamDto) 등 으로 한번에 받음\n 객체 모델링, 자바 컬렉션에 관리  list.add(member);\rMember member = list.get(memberId);\rTeam team = member.getTeam();\r  자바 컬렉션에 넣는다고 생각하면 이러한 형태가 객체지향적으로 설계하기 괜찮음\n 객체 그래프 탐색  객체는 자유롭게 객체 그래프를 탐색 할 수 있어야 한다.\n 처음 실행하는 SQL에 따라 탐색 범위 결정 --select.member.info\rSELECT M.*, T.*\rFROM MEMBER M\rJOIN TEAM T ON M.TEAM_ID = T.TEAM_ID\rmember.getTema() //OK\rmember.getOrder() // null\r  조회한 sql에 따라 order 테이블엔 값이 있어도 sql에서 order를 조회 하지 않았기 때문에 getOrder()에서는 null이 발생\n 엔티티 신뢰 문제 class meberService {\r...\rpublic void process(){\rMember member = memberDAO.find(memberId);\rmember.getTeam();\t// ???\rmember.getOrder().getDelivery(); // ???\r}\r}\r  누군가 개발해둔 소스를 보고 Meamber를 조회하고, getTeam과 getOrder로 Team과 Order를 사용하면 되겠다 생각이 들겠지만, 실제로 memberDAO.find()를 열어서 실제 조회하는 sql을 확인하고 내부동작이 어떻게 되어있는지 확인 하지 않는 이상 어떤 결과가 있을지 모른다. 이러한 계층구조 객체를 레이어드 아키텍처라 하는데, 레이어드 아키텍처는 다음 레이어에서 신뢰하고 사용을 할 수 있어야 한다. 하지만 이경우 엔티티 신뢰 문제가 발생.\n 모든 객체를 미리 로딩할 수는 없다.  상황에 따라 동일한 회원 조회 메서드를 여러벌 생성\n memberDAO.getMember(); // Member만 조회\rmemberDAO.getMemberWithTeam(); // Member와 Team 조회\r// Member, Team, Delivery 조회\rmemberDAO.getMemberWithTeamWithDelivery();  계층형 아키텍처  진정한 의미의 계층 분할이 어렵다.\n 비교하기  비교하기 - 자바 객체로 조회 Long memberId = 100;\rMember member1 = memberDAO.getMember(memberId); Member member2 = memberDAO.getMember(memberId);\rmember1 == member2; //다르다. (getMember에서 sql로 조회된 데이터는 같아도 return되는 객체는 new로 새로 만들기 때문에 다름)\rclass MemberDAO {\rpublic Member getMember(Long memberId) {\rString sql = \u0026quot;SELECT * FROM MEMBER WHERE MEMBER_ID = ?\u0026quot;;\r...\r//JDBC API, SQL 실행\rreturn new Member(...); //객체를 새로만듬\r}\r}\r 비교하기 - 자바 컬렉션에서 조회  이러한 특수한 컬렉션이 있다고 가정\n Long memberId = 100;\rMember member1 = list.get(memberId);\rMember member2 = list.get(memberId);\rmember1 == member2; //같다. (참조 값이 같다)\r  sql에서 다룰때랑, 자바 컬렉션에서 다룰때랑, 자바 객체에서 다룰때, 관계형 DB에서 다룰때 중간에 많은 믹스매치가 발생\n 객체답게 모델링 할수록 매핑 작업만 늘어난다.   객체지향을 배우고 객체지향을 토대로 설계하고 구현할 경우 번잡한 매핑 작업만 들어난다. 그래서 sql에 맞춰서 데이터 전송하는 객체로 만들 수 밖에 없음. (만들 수 있지만, 개발 퍼포먼스 측면에서 지옥이다.)\n 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수 없을까   1980 년대 부터 많은 개발자들이 고민을 해왔다고합니다. 자바 진영에서는 그 고민의 결과 !\n JPA - Java Persistence API   JPA란 Java Persistence API로 자바 진영의 ORM 기술 표준\n ORM ?    Object Relational mapping(객체 관계 매칭) 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설계 ORM 프레임 워크가 중간에서 매핑 대중적인 언어에는 대부분 ORM 기술이 존재   JPA는 애플리케이션과 JDBC 사이에서 동작  JPA 동작 - 저장  JPA에게 Meber객체를 넘기면, JPA가 Member 객체를 분석하고, Insert 쿼리를 생성해서 DB에 전달하고 결과를 받음\n JPA 동작 - 조회  JPA에게 Meber객체를 넘기면, JPA가 Member 객체를 분석하고, Select 쿼리를 생성해서 DB에 전달하고 결과를 받음\n  중요한것은 패러다임 불일치 해결\n JPA 소개   과거 EJB - 엔티티 빈(자바 표준)에도 JPA와 비슷한 ORM 기술이 있었지만 높은 가격에 기능이 떨어지며, 기능 동작도 안되고 안쓰였다고 합니다.\n  SI 개발자인 개빈 킹(Gavin King)이 EJB의 기능을 만족하지 못하여 만든 기술이 하이버네이트입니다. 이후 많은 개발자들이 동참하여 오픈소스화 하였습니다. EJB는 서서히 몰락하게 되었습니다.\n  자바 진영에서 하이버네이트를 만든 개빈킹을 데려다 하이버네이트를 똑닮은 표준을 만들었는데 그것이 JPA입니다.\n JPA는 표준 명세    JPA는 인터페이스의 모음 JPA 2.1 표준 명세를 구현한 3가지 구현체 하이버네이트, EclipseLink, DataNucleus   JPA 버전    JPA 1.0(JSR 220) 2006년 : 초기 버전. 복합 키와 연관관계 기능이 부족 JPA 2.0(JSR 317) 2009년 : 대부분의 ORM 기능을 포함, JPA Criteria 추가 JPA 2.1(JSR 338) 2013년 : 스토어드 프로시저 접근, 컨버터(Converter), 엔티 티 그래프 기능이 추가   JPA를 왜 사용해야 하는가?    SQL 중심적인 개발에서 객체 중심으로 개발 생산성 유지보수 패러다임의 불일치 해결 성능 데이터 접근 추상화와 벤더 독립성 표준   생산성 - JPA와 CRUD   저장 : jpa.persist(member) //영구 저장하다라는 뜻 조회 : Member member = jpa.find(memberId) 수정 : member.setName(\u0026ldquo;변경할 이름\u0026rdquo;) // 객체의 이름을 set으로 변경하면 update 문이 자동으로 날라감 삭제 : jpa.remove(member)   유지보수 - JPA : 필드만 추가하면 됨 SQL은 JPA가 처리  개발이 끝났을때, 기획에서 연락처를 추가해 달라는 요청이 왔다\n public class Member {\rprivate Long memberId;\rprivate String name;\r/* 신규추가 tel */\rprivate String tel; ...\r}\r/*\t//더이상 sql들을 수정할 필요 없음\rINSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUES -- 신규추가 tel\rSELECT MEMBER_ID, NAME, TEL FROM MEMBER M -- 신규추가 tel\rUPDATE MEMBER SET … , TEL = ? -- 신규추가 tel\r*/\r JPA와 패러다임의 불일치 해결  1.JPA와 상속 2.JPA와 연관관계 3.JPA와 객체 그래프 탐색 4.JPA와 비교하기\n JPA와 상속 JPA와 상속 - 저장  ALBUM 객체를 DB에 저장하고 싶을때, jpa.persist()에 album 객체를 넘기면 JPA가 Insert 쿼리를 나누어서 작성\n // 개발자가 할일 jpa.persist(album);\r // 나머진 JPA가 처리\rInsert Into ITEM ...\rInsert Into ALBUM ...\r JPA와 상속 - 조회  Album 객체를 조회하고 싶을때 jpa.find()에 Album의 클래스, PK 값을 넘기면 JPA가 자동으로 ITEM과 ALBUM을 조인하여 데이터를 퍼올려줍니다.\n // 개발자가 할일 Album album = jpa.find(Album.class, albumId);\r // 나머진 JPA가 처리\rSelect I.*\r, A.*\rFROM ITEM I\rJOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID\r JPA와 연관관계, 객체 그래프 탐색  member에 팀을 세팅하고 member를 저장하면 team을 포함한 member가 저장됨.\n // 연관관계 저장\rmember.setTeam(team);\rjpa.persist(member);\r  저장된 team을 가져올때도, 자바 컬렉션에서 데이터를 가져오듯이 member.getTeam()을 이용해 team을 가져올수 있음.\n // 객체 그래프 탐색\rMember member = jpa.find(Member.class, memberId);\rTeam team = member.getTeam();\r 신뢰 할 수 있는 엔티티, 계층  JPA를 이용하면, find()를 이용해 객체 그래프 탐색을 통해서 getTeam()나 getOrder().getDelivery()를 사용하여, 각각의 객체를 자유롭게 조회할 수 있습니다. 또한 Lazy Loading 이라는 기능을 이용하여, 실제 코드를 수행할 당시에 데이터를 불러와 member객체에 하위 계층 객체를 세팅해줍니다. JPA를 이용하면, DB에 데이터가 없지 않는 이상 신뢰 하고 하위 계층을 사용하면 됩니다.\n class MemberService{\r...\rpublic void process(){\rMember member = memberDAO.find(memberId);\rmember.getTeam();\rmember.getOrder().getDelivery();\r}\r}\r JPA와 객체 비교하기  동일한 트랜잭션에서는 조회한 엔티티는 같음 보장\n Long memberId = 100;\rMember member1 = jpa.find(member.class, memberId);\rMember member2 = jpa.find(member.class, memberId);\rmember1 == member2; // 같다\r jpa의 성능 최적화 기능  JPA를 사용하면 성능이 저하되는 것이 아닌가 고민을 할 수 있을수도 있지만, JPA는 성능을 최적화 하기 위해 여러가지 기능을 제공합니다.\n   1차 캐시와 동일성(identity) 보장 트랜잭샨을 지원하는 쓰기 지연(transational write-behind) 지연 로딩(Laze Loading)g   1차 캐시와 동일성 보장   같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상 ``` Long memberId = 100; Memeber member1 = jpa.find(Member.class, memberId); // SQL 조회 Memeber member2 = jpa.find(Member.class, memberId); // 캐시    member1 == member2 // 같다\r```\r  SQL 1번만 실행\n  DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장   트랜잭션을 지원하는 쓰기 지연 - Insert   트랜잭션을 커밋할 때까지 Insert SQL을 모음 JDBC Batch SQL 기능을 사용해서 한번에 SQL을 전송   \ttransction.begin(); // 트랜잭션 시작\rjpa.persist(memberA)\t// 메모리에 적재\rjpa.persist(memberB) // 메모리에 적재\rjpa.persist(memberC) // 메모리에 적재\r// 여기까지 Insert SQL을 DB에 보내지 않는다.\r// 커밋하는 순간 DB에 SQL을 모아서 보낸다.\rtransction.commit(); // 트랜잭션 커밋\r  JPA 이전에도 JDBC Batch라는 기능이 있었고 그것을 쓰면 되지만, 코드가 정말 지저분해집니다. JPA가 하나의 트랜잭션에서 memberA, B, C를 메모리에 쌓았다가 Commit 시점에 동일한것을 모아 한번에 JDBC Batch 기능을 이용하여 네트워크를 통해 DB로 데이터를 전송합니다. JPA 옵션으로 설정해 두면 개발자가 신경 쓰지 않아도 이러한 기능을 지원해 줍니다.\n 지연 로딩과 즉시 로딩   지연 로딩 : 객체가 실제 사용될 때 로딩 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회   // 지연 로딩\rMember member = memberDAO.find(memberId); // SELECT * FROM MEMBER\rTeam team = member.getTeam(); // SELECT * FROM TEAM String teamName = team.getName();   JPA를 통해 객체를 조회할때, team 객체를 사용하는 시점에 TEAM 조회 SQL을 통하여 member객체의 team 객체에 데이터를 세팅\n  member를 조회할 때, 항상 team을 사용한다면 JPA 옵션을 통해서 member를 조회할 때 team을 같이 가져오게 설정을 할 수 있습니다. 옵션을 사용하면 쿼리가 MEMBER외 TEAM을 조인한 이래와 같은 쿼리로 변경해서 사용하게 됩니다.\n // 즉시 로딩\rMember member = memberDAO.find(memberId); // SELECT M.* ,T.* FROM MEMBER M JOIN Team T On ...\rTeam team = member.getTeam(); String teamName = team.getName();   JPA를 사용하지 않은 상태에서 MEMBER와 TEAM의 각각의 쿼리를 조인된 하나의 쿼리로 변경하거나, 조인된 각각의 쿼리를 개별의 쿼리로 나누려 작업한다면 진짜 많은 쿼리를 수정해야 될텐데 JPA를 이용하면 어마 어마한 것들을 간단히 사용할 수 있습니다.\n ORM은 객체와 RDB의 두 기둥위에 있는 기술  어느하나 소홀해서는 안되며 균형있게 두가지 지식이 쌓여 있어야 안전안 애플리케이션을 설계할 수 있습니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 소개","id":64,"section":"blog","tags":["자바 ORM 표준 JPA","김영한","JPA","ORM","Java","인프런"],"title":"[자바 ORM 표준 JPA] JPA 소개","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/about-jpa/"},{"content":"Elements in iteration expect to have \u0026lsquo;v-bind:key\u0026rsquo; directives 문제  이전 버전의 강좌를 보고 따라 하던 도중 vue template에서 li 에 v-for 를 이용해서 v-for=\u0026ldquo;t in tries\u0026rdquo; 루프를 생성하고 싶었으니 오류를 만나게 되었습니다.\n \r\u0026lt;!-- 문제가 발생한 코드 --\u0026gt;\r\u0026lt;li v-for=\u0026quot;item in tries\u0026quot;\u0026gt; {{item}}\r\u0026lt;/li\u0026gt;\r 2.2.0 이상에서 v-for는 key 가 필수 입니다.   \u0026lt;my-component\rv-for=\u0026quot;(item, index) in items\u0026quot;\rv-bind:item=\u0026quot;item\u0026quot;\rv-bind:index=\u0026quot;index\u0026quot;\rv-bind:key=\u0026quot;item.id\u0026quot;\r\u0026gt;\u0026lt;/my-component\u0026gt;\r 수정사항적용 \u0026lt;li v-for=\u0026quot;(item, index) in tries\u0026quot; :key=\u0026quot;index\u0026quot;\u0026gt;\r{{ item }}\r\u0026lt;/li\u0026gt;\r 참조 [Vue.js 에러] Custom elements in iteration require \u0026lsquo;v-bind:key\u0026rsquo; directives 뷰 공식 문서\n","description":"NPM init 패키지명 입력시 오류","id":65,"section":"blog","tags":["Troubleshooting"],"title":"Vue v-for Elements in iteration expect to have 'v-bind:key' directives 문제","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/vue/vue-v-for/"},{"content":"NPM init 패키지명 입력시 오류 발생 문제  npm init 명령어를 사용할때, node를 처음 접하게 되어 발생하였던 문제에 대해 정리\n Sorry, name can no longer contain capital letters. \u0026gt; npm init\r\u0026gt; package name: (3_끝말잇기) WordRelay\r\u0026gt; Sorry, name can no longer contain capital letters.\r package name : UpperCamelCase로 입력 시 오류 발생 Sorry, name can no longer contain capital letters. \u0026gt; npm init\r\u0026gt; package name: (3_끝말잇기) wordRelay\r\u0026gt; Sorry, name can no longer contain capital letters.\r package name : CamelCase로 입력 시 오류 발생 해결방법  npm init을 실행할때, kebab-csse를 사용해야한다. node.js를 포함한 vue의 컴포넌트 Dom 템플릿, Componet evet 등 kebab-case를 사용해야만 하는 경우가 있다.\n why  언젠가는 폴더나 파일이 자체 패키지로 추출될 수 있다고 상상해야 합니다. 패키지는 대문자를 포함할 수 없습니다. 새 패키지는 이름에 대문자가 없어야 합니다. https://docs.npmjs.com/files/package.json#이름 따라서 camelCase절대 사용해서는 안됩니다. snake_case과 kebab-case. kebab-case오늘날 가장 일반적인 협약입니다. 밑줄의 유일한 사용은 내부 노드 패키지용이며 이는 단순히 초기부터의 관례입니다.\n 참조 StackOverFlow kebab-case vuejs guide\n","description":"NPM init 패키지명 입력시 오류","id":66,"section":"blog","tags":["Troubleshooting"],"title":"NPM init 패키지명 입력시 오류, `Sorry, name can no longer contain capital letters.` and `Sorry, name can no longer contain capital letters.`","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/vue/npm-init/"},{"content":"Vue.js WebPack 설정하기 Node.js 설치   node 설치 최신의 LTS 버전 설치 최신버전 보다 안정화가 되어 검증된 LTS 버전 설치 권장   Vue 프로젝트에 WebPack 적용 순서 1. npm init  1.1. webpack을 적용할 vue project의 경로에서 터미널을 열음.\n  1.2. npm init 명령을 실행해서 node_modules을 설치하고, package.json 생성됨 npm init을 실행하고 package 명을 입력하고 그 뒤로는 엔터, 엔터로 끝까지 진행 주의할점은 package name은 kebab-case로 작성 ex) word-relay, camelCase나 UpperCamelCase 시 오류 하단 참조\n  생성된 package.json 설정\n /* package.json */\r{\r\u0026quot;name\u0026quot;: \u0026quot;word-relay\u0026quot;,\t// \u0026lt;\u0026lt;-- 입력한 package \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;\r},\r\u0026quot;author\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;\r}\r  해당 파일은 npm으로 필요한 패키지(디팬던시, 라이브러리 또는 플러그인)를 설치시 package.json에 자동으로 등록되며 이름과 패키지의 버전이 명시되어 빌드나 배포 시 사용된다.\n 2. 필요 패키지 설치 npm install vue -D //뷰 설치\rnpm i vue-loader -D\t//뷰 로더 설치\rnpm i vue-template-compiler@{vue version ex-2.6.14} -D //뷰 템플릿 컴파일러 설치 npm i vue-style-loader -D //뷰 스타일 로더 설치\rnpm i css-loader -D\t//CSS 로더 설치\r  설치 이후\n \r/* package.json */\r{\r\u0026quot;name\u0026quot;: \u0026quot;word-relay\u0026quot;,\r\u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r// \u0026lt;\u0026lt;-- 직접 수정해주어야함, npm run build 시 webpack을 사용함\r\u0026quot;build\u0026quot;: \u0026quot;webpack --watch\u0026quot; //\u0026lt;-- 자동빌드 옵션 },\r\u0026quot;author\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;,\r\u0026quot;devDependencies\u0026quot;: {\r\u0026quot;css-loader\u0026quot;: \u0026quot;^6.5.1\u0026quot;,\r\u0026quot;vue\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;vue-loader\u0026quot;: \u0026quot;^15.9.8\u0026quot;,\r\u0026quot;vue-style-loader\u0026quot;: \u0026quot;^4.1.3\u0026quot;,\r\u0026quot;vue-template-compiler\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;webpack\u0026quot;: \u0026quot;^5.64.0\u0026quot;,\r\u0026quot;webpack-cli\u0026quot;: \u0026quot;^4.9.1\u0026quot;\r\u0026quot;style-loader\u0026quot;: \u0026quot;^3.3.1\u0026quot;\r}\r}\r 3. html 파일 생성  프로젝트의 root 디렉토리에 html 파일 생성 ex) WordRelay.html\n \u0026lt;!-- WordRelay.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot; /\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;끝말잇기\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;끝말잇기\u0026lt;/h2\u0026gt;\r\u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\t// vue의 인스턴스를 연결할 root div \u0026lt;script src=\u0026quot;./dist/app2.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; //webpack을 통해 생성될 통합 app.js의 경로 webpack 빌드후 추가 해도됨\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 4. vue 파일 생성  프로젝트의 root 디렉토리에 vue 파일 생성 ex) WordRelay.vue  \u0026lt;!-- WordRelay.vue --\u0026gt;\r\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;제시어: {{ word }}\u0026lt;/h3\u0026gt;\r\u0026lt;form @submit.prevent=\u0026quot;onSubmitForm\u0026quot;\u0026gt;\r\u0026lt;input ref=\u0026quot;answer\u0026quot; minlength=\u0026quot;2\u0026quot; maxlength=\u0026quot;3\u0026quot; v-model=\u0026quot;value\u0026quot; /\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;입력\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;div\u0026gt;{{ result }}\u0026lt;/div\u0026gt;\r\u0026lt;br /\u0026gt;\r\u0026lt;p\u0026gt;사용한 단어는 사용할 수 없습니다.\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rlet arr = new Array();\rlet first_word = \u0026quot;공부\u0026quot;;\rarr.push(first_word);\rexport default {\rdata() {\rreturn {\rword: first_word,\rvalue: \u0026quot;\u0026quot;,\rresult: \u0026quot;\u0026quot;,\rhistory: arr,\r};\r},\rmethods: {\ronSubmitForm() {\rif (\rthis.word.charAt(this.word.length - 1) ===\rthis.value.charAt(0) \u0026amp;\u0026amp;\r!this.history.includes(this.value)\r) {\rthis.result = \u0026quot;\u0026quot;;\rthis.history.push(this.value);\rthis.word = this.value;\rthis.value = \u0026quot;\u0026quot;;\r} else if (this.history.includes(this.value)) {\rthis.result = \u0026quot;땡, 이전에 사용한 단어입니다.\u0026quot;;\r} else {\rthis.result = \u0026quot;땡\u0026quot;;\r}\r},\r},\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r\u0026lt;/style\u0026gt;\r 5. main.js 생성  프로젝트의 root 디렉토리에 vue 인스턴스를 생성할 js 파일 생성 ex) main.js  import Vue from 'vue' //npm으로 설치후 node_modules에 설치된 vue를 임포트\rimport WordRelay from './WordRelay.vue';\t// 프로젝트에 생성한 .vue 파일 이후 webpack.config.js 의 resolve, extensions 속성에 .vue 추가하면\r// extensions import WordRelay from './WordRelay'; 로 .vue 생략가능\rnew Vue(WordRelay).$mount('#root'); //Vue(.vue 파일 객체).$mount(.html root div id)\r 6. webpack.config.js 생성  프로젝트의 root 디렉토리에 webpack.config.js 생성\n const { VueLoaderPlugin } = require('vue-loader'); // @@@ plugins에 추가해야됨 @@@\rconst path = require('path');\rmodule.exports = { //웹패킹을 할때 모듈을 사용\rmode : 'development', // 프로젝트의 모드 설정 개발 'development', 운영 'production'\rdevtool : 'eval',\t// 하단 링크 참조\rresolve : {\t// 모듈을 해석하는 방식을 설정\rextensions : ['.js','.vue','.html'],\t//사용자가 import 할 때 확장자를 생략 할 수 있도록 함\r},\rentry : { //하나로 합쳐질 파일의 이름 스크립트 및 그외 파일들 rules로 js로 변환해서 통합 저장됨\rapp2 : path.join(__dirname,'main.js') // [name] (합쳐질 파일의 이름) : main.js (vue의 인스턴스가 선언된 js) 의 위치 },\rmodule : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\ttest : /\\.vue$/, // 정규식으로 .vue 파일인 경우 캐치 loader : 'vue-loader', // vue-loader로 변환하여 app.js에 적용\r}],\r},\rplugins : [\rnew VueLoaderPlugin(),\r],\routput : {\t// 프로젝트 산출물 filename : '[name].js',//'app2.js',\rpath : path.join(__dirname, 'dist'),\r}\r};\r devtool 옵션\n7. 빌드 및 webpack 실행 npm run build\r 성공시 출력 PS C:\\develop\\Git\\vue\\example\\3_끝말잇기\u0026gt; npm run build\r\u0026gt; word-relay@1.0.0 build\r\u0026gt; webpack\rasset app2.js 246 KiB [compared for emit] (name: app2)\rruntime modules 891 bytes 4 modules\rcacheable modules 229 KiB\rmodules by path ./*.vue 2.73 KiB\r./WordRelay.vue 1.1 KiB [built] [code generated]\r./WordRelay.vue?vue\u0026amp;type=template\u0026amp;id=39324767\u0026amp; 204 bytes [built] [code generated]\r./WordRelay.vue?vue\u0026amp;type=script\u0026amp;lang=ts\u0026amp; 268 bytes [built] [code generated]\r./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./WordRelay.vue?vue\u0026amp;type=template\u0026amp;id=39324767\u0026amp; 1.05 KiB [built] [code generated]\r./node_modules/vue-loader/lib/index.js??vue-loader-options!./WordRelay.vue?vue\u0026amp;type=script\u0026amp;lang=ts\u0026amp; 126 bytes [built] [code generated]\rmodules by path ./node_modules/ 226 KiB\r./node_modules/vue/dist/vue.runtime.esm.js 223 KiB [built] [code generated]\r./node_modules/vue-loader/lib/runtime/componentNormalizer.js 2.71 KiB [built] [code generated]\r./main.js 189 bytes [built] [code generated]\rwebpack 5.64.0 compiled successfully in 911 ms\r webpack 자동빌드 1. package.json 설정 {\r\u0026quot;name\u0026quot;: \u0026quot;number-baseball\u0026quot;,\r\u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;build\u0026quot;: \u0026quot;webpack --watch\u0026quot; // \u0026lt;\u0026lt;-- --watch 옵션 추가\r},\r\u0026quot;author\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;,\r\u0026quot;devDependencies\u0026quot;: {\r\u0026quot;css-loader\u0026quot;: \u0026quot;^6.5.1\u0026quot;,\r\u0026quot;vue\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;vue-loader\u0026quot;: \u0026quot;^15.9.8\u0026quot;,\r\u0026quot;vue-style-loader\u0026quot;: \u0026quot;^4.1.3\u0026quot;,\r\u0026quot;vue-template-compiler\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;webpack\u0026quot;: \u0026quot;^5.64.0\u0026quot;,\r\u0026quot;webpack-cli\u0026quot;: \u0026quot;^4.9.1\u0026quot;\r}\r}\r 2. webpack.config.js 설정 module.exports = { //웹패킹을 할때 모듈을 사용\rwatch: true,\rwatchOptions: {\rignored: '**/node_modules',\r},\r};\r CSS를 사용해 보자  .vue 파일에서 스타일을 적용하기 위해서는 새로운 로더가 필요하다\n \u0026lt;style\u0026gt;\r#screen {\rwidth: 300px;\rheight: 200px;\rtext-align: center;\ruser-select: none;\r}\r#screen .waiting {\rbackground-color: pink;\r}\r#screen .ready {\rbackground-color: yellow;\r}\r#screen .now {\rbackground-color: rgb(79, 128, 0);\r}\r\u0026lt;/style\u0026gt;\r style-loader npm i style-loader -D\r  webpack.config.js 모듈에 추가, 임포트, 플러그인 추가 안해도됨\n module : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\ttest : /\\.css$/, use : ['style-loader']\r}\r],\r css-loader npm i css-loader -D\r  webpack.config.js 모듈에 추가, 임포트, 플러그인 추가 안해도됨\n module : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\ttest : /\\.css$/, use : ['style-loader','css-loader']\r}\r],\r webpack wacth 옵션\nnom run build 시 나올 수 있는 오류 정리 configuration.output.path: The provided value \u0026ldquo;./dist\u0026rdquo; is not an absolute path! , The output directory as absolute path (required). Debugger attached.\r[webpack-cli] Invalid configuration object. Webpack has been initialized using a configuration object that does not match the API schema.\r- configuration.output.path: The provided value \u0026quot;./dist\u0026quot; is not an absolute path!\r-\u0026gt; The output directory as **absolute path** (required).\r  webpack.config.js의 path : \u0026lsquo;./dist\u0026rsquo;, \u0026laquo; 이부분을 절대경로로\n \rconst path = require('path'); /// 추가\rmodule.exports = { //웹패킹을 할때 모듈을 사용\rentry : {\rapp : path.join(__dirname,'main.js') //하나로 합쳐질 파일의 이름 스크립트 및 그외 파일들 js로 변환해서 통합 저장됨\r},\rmodule : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\r}],\r},\rplugins : [],\routput : {\rfilename : '[name].js',//'app.js',\rpath : path.join(__dirname, 'dist'), ///변경 }\r};\r 오류 없이 빌드 되지만 실행시 html에 root가 그리드 되지 않는 경우 main.js에 뷰 인스턴스 생성시 파라미터로 .vue 파일 객체 안넘긴 경우 import Vue from 'vue'\rimport WordRelay from './WordRelay.vue';\rnew Vue().$mount('#root'); //\u0026lt;\u0026lt;\u0026lt; Vue(WordRelay).$mount('#root');\r html에 webpack이 생성한 파일 ex) app2.js 추가 안한경우 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot; /\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;끝말잇기\u0026lt;/title\u0026gt;\r\u0026lt;style ref=\u0026quot;./dist/style.css\u0026quot;\u0026gt;\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;끝말잇기\u0026lt;/h2\u0026gt;\r\u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- \u0026lt;script src=\u0026quot;./dist/app.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r WARNING in configuration The \u0026lsquo;mode\u0026rsquo; option has not been set, webpack will fallback to \u0026lsquo;production\u0026rsquo; for this value. Set \u0026lsquo;mode\u0026rsquo; option to \u0026lsquo;development\u0026rsquo; or \u0026lsquo;production\u0026rsquo; to enable defaults for each environment. WARNING in configuration\rThe 'mode' option has not been set, webpack will fallback to 'production' for this value.\rSet 'mode' option to 'development' or 'production' to enable defaults for each environment.\rYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/\r  이런 경고가 계속 뜰경우 webpack.config.js module.exports 에 mode : \u0026lsquo;development\u0026rsquo; 추가\n You may need an additional loader to handle the result of these loaders.  loader 모듈이 필요하다는 오류,\n Debugger attached.\r\u0026gt; example@1.0.0 build\r\u0026gt; webpack\rDebugger attached.\rassets by status 64.6 KiB [cached] 1 asset\rorphan modules 227 KiB [orphan] 4 modules\rruntime modules 221 bytes 1 module\rmodules with errors 228 KiB [errors]\r./main.js + 4 modules 227 KiB [built] [code generated] [1 error]\r./example.vue?vue\u0026amp;type=template\u0026amp;id=063a7d4c\u0026amp; 217 bytes [built] [code generated] [1 error]\rERROR in ./example.vue?vue\u0026amp;type=template\u0026amp;id=063a7d4c\u0026amp; 2:0\rModule parse failed: Unexpected token (2:0)\rFile was processed with these loaders:\r* ./node_modules/vue-loader/lib/index.js\rYou may need an additional loader to handle the result of these loaders.\r|\r\u0026gt; \u0026lt;div\u0026gt;\r| \u0026lt;h1\u0026gt;{{result}}\u0026lt;/h1\u0026gt;\r| \u0026lt;form v-on:submit=\u0026quot;onSubmitForm\u0026quot;\u0026gt;\r@ ./example.vue 1:0-86 10:2-8 11:2-17\r@ ./main.js 2:0-36\rERROR in ./example.vue\rModule Error (from ./node_modules/vue-loader/lib/index.js):\rvue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config.\rError: vue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config.\rat Object.module.exports (C:\\develop\\Git\\vue\\example\\0.WebPack\\node_modules\\vue-loader\\lib\\index.js:36:29)\r@ ./main.js 2:0-36\r  아래의 부분을 처리할 수 없으며, 로더가 필요하다는 뜻\n |\r\u0026gt; \u0026lt;div\u0026gt;\r| \u0026lt;h1\u0026gt;{{result}}\u0026lt;/h1\u0026gt;\r| \u0026lt;form v-on:submit=\u0026quot;onSubmitForm\u0026quot;\u0026gt;\r  로더를 import 했지만 오류가 나던 상황이여서 골치를 앓고 있었는데, 내가 발생했던 이유는 webpack.config.js plugins에 VueLoaderPlugin()를 넣지 않아서 오류\n //const VueLoaderPlugin = require('vue-loader/lib/plugin')\rconst { VueLoaderPlugin } = require('vue-loader')\rconst path = require('path');\rmodule.exports = { //웹패킹을 할때 모듈을 사용\rentry : {\rapp : path.join(__dirname,'main.js') //하나로 합쳐질 파일의 이름 스크립트 및 그외 파일들 rules로 js로 변환해서 통합 저장됨\r},\rmodule : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\rtest : /\\.vue$/,\rloader : 'vue-loader', }],\r},\rplugins : [\rnew VueLoaderPlugin() // \u0026lt;\u0026lt;--- 이것이 빠져있었음\r], output : {\rfilename : '[name].js',//'app.js',\rpath : path.join(__dirname, 'dist'),\r}\r};\r ","description":"Vue.js WebPack 설정하기","id":67,"section":"blog","tags":["Front","Vue","framework"],"title":"Vue.js WebPack 설정하기","uri":"https://offetuoso.github.io/blog/develop/frontend/vue/vue-webpack/"},{"content":"Programmers - 12915 문자열 내 마음대로 정렬하기 Task description 원문 : Programmers 12915 링크\n문제 설명  문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [\u0026ldquo;sun\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;car\u0026rdquo;]이고 n이 1이면 각 단어의 인덱스 1의 문자 \u0026ldquo;u\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;a\u0026quot;로 strings를 정렬합니다.\n Condition   strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.   ###입력 형식\n 입출력 예\n    strings n return     [\u0026ldquo;sun\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;car\u0026rdquo;] 1 [\u0026ldquo;car\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;sun\u0026rdquo;]   [\u0026ldquo;abce\u0026rdquo;, \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;] 2 [\u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;abce\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;]    Solution import java.util.ArrayList;\rimport java.util.Collections;\rclass SortStringAtWill {\rpublic static void main(String[] args) {\rString[] strings = {\u0026quot;car\u0026quot;, \u0026quot;bed\u0026quot;, \u0026quot;sun\u0026quot;};\rString[] result = new SortStringAtWill().solution(strings, 1);\rfor(int i=0; i\u0026lt;result.length;i++) {\rSystem.out.println(result[i]);\r}\r}\rpublic String[] solution(String[] strings, int n) {\rArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();\rfor(int i=0;i\u0026lt;strings.length;i++) {\rlist.add(strings[i].charAt(n)+strings[i]);\r}\rCollections.sort(list);\rfor(int i=0; i\u0026lt;list.size();i++) {\rstrings[i] = list.get(i).substring(1);\r}\rreturn strings;\r}\r}\r TestCase    strings n return     [\u0026ldquo;sun\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;car\u0026rdquo;] 1 [\u0026ldquo;car\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;sun\u0026rdquo;]   [\u0026ldquo;abce\u0026rdquo;, \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;] 2 [\u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;abce\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;]    ","description":"12915 문자열 내 마음대로 정렬하기","id":68,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12915 문자열 내 마음대로 정렬하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12915-sort-string-at-will/"},{"content":"Programmers - 12917 문자열 내림차순으로 배치하기 Task description 원문 : Programmers 12917 링크\n문제 설명  문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.\n Condition   str은 길이 1 이상인 문자열입니다.   ###입력 형식\n 입출력 예\n    s return     \u0026ldquo;Zbcdefg\u0026rdquo; \u0026ldquo;gfedcbZ\u0026rdquo;    Solution import java.util.Arrays;\rclass Solution {\rpublic String solution(String s) {\rString answer = \u0026quot;\u0026quot;;\rchar[] ch = s.toCharArray();\rint[] list = new int[ch.length];\rfor(int i = 0 ; i\u0026lt; ch.length; i++) {\rlist[i] = ch[i];\r}\rArrays.sort(list);\rfor(int i=list.length-1;i\u0026gt;-1;i--){\ranswer = answer+String.valueOf((char)list[i]);\r}\rreturn answer;\r}\r}\r Others Solution import java.util.Arrays;\rclass Solution {\rpublic String solution(String s) {\rpublic String solution2(String s) {\rString answer = \u0026quot;\u0026quot;;\rchar[] ch = s.toCharArray();\rArrays.sort(ch);\rreturn new StringBuilder(new String(ch)).reverse().toString();\r}\r}\r TestCase \u0026quot;Zbcdefg\u0026quot;\t\u0026quot;gfedcbZ\u0026quot;\r ","description":"12917 문자열 내림차순으로 배치하기","id":69,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12917 문자열 내림차순으로 배치하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12917-descending-order/"},{"content":"Programmers - 12951 JadenCase 문자열 만들기 Task description 원문 : Programmers 12951 링크\n문제 설명  JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.\n Condition   s는 길이 1 이상인 문자열입니다. s는 알파벳과 공백문자(\u0026quot; \u0026ldquo;)로 이루어져 있습니다. 첫 문자가 영문이 아닐때에는 이어지는 영문은 소문자로 씁니다. ( 첫번째 입출력 예 참고 )   ###입력 형식\n 입출력 예\n    s return     \u0026ldquo;3people unFollowed me\u0026rdquo; \u0026ldquo;3people Unfollowed Me\u0026rdquo;   \u0026ldquo;for the last week\u0026rdquo; \u0026ldquo;For The Last Week\u0026rdquo;    Solution class JadenCase {\rpublic static void main(String[] args) {\rSystem.out.println(new JadenCase().solution(\u0026quot;3people unFollowed me\u0026quot;));\r}\rpublic String solution(String s) {\rString answer = \u0026quot;\u0026quot;;\rs = s.toLowerCase();\rint idx = 0;\rfor(int i=0; i \u0026lt; s.length() ;i++) {\rchar ch = s.charAt(i);\rif(ch == ' ') {\ridx = 0;\r}else {\ridx ++;\r}\rif(idx == 1) {\ranswer += String.valueOf(ch).toUpperCase();\r}else {\ranswer += String.valueOf(ch);\r}\r}\rreturn answer;\r}\r}\r Others Solution class JadenCase {\rpublic static void main(String[] args) {\rSystem.out.println(new JadenCase().solution(\u0026quot;3people unFollowed me\u0026quot;));\r}\rpublic String solution(String s) {\rString answer = \u0026quot;\u0026quot;;\rString[] sp = s.toLowerCase().split(\u0026quot;\u0026quot;);\rboolean flag = true;\rfor(String ss : sp) {\ranswer += flag ? ss.toUpperCase() : ss;\rflag = ss.equals(\u0026quot; \u0026quot;) ? true : false;\r}\rreturn answer;\r}\r}\r TestCase \r\u0026quot;3people unFollowed me\u0026quot;\t\u0026quot;3people Unfollowed Me\u0026quot;\r\u0026quot;for the last week\u0026quot;\t\u0026quot;For The Last Week\u0026quot;\r ","description":"12951 JadenCase 문자열 만들기","id":70,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12951 JadenCase 문자열 만들기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12951-jaden-case/"},{"content":"Programmers - 12981 영어 끝말잇기 Task description 원문 : Programmers 12981 링크\n문제 설명  1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.\n  1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.\n  tank → kick → know → wheel → land → dream → mother → robot → tank\n  위 끝말잇기는 다음과 같이 진행됩니다.\n 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.\r2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.\r3번 사람이 자신의 첫 번째 차례에 know를 말합니다.\r1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.\r(계속 진행)\r끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.\r  사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.\n Condition   끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.   ###입력 형식\n 입출력 예\n    n words result     3 [\u0026ldquo;tank\u0026rdquo;, \u0026ldquo;kick\u0026rdquo;, \u0026ldquo;know\u0026rdquo;, \u0026ldquo;wheel\u0026rdquo;, \u0026ldquo;land\u0026rdquo;, \u0026ldquo;dream\u0026rdquo;, \u0026ldquo;mother\u0026rdquo;, \u0026ldquo;robot\u0026rdquo;, \u0026ldquo;tank\u0026rdquo;] [3,3]   5 [\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;observe\u0026rdquo;, \u0026ldquo;effect\u0026rdquo;, \u0026ldquo;take\u0026rdquo;, \u0026ldquo;either\u0026rdquo;, \u0026ldquo;recognize\u0026rdquo;, \u0026ldquo;encourage\u0026rdquo;, \u0026ldquo;ensure\u0026rdquo;, \u0026ldquo;establish\u0026rdquo;, \u0026ldquo;hang\u0026rdquo;, \u0026ldquo;gather\u0026rdquo;, \u0026ldquo;refer\u0026rdquo;, \u0026ldquo;reference\u0026rdquo;, \u0026ldquo;estimate\u0026rdquo;, \u0026ldquo;executive\u0026rdquo;] [0,0]   2 [\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;one\u0026rdquo;, \u0026ldquo;even\u0026rdquo;, \u0026ldquo;never\u0026rdquo;, \u0026ldquo;now\u0026rdquo;, \u0026ldquo;world\u0026rdquo;, \u0026ldquo;draw\u0026rdquo;] [1,3]     입출력 예 설명\n  입출력 예 #1 3명의 사람이 끝말잇기에 참여하고 있습니다.\n  1번 사람 : tank, wheel, mother 2번 사람 : kick, land, robot\n3번 사람 : know, dream, tank\n와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.\n  입출력 예 #2\n5명의 사람이 끝말잇기에 참여하고 있습니다.\n 1번 사람 : hello, recognize, gather\r2번 사람 : observe, encourage, refer\r3번 사람 : effect, ensure, reference\r4번 사람 : take, establish, estimate\r5번 사람 : either, hang, executive\r와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.\r  입출력 예 #3 2명의 사람이 끝말잇기에 참여하고 있습니다.\n 1번 사람 : hello, even, now, draw\r2번 사람 : one, never, world\r와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.\r Solution def solution(n, words):\ranswers = []\rprev = \u0026quot;\u0026quot;\rfor i in range(len(words)):\rturn = (i // n) + 1\rplayer = (i % n) +1 curr = words[i]\rif prev != \u0026quot;\u0026quot; and prev[-1] != curr[0] or curr in answers:\rreturn [player, turn]\relse:\ranswers.append(curr)\rprev = curr\rreturn [0, 0]\r Others Solution def solution(n, words):\rfor p in range(1, len(words)):\rif words[p][0] != words[p-1][-1] or words[p] in words[:p]: return [(p%n)+1, (p//n)+1]\relse:\rreturn [0,0]\r TestCase \rprint(\rsolution(\r3, [\u0026quot;tank\u0026quot;, \u0026quot;kick\u0026quot;, \u0026quot;know\u0026quot;, \u0026quot;wheel\u0026quot;, \u0026quot;land\u0026quot;, \u0026quot;dream\u0026quot;, \u0026quot;mother\u0026quot;, \u0026quot;robot\u0026quot;, \u0026quot;tank\u0026quot;]\r)\r)\rprint(\rsolution(\r5, [\u0026quot;hello\u0026quot;, \u0026quot;observe\u0026quot;, \u0026quot;effect\u0026quot;, \u0026quot;take\u0026quot;, \u0026quot;either\u0026quot;, \u0026quot;recognize\u0026quot;, \u0026quot;encourage\u0026quot;, \u0026quot;ensure\u0026quot;, \u0026quot;establish\u0026quot;, \u0026quot;hang\u0026quot;, \u0026quot;gather\u0026quot;, \u0026quot;refer\u0026quot;, \u0026quot;reference\u0026quot;, \u0026quot;estimate\u0026quot;, \u0026quot;executive\u0026quot;]\r)\r)\rprint(\rsolution(\r2,\t[\u0026quot;hello\u0026quot;, \u0026quot;one\u0026quot;, \u0026quot;even\u0026quot;, \u0026quot;never\u0026quot;, \u0026quot;now\u0026quot;, \u0026quot;world\u0026quot;, \u0026quot;draw\u0026quot;]\r)\r)\r ","description":"12981 영어 끝말잇기","id":71,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12981 영어 끝말잇기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12981-end-talk/"},{"content":"Programmers - 42586 기능개발 Task description 원문 : Programmers 42586 링크\n문제 설명  프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.\n  먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.\n 입출력 예 #2 모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.\n따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.\n※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다.\nCondition   작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.   입력 형식  입출력 예\n    progresses speeds return     [93, 30, 55] [1, 30, 5] [2, 1]   [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2]    입출력 예 설명  입출력 예 #1 첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\n두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다. 세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\n Solution from collections import deque\rimport copy\rdef solution(progresses, speeds):\rrequired_time = []\rfor i in range(len(progresses)):\rprint(progresses[i], speeds[i])\rrequired = (100 - progresses[i]) // speeds[i]\rif (100 - progresses[i]) % speeds[i] != 0:\rrequired += 1\rrequired_time.append(required)\rque = deque(required_time)\ranswer = []\rwhile que:\rstack = []\rtmp = copy.deepcopy(que)\rfirst_job = que[0]\rfor i in range(len(tmp)):\rif i == 0 or first_job \u0026gt;= tmp[i]:\rstack.append(tmp[i])\rque.popleft()\relse:\rbreak\ranswer.append(len(stack))\rreturn answer\r Others Solution 1 from math import ceil\rdef solution(progresses, speeds):\rdaysLeft = list(map(lambda x: (ceil((100 - progresses[x]) / speeds[x])), range(len(progresses))))\rcount = 1\rretList = []\rfor i in range(len(daysLeft)):\rtry:\rif daysLeft[i] \u0026lt; daysLeft[i + 1]:\rretList.append(count)\rcount = 1\relse:\rdaysLeft[i + 1] = daysLeft[i]\rcount += 1\rexcept IndexError:\rretList.append(count)\rreturn retList\r 2 def solution(progresses, speeds):\rQ=[]\rfor p, s in zip(progresses, speeds):\rif len(Q)==0 or Q[-1][0]\u0026lt;-((p-100)//s):\rQ.append([-((p-100)//s),1])\relse:\rQ[-1][1]+=1\rreturn [q[1] for q in Q]\r TestCase print(solution([93, 30, 55], [1, 30, 5]), [2, 1])\rprint(solution([95, 90, 99, 99, 80, 99], [1, 1, 1, 1, 1, 1]), [1, 3, 2])\r ","description":"42586 기능개발","id":72,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42586 기능개발","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-42586-function-development/"},{"content":"Programmers - 20426 복서 정렬하기 Task description 원문 : Programmers 20426 링크\n문제 설명  복서 선수들의 몸무게 weights와, 복서 선수들의 전적을 나타내는 head2head가 매개변수로 주어집니다. 복서 선수들의 번호를 다음과 같은 순서로 정렬한 후 return 하도록 solution 함수를 완성해주세요.\n   전체 승률이 높은 복서의 번호가 앞쪽으로 갑니다. 아직 다른 복서랑 붙어본 적이 없는 복서의 승률은 0%로 취급합니다. 승률이 동일한 복서의 번호들 중에서는 자신보다 몸무게가 무거운 복서를 이긴 횟수가 많은 복서의 번호가 앞쪽으로 갑니다. 자신보다 무거운 복서를 이긴 횟수까지 동일한 복서의 번호들 중에서는 자기 몸무게가 무거운 복서의 번호가 앞쪽으로 갑니다. 자기 몸무게까지 동일한 복서의 번호들 중에서는 작은 번호가 앞쪽으로 갑니다.   Condition   weights의 길이는 2 이상 1,000 이하입니다. weights의 모든 값은 45 이상 150 이하의 정수입니다. weights[i] 는 i+1번 복서의 몸무게(kg)를 의미합니다. head2head의 길이는 weights의 길이와 같습니다. head2head의 모든 문자열은 길이가 weights의 길이와 동일하며, \u0026lsquo;N\u0026rsquo;, \u0026lsquo;W\u0026rsquo;, \u0026lsquo;L\u0026rsquo;로 이루어진 문자열입니다. head2head[i] 는 i+1번 복서의 전적을 의미하며, head2head[i][j]는 i+1번 복서와 j+1번 복서의 매치 결과를 의미합니다. \u0026lsquo;N\u0026rsquo; (None)은 두 복서가 아직 붙어본 적이 없음을 의미합니다. \u0026lsquo;W\u0026rsquo; (Win)는 i+1번 복서가 j+1번 복서를 이겼음을 의미합니다. \u0026lsquo;L\u0026rsquo; (Lose)는 i+1번 복사가 j+1번 복서에게 졌음을 의미합니다. 임의의 i에 대해서 head2head[i][i] 는 항상 \u0026lsquo;N\u0026rsquo;입니다. 자기 자신과 싸울 수는 없기 때문입니다. 임의의 i, j에 대해서 head2head[i][j] = \u0026lsquo;W\u0026rsquo; 이면, head2head[j][i] = \u0026lsquo;L\u0026rsquo;입니다. 임의의 i, j에 대해서 head2head[i][j] = \u0026lsquo;L\u0026rsquo; 이면, head2head[j][i] = \u0026lsquo;W\u0026rsquo;입니다. 임의의 i, j에 대해서 head2head[i][j] = \u0026lsquo;N\u0026rsquo; 이면, head2head[j][i] = \u0026lsquo;N\u0026rsquo;입니다.   ###입력 형식\n 입출력 예\n    n result     6 8   16 4   626331 -1       weights head2head result     [50,82,75,120] [\u0026ldquo;NLWL\u0026rdquo;,\u0026ldquo;WNLL\u0026rdquo;,\u0026ldquo;LWNW\u0026rdquo;,\u0026ldquo;WWLN\u0026rdquo;] [3,4,1,2]   [145,92,86] [\u0026ldquo;NLW\u0026rdquo;,\u0026ldquo;WNL\u0026rdquo;,\u0026ldquo;LWN\u0026rdquo;] [2,3,1]   [60,70,60] [\u0026ldquo;NNN\u0026rdquo;,\u0026ldquo;NNN\u0026rdquo;,\u0026ldquo;NNN\u0026rdquo;] [2,1,3]    입출력 예 #1\n다음은 선수들의 정보를 나타낸 표입니다.\n   선수 번호 vs 1번 vs 2번 vs 3번 vs 4번 승률 자기보다 무거운 복서를 이긴 횟수 몸무게     1 1번 - 패배 승리 패배 33.33% 1회 50kg   2 2번 승 - 패배 패배 33.33% 0회 82kg   3 3번 패 승리 - 승리 66.66% 2회 75kg   4 4번 승 승리 패배 - 66.66% 0회 120kg    Solution def solution(weights, head2head):\ranswer = []\rplayer = []\rfor i in range(len(weights)):\rwin_cnt = 0\rtotal_cnt = 0\rwin_heavier_cnt = 0\rfor j in range(len(head2head[i])):\rif head2head[i][j] != \u0026quot;N\u0026quot;: total_cnt += 1\rif head2head[i][j] == \u0026quot;W\u0026quot;:\rwin_cnt += 1\rif weights[i] \u0026lt; weights[j]:\rwin_heavier_cnt += 1\rdata = []\rtry:\rrate = (win_cnt / total_cnt) * 1000000\rexcept:\rrate = 0\rdata.append(rate) # 승률\rdata.append(win_heavier_cnt) # 무거운 사람에게 승수\rdata.append(weights[i]) # 무게\rdata.append(i + 1) # 번호\rplayer.append(data)\rfor i in sorted(player, key=lambda x: (-x[0], -x[1], -x[2], x[3])):\ranswer.append(i[3])\rreturn answer\r Others Solution def solution(weights, head2head):\rresult = []\rl = len(weights)\r# 한 번에 정렬해서 풀어봅시다!\rans = [[0 for _ in range(4)] for _ in range(l)] # 승률, 무거운복서 이긴횟수, 자기 몸무게, 번호(음수로)\rfor i in range(l):\rans[i][2] = weights[i]\rans[i][3] = -(i+1)\rcnt = 0 # 판수\rfor j in range(l):\rif head2head[i][j] == 'W':\rans[i][0] += 1 # 일단 이김\rcnt += 1\rif weights[i] \u0026lt; weights[j]:\rans[i][1] += 1 # 무거운 복서 이김\relif head2head[i][j] == 'L':\rcnt += 1 # 판수만 늘려준다\rif cnt == 0:\rans[i][0] = 0\relse:\rans[i][0] /= cnt\rans.sort(reverse=True) # 역순으로 정렬하면 모든 조건이 한 번에 정렬된다\rfor i in range(l):\rresult.append(-ans[i][3])\rreturn result\r TestCase print(solution([50, 82, 75, 120], [\u0026quot;NLWL\u0026quot;, \u0026quot;WNLL\u0026quot;, \u0026quot;LWNW\u0026quot;, \u0026quot;WWLN\u0026quot;]), [3, 4, 1, 2])\rprint(solution([145, 92, 86], [\u0026quot;NLW\u0026quot;, \u0026quot;WNL\u0026quot;, \u0026quot;LWN\u0026quot;]), [2, 3, 1])\rprint(solution([60, 70, 60], [\u0026quot;NNN\u0026quot;, \u0026quot;NNN\u0026quot;, \u0026quot;NNN\u0026quot;]), [2, 1, 3])\r ","description":"20426 복서 정렬하기","id":73,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 20426 복서 정렬하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-20426-boxer-sorting/"},{"content":"Programmers - 129343 콜라츠 추측 Task description 원문 : Programmers 129343 링크\n문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.\n  예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\n 제한 사항 Condition   입력된 수, num은 1 이상 8000000 미만인 정수입니다.   ###입력 형식\n 입출력 예\n    n result     6 8   16 4   626331 -1    입출력 예 #2\r16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 이되어 총 4번만에 1이 됩니다.\r입출력 예 #3\r626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\r Solution def collatz(num):\rcnt = 0\rwhile(True) :\rif cnt \u0026gt;= 500 :\rreturn -1\relif num == 1 :\rreturn cnt\rif num % 2 == 0 : #짝\rnum = num//2\relse : num = num * 3 + 1\rcnt += 1\rprint(collatz(6))\r Others Solution def collatz(num):\rif num == 1 :\rreturn 0\rfor i in range(500):\rnum = num / 2 if num % 2 == 0 else num*3 + 1\rif num == 1:\rreturn i + 1\rreturn -1\rprint(collatz(6))\r TestCase print(collatz(6))\rprint(collatz(16))\rprint(collatz(626331))\rprint(collatz(1))\r ","description":"129343 콜라츠 추측","id":74,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 129343 콜라츠 추측","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-129343-collatz/"},{"content":"Programmers - 83201 상호평가 Task description 원문 : Programmers 83201 링크\n 대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.\n    No. 0 1 2 3 4     0 100 90 98 88 65   1 50 45 99 85 77   2 47 88 95 80 67   3 61 57 100 80 65   4 24 90 94 75 65   평균 45.5 81.25 97.2 81.6 67.8   학점 F B A B D     위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.\n  0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다.\n0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.\n2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다.\n2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.\n당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.\n만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.\n  0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다. 0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.\n4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다. 4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.\n제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.\n    평균 학점     90점 이상\tA   80점 이상 90점 미만\tB   70점 이상 80점 미만\tC   50점 이상 70점 미만\tD   50점 미만\tF     학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.\n Condition   제한사항 2 ≤ scores의 행의 길이(학생 수) ≤ 10 scores의 열의 길이 = scores의 행의 길이 즉, scores는 행과 열의 길이가 같은 2차원 배열입니다. 0 ≤ scores의 원소 ≤ 100   ###입력 형식\n   scores result     [[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]] FBABD\u0026quot;   [[50,90],[50,87]] A\u0026quot;   [[70,49,90],[68,50,38],[73,31,100]] CFD\u0026quot;     출력 예 설명\n입출력 예 #1\n  문제 예시와 같습니다.\n  입출력 예 #2\n    No. 0 1     0 50 90   1 50 87   평균 50 90   학점 D A     1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.\n  입출력 예 #3\n    No. 0 1 2     0 70 49 90   1 68 50 38   2 73 31 100   평균 70.33… 40 64   학점 C F D     1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n  2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n  return 값 형식\n0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.\n Solution   테이블을 피봇하여 n번학생이 평가한 항목 리스트가 아닌, n번 학생에 대한 평가 리스트로 변경 자신이 평가한 최대값 또는 최소값이 유일한 최소, 최대값이라면 리스트에서 제거 2.의 리스트의 평균을 구하여, 등급을 메겨서 문자열로 붙여서 반환    몇가지 케이스를 통과하지 못해서 좀더 풀어봐야 할거같다.\n def solution(scores):\ranswer = ''\rpivot = []\rfor i in range(0, len(scores)) :\rfor j in range(0, len(scores)) :\rif j == 0 :\rtemp = []\rtemp.append(scores[j][i])\rpivot.append(temp)\ranswer = ''\rfor i in range(0, len(pivot)) : score = pivot[i]\rmin_value = min(score)\rmin_cnt = score.count(min_value)\rmax_value = max(score)\rmax_cnt = score.count(max_value)\r_score = [ score[k] for k in range(0, len(score)) if i != k or not ( (i == k and min_value == score[k] and min_cnt == 1) or (i == k and max_value == score[k] and max_cnt == 1) )]\ravg = sum(_score)/len(_score)\rif 90 \u0026lt;= avg:\ranswer += 'A'\relif 80 \u0026lt;= avg \u0026lt; 90 : answer += 'B'\relif 70 \u0026lt;= avg \u0026lt; 80 : answer += 'C'\relif 50 \u0026lt;= avg \u0026lt; 70 : answer += 'D'\relif avg \u0026lt; 50 : answer += 'F'\rreturn answer\r Others Solution def solution(scores):\ranswer = ''\rfor i, score in enumerate(zip(*scores)):\ravg = (sum(score) - score[i]) / (len(score) - 1) if score[i] in (min(score), max(score)) and score.count(score[i]) == 1 else sum(score) / len(score)\ranswer += \u0026quot;%s\u0026quot; % (\r\u0026quot;A\u0026quot; if 90 \u0026lt;= avg else\r\u0026quot;B\u0026quot; if 80 \u0026lt;= avg else\r\u0026quot;C\u0026quot; if 70 \u0026lt;= avg else\r\u0026quot;D\u0026quot; if 50 \u0026lt;= avg else\r\u0026quot;F\u0026quot;\r)\rreturn answer\r from collections import Counter\rdef solution(scores): answer = ''\rfor idx, score in enumerate(list(map(list, zip(*scores)))):\rlength = len(score)\rif Counter(score)[score[idx]] == 1 and (max(score) == score[idx] or min(score) == score[idx]):\rdel score[idx]\rlength -= 1\rgrade = sum(score) / length\rif grade \u0026gt;= 90:\ranswer += 'A'\relif grade \u0026gt;= 80:\ranswer += 'B'\relif grade \u0026gt;= 70:\ranswer += 'C'\relif grade \u0026gt;= 50:\ranswer += 'D'\relse:\ranswer += 'F'\rreturn answer\r TestCase print(solution([[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]),\t\u0026quot;FBABD\u0026quot;)\rprint(solution([[50,90],[50,87]]),\t\u0026quot;DA\u0026quot;)\rprint(solution([[70,49,90],[68,50,38],[73,31,100]]),\t\u0026quot;CFD\u0026quot;)\rprint(solution([[0,50,0],[50,0,0],[50,0,0]]),\t\u0026quot;CFD\u0026quot;)\r ","description":"83201 상호평가","id":75,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 83201 상호평가","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-83201-mutual-evaluation/"},{"content":"Programmers - 12910 나누어 떨어지는 숫자 배열 Task description 원문 : Programmers 12910 링크\n array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.\ndivisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.\n Condition   arr은 자연수를 담은 배열입니다. 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다. divisor는 자연수입니다. array는 길이 1 이상인 배열입니다.   ###입력 형식\n   arr divisor return     [5, 9, 7, 10] 5 [5, 10]   [2, 36, 1, 3] 1 [1, 2, 3, 36]   [3,2,6] 10 [-1]     입출력 예 설명\n입출력 예#1 arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다.\n  입출력 예#2\narr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다.\n  입출력 예#3\n3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다.\n Solution   배열의 요소 i를 divisor로 나눠떨어지면 배열에 담는다. 반환된 배열을 정렬한다. 배열이 비어있다면, [-1]로 반환한다.    def solution(arr, divisor):\rreturn sorted([i for i in arr if i%divisor == 0]) if len([i for i in arr if i%divisor == 0]) != 0 else [-1]\r Others Solution  마지막 [] 이면 이라는 조건을 단지 or로 사용\n def solution(arr, divisor): return sorted([n for n in arr if n%divisor == 0]) or [-1]\r TestCase print(solution([5, 9, 7, 10],\t5),\t[5, 10])\rprint(solution([2, 36, 1, 3],\t1),\t[1, 2, 3, 36])\rprint(solution([3,2,6],\t10),\t[-1])\r ","description":"12910 나누어 떨어지는 숫자 배열","id":76,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12910 나누어 떨어지는 숫자 배열","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-12910-divisible-array-of-numbers/"},{"content":"Programmers - 72412 순위 검색 Task description 원문 : Programmers 72412 링크\n 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.\n  코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다. 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다. 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다. 인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다. 예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다. 코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?   물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.   코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가? 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가? 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가? 즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.   * [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가? [문제] 지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때, 각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.\n Condition   info 배열의 크기는 1 이상 50,000 이하입니다. info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 \u0026ldquo;개발언어 직군 경력 소울푸드 점수\u0026rdquo; 형식입니다. 개발언어는 cpp, java, python 중 하나입니다. 직군은 backend, frontend 중 하나입니다. 경력은 junior, senior 중 하나입니다. 소울푸드는 chicken, pizza 중 하나입니다. 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. query 배열의 크기는 1 이상 100,000 이하입니다. query의 각 문자열은 \u0026ldquo;[조건] X\u0026rdquo; 형식입니다. [조건]은 \u0026ldquo;개발언어 and 직군 and 경력 and 소울푸드\u0026rdquo; 형식의 문자열입니다. 언어는 cpp, java, python, - 중 하나입니다. 직군은 backend, frontend, - 중 하나입니다. 경력은 junior, senior, - 중 하나입니다. 소울푸드는 chicken, pizza, - 중 하나입니다. \u0026lsquo;-\u0026rsquo; 표시는 해당 조건을 고려하지 않겠다는 의미입니다. X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. 예를 들면, \u0026ldquo;cpp and - and senior and pizza 500\u0026quot;은 \u0026ldquo;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 \u0026gt;- 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026ldquo;를 의미합니다.   ###입력 형식\n   info query result     [\u0026ldquo;java backend junior pizza 150\u0026rdquo;,\u0026ldquo;python frontend senior chicken 210\u0026rdquo;,\u0026ldquo;python frontend senior chicken 150\u0026rdquo;,\u0026ldquo;cpp backend senior pizza 260\u0026rdquo;,\u0026ldquo;java backend junior chicken 80\u0026rdquo;,\u0026ldquo;python backend senior chicken 50\u0026rdquo;] [\u0026ldquo;java and backend and junior and pizza 100\u0026rdquo;,\u0026ldquo;python and frontend and senior and chicken 200\u0026rdquo;,\u0026ldquo;cpp and - and senior and pizza 250\u0026rdquo;,\u0026quot;- and backend and senior and - 150\u0026rdquo;,\u0026quot;- and - and - and chicken 100\u0026rdquo;,\u0026quot;- and - and - and - 150\u0026rdquo;] [1,1,1,1,2,4]     입출력 예에 대한 설명 지원자 정보를 표로 나타내면 다음과 같습니다.\n    언어 직군 경력 소울 푸드 점수     java backend junior pizza 150   python frontend senior chicken 210   python frontend senior chicken 150   cpp backend  senior pizza   java backend junior chicken 80   python backend senior chicken 50      \u0026ldquo;java and backend and junior and pizza 100\u0026rdquo; : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다. \u0026ldquo;python and frontend and senior and chicken 200\u0026rdquo; : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다. \u0026ldquo;cpp and - and senior and pizza 250\u0026rdquo; : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다. \u0026ldquo;- and backend and senior and - 150\u0026rdquo; : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다. \u0026ldquo;- and - and - and chicken 100\u0026rdquo; : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다. \u0026ldquo;- and - and - and - 150\u0026rdquo; : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.   Solution  테스트 케이스를 통과하였지만, 효율성을 통과하지 못한 답변 1\n  def solution(info, query):\ranswer = []\rdatas = []\rquery_cnt = 5\rfor i in range(0,len(info)) :\rdatas.append(re.split(r' ',info[i]))\rfor i in range(0,len(query)) :\r_datas = datas order = str(query[i].replace('and ', '', query_cnt)).split()\rfor k in range(0,query_cnt) :\rif k \u0026lt; query_cnt-1 :\r_datas = [user for user in _datas if order[k] == user[k] or order[k] == '-'] else : _datas = [user for user in _datas if int(order[k]) \u0026lt;= int(user[k]) or order[k] == '-'] answer.append(len(_datas))\rreturn answer\r  테스트 케이스를 통과하였지만, 효율성을 통과하지 못한 답변 2\n import re\rdef solution(info, query):\ranswer = []\rdatas = []\rquery_cnt = 5\rfor i in range(0,len(info)) :\rdatas.append(re.split(r' ',info[i]))\rfor i in range(0,len(query)) :\r_datas = datas order = str(query[i].replace('and ', '', query_cnt)).split()\r_datas = [user for user in _datas if order[0] == user[0] or order[0] == '-'] _datas = [user for user in _datas if order[1] == user[1] or order[1] == '-'] _datas = [user for user in _datas if order[2] == user[2] or order[2] == '-'] _datas = [user for user in _datas if order[3] == user[3] or order[3] == '-'] _datas = [user for user in _datas if int(order[4]) \u0026lt;= int(user[4]) or order[4] == '-'] answer.append(len(_datas))\rreturn answer\r  -까지 포함된 모든 경우의 수를 키로 만들어 dic 으로 점수를 저장 dic을 정렬하고 2진검색을 사용하여 검색\n def solution(info, query):\ranswer = []\rdic = {}\rcomb = [0, 1, 2, 3]\rfor i in info:\rdata = i.split()\rconditions = data[:-1]\rscore = int(data[-1])\rfor j in range(5):\rfor k in list(combinations(comb, j)):\rtemp = conditions.copy()\rfor idx in k:\rtemp[idx] = '-'\rkey = ''.join(temp)\rif key in dic:\rdic[key].append(score)\relse:\rdic[key] = [score]\rfor value in dic.values(): value.sort()\rfor i in query:\rq_list = []\rfor j in i.split():\rif j == 'and':\rcontinue\rq_list.append(j)\rkey = ''.join(q_list[:-1])\rvalue = int(q_list[-1])\rif key in dic:\rdic_list = dic[key]\rindex = bisect_left(dic_list, value)\ranswer.append(len(dic_list) - index)\relse:\ranswer.append(0)\rcontinue\rreturn answer\r Others Solution from itertools import combinations\rdef solution(info, query):\ranswer = []\rdb = {}\rfor i in info: # info에 대해 반복\rtemp = i.split()\rconditions = temp[:-1] # 조건들만 모으고, 점수 따로\rscore = int(temp[-1]) for n in range(5): # 조건들에 대해 조합을 이용해서 combi = list(combinations(range(4), n))\rfor c in combi:\rt_c = conditions.copy()\rfor v in c: # '-'를 포함한 새로운 조건을 만들어냄.\rt_c[v] = '-'\rchanged_t_c = '/'.join(t_c)\rif changed_t_c in db: # 모든 조건의 경우에 수에 대해 딕셔너리\rdb[changed_t_c].append(score)\relse:\rdb[changed_t_c] = [score]\rfor value in db.values(): # 딕셔너리 내 모든 값 정렬\rvalue.sort()\rfor q in query: # query의 모든 조건에 대해서\rqry = [i for i in q.split() if i != 'and']\rqry_cnd = '/'.join(qry[:-1])\rqry_score = int(qry[-1])\rif qry_cnd in db: # 딕셔너리 내에 값이 존재한다면,\rdata = db[qry_cnd]\rif len(data) \u0026gt; 0: start, end = 0, len(data) # lower bound 알고리즘 통해 인덱스 찾고,\rwhile start != end and start != len(data):\rif data[(start + end) // 2] \u0026gt;= qry_score:\rend = (start + end) // 2\relse:\rstart = (start + end) // 2 + 1\ranswer.append(len(data) - start) # 해당 인덱스부터 끝까지의 갯수가 정답\relse:\ranswer.append(0)\rreturn answer\r TestCase info = [\u0026quot;java backend junior pizza 150\u0026quot;,\u0026quot;python frontend senior chicken 210\u0026quot;,\u0026quot;python frontend senior chicken 150\u0026quot;,\u0026quot;cpp backend senior pizza 260\u0026quot;,\u0026quot;java backend junior chicken 80\u0026quot;,\u0026quot;python backend senior chicken 50\u0026quot;]\tquery = [\u0026quot;java and backend and junior and pizza 100\u0026quot;,\u0026quot;python and frontend and senior and chicken 200\u0026quot;,\u0026quot;cpp and - and senior and pizza 250\u0026quot;,\u0026quot;- and backend and senior and - 150\u0026quot;,\u0026quot;- and - and - and chicken 100\u0026quot;,\u0026quot;- and - and - and - 150\u0026quot;]\rsolution(info, query)\r ","description":"72412 순위 검색","id":77,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 72412 순위 검색","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-72412-rank-search/"},{"content":"Programmers - 67257 수식 최대화 Task description 원문 : Programmers 67257 링크\n IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.\n이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.\n해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, ) 만으로 이루어진 연산 수식이 전달되며,\n참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.\n단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + \u0026gt; - \u0026gt; * 또는 - \u0026gt; * \u0026gt; + 등과 같이\n연산자 우선순위를 정의할 수 있으나 +, \u0026gt; - 또는 * \u0026gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.\n만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.\n  예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.\n  \u0026ldquo;100-200*300-500+20\u0026rdquo;\n  일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * \u0026gt; +,- 로 우선순위가 정의되어 있습니다.\n대회 규칙에 따라 + \u0026gt; - \u0026gt; * 또는 - \u0026gt; * \u0026gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* \u0026gt; - 또는 * \u0026gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.\n수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + \u0026gt; - \u0026gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.\n반면에 * \u0026gt; + \u0026gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.\n  참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.\n Condition   expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, ) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.\n즉, \u0026ldquo;402+-561\u0026ldquo;처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.\nexpression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.\n즉, \u0026ldquo;100-2145*458+12\u0026quot;처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.\n\u0026ldquo;-56+100\u0026quot;처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.\nexpression은 적어도 1개 이상의 연산자를 포함하고 있습니다.\n연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.\n같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.   ###입력 형식\n   expression result     \u0026ldquo;100-200*300-500+20\u0026rdquo; 60420   \u0026ldquo;506-32\u0026rdquo; 300     입출력 예에 대한 설명\n입출력 예 #1\n  * \u0026gt; + \u0026gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\n연산 순서는 아래와 같습니다.\n 100-200*300-500+20\r= 100-(200*300)-500+20\r= 100-60000-(500+20)\r= (100-60000)-520\r= (-59900-520)\r= -60420\r  따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.\n  입출력 예 #2 - \u0026gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\n연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)\n 50*6-3*2\r= 50*(6-3)*2\r= (50*3)*2\r= 150*2\r= 300\r  따라서, 우승 시 받을 수 있는 상금은 300 입니다.\n Solution   숫자와 부호를 배열에 담는다. 숫자와 부호를 부호 우선순위를 완전탐색하여 가장 높은 값을 찾는다.    def solution(expression):\ranswer = 0\rsigns = [\r['*','+','-']\r, ['*','-','+']\r, ['+','*','-']\r, ['+','-','*']\r, ['-','*','+']\r, ['-','+','*']\r]\rexp = []\rtmp = ''\rfor e in expression :\rif e == '' or e not in ['*','+','-'] :\rtmp += e\relse : exp.append(int(tmp))\rexp.append(e)\rtmp =''\rexp.append(int(tmp))\rmaximum = 0\rfor sign in signs :\r_exp = exp\r_stack = []\rtmp = ''\rfor s in sign:\rfor i in range(0,len(_exp)) :\rif _exp[i-1] in ['*','+','-'] and s == _exp[i-1] :\rprv = _stack.pop()\rpprv = _stack.pop()\rif prv == '*' :\r_stack.append(pprv * _exp[i])\relif prv == '+' :\r_stack.append(pprv + _exp[i])\relse :\r_stack.append(pprv - _exp[i])\relse : _stack.append(_exp[i])\rif len(_stack) == 1 :\rmaximum = max(abs(_stack[0]),maximum)\r_exp = _stack\r_stack = []\rreturn maximum\r  새로 배운 기능\n    기능 설명 예     permutations() 순열을 조합해 주는 함수 [\u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;] -\u0026gt; \u0026lsquo;ABC\u0026rsquo;, \u0026lsquo;ACB\u0026rsquo;, \u0026lsquo;BAC\u0026rsquo;, \u0026lsquo;BCA\u0026rsquo;, \u0026lsquo;CAB\u0026rsquo;, \u0026lsquo;CBA\u0026rsquo;   eval() 문자열을 수식으로 계산해주는 함수 eval(\u0026lsquo;100\u0026rsquo;+'+'+\u0026lsquo;200\u0026rsquo;) -\u0026gt;300   re.split(r'(\\D)',expression) 숫자와 문자를 분리 시켜켜 배열로 만들어주는 정규식 \u0026lsquo;10+20\u0026rsquo; -\u0026gt; \u0026lsquo;10\u0026rsquo;,'+'+\u0026lsquo;20\u0026rsquo;    \rimport re\rimport itertools\rdef solution(expression):\rsign = ['*','+','-']\rsigns = list(map(''.join, itertools.permutations(sign))) #sighs : ['*+-', '*-+', '+*-', '+-*', '-*+', '-+*']\rexp = re.split(r'(\\D)',expression)\rmaximum = 0\rfor sign in signs :\r_exp = exp[:]\r_stack = []\rfor s in sign:\rfor i in range(0,len(_exp)) :\rif _exp[i-1] in ['*','+','-'] and s == _exp[i-1] :\rex = str(_stack.pop())\rprev = str(_stack.pop())\rcurr = str(_exp[i])\r_stack.append(eval(prev+ex+curr))\relse : _stack.append(_exp[i])\rif len(_stack) == 1 :\rmaximum = max(abs(_stack[0]),maximum)\r_exp = _stack\r_stack = []\rreturn maximum\r Others Solution import re\rfrom itertools import permutations\rdef solution(expression):\r#1\rop = [x for x in ['*','+','-'] if x in expression]\rop = [list(y) for y in permutations(op)]\rex = re.split(r'(\\D)',expression)\r#2\ra = []\rfor x in op:\r_ex = ex[:]\rfor y in x:\rwhile y in _ex:\rtmp = _ex.index(y)\r_ex[tmp-1] = str(eval(_ex[tmp-1]+_ex[tmp]+_ex[tmp+1]))\r_ex = _ex[:tmp]+_ex[tmp+2:]\ra.append(_ex[-1])\r#3\rreturn max(abs(int(x)) for x in a)\r def solution(expression):\roperations = [('+', '-', '*'),('+', '*', '-'),('-', '+', '*'),('-', '*', '+'),('*', '+', '-'),('*', '-', '+')]\ranswer = []\rfor op in operations:\ra = op[0]\rb = op[1]\rtemp_list = []\rfor e in expression.split(a):\rtemp = [f\u0026quot;({i})\u0026quot; for i in e.split(b)]\rtemp_list.append(f'({b.join(temp)})')\ranswer.append(abs(eval(a.join(temp_list))))\rreturn max(answer)\r TestCase print(solution('100-200*300-500+20'), 60420)\r ","description":"67257 수식 최대화","id":78,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 67257 수식 최대화","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-67257-maximize-formula/"},{"content":"Programmers - 42840 모의고사 Task description 원문 : Programmers 42840 링크\n 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\n 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\r2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...\r3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\r  1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n Condition   시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.   ###입력 형식\n 입출력 예\n    answers return     [1,2,3,4,5] [1]   [1,3,2,4,2] [1,2,3]     입출력 예 설명 입출력 예 #1\n  수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.\n  입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다.\n Solution   문제수와 정답 패턴의 길이를 맞춘다. 길면 자르고 모자라면 붙인다. 정답을 채점한다 최고점을 찾는다. 최고점 맞은 사람을 리스트에 담는다.    def solution(answers):\rlength = len(answers)\ranswer = []\rstudnet = [[1, 2, 3, 4, 5], [2, 1, 2, 3, 2, 4, 2, 5], [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]]\rresult = []\rfor s in studnet :\rarr = []\r[arr.extend(s) for i in range(len(answers)//len(s))]\rif len(answers)%len(s) != 0 :\rarr[len(arr):len(arr)] = s[:len(answers)%len(s)]\rresult.append(arr)\rmax_score = 0\rscore = {}\rfor j in range(0,3) :\rscore[j] = list(map(lambda i : 'O' if result[j][i] == answers[i] else 'X', range(0,len(answers)))).count('O')\rmax_score = max(score[j], max_score)\rprint(score,max_score)\rfor key in score.keys() :\rif score[key] == max_score :\ranswer.append(key+1)\rreturn answer\r Others Solution  cycle 사용\n from itertools import cycle\rdef solution(answers):\rgiveups = [\rcycle([1,2,3,4,5]),\rcycle([2,1,2,3,2,4,2,5]),\rcycle([3,3,1,1,2,2,4,4,5,5]),\r]\rscores = [0, 0, 0]\rfor num in answers:\rfor i in range(3):\rif next(giveups[i]) == num:\rscores[i] += 1\rhighest = max(scores)\rreturn [i + 1 for i, v in enumerate(scores) if v == highest]\r  enumerate 사용\n def solution(answers):\rp = [[1, 2, 3, 4, 5],\r[2, 1, 2, 3, 2, 4, 2, 5],\r[3, 3, 1, 1, 2, 2, 4, 4, 5, 5]]\rs = [0] * len(p)\rfor q, a in enumerate(answers):\rfor i, v in enumerate(p):\rif a == v[q % len(v)]:\rs[i] += 1\rreturn [i + 1 for i, v in enumerate(s) if v == max(s)]\r TestCase print(solution([1,2,3,4,5,1,2,3,4]), [1])\r ","description":"42840 모의고사","id":79,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42840 모의고사","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-42840-mock-exam/"},{"content":"Programmers - 82612 부족한 금액 계산하기 Task description 원문 : Programmers 82612 링크\n 새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\n  놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를\nreturn 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요.\n Condition   놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수 처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수 놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수   ###입력 형식\n 입출력 예\n    price money\tcount result      3 20 4 10     입출력 예 설명\n입출력 예 #1\n이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.\n Solution   1~N 까지 가격을 곱한 값의 배열을 구함, 그후 SUM을 통해 합계를 구함 구한 값을 cost라 하고, 가지고 있는 money와 비교 후 부족한 금액 또는 0 반환    def solution(price, money, count):\rcost = sum([price * i for i in range(1,count+1)])\rif cost - money \u0026gt; 0 :\rreturn cost - money\relse :\rreturn 0\r  def solution(price, money, count):\rreturn sum([price * i for i in range(1,count+1)])-money if sum([price * i for i in range(1,count+1)])-money \u0026gt; 0 else 0\r Others Solution def solution(price, money, count):\rreturn abs(min(money - sum([price*i for i in range(1,count+1)]),0))\r TestCase print(solution(3, 20, 4) , 10)\r ","description":"82612 부족한 금액 계산하기","id":80,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 82612 부족한 금액 계산하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-82612-calculate-the-shortfall/"},{"content":"Programmers - 42883 큰 수 만들기 Task description 원문 : Programmers 42883 링크\n 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.\n  예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.\n  문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.\n Condition   number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다.   ###입력 형식\n 입출력 예\n    number k return     \u0026ldquo;1924\u0026rdquo; 2 \u0026ldquo;94\u0026rdquo;   \u0026ldquo;1231234\u0026rdquo; 3 \u0026ldquo;3234\u0026rdquo;   \u0026ldquo;4177252841\u0026rdquo; 4 \u0026ldquo;775841\u0026rdquo;    Solution def solution(number, k):\rstack = []\rfor i in number:\rwhile stack and stack[-1] \u0026lt; i and k\u0026gt;0:\rk-=1\rstack.pop()\rstack.append(i)\rreturn \u0026quot;\u0026quot;.join(stack[:len(stack)-k])\r Others Solution def solution(number, k):\rstack = [number[0]]\rfor num in number[1:]:\rwhile len(stack) \u0026gt; 0 and stack[-1] \u0026lt; num and k \u0026gt; 0:\rk -= 1\rstack.pop()\rstack.append(num)\rif k != 0:\rstack = stack[:-k]\rreturn ''.join(stack)\r TestCase print(solution(\u0026quot;1924\u0026quot;,\t2),\t\u0026quot;94\u0026quot;)\rprint(solution(\u0026quot;1231234\u0026quot;,\t3),\t\u0026quot;3234\u0026quot;)\rprint(solution(\u0026quot;4177252841\u0026quot;\t,4), \u0026quot;775841\u0026quot;)\r ","description":"42883 큰 수 만들기","id":81,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42883 큰 수 만들기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-42883-make-big-numbers/"},{"content":"Programmers - 43162 네트워크 Task description 원문 : Programmers 43162 링크\n 네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.\n  컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.\n Condition   컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다.   ###입력 형식\n 입출력 예\n    n computers return     3 [[1, 1, 0], [1, 1, 0], [0, 0, 1]] 2   3 [[1, 1, 0], [1, 1, 1], [0, 1, 1]] 1     입출력 예 설명 예제 #1\n아래와 같이 2개의 네트워크가 있습니다.\n Solution #DFS\nfrom collections import deque\rdef dfs(i, visited, computers):\rvisited[i] = True\rfor c in range(0,len(computers[i])) :\rif c != i and visited[c] == False and computers[i][c] == 1:\rdfs(c, visited, computers)\rreturn 0\rdef solution(n, computers):\rcount = 0\rvisited = [False for i in range(0,n)]\rfor i in range(0,n) :\rif not visited[i] : dfs(i, visited, computers)\rcount += 1\rreturn count\r Others Solution def solution(n, computers): def BFS(node, visit):\rque = [node]\rvisit[node] = 1\rwhile que:\rv = que.pop(0)\rfor i in range(n):\rif computers[v][i] == 1 and visit[i] == 0:\rvisit[i] = 1\rque.append(i)\rreturn visit\rvisit = [0 for i in range(n)]\ranswer = 0\rfor i in range(n):\rtry:\rvisit = BFS(visit.index(0), visit)\ranswer += 1\rexcept:\rbreak\rreturn answer\r TestCase solution(3, [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\t)\r ","description":"43162 네트워크","id":82,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 43162 네트워크","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-43162-network/"},{"content":"Programmers - 43165 타겟 넘버 Task description 원문 : Programmers 43165 링크\n n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.\n -1+1+1+1+1 = 3\r+1-1+1+1+1 = 3\r+1+1-1+1+1 = 3\r+1+1+1-1+1 = 3\r+1+1+1+1-1 = 3\r  사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.\n Condition   주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다.   ###입력 형식\n 입출력 예\n    numbers target return     [1, 1, 1, 1, 1] 3 5    입출력 예 설명 문제에 나온 예와 같습니다.\nSolution BFS from collections import deque\rdef solution(numbers, target):\rcount = 0\rqueue = deque()\rqueue.append([0,0])\rwhile queue :\rsum, length = queue.popleft() #print(sum,length)\rif length \u0026gt; len(numbers) :\rbreak\relif length == len(numbers) and sum == target:\rcount += 1\rqueue.append([sum+numbers[length-1],length+1])\rqueue.append([sum-numbers[length-1],length+1])\rreturn count\r DFS\ndef solution(numbers, target):\rif len(numbers) == 0 :\rif target == 0 :\rreturn 1\relse : return 0\rreturn solution(numbers[1:], numbers[0]+target)+solution(numbers[1:], numbers[0]-target)\r Others Solution from itertools import product\rdef solution(numbers, target):\rl = [(x, -x) for x in numbers]\rs = list(map(sum, product(*l)))\rreturn s.count(target)\r TestCase #print(solution([1, 1, 1, 1, 1], 3), 5)\r#print(solution([1, 2, 1, 2], 2), 3)\r#print(solution([1, 2, 1, 2], 6), 1)\r ","description":"43165 타겟 넘버","id":83,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 43165 타겟 넘버","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-43165-target-number/"},{"content":"Programmers - 12906 같은 숫자는 싫어 Task description 원문 : Programmers 12906 링크\n 배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,\n arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.\rarr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.\r배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.\r Condition   배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수   ###입력 형식\n 입출력 예\n    arr answer     [1,1,3,3,0,1,1] [1,3,0,1]   [4,4,4,3,3] [4,3]    Solution def solution(arr):\ranswer = []\rfor x in arr : if len(answer) == 0 : answer.append(x)\relif answer[-1] != x :\ranswer.append(x)\rreturn answer\r Others Solution def no_continuous(s):\rreturn [s[i] for i in range(len(s)) if s[i] != s[i+1:i+2]]\r def no_continuous(s):\rreturn [ v for i,v in enumerate(s) if s[i-1]!=s[i]]\r TestCase  ","description":"12906 같은 숫자는 싫어","id":84,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12906 같은 숫자는 싫어","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-12906-i-hate-the-same-number/"},{"content":"Programmers - 60057 문자열 압축 Task description 원문 : Programmers 60057 링크\n 데이터 처리 전문가가 되고 싶은 \u0026ldquo;어피치\u0026quot;는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.\n간단한 예로 \u0026ldquo;aabbaccc\u0026quot;의 경우 \u0026ldquo;2a2ba3c\u0026rdquo;(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다.\n예를 들면, \u0026ldquo;abcabcdede\u0026quot;와 같은 문자열은 전혀 압축되지 않습니다. \u0026ldquo;어피치\u0026quot;는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.\n  예를 들어, \u0026ldquo;ababcdcdababcdcd\u0026quot;의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 \u0026ldquo;2ab2cd2ab2cd\u0026quot;로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 \u0026ldquo;2ababcdcd\u0026quot;로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.\n  다른 예로, \u0026ldquo;abcabcdede\u0026quot;와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 \u0026ldquo;abcabc2de\u0026quot;가 되지만, 3개 단위로 자른다면 \u0026ldquo;2abcdede\u0026quot;가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.\n  압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.\n Condition   s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s\tresult \u0026ldquo;aabbaccc\u0026rdquo;\t7 \u0026ldquo;ababcdcdababcdcd\u0026rdquo;\t9 \u0026ldquo;abcabcdede\u0026rdquo;\t8 \u0026ldquo;abcabcabcabcdededededede\u0026rdquo;\t14 \u0026ldquo;xababcdcdababcdcd\u0026rdquo;\t17   ###입력 형식\n 입출력 예 #1\n  문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.\n  입출력 예 #2\n  문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.\n  입출력 예 #3\n  문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.\n  입출력 예 #4\n 문자열을 2개 단위로 자르면 \u0026quot;abcabcabcabc6de\u0026quot; 가 됩니다.\r문자열을 3개 단위로 자르면 \u0026quot;4abcdededededede\u0026quot; 가 됩니다.\r문자열을 4개 단위로 자르면 \u0026quot;abcabcabcabc3dede\u0026quot; 가 됩니다.\r문자열을 6개 단위로 자를 경우 \u0026quot;2abcabc2dedede\u0026quot;가 되며, 이때의 길이가 14로 가장 짧습니다.\r  입출력 예 #5\n  문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.\n따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.\n이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.\n Solution   record의 아이디별 최종 변경된 닉네임을 딕셔너리에 등록 record Enter와 Leave의 메시지와 변경된 닉네임으로 결과에 추가   def solution(s):\rindex = 0\rcompression = []\rwhile True:\rcompression.append('')\rif len(s) == index:\rbreak\rarr = [s[i+(i*index):i+(i*index)+(index+1)] for i in range(0,len(s)) ]\rprv = ''\rcnt = 0\rfor i in range(0,len(arr)) :\rif prv == '' : cnt = 1\rprv = arr[i] elif prv == arr[i] :\rcnt += 1\relse :\rif cnt \u0026gt; 1 :\rcompression[index] += str(cnt)\rcompression[index] += prv\rcnt = 1\rprv = arr[i] if i == len(arr)-1 :\rif cnt \u0026gt; 1 :\rcompression[index] += str(cnt)\rcompression[index] += prv\rindex += 1\rminimum = 99999\rfor s in compression :\rif len(s) != 0 :\rminimum = min(len(s),minimum)\rreturn minimum\r Others Solution def compress(text, tok_len):\rwords = [text[i:i+tok_len] for i in range(0, len(text), tok_len)]\rres = []\rcur_word = words[0]\rcur_cnt = 1\rfor a, b in zip(words, words[1:] + ['']):\rif a == b:\rcur_cnt += 1\relse:\rres.append([cur_word, cur_cnt])\rcur_word = b\rcur_cnt = 1\rreturn sum(len(word) + (len(str(cnt)) if cnt \u0026gt; 1 else 0) for word, cnt in res)\rdef solution(text):\rreturn min(compress(text, tok_len) for tok_len in list(range(1, int(len(text)/2) + 1)) + [len(text)])\r TestCase  = [\r\u0026quot;aabbaccc\u0026quot;,\r\u0026quot;ababcdcdababcdcd\u0026quot;,\r\u0026quot;abcabcdede\u0026quot;,\r\u0026quot;abcabcabcabcdededededede\u0026quot;,\r\u0026quot;xababcdcdababcdcd\u0026quot;,\r'aaaaaa',\r]\rfor x in a:\rprint(solution(x))\r ","description":"60057 문자열 압축","id":85,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 60057 문자열 압축","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-60057-string-compression/"},{"content":"Programmers - 42888 오픈 채팅방 Task description 원문 : Programmers 42888 링크\n 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.\n  신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.\n \u0026quot;[닉네임]님이 들어왔습니다.\u0026quot;\r  채팅방에서 누군가 나가면 다음 메시지가 출력된다.\n \u0026quot;[닉네임]님이 나갔습니다.\u0026quot;\r  채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.\n  채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.\n  예를 들어, 채팅방에 \u0026ldquo;Muzi\u0026quot;와 \u0026ldquo;Prodo\u0026quot;라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.\n \u0026quot;Muzi님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r  채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.\n \u0026quot;Muzi님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Muzi님이 나갔습니다.\u0026quot;\r  Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.\n \u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 나갔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r  채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.\n \u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Ryan님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 나갔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r  채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.\n Condition   record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다. 다음은 record에 담긴 문자열에 대한 설명이다. 모든 유저는 [유저 아이디]로 구분한다. [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - \u0026ldquo;Enter [유저 아이디] [닉네임]\u0026rdquo; (ex. \u0026ldquo;Enter uid1234 Muzi\u0026rdquo;) [유저 아이디] 사용자가 채팅방에서 퇴장 - \u0026ldquo;Leave [유저 아이디]\u0026rdquo; (ex. \u0026ldquo;Leave uid1234\u0026rdquo;) [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - \u0026ldquo;Change [유저 아이디] [닉네임]\u0026rdquo; (ex. \u0026ldquo;Change uid1234 Muzi\u0026rdquo;) 첫 단어는 Enter, Leave, Change 중 하나이다. 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다. 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다. 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다. 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.   ###입력 형식\n   record result     [\u0026ldquo;Enter uid1234 Muzi\u0026rdquo;, \u0026ldquo;Enter uid4567 Prodo\u0026rdquo;,\u0026ldquo;Leave uid1234\u0026rdquo;,\u0026ldquo;Enter uid1234 Prodo\u0026rdquo;,\u0026ldquo;Change uid4567 Ryan\u0026rdquo;] [\u0026ldquo;Prodo님이 들어왔습니다.\u0026rdquo;, \u0026ldquo;Ryan님이 들어왔습니다.\u0026rdquo;, \u0026ldquo;Prodo님이 나갔습니다.\u0026rdquo;, \u0026ldquo;Prodo님이 들어왔습니다.\u0026quot;]    Solution   record의 아이디별 최종 변경된 닉네임을 딕셔너리에 등록 record Enter와 Leave의 메시지와 변경된 닉네임으로 결과에 추가   def solution(record):\ranswer = [] user = {}\rfor row in record :\rorder = row.split()[0]\ruid = row.split()[1]\rif order == 'Enter' :\ruser[uid] = row.split()[2]\relif order == 'Change' :\ruser[uid] = row.split()[2]\rfor row in record :\rorder = row.split()[0]\ruid = row.split()[1]\rif order == 'Enter' :\ranswer.append(user[uid]+\u0026quot;님이 들어왔습니다.\u0026quot;)\relif order == 'Leave' :\ranswer.append(user[uid]+\u0026quot;님이 나갔습니다.\u0026quot;)\rreturn answer\r def solution(record):\ruser = { row.split()[1]:row.split()[-1] for row in list(filter(lambda x : x.startswith('Enter') or x.startswith('Change') ,record)) }\rreturn [f'{user[row.split()[1]]}님이 들어왔습니다.' if row.startswith('Enter') else f'{user[row.split()[1]]}님이 나갔습니다.' for row in list(filter(lambda x : not x.startswith('Change') ,record)) ]\r Others Solution def solution(record):\ruser_id = {EC.split()[1]:EC.split()[-1] for EC in record if EC.startswith('Enter') or EC.startswith('Change')}\rreturn [f'{user_id[E_L.split()[1]]}님이 들어왔습니다.' if E_L.startswith('Enter') else f'{user_id[E_L.split()[1]]}님이 나갔습니다.' for E_L in record if not E_L.startswith('Change')]\r TestCase solution([\u0026quot;Enter uid1234 Muzi\u0026quot;, \u0026quot;Enter uid4567 Prodo\u0026quot;,\u0026quot;Leave uid1234\u0026quot;,\u0026quot;Enter uid1234 Prodo\u0026quot;,\u0026quot;Change uid4567 Ryan\u0026quot;])\r ","description":"42888 오픈 채팅방","id":86,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42888 오픈 채팅방","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42888-open-chat-room/"},{"content":"Programmers - 42626 더 맵게 Task description 원문 : Programmers 42626 링크\n 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.\n  섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\nLeo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.\n 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.\nCondition   scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.   ###입력 형식\n   scoville K return     [1, 2, 3, 9, 10, 12] 7 2     입출력 예 설명\n스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\n새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\n가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]\n  스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\n새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\n가진 음식의 스코빌 지수 = [13, 9, 10, 12]\n Solution import heapq\rdef solution(scoville, K):\ranswer = 0\rheapq.heapify(scoville)\rwhile scoville[0] \u0026lt; K :\rtry :\rf = heapq.heappop(scoville)\rs = heapq.heappop(scoville)\rheapq.heappush(scoville, f+(s*2))\ranswer += 1\rexcept :\rreturn -1\rreturn answer\r Others Solution import heapq as hq\rdef solution(scoville, K):\rhq.heapify(scoville)\ranswer = 0\rwhile True:\rfirst = hq.heappop(scoville)\rif first \u0026gt;= K:\rbreak\rif len(scoville) == 0:\rreturn -1\rsecond = hq.heappop(scoville)\rhq.heappush(scoville, first + second*2)\ranswer += 1 return answer\r TestCase  ","description":"42626 더 맵게","id":87,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42626 더 맵게","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42626-more-spicy/"},{"content":"Programmers - 17677 뉴스 클러스터링 Task description 원문 : Programmers 17677 링크\n 뉴스 클러스터링\n여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다.\nDaum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.\n  개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 \u0026ldquo;카카오 신입 개발자 공채\u0026rdquo; 관련 기사를 검색해보았다.\n  카카오 첫 공채..\u0026lsquo;블라인드\u0026rsquo; 방식 채용\n카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용\n카카오, 블라인드 전형으로 신입 개발자 공채\n카카오 공채, 신입 개발자 코딩 능력만 본다\n카카오, 신입 공채.. \u0026ldquo;코딩 실력만 본다\u0026rdquo;\n카카오 \u0026ldquo;코딩 능력만으로 2018 신입 개발자 뽑는다\u0026rdquo;\n기사의 제목을 기준으로 \u0026ldquo;블라인드 전형\u0026quot;에 주목하는 기사와 \u0026ldquo;코딩 테스트\u0026quot;에 주목하는 기사로 나뉘는 걸 발견했다.\n튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.\n  유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 \u0026ldquo;자카드 유사도\u0026quot;라는 방법을 찾아냈다.\n  자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.\n  예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때,\n교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로,\n집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다.\n집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다.\n  자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 \u0026ldquo;1\u0026quot;을 3개 가지고 있고, 다중집합 B는 원소 \u0026ldquo;1\u0026quot;을 5개 가지고 있다고 하자.\n이 다중집합의 교집합 A ∩ B는 원소 \u0026ldquo;1\u0026quot;을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 \u0026ldquo;1\u0026quot;을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로,\n자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다.\n  이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 \u0026ldquo;FRANCE\u0026quot;와 \u0026ldquo;FRENCH\u0026quot;가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(\u0026ldquo;FRANCE\u0026rdquo;, \u0026ldquo;FRENCH\u0026rdquo;) = 2/8 = 0.25가 된다.\n Condition ###입력 형식\n 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.\n입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고,\n기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 \u0026ldquo;ab+\u0026ldquo;가 입력으로 들어오면,\n\u0026ldquo;ab\u0026quot;만 다중집합의 원소로 삼고, \u0026ldquo;b+\u0026ldquo;는 버린다.\n다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. \u0026ldquo;AB\u0026quot;와 \u0026ldquo;Ab\u0026rdquo;, \u0026ldquo;ab\u0026quot;는 같은 원소로 취급한다.\n ###출력 형식\n 입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.\n input output  예제 입출력\n    str1 str2 answer     FRANCE french 16384   handshake shake hands 65536   aa1+aa2 AAAA12 43690   E=M*C^2 e=m*c^2 6553644\u0026rdquo;    Solution import math\rfrom collections import Counter\rdef makeArr(str) :\rarr = [] prv = ''\rfor crr in str : if prv != '' :\rif crr.isalpha() and prv.isalpha() :\rarr.append(prv+crr)\rprv = crr\rreturn sorted(arr)\rdef J(A, B):\ranswer = 0\rintersection = []\runion = []\rtry :\rfor i in range(len(A)) : for j in range(len(B)) : if A[i] == B[j] :\rintersection.append(A[i])\runion.append(A[i])\rB[j] = None\rA[i] = None for a in A : if a is not None :\runion.append(a)\rfor b in B : if b is not None :\runion.append(b)\rif answer == 0 and len(union) != 0:\ranswer = len(intersection)/len(union)\relif answer == 0 and len(union) == 0:\ranswer = 1\rexcept :\ranswer = 1\rreturn math.trunc(answer*65536)\rdef solution(str1, str2):\rstr1 = str1.lower()\rstr2 = str2.lower()\rA = makeArr(str1)\rB = makeArr(str2)\rreturn J(A, B)\r Others Solution import re\rimport math\rdef solution(str1, str2):\rstr1 = [str1[i:i+2].lower() for i in range(0, len(str1)-1) if not re.findall('[^a-zA-Z]+', str1[i:i+2])]\rstr2 = [str2[i:i+2].lower() for i in range(0, len(str2)-1) if not re.findall('[^a-zA-Z]+', str2[i:i+2])]\rgyo = set(str1) \u0026amp; set(str2)\rhap = set(str1) | set(str2)\rif len(hap) == 0 :\rreturn 65536\rgyo_sum = sum([min(str1.count(gg), str2.count(gg)) for gg in gyo])\rhap_sum = sum([max(str1.count(hh), str2.count(hh)) for hh in hap])\rreturn math.floor((gyo_sum/hap_sum)*65536)\r TestCase #solution('11111', '111')\r#solution('FRANCE', 'french')\r#solution('handshake', 'shake hands')\r#solution('AAAA12','aa1+aa2') #43690\r#solution('E=M*C^2', 'e=m*c^2')\r ","description":"17677 뉴스 클러스터링","id":88,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 17677 뉴스 클러스터링","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-17677-news-clustering/"},{"content":"Programmers - 12948 핸드폰 번호 가리기 Task description 원문 : Programmers 12948 링크\n 프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.\n Condition   s는 길이 4 이상, 20이하인 문자열입니다.   input output  입출력 예\n    입출력 예     phone_number return   \u0026ldquo;01033334444\u0026rdquo; \u0026ldquo;*******4444\u0026rdquo;   \u0026ldquo;027778888\u0026rdquo; \u0026ldquo;*****8888\u0026rdquo;    Solution   받아온 숫자를 뒤 4번째 부터 자른다. 1에서 만든 4자리에 원래 받아온 숫자 자리수 까지 왼쪽을 *로 채운다   def solution(phone_number): return phone_number[-4:].rjust(len(phone_number),'*')\r Others Solution def hide_numbers(s):\rreturn \u0026quot;*\u0026quot;*(len(s)-4) + s[-4:]\r TestCase solution(\u0026quot;01033334444\u0026quot;)\rsolution(\u0026quot;027778888\u0026quot;)\rsolution(\u0026quot;4444\u0026quot;)\r ","description":"12948 핸드폰 번호 가리기","id":89,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12948 핸드폰 번호 가리기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-12948-phone-number-masking/"},{"content":"Programmers - 68644 두 개 뽑아서 더하기 Task description 원문 : Programmers 68644 링크\n 정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.\n Condition   numbers의 길이는 2 이상 100 이하입니다. numbers의 모든 수는 0 이상 100 이하입니다.   input output  입출력 예\n    numbers result     [2,1,3,4,1] [2,3,4,5,6,7]   [5,0,2,7] [2,5,7,9,12]     입출력 예 설명\n입출력 예 #1\n  2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다.\n4 = 1 + 3 입니다.\n5 = 1 + 4 = 2 + 3 입니다.\n6 = 2 + 4 입니다.\n7 = 3 + 4 입니다.\n따라서 [2,3,4,5,6,7] 을 return 해야 합니다.\n입출력 예 #2\n  2 = 0 + 2 입니다.\n5 = 5 + 0 입니다.\n7 = 0 + 7 = 5 + 2 입니다.\n9 = 2 + 7 입니다.\n12 = 5 + 7 입니다.\n따라서 [2,5,7,9,12] 를 return 해야 합니다.\n Solution   numbers를 2중 루프로 순회 numbers를 인덱스 i와 j가 같지 않을때 두값을 더한다 set으로 중복제거후 sorted로 정렬 하여 반환   def solution(numbers):\rfor i in range(0,len(numbers)) :\rfor j in range(0,len(numbers)) :\rif i != j :\ranswer.append(numbers[i]+numbers[j])\rreturn sorted(set(answer))\r TestCase # solution([2,1,3,4,1])\r# solution([5,0,2,7])\r ","description":"Programmers 두 개 뽑아서 더하기","id":90,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 68644 두 개 뽑아서 더하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-68644-take-two-and-add/"},{"content":"Programmers - 12973 짝지어 제거하기 Task description 원문 : Programmers 12973 링크\n 짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.\n  예를 들어, 문자열 S = baabaa 라면\n  b aa baa → bb aa → aa →\n  의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.\n Condition   문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다.   input output  입출력 예\n    s result     baabaa 1   cdcd 0     입출력 예 설명 입출력 예 #1\n위의 예시와 같습니다.\n  입출력 예 #2 문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.\n Solution   stack 생성 stack이 비어있거나, stack의 마지막과 현재 순회중인 문자열(S)과 다르면 추가 stack의 마지막과 현재 순회중인 문자열이 같으면 stack의 마지막 pop stack이 비어있으면 1 남아있는게 있으면 0 리턴   def solution(string):\rstack = [] # stack 생성\rfor s in string :\rif len(stack) == 0 or stack[-1] != s: # stack이 비어있거나, stack의 마지막과 현재 순회중인 문자열(S)과 다르면 추가\rstack.append(s)\relif stack[-1] == s : #stack의 마지막과 현재 순회중인 문자열이 같으면 stack의 마지막 pop\rstack.pop()\rif len(stack) == 0 : #stack이 비어있으면 1 return 1\relse :\t#남아있는게 있으면 0 리턴\rreturn 0\r TestCase # solution('baabaa')\r# solution('babaa')\r# solution('cdcd')\r ","description":"Programmers 짝지어 제거하기","id":91,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12973 짝지어 제거하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-12973-remove-by-pair/"},{"content":"Programmers - 17681 비밀지도 Task description 원문 : Programmers 17681 링크\n 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n   지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026quot;#\u0026quot;) 두 종류로 이루어져 있다.  전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;는 각각 정수 배열로 암호화되어 있다.\n 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\n    네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n Condition   1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식 원래의 비밀지도를 해독하여 \u0026lsquo;#\u0026rsquo;, 공백으로 구성된 문자열 배열로 출력하라.   input output  입력 형식\n입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.\n  입출력 예제     매개변수 값     n 5   arr1 [9, 20, 28, 18, 11]   arr2 [30, 1, 21, 17, 28]     출력\t[\u0026quot;#####\u0026rdquo;,\u0026quot;# # #\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;# ##\u0026rdquo;, \u0026ldquo;#####\u0026quot;]\n    매개변수 값     n 6   arr1 [46, 33, 33 ,22, 31, 50]   arr2 [27 ,56, 19, 14, 14, 10]     출력\t[\u0026quot;######\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;## ##\u0026rdquo;, \u0026quot; #### \u0026ldquo;, \u0026quot; #####\u0026rdquo;, \u0026ldquo;### # \u0026ldquo;]\n Solution   map 함수로 arr1, arr2 를 순회하여 변경 arr1의 arr2의 a,b를 bin(a|b) 로 or 연산 0b 를 자르기 위해 [2:] 2부터 나머지 까지 자름 zfill로 n까지 0으로 채움 1을 #으로, 0을 ' \u0026lsquo;으로 변경   def solution(n, arr1, arr2):\rreturn list(map(lambda a,b : (str(bin(a|b))[2:].zfill(n)).replace('1','#').replace('0',' '), arr1, arr2))\r Others Solution solution = lambda n, arr1, arr2: ([''.join(map(lambda x: '#' if x=='1' else ' ', \u0026quot;{0:b}\u0026quot;.format(row).zfill(n))) for row in (a|b for a, b in zip(arr1, arr2))])\r TestCase \u0026quot;\u0026quot;\u0026quot;\rn = 5\rarr1 = [9, 20, 28, 18, 11]\rarr2 =\t[30, 1, 21, 17, 28]\r\u0026quot;\u0026quot;\u0026quot;\r\u0026quot;\u0026quot;\u0026quot;\rn = 6\rarr1 = [46, 33, 33 ,22, 31, 50]\rarr2 = [27 ,56, 19, 14, 14, 10]\rsolution(n, arr1, arr2)\r\u0026quot;\u0026quot;\u0026quot;\r ","description":"Programmers 비밀지도","id":92,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 17681 비밀지도","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-17681-secret-map/"},{"content":"Programmers - 42889 실패율 Task description 원문 : Programmers 42889 링크\n 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.\n  이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.\n  실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.\n Condition   스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\n stages의 길이는 1 이상 200,000 이하이다.\n stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.   input output  입출력 예\n    N stages result     5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5]   4 [4,4,4,4,4] [4,1,2,3]     입출력 예 설명 입출력 예 #1 1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.\n1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다.\n3 번 스테이지 실패율 : 2/4\n4번 스테이지 실패율 : 1/2\n5번 스테이지 실패율 : 0/1\n각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.\n[3,4,2,1,5]\n  입출력 예 #2\n모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.\n[4,1,2,3]\n Solution def solution(N, stages):\rfailureRate = {}\rchallenger = len(stages)\rfor stage in range(1,N+1) :\rfailure = stages.count(stage) # stage별 실패자의 카운트\rif challenger == 0 :\t# 도전자가 0이면 실패율 0\rfailureRate[stage] = 0\relse :\r# '실패율 = 실패자 / 도전자' failureRate[stage] = failure / challenger # 실패율 dict에 스테이지별로 실패율 저장\rchallenger = challenger - failure\t# 다음 스테이지 도전자 = '도전자 - 실패자'\rreturn sorted(failureRate, key=lambda x : failureRate[x], reverse=True)  Others Solution def solution(N, stages):\rresult = {}\rdenominator = len(stages)\rfor stage in range(1, N+1):\rif denominator != 0:\rcount = stages.count(stage)\rresult[stage] = count / denominator\rdenominator -= count\relse:\rresult[stage] = 0\rreturn sorted(result, key=lambda x : result[x], reverse=True)\r TestCase #solution(5,\t[2, 1, 2, 6, 2, 4, 3, 3])\r#solution(5, [2,1,2,4,2,4,3,3])\r ","description":"Programmers 실패율","id":93,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42889 실패율","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42889-failure-rate/"},{"content":"Programmers - 17682 다트 게임 Task description 원문 : Programmers 17682 링크\n 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다. 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.\n  다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.\n점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.\n옵션으로 스타상() , 아차상(#)이 존재하며 스타상() 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.\n스타상()은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상()의 점수만 2배가 된다. (예제 4번 참고)\n스타상()의 효과는 다른 스타상()의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상() 점수는 4배가 된다. (예제 4번 참고)\n스타상()의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)\nSingle(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.\n스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.\n0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.\n Condition   점수는 0에서 10 사이의 정수이다. 보너스는 S, D, T 중 하나이다. 옵선은 *이나 # 중 하나이며, 없을 수도 있다. 입력 형식 \u0026ldquo;점수|보너스|[옵션]\u0026ldquo;으로 이루어진 문자열 3세트. 예) 1S2D*3T 출력 형식 3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다. 예) 37   input output    예제 dartResult answer 설명     1 1S2D*3T 37 11 * 2 + 22 * 2 + 33   2 1D2S#10S 9 12 + 21 * (-1) + 101   3 1D2S0T 3 12 + 21 + 03   4 1S2T3S 23 11 * 2 * 2 + 23 * 2 + 31   5 1D#2S*3S 5 12 * (-1) * 2 + 21 * 2 + 31   6 1T2D3D# -4 13 + 22 + 32 * (-1)   7 1D2S3T* 59 12 + 21 * 2 + 33 * 2    Solution   숫자(문자열)은 number에 붙임 SDT 면 number를 숫자로 변경후 해당 dart 값을 거듭제곱 *이면 현재값, 이전값 *2 #이면 현재값 -로 변경 결과 배열합해서 반환   def solution(dartResult):\rdart = {'S':1, 'D':2, 'T':3}\rscore = [0,0,0]\rnumber = ''\rfor i in range(0,len(dartResult)):\rs = dartResult[i]\rif s in dart :\t# SDT는 **1,**2,**3 score.append(int(number) ** dart [s])\tnumber = ''\relif s == '*' :\t# *는 현재 점수 *2, 이전 점수 *2\rscore[-1] *= 2\rscore[-2] *= 2\relif s == '#' :\t# #은 현재 점수 *-1\rscore[-1] *= -1\relse :\t# 숫자 문자열 시 number에 문자열 합침\rnumber += s\rreturn sum(score)\r Others Solution import re\rdef solution(dartResult):\rbonus = {'S' : 1, 'D' : 2, 'T' : 3}\roption = {'' : 1, '*' : 2, '#' : -1}\rp = re.compile('(\\d+)([SDT])([*#]?)')\rdart = p.findall(dartResult)\rfor i in range(len(dart)):\rif dart[i][2] == '*' and i \u0026gt; 0:\rdart[i-1] *= 2\rdart[i] = int(dart[i][0]) ** bonus[dart[i][1]] * option[dart[i][2]]\ranswer = sum(dart)\rreturn answer\r TestCase \rtestcase = ['1S2D*3T','1D2S#10S','1D2S0T','1S*2T*3S','1D#2S*3S','1T2D3D#','1D2S3T*']\rfor test in testcase :\rsolution(test);\r ","description":"Programmers 다트 게임","id":94,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 17682 다트 게임","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-17682-dart-game/"},{"content":"Programmers - 67256 키패드 누르기 Task description 원문 : Programmers 67256 링크\n 스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\n  이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.\n맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\n  엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.\n오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.\n가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.\n4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\n순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.\n Condition   numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 \u0026ldquo;left\u0026rdquo; 또는 \u0026ldquo;right\u0026rdquo; 입니다. \u0026ldquo;left\u0026quot;는 왼손잡이, \u0026ldquo;right\u0026quot;는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.   input output  입출력 예\n    numbers hand result     [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] \u0026ldquo;right\u0026rdquo; \u0026ldquo;LRLLLRLLRRL\u0026rdquo;   [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] \u0026ldquo;left\u0026rdquo; \u0026ldquo;LRLLRRLLLRR\u0026rdquo;   [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] \u0026ldquo;right\u0026rdquo; \u0026ldquo;LLRLLRLLRL\u0026rdquo;     입출력 예에 대한 설명 입출력 예 #1\n  순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다.\n    왼손 위치 오른손 위치 눌러야 할 숫자 사용한 손 설명     * # 1 L 1은 왼손으로 누릅니다.   1 # 3 R 3은 오른손으로 누릅니다.   1 3 4 L 4는 왼손으로 누릅니다.   4 3 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.   5 3 8 L 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다.   8 3 2 R 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다.   8 2 1 L 1은 왼손으로 누릅니다.   1 2 4 L 4는 왼손으로 누릅니다.   4 2 5 R 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다.   4 5 9 R 9는 오른손으로 누릅니다.   4 9 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.   5 9 - -      따라서 \u0026ldquo;LRLLLRLLRRL\u0026quot;를 return 합니다.\n  입출력 예 #2 왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 \u0026ldquo;LRLLRRLLLRR\u0026quot;이 됩니다.\n  입출력 예 #3 오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 \u0026ldquo;LLRLLRLLRL\u0026quot;이 됩니다.\n Solution def getDistance(n, target):\rkeypad = {}\t# 딕셔너리로 각 좌표를 생성\rkeypad[1] = [0,0]\tkeypad[2] = [0,1]\t#\t1[0,0] 2[0,1] 3[0,2] keypad[3] = [0,2]\tkeypad[4] = [1,0] #\t4[1,0] 5[1,1] 6[1,2] keypad[5] = [1,1] keypad[6] = [1,2] #\t7[2,0] 8[2,1] 9[2,2] keypad[7] = [2,0] keypad[8] = [2,1] #\t*[3,0] 0[3,1] #[3,2] keypad[9] = [2,2] keypad['*'] = [3,0] keypad[0] = [3,1] keypad['#'] = [3,2] targetPosition = keypad[target] # 타겟의 좌표\rnowPosition = keypad[n]\t# 검사할 손의 좌표\r# 타겟과 검사할 손의 좌표를 y축끼리 x축끼리 빼서 절대값 변환후 더해 반환\rreturn (abs(targetPosition[0] - nowPosition[0]) + abs(targetPosition[1] - nowPosition[1])) def solution(numbers, hand):\ranswer = ''\rleftHand = '*'\rrightHand = '#'\rfor number in numbers : if number in [1,4,7] : #1,4,7이면 결과에 L추가, leftHand 위치 변경\ranswer += 'L'\rleftHand = number\relif number in [3,6,9] : #3,6,9이면 결과에 R추가, rightHand 위치 변경\ranswer += 'R'\rrightHand = number\relse :\rleftDistance = getDistance(leftHand, number); # 타겟과의 L거리\rrightDistance = getDistance(rightHand, number); # 타겟과의 R거리\rif leftDistance \u0026lt; rightDistance or (leftDistance == rightDistance and hand == 'left' ): # 거리가 left가 짧거나 거리가 같은데 왼손잡이인 경우\ranswer += 'L'\rleftHand = number\relif leftDistance \u0026gt; rightDistance or (leftDistance == rightDistance and hand == 'right' ): # 거리가 right가 짧거나 거리가 같은데 오른손잡이인 경우\ranswer += 'R'\rrightHand = number\rreturn answer  Others Solution def solution(numbers, hand):\ranswer = ''\rlocation = [[3, 1], [0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\rleft, right = [3, 0], [3, 2]\rfor i in numbers:\rif i % 3 == 1:\ranswer += 'L'\rleft = location[i]\relif i % 3 == 0 and i != 0:\ranswer += 'R'\rright = location[i]\relse:\rl = abs(location[i][0] - left[0]) + abs(location[i][1] - left[1])\rr = abs(location[i][0] - right[0]) + abs(location[i][1] - right[1])\rif l \u0026lt; r:\ranswer += 'L'\rleft = location[i]\relif l \u0026gt; r:\ranswer += 'R'\rright = location[i]\relse:\ranswer += hand[0].upper()\rif hand == 'right':\rright = location[i]\relse:\rleft = location[i] return answer\r TestCase #solution( [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2], 'left')\r#solution([1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5], \u0026quot;right\u0026quot;)  ","description":"Programmers 키패드 누르기","id":95,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 67256 키패드 누르기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-67256-keypad-press/"},{"content":"Programmers - 42862 체육복 Task description 원문 : Programmers 42862 링크\n 점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.\n  전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.\n Condition   전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.   input output  입출력 예\n    n lost reserve return     5 [2, 4] [1, 3, 5] 5   5 [2, 4] [3] 4   3 [3] [1] 2     입출력 예 설명   예제 #1\n1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.\n  예제 #2\n3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.\n Solution filter()  원하는 조건에 맞는 요소만 리스트로 다시 만들어 주는 함수\nfilter(함수, 리스트)\n   자신이 예비를 가져왔지만, 도둑 맞은경우 제거 - reserve에 해당하지 않는 lost만 _lost로 생성 - lost에 해당하지 않는 reserve만 _reserve 생성 _reserve를 순회하여 옷가져온 학생(r)의 앞 학생(r-1)이 _lost에 해당하는지 확인 - 해당하면 _lost.remove(앞 학생(r-1)) _reserve를 순회하여 옷가져온 학생(r)의 뒤 학생(r+1)이 _lost에 해당하는지 확인 - 해당하면 _lost.remove(뒤 학생(r+1)) 총학생수(n) - 체육복을 못빌린 학생 (len(_lost) )   def solution(n, lost, reserve):\r# 자신이 예비를 가져왔지만, 도둑 맞은경우 제거\r_lost = list(filter(lambda x : x not in reserve, lost))\r_reserve = list(filter(lambda x : x not in lost, reserve))\rfor r in _reserve :\rif r-1 in _lost : # 앞 학생(r-1)이 _lost에 해당하는지\r_lost.remove(r-1)\t# 빌려줌으로 _lost에서 제거\relif r+1 in _lost : # 뒤 학생(r+1)이 _lost에 해당하는지\r_lost.remove(r+1)\t# 빌려줌으로 _lost에서 제거\rreturn n - len(_lost)\r Others Solution def solution(n, lost, reserve):\r_reserve = [r for r in reserve if r not in lost]\r_lost = [l for l in lost if l not in reserve]\rfor r in _reserve:\rf = r - 1\rb = r + 1\rif f in _lost:\r_lost.remove(f)\relif b in _lost:\r_lost.remove(b)\rreturn n - len(_lost)\r TestCase #solution(10, [8,10], [6,7,9])\r#solution(5,\t[2, 4],\t[1, 3, 5])\r#solution(5, [2,3,4] ,[1,2,3])\r#solution(5,\t[2, 4],\t[3])\r#solution(3,\t[3],\t[1])\r ","description":"Programmers 체육복","id":96,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42862 체육복","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42862-gym-suit/"},{"content":"Programmers - 81301 숫자 문자열과 영단어 Task description 원문 : Programmers 81301 링크\n 네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.\n  다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\n 1478 → \u0026quot;one4seveneight\u0026quot;\r234567 → \u0026quot;23four5six7\u0026quot;\r10203 → \u0026quot;1zerotwozero3\u0026quot;\r  이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.\n  참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.\n    숫자 영단어     0 zero   1 one   2 two   3 three   4 four   5 five   6 six   7 seven   8 eight   9 nine    Condition   1 ≤ s의 길이 ≤ 50 s가 \u0026ldquo;zero\u0026rdquo; 또는 \u0026ldquo;0\u0026quot;으로 시작하는 경우는 주어지지 않습니다. return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.   input output    s result     \u0026ldquo;one4seveneight\u0026rdquo; 1478   \u0026ldquo;23four5six7\u0026rdquo; 234567   \u0026ldquo;2three45sixseven\u0026rdquo; 234567   \u0026ldquo;123\u0026rdquo; 123     입출력 예 #1\n문제 예시와 같습니다.\n  입출력 예 #2\n문제 예시와 같습니다.\n  입출력 예 #3\n\u0026ldquo;three\u0026quot;는 3, \u0026ldquo;six\u0026quot;는 6, \u0026ldquo;seven\u0026quot;은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다.\n입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\n  입출력 예 #4 s에는 영단어로 바뀐 부분이 없습니다.\n Solution 배열과 반복문을 이용한 해결   배열에 담는다. (배열인덱스가 0부터 시작이므로 zero 부터 nine 까지 인덱스와 숫자 영단어와 매핑이 된다. 문자열 s를 numbers를 순회하며, 숫자 영단어(numbers[i])의 값을 숫자(str(i)) 값으로 리플레이스   def solution(s):\rnumbers = [\u0026quot;zero\u0026quot;,\u0026quot;one\u0026quot;,\u0026quot;two\u0026quot;,\u0026quot;three\u0026quot;,\u0026quot;four\u0026quot;,\u0026quot;five\u0026quot;,\u0026quot;six\u0026quot;,\u0026quot;seven\u0026quot;,\u0026quot;eight\u0026quot;,\u0026quot;nine\u0026quot;]\rfor i in range(0, len(numbers)) :\rs = s.replace(numbers[i],str(i))\rreturn int(s)\r 배열과 reduce()를 이용한 해결  reduce를 누적 집계 목적으로 사용하는게 일반적이지만, 반복 처리에도 사용가능하다는 것을 배웠다.\n from functools import reduce\rdef solution(s):\rnumbers = [\u0026quot;zero\u0026quot;,\u0026quot;one\u0026quot;,\u0026quot;two\u0026quot;,\u0026quot;three\u0026quot;,\u0026quot;four\u0026quot;,\u0026quot;five\u0026quot;,\u0026quot;six\u0026quot;,\u0026quot;seven\u0026quot;,\u0026quot;eight\u0026quot;,\u0026quot;nine\u0026quot;]\rreturn int(reduce(lambda value, idx : value.replace(numbers[idx], str(idx)), range(len(numbers)) ,s))\r reduce()  reduce(function, iterable(순회 가능한 데이터) [, initializer=None(초기값)])\n 누적 집계를 위해서 사용한다. 파라미터의 function에는2가지 인자가 존재한다. (value(누적대상), element(iterable의 현재 값))    reduce()를 통해 풀수 있다는 것을 다른 사람의 코드로 확인후 풀어보면서, 이해가 안가는 것이 생겨 reduce() 함수를 찾아보게 되었다.\n  reduce(lambda value, idx : formula , [0,1,2\u0026hellip;9], \u0026lsquo;one4seveneight\u0026rsquo;) 여기에서 value와 idx의 값 매핑이 생각했던 것과 달랐다. reduce(lambda a, b : formula , x, y) a는 x, b는 y로 매핑될것 같았지만, a는 y가 b는 x가 매핑되었다. 왜 이런 결과가 나오나 이해가 되지 않아 검색하던 도중 reduce의 코드를 보고 이해가 되었다.\n reduce code link def reduce(function, iterable, initializer=None):\rit = iter(iterable)\rif initializer is None:\t# initializer가 입력이 되지않은 경우\rvalue = next(it) # 첫값을 뽑고 인덱스++\telse:\t# initializer가 입력이된 경우\rvalue = initializer for element in it:\rvalue = function(value, element)\rreturn value\r  reduce의 파라미터중 initializer가 입력이 되지않는 일반적인 경우 function의 첫번째 파라미터는 최초 iterable의 첫번째 값이며, 이후 function의 결과값(누적된 값)이 들어간다.\n  reduce의 파라미터중 initializer가 입력이 되어 있는 경우 function의 첫번째 파라미터는 최초 initializer 값이며, 이후 function의 결과값(누적된 값)이 들어간다.\n  생각했던 lambda a,b: a+b (10,20) 같은 function(10,20)의 파라미터 세팅이 아닌, reduce(lambda a,b: a+b, [0,1,2,\u0026hellip;9],100)의 function(100,0) 파라미터 세팅이였다.\n Others Solution from functools import reduce\rdigit={'zero':'0','one':'1','two':'2','three':'3','four':'4','five':'5','six':'6','seven':'7','eight':'8','nine':'9'}\rdef solution(s):\rreturn int(reduce(lambda ans,d:ans.replace(d,digit[d]),digit.keys(),s))\r TestCase a = [\u0026quot;one4seveneight\u0026quot;, \u0026quot;23four5six7\u0026quot;, \u0026quot;2three45sixseven\u0026quot;, \u0026quot;123\u0026quot;]\rfor i in a :\rsolution(i)\r ","description":"Programmers 숫자 문자열과 영단어","id":97,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 81301 숫자 문자열과 영단어","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-81301-numeric-strings-and-english-words/"},{"content":"Programmers - 64061 크레인 인형 뽑기 Task description 원문 : Programmers 64061 링크\n 게임개발자인 \u0026ldquo;죠르디\u0026quot;는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. \u0026ldquo;죠르디\u0026quot;는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\n  게임 화면은 \u0026ldquo;1 x 1\u0026rdquo; 크기의 칸들로 이루어진 \u0026ldquo;N x N\u0026rdquo; 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 \u0026ldquo;5 x 5\u0026rdquo; 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 \u0026ldquo;1 x 1\u0026rdquo; 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.\n  만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.\n  크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)\n  게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.\n Condition   board 배열은 2차원 배열로 크기는 \u0026ldquo;5 x 5\u0026rdquo; 이상 \u0026ldquo;30 x 30\u0026rdquo; 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.   input output    board moves result     [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4     입출력 예에 대한 설명 입출력 예 #1\n  인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\n Solution   크레인의 이동만큼 반복 board의 길이 만큼 반복 move위치의 board를 순서대로 순회해서, 0이 아닌경우 basket이 비어있지 않으면 마지막 값과 board[i][move-1] 값을 비교해서 같다면 - 마지막 값 팝 - 터진 인형의 개수 +2 basket이 비어있지 않으면 마지막 값과 board[i][move-1] 값이 다르면 - basket에 담는다. board[i][move-1] 위치의 값을 0으로 세팅하고, 루프를 나간다.   def solution(board, moves):\ranswer = 0\rbasket = [] # 뽑은 인형을 담을 stack\rfor move in moves :\t# 크레인의 이동만큼 반복\rfor i in range(0, len(board[0])): # board의 길이 만큼 반복\rif board[i][move-1] != 0 : # move위치의 board를 순서대로 순회\rif len(basket) != 0 and basket[-1] == board[i][move-1] : # basket이 비어있지 않으면 마지막 값과 ``board[i][move-1]`` 값이 같다면\rbasket.pop()\t# 마지막 값 팝 answer += 2\t# 터진 인형의 개수 +2\relse :\rbasket.append(board[i][move-1])\t#basket에 담는다.\rboard[i][move-1] = 0\t#``board[i][move-1]`` 위치의 값을 0으로 세팅하고,\rbreak\t# 루프를 나간다.\rreturn answer\r Others Solution def solution(board, moves):\rcols = list(map(lambda x: list(filter(lambda y: y \u0026gt; 0, x)), zip(*board)))\ra, s = 0, [0]\rfor m in moves:\rif len(cols[m - 1]) \u0026gt; 0:\rif (d := cols[m - 1].pop(0)) == (l := s.pop()):\ra += 2\relse:\rs.extend([l, d])\rreturn a\r TestCase solution([[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]], [1,5,3,5,1,2,1,4])\t#4\r ","description":"Programmers 크레인 인형 뽑기","id":98,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 64061 크레인 인형 뽑기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-64061-crane-puppet-game/"},{"content":"Programmers - 70128 내적 Task description 원문 : Programmers 70128 링크\n 길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.\n  이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + \u0026hellip; + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)\n Condition   a, b의 길이는 1 이상 1,000 이하입니다. a, b의 모든 수는 -1,000 이상 1,000 이하입니다.   input output    a b result     [1,2,3,4] [-3,-1,0,2] 3   [-1,0,1] [1,0,-1] -2     입출력 예 설명\n 입출력 예 #1 a와 b의 내적은 1*(-3) + 2*(-1) + 3*0 + 4*2 = 3 입니다. 입출력 예 #2 a와 b의 내적은 (-1)1 + 00 + 1*(-1) = -2 입니다.   Point  n-1이 나와서 재귀함수로 접근해야하나 싶었지만, 배열 문제에 자주 나오던 람다식으로 시도해보았다.\n 람다  람다는 익명 함수를 한줄의 코드로 선언하여 변수 또는 반환값, 파라미터로 사용하는 코드이다.\n  람다식 - lambda parameter : formula 단독 수행 - lambda parameter : formula (input-value)\n def hap(x,y): return x+y\r  일반 함수로 합을 구하는 공식을 람다식으로 변환하면 아래와같고,\n lambda x,y : x+y (10,20)\r map 함수  map()은 리스트를 받아서 요소(배열의 값)들을 람다식을 적용하여, 새로운 배열로 만들어 반환.\n  리스트 1개 일때 - map(function, list) 리스트 1개 이상 - map(function, list1, list2..)\n   map 함수는 함수와 리스트를 인자로 받음. 리스트의 요소(원소;배열의 값)를 하나씩 꺼내서 함수를 적용. 그 결과를 새로운 리스트에 담아 반환.   a = [1,2,3]\rb = [4,5,6]\rresult = []\rfor i in range(0,len(a)) :\rresult.append(a[i]+b[i])\r  map을 이용하면 위의 복잡한 식을 한줄로 줄일 수 있다.\n list(map(lambda x,y : x+y, [1,2,3],[4,5,6]))\r  여담으로 zip 함수를 이용할 수도 있다.\n result = []\rfor t in list(zip([1, 2, 3], [4, 5, 6])) : result.append(sum(t))\r Solution   배열 a와 b를 map함수로, 배열의 요소 x,y를 서로 곱해서 배열로 반환 배열의 합을 구함   def solution(a, b):\rreturn sum(list(map(lambda x,y : x*y , a,b))) #sum( 생성된 map 배열을 더함\r#\tlist(map(\t# a,b 배열을 받아 각 요소 x,y를 람다식을 수행\r#\tlambda x,y : x*y\t# x,y 를 곱하는 람다식\r# , a,b))\r#)  Others Solution  zip을 이용하여 한줄로 표현할 수 도 있다.\n def solution(a, b):\rreturn sum([x*y for x, y in zip(a,b)])\r  람다를 for 문처럼 사용\n def solution(a, b):\rreturn sum(map(lambda i: a[i]*b[i], range(len(a))))\r TestCase solution([1,2,3,4], [-3,-1,0,2])\rsolution([-1,0,1],\t[1,0,-1])\r ","description":"Programmers 내적","id":99,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 70128 내적","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-70128-inner-product/"},{"content":"Programmers - 42748 K번째 수 Task description 원문 : Programmers 42748 링크\n 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.\n  예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\n  array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n Condition   array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다.   input output    array commands return     [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3]    Solution   commands를 순회 command를 얻어 array를 자른다 잘라낸 배열을 정렬한다. 그중 N 번째 수를 결과 배열에 담는다.   def solution(array, commands):\ranswer = []\rfor command in commands : tmp = array[command[0]-1:command[1]]\rtmp.sort()\ranswer.append(tmp[command[2]-1])\rreturn answer\r Others Solution  람다식으로 한줄로 표현 할 수도 있다.\n def solution(array, commands):\rreturn list(map(lambda x:sorted(array[x[0]-1:x[1]])[x[2]-1], commands))\r TestCase solution([1, 5, 2, 6, 3, 7, 4],\t[[2, 5, 3], [4, 4, 1], [1, 7, 3]])\r ","description":"Programmers K번째 수","id":100,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42748 K번째 수","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42748-kth-number/"},{"content":"Programmers - 72410 신규 아이디 추천 Task description 원문 : Programmers 72410 링크\n 카카오에 입사한 신입 개발자 네오는 \u0026ldquo;카카오계정개발팀\u0026quot;에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \u0026ldquo;네오\u0026quot;에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다. 다음은 카카오 아이디의 규칙입니다.\n  아이디의 길이는 3자 이상 15자 이하여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.\n단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\n\u0026ldquo;네오\u0026quot;는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\n신규 유저가 입력한 아이디가 new_id 라고 한다면,\n 1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.\r2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\r3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\r4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\r5단계 new_id가 빈 문자열이라면, new_id에 \u0026quot;a\u0026quot;를 대입합니다.\r6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.\r만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\r7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\r  예를 들어, new_id 값이 \u0026ldquo;\u0026hellip;!@BaT#*..y.abcdefghijklm\u0026rdquo; 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다.\n  1단계 대문자 \u0026lsquo;B\u0026rsquo;와 \u0026lsquo;T\u0026rsquo;가 소문자 \u0026lsquo;b\u0026rsquo;와 \u0026rsquo;t\u0026rsquo;로 바뀌었습니다.\n\u0026quot;...!@BaT#*..y.abcdefghijklm\u0026quot; → \u0026quot;...!@bat#*..y.abcdefghijklm\u0026quot;\n  2단계 \u0026lsquo;!\u0026rsquo;, \u0026lsquo;@\u0026rsquo;, \u0026lsquo;#\u0026rsquo;, \u0026lsquo;*\u0026rsquo; 문자가 제거되었습니다.\n\u0026quot;...!@bat#*..y.abcdefghijklm\u0026quot; → \u0026quot;...bat..y.abcdefghijklm\u0026quot;\n  3단계 \u0026lsquo;\u0026hellip;\u0026lsquo;와 \u0026lsquo;..\u0026rsquo; 가 \u0026lsquo;.\u0026lsquo;로 바뀌었습니다.\n\u0026quot;...bat..y.abcdefghijklm\u0026quot; → \u0026quot;.bat.y.abcdefghijklm\u0026quot;\n  4단계 아이디의 처음에 위치한 \u0026lsquo;.\u0026lsquo;가 제거되었습니다.\n\u0026quot;.bat.y.abcdefghijklm\u0026quot; → \u0026quot;bat.y.abcdefghijklm\u0026quot;\n  5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.\n\u0026quot;bat.y.abcdefghijklm\u0026quot; → \u0026quot;bat.y.abcdefghijklm\u0026quot;\n  6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.\n\u0026quot;bat.y.abcdefghijklm\u0026quot; → \u0026quot;bat.y.abcdefghi\u0026quot;\n  7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.\n\u0026quot;bat.y.abcdefghi\u0026quot; → \u0026quot;bat.y.abcdefghi\u0026quot;\n  따라서 신규 유저가 입력한 new_id가 \u0026ldquo;\u0026hellip;!@BaT#*..y.abcdefghijklm\u0026quot;일 때, 네오의 프로그램이 추천하는 새로운 아이디는 \u0026quot;bat.y.abcdefghi\u0026quot; 입니다.\n  신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, \u0026ldquo;네오\u0026quot;가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.\n Condition   new_id는 길이 1 이상 1,000 이하인 문자열입니다. new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다. new_id에 나타날 수 있는 특수문자는 -_.~!@#$%^\u0026amp;*()=+[{]}:?,\u0026lt;\u0026gt;/ 로 한정됩니다.   input output    no new_id result     예1 \u0026ldquo;\u0026hellip;!@BaT#*..y.abcdefghijklm\u0026rdquo; \u0026ldquo;bat.y.abcdefghi\u0026rdquo;   예2 \u0026ldquo;z-+.^.\u0026rdquo; \u0026ldquo;z\u0026ndash;\u0026rdquo;   예3 \u0026ldquo;=.=\u0026rdquo; \u0026ldquo;aaa\u0026rdquo;   예4 \u0026ldquo;123_.def\u0026rdquo; \u0026ldquo;123_.def\u0026rdquo;   예5 \u0026ldquo;abcdefghijklmn.p\u0026rdquo; \u0026ldquo;abcdefghijklmn\u0026rdquo;    Solution   lower()를 이용한 lowercase 정규식을 이용해 허용되지 않는 특수문자 제거 문자열을 순회하며 이전이 . 인경우 스킵 아닌경우, temp 변수에 추가 문자열 처음과 마지막이 . 이면 삭제 new_id가 빈문자열이면 a로 세팅 new_id 16보다 길면 15자리로 잘라내고, 마지막이 .이면 삭제 new_id 3자리 보다 작으면 마지막 단어로 반복 3까지   import re def solution(new_id):\r#step1 new_id = new_id.lower()\r#step2\rregex = re.compile('(\\~|\\!|\\@|\\#|\\$|\\%|\\^|\\\u0026amp;|\\*|\\(|\\)|\\=|\\+|\\[|\\{|\\]|\\}|\\:|\\?|\\,|\\\u0026lt;|\\\u0026gt;|\\/|)')\rnew_id = regex.sub('', new_id)\r#step3\rstep3 = ''\rfor i in range(0,len(new_id)) :\rif i != 0 and new_id[i] == '.' :\rif(new_id[i-1] != '.') :\rstep3 += new_id[i]\relse : step3 += new_id[i]\rnew_id = step3\r#step4\rif new_id[0] == '.' :\rnew_id = new_id[1:]\rif len(new_id) != 0 and new_id[-1] == '.' :\rnew_id = new_id[:len(new_id)-1]\rnew_id = new_id\r#step5 if new_id == '' :\rnew_id = 'a'\r#step6 if len(new_id) \u0026gt; 15 :\rnew_id = new_id[:15]\rif new_id[-1] == '.' :\rnew_id = new_id[:len(new_id)-1]\r#step7 if len(new_id) \u0026lt; 3 :\rfor i in range(0, 3-len(new_id)) :\rnew_id += new_id[-1]\rreturn new_id\r Other Solution  다른 사람의 풀이를 보고 정규식의 중요성을 배웠다.\n import re\rdef solution(new_id):\rst = new_id\rst = st.lower()\rst = re.sub('[^a-z0-9\\-_.]', '', st)\rst = re.sub('\\.+', '.', st)\rst = re.sub('^[.]|[.]$', '', st)\rst = 'a' if len(st) == 0 else st[:15]\rst = re.sub('^[.]|[.]$', '', st)\rst = st if len(st) \u0026gt; 2 else st + \u0026quot;\u0026quot;.join([st[-1] for i in range(3-len(st))])\rreturn st\r TestCase tests = [\u0026quot;...!@BaT#*..y.abcdefghijklm\u0026quot;, \u0026quot;z-+.^.\u0026quot;,\u0026quot;=.=\u0026quot;, \u0026quot;123_.def\u0026quot;, \u0026quot;abcdefghijklmn.p\u0026quot;]\rfor test in tests :\rsolution(test)\r ","description":"Programmers 신규 아이디 추천","id":101,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 72410 신규 아이디 추천","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-72410-new-id-recommendation/"},{"content":"Programmers - 42576 완주하지 못한 선수 Task description 원문 : Programmers 42576 링크\n 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.\n Condition   마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다.   input output    participant completion return     [\u0026ldquo;leo\u0026rdquo;, \u0026ldquo;kiki\u0026rdquo;, \u0026ldquo;eden\u0026rdquo;] [\u0026ldquo;eden\u0026rdquo;, \u0026ldquo;kiki\u0026rdquo;] \u0026ldquo;leo\u0026rdquo;   [\u0026ldquo;marina\u0026rdquo;, \u0026ldquo;josipa\u0026rdquo;, \u0026ldquo;nikola\u0026rdquo;, \u0026ldquo;vinko\u0026rdquo;, \u0026ldquo;filipa\u0026rdquo;] [\u0026ldquo;josipa\u0026rdquo;, \u0026ldquo;filipa\u0026rdquo;, \u0026ldquo;marina\u0026rdquo;, \u0026ldquo;nikola\u0026rdquo;] \u0026ldquo;vinko\u0026rdquo;   [\u0026ldquo;mislav\u0026rdquo;, \u0026ldquo;stanko\u0026rdquo;, \u0026ldquo;mislav\u0026rdquo;, \u0026ldquo;ana\u0026rdquo;] [\u0026ldquo;stanko\u0026rdquo;, \u0026ldquo;ana\u0026rdquo;, \u0026ldquo;mislav\u0026rdquo;] \u0026ldquo;mislav\u0026rdquo;    Solution   participant 배열을 DICT로 변경 - 키는 선수명, 값은 카운트 - 키가 없으면 1, 키가 있다면 +1 completion를 순회 하며 DICT을 조회 - 선수를 조회하여 카운트 값이 1이면 삭제 - 선수를 조회하여 카운트 값이 1보다 크면 -1 남아있는 선수의 이름을 반환   \rdef solution(participant,completion):\ranswer = ''\rdic = {}\rfor player in participant :\t# participant 배열을 DICT로 변경\rif dic.get(player) is None :\t# 키는 선수명, 값은 카운트\rdic[player] = 1\telse :\rdic[player] += 1\t# 키가 없으면 1, 키가 있다면 +1\rfor player in completion :\t# completion를 순회 하며 DICT을 조회\rif dic[player] == 1 :\t# 선수를 조회하여 카운트 값이 1이면 삭제\rdel(dic[player])\relse :\rdic[player] -= 1\t# 선수를 조회하여 카운트 값이 1보다 크면 -1\rfor k in dic.keys() :\t# 남아있는 선수의 이름을 반환\ranswer = k\rreturn answer\r Other Solution  다른 사람의 풀이를 보고 Counter라는 콜렉션의 함수를 처음 보았다. ~메모~\n from collections import Counter\rdef solution(participant, completion):\ranswer = Counter(participant) - Counter(completion) # Counter로 생성하여 서로 -연산을 통해 남는 카운트를 반환\rreturn list(answer.keys())[0]\r TestCase solution([\u0026quot;leo\u0026quot;, \u0026quot;kiki\u0026quot;, \u0026quot;eden\u0026quot;],\t[\u0026quot;eden\u0026quot;, \u0026quot;kiki\u0026quot;]) # \u0026quot;leo\u0026quot;\rsolution([\u0026quot;marina\u0026quot;, \u0026quot;josipa\u0026quot;, \u0026quot;nikola\u0026quot;, \u0026quot;vinko\u0026quot;, \u0026quot;filipa\u0026quot;], [\u0026quot;josipa\u0026quot;, \u0026quot;filipa\u0026quot;, \u0026quot;marina\u0026quot;, \u0026quot;nikola\u0026quot;]) # \u0026quot;vinko\u0026quot;\rsolution([\u0026quot;mislav\u0026quot;, \u0026quot;stanko\u0026quot;, \u0026quot;mislav\u0026quot;, \u0026quot;ana\u0026quot;], [\u0026quot;stanko\u0026quot;, \u0026quot;ana\u0026quot;, \u0026quot;mislav\u0026quot;]) #\u0026quot;mislav\u0026quot;\r ","description":"Programmers 완주하지 못한 선수","id":102,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42576 완주하지 못한 선수","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42576-players-who-did-not-finish/"},{"content":"BAEKJOON - 4949 균형잡힌 세상 Task description 원문 : 백준 4949 링크\n메시지를 입력받아 괄호를 열고 닫아야 한다.\n 열고 닫는 괄호가 균형 맞게 되어있으면 yes 아니면 no 출력\n ex) asd(b)dd(d[ddd]) yes ex) (asdasd] no 메시지의 끝은 .으로 끝나고 메시지가 \u0026ldquo;.\u0026rdquo; 이면 종료   Condition   모든 왼쪽 소괄호(\u0026quot;(\u0026quot;)는 오른쪽 소괄호(\u0026quot;)\u0026quot;)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(\u0026quot;[\u0026quot;)는 오른쪽 대괄호(\u0026quot;]\u0026quot;)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 하나 또는 여러줄에 걸쳐서 문자열이 주어진다. 각 문자열은 영문 알파벳, 공백, 소괄호(\u0026quot;( )\u0026quot;) 대괄호(\u0026quot;\u0026quot;)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다. 7번째의 \u0026quot; .\u0026ldquo;와 같이 괄호가 하나도 없는 경우도 균형잡힌 문자열로 간주할 수 있다. 입력의 종료조건으로 맨 마지막에 점 하나(\u0026rdquo;.\u0026quot;)가 들어온다.   input output 예제 입력 1 So when I die (the [first] I will see in (heaven) is a score list).\r[ first in ] ( first out ).\rHalf Moon tonight (At least it is better than no Moon at all].\rA rope may form )( a trail in a maze.\rHelp( I[m being held prisoner in a fortune cookie factory)].\r([ (([( [ ] ) ( ) (( ))] )) ]).\r.\r.\r예제 출력 1 yes\ryes\rno\rno\rno\ryes\ryes\r Solution   메시지가 \u0026ldquo;.\u0026rdquo; 이면 종료 메시지가 \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;[\u0026rsquo; 이면 스택에 추가   \rwhile True : msg = input()\rif msg == '.' :\t# \u0026quot;.\u0026quot; 이면 종료\rbreak\rfront = []\t# 스택 생성\rflag = True # .이나오기 전에 조건에 만족(균형) X 면 False\rfor i in range(0, len(msg)) :\tif msg[i] == '.' : if len(front) == 0 and flag: # 스택이 모두 pop되고, 조건에 만족(균형) 하면 yes\rprint('yes')\relse : print('no')\relif msg[i] == '(' or msg[i] == '[' : # 메시지가 '(' 또는 '[' 이면 스택에 추가\rfront.append(msg[i])\relif (msg[i] == ')' or msg[i] == ']') and len(front) == 0 : # 괄호를 안열고, 닫으려 할때 flag = False\relif msg[i] == ')' : # )가 나왔을때 if front[-1] == '(' :\t# 스택 마지막이 ( 였다면 팝\rfront.pop()\relse :\rflag = False\t# 스택 마지막이 [ 으로 조건에 만족(균형) no\relif msg[i] == ']' :\t# ]가 나왔을때 if front[-1] == '[' : # 스택 마지막이 [ 였다면 팝\rfront.pop()\relse : flag = False\t# 스택 마지막이 ( 으로 조건에 만족(균형) no\r TestCase \r ","description":"백준 균형잡힌 세상","id":103,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 4949 균형잡힌 세상","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-4949-a-balanced-world/"},{"content":"BAEKJOON - 1541 잃어버린 괄호 Task description 원문 : 백준 1541 링크\n +와 -그리고 괄호를 가진 식에서 괄호를 모두 지웠다. 그리고 나서 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n Condition   첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다. 첫째 줄에 정답을 출력한다.   input output 예제 입력 1 55-50+40\r예제 출력 1 -35\r Solution   +와 -그리고 숫자들을 배열에 넣는다. 첫번째 - 이후 +는 괄호로 묶는다 (- (A + B) 랑 -A-B 와 같으므로 +여도 -로 계산한다.)   message = input() # 입력받은 메시지\rformula = [] # 공식 배열 (숫자,+,-)\rvalue = \u0026quot;\u0026quot;\t# 쪼개진 숫자 문자열로 조합\rflag = False # +를 -로 계산할지 여부 (첫 -가 나왔는지 여부)\rresult = 0\t# 결과값\rfor i in range(0,len(message)) :\t# +와 -그리고 숫자들을 배열에 넣는다.\rif message[i] == \u0026quot;+\u0026quot; or message[i] == \u0026quot;-\u0026quot; :\tformula.append(int(value))\t# +, -가 나오면 그전까지의 value를 숫자로 바꿔 formula 배열에 넣는다\rvalue=\u0026quot;\u0026quot;\rformula.append(message[i])\t# + or - 를 formula 배열에 추가\relif i ==len(message)-1 :\rvalue += message[i]\t# 마지막 인덱스인경우 value를 숫자로 바꿔 formula 배열에 넣는다\rformula.append(int(value))\telse :\t# 숫자는 value에 추가\rvalue += message[i]\rfor i in range(0,len(formula)) :\rif formula[i] == \u0026quot;+\u0026quot; or formula[i] == \u0026quot;-\u0026quot; :\rif(formula[i] == \u0026quot;-\u0026quot;) :\rflag = True\relse :\rif flag == False :\rresult += formula[i] else :\rresult -= formula[i] print(result)\r TestCase  ","description":"백준 잃어버린 괄호 ","id":104,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 1541 잃어버린 괄호 ","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-1541-lost-parenthesis/"},{"content":"BAEKJOON - 10828 스택 Task description 원문 : 백준 10828 링크\n 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\n  명령은 총 다섯 가지이다.\n  push X: 정수 X를 스택에 넣는 연산이다. pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 스택에 들어있는 정수의 개수를 출력한다. empty: 스택이 비어있으면 1, 아니면 0을 출력한다. top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\n Condition   첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.   input output 14\rpush 1\rpush 2\rtop\rsize\rempty\rpop\rpop\rpop\rsize\rempty\rpop\rpush 3\rempty\rtop\r예제 출력 1 복사\r2\r2\r0\r2\r1\r-1\r0\r1\r-1\r0\r3\r예제 입력 2 복사\r7\rpop\rtop\rpush 123\rtop\rpop\rtop\rpop\r예제 출력 2 복사\r-1\r-1\r123\r123\r-1\r-1\r Solution import sys\rclass Stack :\t# 클래스 생성\rdef __init__(self) :\rself.elements = []\t# 스택의 엘리먼츠 추가\rdef push(self, x) :\tself.elements.append(x)\t# x를 스택에 추가\rdef empty(self) :\t# 엘리먼츠의 길이(사이즈)가 0 이면 1 if len(self.elements) == 0 : print(1)\rreturn 1\relse :\rprint(0)\rreturn 0\rdef pop(self) :\tif len(self.elements) == 0 : #비어있는 경우 -1\rprint(-1)\relse :\rself.top()\rself.elements.pop()\rdef size(self) :\rprint(len(self.elements))\rreturn len(self.elements)\rdef top(self) :\rif len(self.elements) == 0 :\rprint(-1)\relse :\rprint(self.elements[-1])\r#n = int(input())\rn = int(sys.stdin.readline().rstrip())\rs = Stack()\rfor i in range(0,n) :\rinput_split = sys.stdin.readline().rstrip().split()\rcommand = input_split[0]\r#command = str(input())\rif 'pop' == command.lower() :\rs.pop()\relif 'size' == command.lower() :\rs.size()\relif 'top' == command.lower() :\rs.top()\relif 'empty' == command.lower() :\rs.empty()\relif 'push' == command.lower() :\rs.push(input_split[1])\r TestCase  ","description":"백준 스택","id":105,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 10828 스택","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-10872-stack/"},{"content":"BAEKJOON - 10872 팩토리얼(Factorial) Task description 원문 : 백준 10872 링크\n 0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.\n Condition   첫째 줄에 정수 N(0 ≤ N ≤ 12)가 주어진다.   input output 예제 입력 1 복사\r10\r예제 출력 1 복사\r3628800\r예제 입력 2 복사\r0\r예제 출력 2 복사\r1\r Solution  0이면 1리턴 0이 아니면 N * factorial(N-1) 리턴 # N * (N-1)!\n def factorial(N): if ( N != 0) :\rreturn N * factorial(N-1) #N * (N-1)!\relse :\rreturn 1\rN = int(input())\rfn = factorial(N)\rprint(fn)\r TestCase  ","description":"백준 팩토리얼","id":106,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 10872 팩토리얼","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-10872-factorial/"},{"content":"dimsom / dumplings (\u0026lsquo;딤섬 / 만두\u0026rsquo;) ingredient (\u0026lsquo;재료, 성분\u0026rsquo;)  a. What ingredients do you need to make a 김치찌개?\n grocery (\u0026lsquo;식료품, 식자재 / 식료품점\u0026rsquo;)  I need to go to the grocery (store). / I need to buy some groceries.\n ingredient 와 grocery   ingredient는 요리 뿐만 아니라 만드는 모든 것의 재료 grocery는 음식을 만들때의 재료   I had A on B . (\u0026lsquo;B에 A가 있었습니다.')  I had a P.T. on Wednesday. (수요일에 PT가 있었습니다.) I had a haircut on Tuesday. (화요일에 머리를 잘랐었습니다.)\n I had/ate A at the B. (\u0026lsquo;B에서 A를 먹었습니다.')  I had fried chicken at the company. (나는 회사에서 후라이드 치킨을 먹었습니다.) I ate dinner at the company. (나는 회사에서 저녁을 먹었습니다.)\n I enjoy trying out A (\u0026lsquo;나는 A를 즐긴다\u0026rsquo;)  I enjoy trying out new exercise (나는 새로운 운동을 즐깁니다.) I enjoy trying out new foods. (나는 새로운 음식을 즐깁니다.) I enjoy trying out new menus / dishes. (나는 새로운 메뉴/요리를 시도하는 것을 즐깁니다.)\n leek (\u0026lsquo;부추\u0026rsquo;) sesame oil (\u0026lsquo;참기름\u0026rsquo;) I prefer A (\u0026lsquo;나는 A를 선호한다.')  I prefer shopping (groceries) online (나는 온라인 쇼핑(식료품)을 선호한다)\n when I need it at the moment. (\u0026lsquo;지금 내가 필요할 때\u0026rsquo;) I bought A and it was really good. (\u0026lsquo;A 샀었는데 정말 좋았습니다.')  I bought grocery beef for steak and it was really good.\n Grammar Error: I was Tuesday. → I had a haircut on Tuesday. I was eat chicken at company. → I had/ate fried chicken at the company.\rI try delivery new restaurants. → I enjoy trying out new delivery restaurants/foods. / I enjoy trying out new restaurants on the delivery app.\rI enjoy trying out new menus / dishes.\rI like online stores, like Market Kurly, but I sometimes use supermarkets or local stores when I’m busy. → I prefer shopping (groceries) online ~ when I need it at the moment.\rI bought grocery beef for steak and it was really good. → I bought a beef steak at Market Kurly and ~.  New expressions learned today: ingredient 재료 / grocery 식료품, 식자재 / 식료품점\rI need to go to the grocery (store). / I need to buy some groceries.\ra. What _ingredients_ do you need to make a 김치찌개?\rb. I went out to buy some _groceries_ because we didn’t have anything to eat.\rfrozen ready-made food → ready meal\rdimsom / dumplings\rI like (__) the best. = (___) is my favorite frozen/instant food. = My favorite ready meal is (___). leek (green onion, spring onion), garlic\r열려라 참깨! Open Sesame! → sesame oil 참기름\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":107,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.07.08","uri":"https://offetuoso.github.io/blog/english/202107/20210708-english-speak/"},{"content":"BAEKJOON - 11729 하노이 탑 이동 순서(Hanoi Tower Travel Order) Task description 원문 : 백준 11729 링크\n 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 아래서 부터 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라.\n  아래 그림은 원판이 5개인 경우의 예시이다.\n Condition   한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. 이동 횟수는 최소가 되어야 한다.   input output 예제 입력 1 복사\r3\r예제 출력 1 복사\r7\r1 3\r1 2\r3 2\r1 3\r2 1\r2 3\r1 3\r Solution   첫번째 봉에 있는 1~n-1 까지의 원반을 두번째 봉에 옮김 첫번째 봉에 있는 n 원반을 세번째 봉에 옮김 세번째 봉에 있는 1~n-1 까지의 원반을 세번째 봉에 옮김   def hanoi(n, first, second ,third) :\rif n == 1 :\rresult.appthird(str(first)+' '+str(third)) # n이 1까지 재귀로 호출되면 결과 배열에 담음\relse : hanoi(n-1, first, third, second) # first에서 n-1의 모든 원반을 second로 모두 옮김, 임시 경유는 third\rhanoi(1, first, second, third)\t# first에서 third로 마지막(N번째) 원반을 third로 옮김, 임시 경유는 second\rhanoi(n-1, second, first, third) # second에 있는 n-1의 모든 원반을 third로 옮김, 임시 경유는 first\rresult = []\rn = int(input())\rhanoi(n, 1, 2, 3) # hanoi(옮길 원반수, 1번 봉, 2번 봉, 3번 봉)\rprint(len(result))\rfor item in result :\rprint(item)\r TestCase  ","description":"백준 하노이 탑 이동 순서","id":108,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 11729 하노이 탑 이동 순서","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-11729-hanoi-tower-travel-order/"},{"content":"BAEKJOON - 2941 크로아티아 알파벳(Croatian Alphabet) Task description 원문 : 백준 2941 링크\n 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n    크로아티아 알파벳 변경     č c=   ć c-   dž dz=   đ d-   lj lj   nj nj   š s=   ž z=      예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.   Condition   dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.   input output 예제 입력 1 ljes=njak\r예제 출력 1\r6\r예제 입력 2\rddz=z=\r예제 출력 2\r3\r예제 입력 3\rnljj\r예제 출력 3\r3\r예제 입력 4\rc=c=\r예제 출력 4\r2\r예제 입력 5\rdz=ak\r예제 출력 5\r3\r Solution    입력 변경     dz= 0\t(dž)   z= 1 (ž)   d- 2 (đ)   c= 3 (č)   c- 4 (ć)   nj 5 (nj)   s= 6 (š)   lj 7 (lj)     알파벳과 -, = 만 입력이 이루어 지기 때문에 1자리의 다른 문자열로 치환(숫자) , 순서는 dz=가 z= 보다 먼저 배열에 들어가 있어야 한다. 자리수를 센다.\n msg = input() # 케이스 입력받음\rcroatian = ['dz=','z=','d-','c=','c-','nj','s=','lj'] #크로아티아 문자열 배열, 치환할 우선순위에 맞게 배열 생성\rfor i in range(0,len(croatian)) :\rmsg = msg.replace(croatian[i], str(i)) #크로아티아 문자열을 배열 인덱스로 변환\rprint(len(msg)) #길이 출력\r TestCase ljes=njak #6\rddz=z= #3\rnljj #3\rc=c= #2\rdz=ak #3\r ","description":"백준 크로아티아 알파벳","id":109,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2941 크로아티아 알파벳","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2941-croatian-alphabet/"},{"content":"Lombok @Data 어노테이션 \u0026ldquo;getter\u0026rdquo; \u0026ldquo;setter\u0026rdquo; 인식 안될때 문제  Spring Boot에서 프로젝트 생성시 아래와 같이 lombok을 추가하고 데이터 오브젝트 클래스에서 lombok 선언을 하였음에도, 컨트롤러에서 @RequestBody를 통해 Company company 객체를 전달받았을때, 데이터가 세팅이 안되고 Null로 데이터가 있는 경우가 있었다.\n  찾아보니, 사용하는 lombok-xxx.jar를 실행하여 IDE(eclipse, sts)에 설치 해줘야 한다는 것이다.\n 해결책   Jar가 설치된 위치로 가서 Terminal을 연다.    Jar를 실행시킨다.   \tjava -jar [jar 파일.jar]\r  lombok 설치화면이 뜬다.    specify location(위치 지정) 클릭    설치할 IDE 선택    설치완료    ini 파일 확인   해당 체크한 부분이 있는지 확인한다. lombok이 설치되고 경로를 추가해준다. ini가 수정이 안된경우 해당 내용을 넣어 수정해준다.   -javaagent: [lombok.jar 경로] (C:\\develop\\Files\\IDE\\sts-4.8.1.RELEASE\\lombok.jar)\r  IDE 재시작 Project \u0026gt; clean   참조 Lombok is not generating getter and setter \n","description":"Lombok @Data 어노테이션 문제","id":110,"section":"blog","tags":["Troubleshooting"],"title":"Lombok @Data 어노테이션 getter setter 인식 안될때","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/spring/lombok-error/"},{"content":"BAEKJOON - 2798 블랙잭(black jack) Task description 원문 : 백준 2798 링크\n  첫번째 줄은 카드의 (장)수 N과 블랙잭 넘버(목표 값) M을 입력받는다. 두번째 줄은 공백으로 구분된 N장의 카드 입력받는다. M이 넘지 않는 3장의 합중 가장 큰 경우 출력.   Condition   첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.   input output 예제 입력 1 5 21\r5 6 7 8 9\r예제 출력 1 21\r예제 입력 2 10 500\r93 181 245 214 315 36 185 138 216 295\r예제 출력 2 497\r Solution  완전탐색 (Brute-Force) 문제로 경우의 수를 모두 찾아본다.\n 같은 배열을 자리수 만큼 반복 이전에 나온것은 사용하지 않는다.   n, m = map(int, input().split())\rnumbers = list(map(int, input().split()))\rresult = 0\rfor i in numbers :\rfor j in numbers :\rif i != j :\t# 첫번째에서 선택한 값이 아닌것 for k in numbers :\rsum = i+j+k\rif i != k and j != k and sum \u0026lt;= m: #첫번째 두번째에서 선택한 값이 아닌것이며, i,j,k의 값이 sum을 넘지 않는것\rresult = max(sum,result) # 그 중에 가장 큰 값\rprint(result)\r TestCase #n, m = 5, 21\r#numbers = [5, 6, 7, 8, 9]\r#n, m = 10, 500\r#numbers = [93, 181, 245, 214, 315, 36, 185, 138, 216, 295]\r ","description":"백준 블랙잭","id":111,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2798 블랙잭","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2798-black-jack/"},{"content":"BAEKJOON - 1712 손익분기점(break even point) Task description 원문 : 백준 1712 링크\n 노트북 제조하는데 노트북 판매 대수에 상관없이 A만원의 고정 비용이 든다.\n한 대의 노트북을 생산하는 데에는 B만원의 가변 비용이 든다\nA=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며,\n열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다.\n생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다. 첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.   input output 예제 입력 1 1000 70 170\r예제 출력 1 11\r예제 입력 2 3 2 1\r예제 출력 2 -1\r예제 입력 3 2100000000 9 10\r예제 출력 3 2100000001\r Solution  일단 하나씩 계산해서 손익분기점을 찾아보았으나.. 시간초과에 걸린다.\n a, b, c = map(int, input().split())\rqty = 0\rif(c \u0026lt; 2):\rprint(-1)\rexit()\relse :\rwhile True :\rqty += 1\rformula1 = a + (b*qty)\rformula2 = (c*qty)\rif(formula1 \u0026lt; formula2):\rprint(formula2)\rbreak\r  루프 없이 어떻게 계산을 해야할까 고민하다 가변, 판매단가만 곱했을때 변하는것을 보고 판매단가 - 가변비용를 생각하였다.\n a, b, c = map(int, input().split())\rif(b \u0026gt;= c):\t# 가변비용이 판매단가와 같거나 크면, 아무리 수량을 늘려도 손익분기점에 도달하지 못한다\rprint(-1)\relse :\rprint((a//(c-b))+1) # (고정비/(단가-가변비용)) +1 (+1를 추가되어 손익분기점이 됨)\r   TestCase \r ","description":"백준 손익분기점","id":112,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 1712 손익분기점","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-1712-break-even-point/"},{"content":"BAEKJOON - 7576 토마토(tomato) Task description  철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.\n  창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.\n  토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.\n  입력 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 토마토가 하나 이상 있는 경우만 입력으로 주어진다.\n  출력 여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.\n Condition   토마토가 하나 이상 있는 경우만 입력으로 주어진다. 2 ≤ M,N ≤ 1,000   input output 예제 입력 1 6 4\r0 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 1\r예제 출력 1 8\r예제 입력 2 6 4\r0 -1 0 0 0 0\r-1 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 1\r예제 출력 2 -1\r예제 입력 3 6 4\r1 -1 0 0 0 0\r0 -1 0 0 0 0\r0 0 0 0 -1 0\r0 0 0 0 -1 1\r예제 출력 3 6\r예제 입력 4 5 5\r-1 1 0 0 0\r0 -1 -1 -1 0\r0 -1 -1 -1 0\r0 -1 -1 -1 0\r0 0 0 0 0\r예제 출력 4 14\r예제 입력 5 2 2\r1 -1\r-1 1\r예제 출력 5 0\r Solution \rfrom collections import deque\rdx = [-1, 1, 0, 0]\rdy = [0, 0, -1, 1]\rdef bfs() :\rresult = 0\rwhile queue :\ra, b = queue.popleft()\rfor i in range(4) :\rx = a + dx[i]\ry = b + dy[i]\rif 0 \u0026lt;= x \u0026lt; N and 0 \u0026lt;= y \u0026lt; M and graph[x][y] == 0 :\rqueue.append([x,y])\rgraph[x][y] = graph[a][b] + 1\rresult = max(graph[a][b], result)\rreturn result\rM, N = map(int, input().split())\rqueue = deque([])\rgraph = []\rfor i in range(N) :\rgraph.append(list(map(int, input().split())))\rfor j in range(M) :\rif graph[i][j] == 1 :\rqueue.append([i,j])\rr = bfs() for i, j in enumerate(graph) :\rif 0 in j :\rr = -1\rbreak\rprint(r)\r TestCase \r ","description":"백준 토마토","id":113,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 7578 토마토","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-7578-tomato/"},{"content":"BAEKJOON - 2606 미로(maze) Task description  N×M크기의 배열로 표현되는 미로가 있다.\n1\t0\t1\t1\t1\t1\n1\t0\t1\t0\t1\t0\n1\t0\t1\t0\t1\t1\n1\t1\t1\t0\t1\t1\n  미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.\n  위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.\n Condition input 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.\n4 6\r101111\r101010\r101011\r111011\r output 15\r Solution n, m = map(int, input().split())\rqueue = []\rmatrix = []\rfor i in range(n):\rmatrix.append(list(input()))\rqueue = [[0, 0]]\rmatrix[0][0] = 1\rdx = [+1, -1, 0, 0]\rdy = [ 0, 0, -1, +1] #상하좌우\rwhile queue :\ra,b = queue[0][0],queue[0][1]\rdel queue[0]\rfor i in range(4):\rx = a + dx[i]\ry = b + dy[i]\rif 0 \u0026lt;= x \u0026lt; n and 0 \u0026lt;= y \u0026lt; m and matrix[x][y] == \u0026quot;1\u0026quot; : queue.append([x,y])\rmatrix[x][y] = matrix[a][b] + 1\rprint(matrix[n - 1][m - 1])\r TestCase \r ","description":"백준 미로","id":114,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2178 미로","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2178-maze/"},{"content":"BAEKJOON - 2606 바이러스(virus) Task description  신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.\n  예를 들어 7대의 컴퓨터가 \u0026lt;그림 1\u0026gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.\n  어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.\n  입력\n첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.\n  출력\n1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.\n Condition   1 번 컴퓨터가 탐색 시작 노드이다. 1 \u0026lt;= N \u0026gt;= 100 (컴퓨터의 수) M (네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수)   input 7\r6\r1 2\r2 3\r1 5\r5 2\r5 6\r4 7\r output 4\r Solution   1부터 10001까지 모든 숫자 조회 숫자를 문자로 바꿔 저장 no는 자기자신의 값 i로 세팅 숫자의 자리수 만큼 반복 자리수의 숫자를 no에 더해줌 생성된 d(n) 값을 self dict에 추가 1 ~ 10001 까지의 숫자중 dict에 없는 숫자만 출력   from collections import deque\rN = int(input()) # 컴퓨터의 갯수\rM = int(input()) # 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수\r# 그래프 생성\rgraph = [[] for i in range(N+1)] # 0부터 N까지의 배열 (0은 사용안함)\rfor i in range(0,M) : # 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수만큼 반복\rK = list(map(int, input().split()))\t# 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍\rgraph[K[0]].append(K[1])\t# 그래프에 연결 추가\rgraph[K[1]].append(K[0]) # 반대의 경우도 연결 추가\r# 방문을 체크할 배열 생성\rvisited = [False for i in range(N+1)] # 방문 안한것으로 0~N까지의 배열 생성 (0은 사용 안함)\rqueue = deque() # 큐 생성\rcount = 0 # 결과 (1번 컴퓨터로 인해 바이러스 감염된 컴퓨터의 수)\rstart = 1 # 탐색 시작 컴퓨터 1\rqueue.append(start)\t# 큐에 추가\rvisited[start] = True\t# 1번 컴퓨터 방문처리\rwhile queue : # 큐의 데이터가 있는 동안\ridx = queue.popleft() # 검사할 컴퓨터의 번호를 팝\r#print(idx) # BFS 출력 하지만 문제\rif idx != start : # 탐색 시작 노드 1이 아닌것\rcount += 1\t# 1번 컴퓨터로 인해 감염된 컴퓨터 카운트\rfor node in graph[idx]: # 검사할 컴퓨터의 인접노드(graph[idx])의 연결된 인접 컴퓨터(노드) 만큼\rif not visited[node] : # 방문한 컴퓨터가 아닌 경우\rqueue.append(node)\t# 큐에 추가\rvisited[node] = True # 방문처리\rprint(count) # 결과 출력 (1번 컴퓨터로 인해 바이러스 감염된 컴퓨터의 수)\r  최초 함수로 코딩했으나, 백준에서는 함수를 사용하면 오답처리가 되었다.\n \rfrom collections import deque\rdef bfs(graph, start ,visited) :\rcount = 0\rqueue = deque()\rqueue.append(start)\rvisited[start] = True\rwhile queue :\ridx = queue.popleft()\r#print('pop',idx)\rif idx != start :\rcount += 1\rfor node in graph[idx]:\rif not visited[node] :\rqueue.append(node)\rvisited[node] = True\rreturn count\rN = int(input())\rM = int(input())\rgraph = [[] for i in range(N+1)]\rfor i in range(0,M) :\rK = list(map(int, input().split()))\rgraph[K[0]].append(K[1])\rgraph[K[1]].append(K[0])\rvisited = [False for i in range(N+1)]\r#print (graph,'\\n', visited)\rbfs(graph,1,visited)\r TestCase 예제 입력 7\r6\r1 2\r2 3\r1 5\r5 2\r5 6\r4 7\r예제 출력 4\r ","description":"백준 셀프 넘버","id":115,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2606 바이러스","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2606-virus/"},{"content":"너비 우선 탐색 알고리즘 BFS (Breadth-First Search)  BFS는 너비 우선 탐색이라고 부르며, 시작 위치에서 가까운 노드부터 우선적으로 탐색하는 알고리즘이다.\n  BFS는 큐 자료구조를 이용하며, 구체적인 동작 과정은 아래와 같다.\n   탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복함.     그래프를 준비하고, 시작 노드는 1로 BFS를 시작한다. (번호가 낮은 인접 노드부터 방문)    시작 노드인 \u0026lsquo;1\u0026rsquo;을 큐에 삽입하고 방문 처리를 한다.    큐에서 노드 \u0026lsquo;1\u0026rsquo;을 꺼내 방문하지 않은 인접 노드 \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;8\u0026rsquo;을 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;2\u0026rsquo;를 꺼내 방문하지 않은 인접 노드 \u0026lsquo;7\u0026rsquo;을 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;3\u0026rsquo;을 꺼내 방문하지 않은 인접 노드 \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;를 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;8\u0026rsquo;을 꺼내고 방문하지 않은 인접 노드가 없으므로 무시한다.    큐에 남아있는 \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;을 꺼낸다.    이러한 과정을 반복하여 전체 노드의 탐색 순서는 다음과 같다.\n 1 2 3 8 7 4 5 6  BFS 소스코드 예제 (Python)  아래 소스는 노드를 2차원 배열로 생성하여 [0]은 비워두고, 인덱스 별로 배열로 인접 노드를 정의함. 예를들어, graph[1] = [2, 3, 8] 로 1번 노드에 인접한 2, 3 8로 구성된다.\n from collections import deque\r# BFS 함수 정의\rdef bfs(graph, start, visited):\r# 큐(Queue) 구현을 위해 deque 라이브러리 사용\rqueue = deque()\r# 시작 노드(1)를 큐에 넣고, 방문 처리\rqueue.append(start)\rvisited[start] = True\r# 큐가 빌 때까지 반복\rwhile queue :\r# 큐에서 하나의 원소를 뽑아 출력\rv = queue.popleft()\rprint(v, end=' ') # print()의 기본 옵션중 end=' '를 통해 개행하지 않고 옆으로 출력을 붙인다.\r# 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입\rfor i in graph[v]:\rif not visited[i] :\rqueue.append(i)\rvisited[i] = True\rpass\r# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)\rgraph = [\r[],\r[2, 3, 8],\r[1, 7],\r[1, 4, 5],\r[3, 5],\r[3, 4],\r[7],\r[2, 6, 8],\r[1, 7]\r]\r# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)\rvisited = [False] * 9\r# 정의된 BFS 함수 호출\rbfs(graph, 1, visited)\r 참고   파이썬(Python) 기초 print ( )문의 옵션 (sep , end , format , Escape )          ","description":"bfs 탐색 알고리즘.","id":116,"section":"blog","tags":["Algorithm"],"title":"너비 우선 탐색 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/search/bfs/bfs-algorithm/"},{"content":"I have worked A (\u0026lsquo;나는 A에서 일했었습니다\u0026rsquo;)  Eight years ago, I have worked in a buffet. I served foods and cleaned the rooms. (나는 8년전에 뷔페에서 일했습니다. 나는 음식을 제공하고 방을 청소했습니다.)\n really/quite tough (\u0026lsquo;정말/꽤 힘들다\u0026rsquo;)  it was really/quite tough but fun at the same time. (매우/꽤 힘들었지만, 동시에 재미있었습니다.)\n I worked with A (\u0026lsquo;나는 A와 함께 일했다\u0026rsquo;)  because I worked with my friends. (왜냐하면, 나의 친구들과 같이 일했기 때문이다)\n be 동사 + V-ing (\u0026lsquo;V 하는중이다\u0026rsquo;)  I am working right now. (나는 일하는 중이다.)\n  I was hanging out with my friends. (나는 친구들과 어울리고 있었다.)\n I met A (\u0026lsquo;나는 A를 만났다\u0026rsquo;)  I met good friends there. (\u0026lsquo;나는 그곳에서 좋은 친구들을 만났다\u0026rsquo;)\n I was A and [sub-topic] (나는 A 였고, [sub-topic] 이였습니다.)  I was a student and got a part-time job for weekends. (저는 학생이었고 주말에 아르바이트를했습니다.)\n  I was a child and liked to joke (저는 어렸었고, 장난을 좋아했습니다.)\n I worked there on weekends while I was a student and even after I graduated/after I got a full-time job.   저는 학생 시절 주말에 일했고 졸업 후에도 정규직을 얻은 후에도 그곳에서 일했습니다.)\n I first started working there when I was a student, but kept working on weekends even after I got a full-time job  학생 시절부터 일을 시작했는데 정규직을 잡은 후에도 주말에도 계속 일했습니다.)\n don’t enjoy going to buffets because of their low-quality food, but I like the lunch buffets of the family restaurants, like Outback or VIPs.   음식의 질이 낮기 때문에 뷔페에가는 것을 좋아하지 않지만 아웃백이나 VIP 같은 패밀리 레스토랑의 점심 뷔페는 좋아합니다.')\n Just because (\u0026lsquo;그냥\u0026rsquo;) because + 문장  because you are beautiful. (당신은 아름다우니까요.)\n because of + 단어/절  because of your money. (당신의 돈 때문에요.)\n Grammar Error: Eight years ago, I was worked 뷔페, serve and cleaned rooms. → Eight years ago, I have worked in a 돌잔치 buffet. I served steaks (foods) and cleaned the rooms.\rIt was so tough and fun → It was really/quite tough but fun (at the same time).\rIt was so tough, (that) I quit.\rbecause working with friends → because I worked with my friends.\rbe 동사 + V-ing (I am working right now. / I was hanging out with my friends.)\rI was + meet good friends → I met good friends there.\rI was a student and got a job to work on weekends. → I was a student and got a part-time job for weekends.\r→ I worked there on weekends while I was a student and even after I graduated/after I got a full-time job.\r→ I first started working there when I was a student, but kept working on weekends even after I got a full-time job (I became ~).\rI don’t enjoy buffet because of their food, but I like franchise restaurants’ lunch buffet, like Outback. → I don’t enjoy going to buffets because of their low-quality food, but I like the lunch buffets of the family restaurants, like Outback or VIPs.\r New expressions learned today: because + 문장 because you are beautiful. because of + 단어/절 because of your money.\rJust because. 그냥\rA: Why do you like skateboarding?\rB: Just because. It’s fun.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":117,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.07.01","uri":"https://offetuoso.github.io/blog/english/202107/20210701-english-speak/"},{"content":"백준 4673 Self Number Task description  문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n  양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n  예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.\n  33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...\r  n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.\n  생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다.\n 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97\r  10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.\n Condition   10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.   input  없음\n output 1\r3\r5\r7\r9\r20\r31\r42\r53\r64\r|\r| \u0026lt;-- a lot more numbers\r|\r9903\r9914\r9925\r9927\r9938\r9949\r9960\r9971\r9982\r9993\r Solution   1부터 10001까지 모든 숫자 조회 숫자를 문자로 바꿔 저장 no는 자기자신의 값 i로 세팅 숫자의 자리수 만큼 반복 자리수의 숫자를 no에 더해줌 생성된 d(n) 값을 self dict에 추가 1 ~ 10001 까지의 숫자중 dict에 없는 숫자만 출력   \rself = {} #dist 생성\rfor i in range(1, 10001) : # 1 ~ 10000 까지\rsNo = str(i)\t# 숫자를 문자열로 변경\rno = i # 자기 자신을 세팅하여, \u0026lt;mark\u0026gt;33\u0026lt;/mark\u0026gt; + 3 + 3 = 39 부분을 처리\rfor j in range(0,len(sNo)) :\t# 반복문으로 자리수 마다 no에 더해주며, 33 \u0026lt;mark\u0026gt;+ 3 + 3\u0026lt;/mark\u0026gt; = 39 부분을 처리\rno += int(sNo[j])\rself[no] = no # 생성된 값을 dist에 추가\rfor i in range(1, 10001) :\t# 1 ~ 10000까지 숫자중 if self.get(i) is None :\t# d(n)를 통하여 생성되지 않은 숫자를 찾음\rprint(i)\t# self number 출력\r TestCase  ","description":"백준 셀프 넘버","id":118,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 4673 셀프 넘버","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/self-number/"},{"content":"백준 8958 ox quiz Task description  \u0026ldquo;OOXXOXXOOO\u0026quot;와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.\n  \u0026ldquo;OOXXOXXOOO\u0026quot;의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.\n  OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.   input 5\rOOXXOXXOOO\rOOXXOOXXOO\rOXOXOXOXOXOXOX\rOOOOOOOOOO\rOOOOXOOOOXOOOOX\r output 10\r9\r7\r55\r30\r Solution   입력 받은 N 만큼 케이스를 입력받아 반복한다. 케이스를 입력받고 길이만큼 반복한다. 점수(score)와 더해줄 값(addition)을 0으로 초기화 한다. 케이스를 문자열로 변경하고 문자열 하나씩 슬라이스하여 str에 저장. str의 값을 비교하여 1. O인경우, addition을 1 증가시키고 score에 addition을 더해준다. 2. X인경우, addition을 0 으로 초기화 시킨다. 케이스의 마지막 str일때 score를 출력한다.   n = int(input()) # 입력받을 케이스 갯수\rfor i in range(n): # 입력받은 수 만큼 반복\rcase = input()\t# 케이스 입력받음 ex) OOXXOXXOOO\rscore = 0\t# 케이스의 점수\raddition = 0\t# 점수에 더해지는 값\rfor j in range(0,len(case)):\t# 케이스의 길이 만큼 len(OOXXOXXOOO)\rstr = case[j] # 케이스를 인덱스로 1개씩 순회\rif str == 'O' :\t# O인경우 addtion 1증가 score에 addtion 더함\raddition +=1\rscore += addition else : # X인경우 addtion 0으로 초기화\raddition = 0\rif j == len(case) -1 :\t# 케이스의 마지막 str인 경우 score 출력\rprint(score)\r TestCase 5\rOOXXOXXOOO\rOOXXOOXXOO\rOXOXOXOXOXOXOX\rOOOOOOOOOO\rOOOOXOOOOXOOOOX\r ","description":"백준 OX 퀴즈","id":119,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 8958 OX 퀴즈","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/ox-quiz/"},{"content":"PermCheck  Codility - Lesson4 - Counting Elements - PermCheck\n Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다.\n순열은 1부터 N까지의 각 요소를 한 번만 포함하는 시퀀스입니다. 예를 들어 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\rA [3] = 2\r  순열이지만 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\r  값 2가 없기 때문에 순열이 아닙니다.\n  목표는 배열 A가 순열인지 확인하는 것입니다.\n  배열 A가 주어지면 배열 A가 순열이면 1을 반환하고 그렇지 않으면 0을 반환합니다.\n예를 들어 다음과 같은 배열 A가 있습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\rA [3] = 2\r  함수는 1을 반환해야합니다. 주어진 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\r  함수는 0을 반환해야합니다.\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . def solution(A) N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수 입니다.   Solution   조건1 배열 A는 순열 [1 \u0026hellip; N] 배열 A를 오름 정렬한다 1. A.sort() 2. N = A[-1] ( A.sort()후 A[-1]은 배열의 최대값)    SUM(A)는 는 순열 A 배열의 합 B(비교대상) = N*(N+1)//2 (수열의 합 공식; 1 ~ N 까지의 합)    SUM(A) == B 는 배열의 합과 수열의 합 공식이 맞는지 비교 1. solution[9, 5, 7, 3, 2, 7, 3, 1, 10, 8] 의 경우 합이 55가 되며, B와 같다. 이를 해결하기 위해서 중복된 숫자를 제거\nA = list(set(A)) 2. set을 통해 중복제거 시 [1,1] 의 경우 문제가 생긴다. 중복제거후 [1],과 1*(1+1)//2 는 1로 통과가 되는 논리적 오류가 발생한다. 이를 해결하기 위해 중복 제거하기 전 A배열의 길이와 N값과 비교한다. 예를 들어, [1,2,3,4] 1부터 4까지의 수열이 있다면 길이와 마지막 숫자는 같을 수 밖에 없으므로 length = N   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\rlength = len(A) # 중복 제거하기 전 A배열의 길이\rA = list(set(A))\t# 중복제거\rA.sort()\t# 정렬\rN = A[-1]\t# A의 제일 큰 수\rB = N*(N+1)//2\t# 수열의 합의 공식\rif sum(A) == B and length == N : # 배열 A와 수열의 합이 공식이 같고, 중복 제거하기 전 A배열의 길이와 N의 값이 같은지 체크\rreturn 1\relse :\rreturn 0\rpass\r#solution([4,1,3,2])\r#solution([2,2,8])\r#solution([9, 5, 7, 3, 2, 7, 3, 1, 10, 8])\r#solution([1,1])\r  시간 복잡성 O(N) or O(N * log(N))\n TestCase #solution([4,1,3,2])\r#solution([2,2,8])\r#solution([9, 5, 7, 3, 2, 7, 3, 1, 10, 8]) \u0026lt;\u0026lt; 순열이 아닌경우\r#solution([1,1]) \u0026lt;\u0026lt; 순열이 아닌경우2 (중복제거 해도 문제)\r ","description":"PermCheck","id":120,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - PermCheck","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-check/"},{"content":"백준 2839 설탕배달 Task description  상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n  상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\n  상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)   input output    case input ouput     1 18 4   2 4 -1   3 6 2   4 9 3   5 11 3    Solution   5로 최대한 나눈다. 5로 나누어 몫이 0인경우, 0이 아닌경우로 나누어진다. 1. 5로 나누어 몫이 0인경우 5의 배수이므로 5로 나눈 값(division) 이 결과 5로 나누어 몫이 아닌경우 1. 5로 나눌수 없고(값이 0) 3으로 나누어 떨어지지 않는경우 -1 이 결과 2. 5로 나눈 몫을 3으로 나누어 몫이 0인 경우 5로 나눈 값(division)와 5로 나눈 몫을 3으로 나눈 값(quotient//3)을 더한 값이 결과 ; 3. 5로 나눈 몫을 3으로 나누어 몫이 0이 아닌경우 1~ 5로 나눈 값 까지 루프를 생성 1. 5로 나눈것을 1단계씩 되돌려, 3으로 나누어 몫이 0으로 나누어 떨어지는 값 찾으면, (division-i)+(quotient+(5*i)) 이 값 2. 끝까지 못찾았을때 -1이 결과   N = int(input())\rdivision = N//5 # 5로 나눈 값\rquotient = N%5 # 5로 나눈 몫\rresult = 0\rif quotient == 0 : # 5로 나누어 떨어지면 result = division # 5로 나눈 값이 결과\relse : # 5로 나누어 몫이 남는 경우\rif division == 0 and not N % 3 == 0 :\t# 5로 나눌수 없고(값이 0) 3으로 나누어 떨어지지 않는경우 -1 이 결과\rresult = -1\relif quotient%3 == 0 : # 5로 나눈 몫을 3으로 나누어 몫이 0인 경우 \u0026lt;mark\u0026gt;5로 나눈 값(division)와 5로 나눈 몫을 3으로 나눈 값(quotient//3)을 더한 값이 결과\rresult = division\rresult += quotient // 3\relse :\t# 5로 나눈 몫을 3으로 나누어 몫이 0이 아닌경우\rfor i in range(1, division+1) : # 1~ 5로 나눈 값 까지 루프\rif (quotient+(5*i)) %3 == 0 :\t# 5로 나눈것을 1단계씩 되돌려, 3으로 나누어 몫이 0으로 나누어 떨어지는 값 찾으면, (division-i)+(quotient+(5*i)) 이 값\rresult = (division-i) result += (quotient+(5*i)) // 3\rbreak\relse :\rif i == division :\t# 끝까지 못찾았을때 -1이 결과\rresult = -1\rbreak\rprint(result)\r TestCase 18 #4\r4 #-1\r6 #2\r9 #3\r11 #3\r ","description":"백준 설탕배달","id":121,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2839 설탕배달","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/sugar-delivery/"},{"content":"MaxCounter  Codility - Lesson4 - Counting Elements - MaxCounter\n Task description  처음에는 0으로 설정된 N 개의 카운터가 제공되며 두 가지 가능한 작업이 있습니다.\n  증가 (X) -카운터 X가 1 증가합니다. 최대 카운터 -모든 카운터는 모든 카운터의 최대 값으로 설정됩니다. M 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 이 배열은 연속 작업을 나타냅니다.\n  A [K] = X, 즉 1 ≤ X ≤ N이면 연산 K는 증가 (X), A [K] = N + 1이면 작업 K는 최대 카운터입니다. 예를 들어, 정수 N = 5이고 배열 A가 다음과 같은 경우 :\n  A [0] = 3 A [1] = 4 A [2] = 4 A [3] = 6 A [4] = 1 A [5] = 4 A [6] = 4\r  각 연속 작업 후 카운터 값은 다음과 같습니다.\n  (0, 0, 1, 0, 0) (0, 0, 1, 1, 0) (0, 0, 1, 2, 0) (2, 2, 2, 2, 2) (3, 2, 2 , 2, 2) (3, 2, 2, 3, 2) (3, 2, 2, 4, 2)\r  목표는 모든 작업 후 모든 카운터의 값을 계산하는 것입니다.\n  정수 N과 M 개의 정수로 구성된 비어 있지 않은 배열 A가 주어지면 카운터 값을 나타내는 정수 시퀀스를 반환합니다. 결과 배열은 정수 배열로 반환되어야합니다. 예를 들면 다음과 같습니다.\n  A [0] = 3 A [1] = 4 A [2] = 4 A [3] = 6 A [4] = 1 A [5] = 4 A [6] = 4\r  함수는 위에서 설명한대로 [3, 2, 2, 4, 2]를 반환해야합니다.\n Condition   def solution(N, A) 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. N + 1 ] 범위 내의 정수 입니다.   Solution  이번 문제 풀이의 핵심은 increase(X) 보다, max counter를 루프를 돌지 않고 해결하는가 였습니다. 카운트는 0부터 값을 세지만, max counter 이후에는 max counter 시점의 최대 카운트 값부터 다시 카운트를 세고, max counter 시점의 최대 카운트 값을 모든 배열에 적용 후 각각의 카운트 값(다시 카운트를 센 카운트 값)을 더해주면 루프 없이 해결할 수 있습니다.\n   count라는 딕셔너리를 생성 배열 A를 루프로 선회하며, 값은 X (A[K])    increase(X) 기능 (1 \u0026lt;= X \u0026lt;= N 일때) \u0026gt; - count에 키가 X인 딕셔너리가 없으면 0으로 생성 \u0026gt; - count1증가 \u0026gt; - max_count(현재 최대 카운트) 값 구함    1 \u0026lt;= X \u0026lt;= N 아닌 ( N+1 == X) 경우 \u0026gt; - max counter 실행시 최대 카운트 세팅 \u0026gt; - 모든 count 값 삭제 \u0026gt; - 현재 최대 카운트 값 0으로 초기화    N개의 요소를 가지는 결과 배열을 max_value(max counter 실행시 최대 카운트) 값으로 생성 count 딕셔너리로 루프 \u0026gt; - max_value 부터 추가된 count의 값 결과 배열 result[X-1]에 세팅 # -1 은 인덱스 번호로 변경 0~ X-1   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(N, A):\rcount = {}\rmax_count = 0 # 현재 최대 카운트 값\rmax_value = 0 # max counter 이후에는 max counter 시점의 최대 카운트 값\rfor X in A :\rif 1 \u0026lt;= X \u0026lt;= N : # increase(X) 기능 (1 \u0026lt;= X \u0026lt;= N 일때)\rif count.get(X) is None :\t# count에 키가 X인 딕셔너리가 없으면 0으로 생성\rcount[X] = 0\rcount[X] += 1\t# count[X] 1증가\rmax_count = max(count[X], max_count) # 현재 최대 카운트 값 구함 else : # max counter 기능 (N+1 == X인 경우)\rmax_value += max_count\t# max counter 실행시 최대 카운트 세팅 count.clear()\t# 모든 count 값 삭제\rmax_count = 0\t# 현재 최대 카운트 값 0으로 초기화\rresult = [max_value] * N # N개의 요소를 가지는 결과 배열을 max_value(max counter 실행시 최대 카운트) 값으로 생성\rfor X, value in count.items() :\rresult[X-1] += value\t# max_value 부터 추가된 count[X]의 값 결과 배열 result[X-1]에 세팅 # -1 은 인덱스 번호로 변경 0~ X-1\rreturn result\r  시간 복잡성 O(N + M)\n TestCase solution(5,[3,4,4,6,1,4,4])\r ","description":"MaxCounter","id":122,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - MaxCounter","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/max-counter/"},{"content":"샤딩(Sharding) Database의 샤딩(Sharding)이란?  같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미.\n 샤딩은 수평 분할(Horizontal Partitioning)과 동일. 테이블의 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위함. application level에서도 가능하지만 database level에서도 가능.   수평 분할 (horizotal partitioning, Range Based Partitioning)  샤딩과 동일한 의미를 가지며 스키마를 다수의 복제본을 구성하고 각각의 샤드에 샤드키를 기준으로 데이터를 분리하는 것을 말한다. DBA가 데이터의 패턴과 저장공간을 잘 알고 샤드키를 선정하여 분할한다.\n    id Name Age     1 Bob 27   3 Alice 23   5 Dennis 20   7 Miller 24       id Name Age     2 Sago 29   4 Riley 30   6 Wilson 18   8 Brown 25    샤딩의 장점과 단점 장점   수평적 확장 horizontal scaling (=scaling out)이 가능하다: 서버의 하드웨어(RAM, CPU 등)를 업그레이드하는 수직적 확장과 다르게, 존재하는 stack에 machine을 추가하는 방식으로 능력을 향상시킬 수 있다. 쿼리 반응 속도를 빠르게 한다: 스캔 범위를 줄이기 때문!\n application을 신뢰할 수 있게 만든다: 서버 다운 등 생겼을 때, un-sharded 데이터베이스와 다르게 단일 shard에만 영향을 줄 확률이 높다. application이 일부라도 작동할 수 있도록 위험을 완화시켜준다.   단점   잘못 사용했을 때 risk(데이터 손상, 유실 등)가 크다. 데이터가 한 쪽 shards에 쏠려 sharding이 무의미 해질 수 있다. 한 번 쪼개게 되면, 다시 un-sharded 구조로 돌리기 어렵다. 모든 데이터베이스 엔진에서 natively support 되지 않는다.   샤딩시 고려사항   데이터 재분배   샤딩을 진행 한 DB의 물리적인 용량한계와 성능한계가 왔을 경우 적절하게 shard수를 scale-up 작업을 늘릴 수 있도록 설계해야한다. (확장고려)    샤딩으로부터 데이터 조인   샤딩된 데이터베이스간에 조인이 불가능하기 때문에 어느정도의 데이터 중복은 감안해야 한다.    파티셔닝 잘 구현하기   샤딩의 기준이되는 샤드키를 잘 정하거나 hash의 경우 함수를 잘 선택해야 한다.    샤드된 DBMS들의 트랜잭션 문제   XA와 같은 Global Transaction을 사용하면 샤딩된 데이터베이스간에 트랜잭션이 가능하나 성능저하의 문제가 있다.    Global Unique Key   샤딩에 경우 DBMS에서 제공하는 auto-increment를 사용하면 key가 중복될 가능성이 있기 때문에 application 레벨에서 key 생성을 담당해야 한다.    데이터 축소   Table 단위를 가능한 작게 만들자.   샤딩(Sharding) 구성시 고려할 문제   샤딩 알고리즘 : 정수값 등으로 샤딩을 처리할 때 데이터의 비율 고려 샤딩 데이터 조회 : 분산된 Database에서 Data를 어떻게 읽을 것인가 데이터 재분배 : 서비스 정지 없이 데이터베이스 스키마 및 서버 설계 필요 샤딩 조인 : 역정규화를 어느정도 감수해야 함   샤딩(Sharding) 방법  Shard Key를 어떻게 정의하느냐에 따라 데이터를 분산시키는 방법이 결정됩니다.\n range-based sharding  주어진 value의 범위를 기반으로 데이터를 나누는 샤딩 방법입니다. 예를 들어 연도 컬럼을 이용하여 데이터를 나눌수 있습니다. 이 방식을 이용하면 몇몇 개의 shard를 만들고 범위에 연도에 따라 데이터를 저장할 수 있습니다.\n    hiredate Name Age     1981 Bob 27   1982 Alice 23   1983 Dennis 20   1985 Miller 24       hiredate Name Age     2001 Sago 29   2005 Riley 30   2007 Wilson 18   2009 Brown 25       hiredate Name Age     2011 Oh 32   2012 Kim 33   2017 Park 24   2021 Lee 42    장점  가장 큰 장점은 실행이 비교적 간단하다는 것이다. 모든 shard들은 다른 데이터를 가지고 있고, original 데이터베이스 뿐 아니라 서로가 똑같은 스키마를 가지게 된다. application code는 그저 데이터가 어떤 범위인지 읽고 그에 상응하는 shard에 쓰면 된다.\n 단점  반면, 데이터베이스를 골고루 분배하지는 못하기 때문에 앞서 말한 데이터베이스 hotspots가 생길 수 있다. 위 그림 상으로는 모든 shard들이 같은 양의 데이터를 가지고 있지만, 특정 데이터가 다른 데이터에 비해 더 많이 찾아질 수 있기 때문에 읽는 횟수가 불균형할 수 있다.\n hash based sharding  다른 말로 Key Based Sharding, modulus-based sharding이라고도 불린다. 키와 같은 값을 해쉬함수(Hash)에 넣어 나오는 값으로 서버를 지정하는 방식\n  hash 함수는 고객 이메일과 같은 데이터 조각을 Input으로 받아, hash value라는 완전히 다른 형태의 value를 Ouput으로 내보낸다. sharding의 관점에서 봤을 때 hash value는 들어오는 데이터가 저장될 shard를 결정하는 shard ID가 될 것이다.\n shard key  올바른 shard에 일관성 있는 방식으로 들어갈 수 있도록 entry를 위치시키기 위해, hash 함수에 들어가는 value들은 같은 column에서 나와야 한다. 이 colum을 shard key라고 부른다.\n   각 행을 위한 고유 식별자를 생성한다는 측면에서 shard keys는 primary keys(pk)와 비슷하다. 넓게 본다면, shard key는 정적이어야 하고 시간에 따라 바뀌어서는 안 된다. 그렇지 않으면 업데이트에 필요한 작업이 증가하고 퍼포먼스를 느리게할 수 있다.   단점  key based sharding이 많이 쓰이긴 하지만, 데이터베이스에 서버를 동적으로 추가하거나 제거할 때 어려울 수 있다. 서버를 추가할 때 각각의 서버는 그에 상응하는 hash value가 있어야 하고, 존재하는 많은 entry들은 맞는 hash value에 다시 매핑되고, 적합한 서버에 migrate 되어야 한다. 데이터를 rebalancing하는 것을 시작한다면 새로운 hash 함수 뿐 아니라 예전 hsah 함수도 유효하지 않게 된다. 결과적으로 migration을 하는 동안 애플리케이션은 새로운 데이터를 쓰지 못하고, 쉴 수밖에 없다.\n 장점  이 전략의 가장 큰 장점은 hotspots를 방지하기 위해 데이터를 골고루 분배할 수 있고, 알고리즘적으로 분배하기 때문에 range나 directory와 다르게 모든 데이터가 어디에 위치하는지 말해주는 map을 가질 필요가 없다.\n Directory Based Sharding  파티셔닝 매커니즘을 제공하는 추상화된 서비스 생성. 이 sharding을 실행하기 위해서는 반드시 어떤 shard가 어떤 데이터를 갖고 있는지를 추적할 수 있는 shard key를 사용하는 lookup table을 만들고 유지해야 한다.\n lookup table  간단히 말하면 특정 데이터를 찾을 수 있는(where specific data can be found) 정적인 정보를 갖고 있는 테이블이다.\n  Delivery Zone 열은 shard key로 정의된다. shard key로부터 온 데이터는 각각의 행이 어떤 shard에 쓰여져야 하는지를 lookup 테이블과 함께 쓰여진다. range based sharding과 비슷해 보이지만, 범위를 기준으로 shard key의 데이터를 내려주는 것과 다르게 각 키들은 각자 자신만의 특별한 shard에 들어가게 된다.\n 어떤 상황에서 쓸지  해당 방법은 shard key가 낮은 cardinality를 가질 때 좋은 선택이다. hash 함수를 거치지 않기 때문에 key based sharding과도 다르다. 그저 lookup table에서 key를 보고 어디에 데이터를 쓸지 결정하는 것 뿐이다.\n 장점  유연성(flexibility)이다. range based sharding은 범위에 국한되고, key based sharding은 만들고 난 뒤 바꾸기 매우 어려운 hash 함수에 국한된다. 반면 directory based sharding은 데이터를 쪼개기 위한 entry들은 어떤 시스템이나 알고리즘에 상관 없이 entry를 할당할 수 있도록 해준다. 동적으로 shard를 추가하는 것도 비교적 쉽다.\n 단점  반면 쿼리하거나 write하기 전에 lookup table에 연결이 필요하기 때문에, application 퍼포먼스에 안 좋은 영향(detrimental impact)을 줄 수 있다. 게다가 lookup table은 실패 지점이 될 수 있다. lookup table이 손상되면 데이터를 새로 쓰거나 존재하는 데이터에 접근하는 것에 영향을 줄 수 있기 때문이다.\n 참조   MySQL Shard 데이터 재분배 Database sharding이란? Database의 샤딩(Sharding)이란? 파티셔닝의 정의와 종류 그리고 샤딩   ","description":"샤딩 ","id":123,"section":"blog","tags":["Database","Sharding","manage"],"title":"샤딩(Sharding)","uri":"https://offetuoso.github.io/blog/develop/database/tech/sharding/"},{"content":"AWS RDS RDS 서비스 생성  AWS Management Console에서 RDS 접속\n RDS 데이터베이스 인스턴스 생성  RDS에 MySQL 인스턴스를 생성한다.\n  데이터베이스 생성 클릭\n  데이터베이스 생성\n 표준 생성 원하는 데이터베이스 선택    Mysql 버전 선택과 템플릿 설정\n Mysql Community Mysql 버전 선택 - MySQL 5.7.22 템플릿 선택 -    DB 인스턴스 설정\n 인스턴스명 추가 DB에 접근할 계정 정보 입력    DB 인스턴스 크기\n  DB 인스턴스 크기\n 스토리지 자동조정 해제 - 체크 해두면 자동 스토리지 증설로 인한 요금부과가 될 수 있습니다.    연결 설정\n 추가 연결 구성 클릭후 펼치기    외부 연결을 위한 퍼블릭 액세스 수정 - 예    데이터베이스 생성\n  생성된 데이터베이스 인스턴스 확인  파라미터 그룹 추가  데이터베이스의 문자 인코딩 관련 파라미터를 UTF-8로 설정을 한다.\n  왼쪽 메뉴 파라미터 그룹 - 파라미터 그룹 생성\n  파라미터 그룹 생성\n 생성한 MySQL 버전을 선택 - 잘못 선택되면 파라미터 그룹 선택 창에서 보이지 않음 파라미터 정보 추가    생성된 파라미터 그룹명 클릭\n  파라미터 인코딩 수정\n cha 검색    1.1. utf8 선택 가능한 것들 모두 수정\n  col 검색    2.1. utf8 선택 가능한 것들 모두 수정\n  생성된 데이터베이스 인스턴스 수정\n  생성한 파라미터 그룹 선택\n  데이터베이스 인스턴스 수정\n 수정 예약 - 즉시 적용    수정중\n 보안 설정 (인바운스)  외부에서 접속이 안되는 경우 확인 해봐야 할것\n 연결 - 퍼블릭액세스 (예) 보안 - 인바운스 규칙    데이터베이스 - 인스턴스 - 수정\n  인바운스 default 클릭\n  보안그룹 클릭\n  인바운스 규칙 편집\n  인바운스 규칙 저장\n DBeaver 연결  연결 생성\n  Server 정보 추가\n   Server Host는 생성한 RDS의 엔드포인트 입력   RDS 왼쪽 메뉴 데이터베이스 - 인스턴스 - 연결및 보안    연결 완료\n End ","description":"AWS RDS를 이용한 Mysql","id":124,"section":"blog","tags":["AWS","RDS","MySQL"],"title":"AWS RDS에 MySQL 인스턴스 생성 후 연결","uri":"https://offetuoso.github.io/blog/develop/database/mysql/aws-rds-mysql/"},{"content":"FrogRiverOne  Codility - Lesson4 - Counting Elements - FrogRiverOne\n Task description  은 개구리가 강 건너편으로 가고 싶어합니다. 개구리는 처음에 강의 한 둑 (위치 0)에 있으며 반대쪽 둑 (위치 X + 1)에 도달하려고합니다. 잎은 나무에서 강 표면으로 떨어집니다.\n  엽을 나타내는 N 개의 정수로 구성된 배열 A가 제공됩니다. A[K]는 초 단위로 측정 된 시간 K에서 한 잎이 떨어지는 위치를 나타냅니다.\n  는 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 찾는 것입니다. 개구리는 잎이 1에서 X까지 강 건너 모든 위치에 나타날 때만 건널 수 있습니다 (즉, 1에서 X까지의 모든 위치가 잎으로 덮여있는 가장 빠른 순간을 찾고 싶습니다). 강의 흐름 속도가 무시할 정도로 작다고 가정 할 수 있습니다. 즉, 잎이 강에 떨어지면 위치가 바뀌지 않습니다.\n  예를 들어, 다음과 같은 정수 X = 5 및 배열 A가 제공됩니다.\n  A [0] = 1\rA [1] = 3\rA [2] = 1\rA [3] = 4\rA [4] = 2\rA [5] = 3\rA [6] = 5\rA [7] = 4\r  번째 6에서는 잎이 위치 5로 떨어집니다. 이것은 잎이 강 건너 모든 위치에 나타나는 가장 빠른 시간입니다.\n  N 개의 정수와 X로 구성된 비어 있지 않은 배열 A가 주어지면 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 반환합니다. 개구리가 강 반대편으로 점프 할 수없는 경우 함수는 −1을 반환해야합니다.\n  예를 들어, 주어진 X = 5이고 배열 A는 다음과 같습니다.\n  A [0] = 1\rA [1] = 3\rA [2] = 1\rA [3] = 4\rA [4] = 2\rA [5] = 3\rA [6] = 5\rA [7] = 4\r  함수는 위에서 설명한대로 6을 반환해야합니다.\n Condition   def solution(X, A) 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . N 및 X는 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. X ] 범위 내의 정수 입니다.   Solution   total = sum(range(X+1)) chked = [None for i in range(X)] # 체크 배열을 None으로 초기화 하여 생성 루프로 A를 순회 if( chked[A[i]-1] == None) : #체크 배열에 값이 없는지 체크 4-1. chked[A[i]-1]에 A[i] 세팅 4-2. chk_sum에 A[i]을 합함 if total == chk_sum : #   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, A):\rtotal = sum(range(X+1))\t# 1~X 까지의 합을 생성\rchked = [None for i in range(X)] # 체크 배열을 None으로 초기화 하여 생성\rchk_sum = 0\rfor i in range(len(A)) :\rif( chked[A[i]-1] == None) : # 체크 배열에 값이 없는지 체크\rchked[A[i]-1] = A[i]\rchk_sum += A[i]\rif total == chk_sum : # total과 chk_sum같다면 모든 1~X까지 찾은 상태이므로 현재의 i를 반환\rreturn i\rif total != chk_sum :\t# total과 chk_sum 다르다면 1~X까지의 찾은 숫자중에 나오지 않은 수가 있는것 return -1\r  시간 복잡성 O(N)\n TestCase solution(5, [1,3,1,4,2,3,5,4])\r ","description":"FrogRiverOne","id":125,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - FrogRiverOne","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/frog-river-one/"},{"content":"Tape Equilibrium  Codility - Lesson3 - Time Complexity - TapeEquilibrium\n Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 0 \u0026lt;P \u0026lt;N 인 정수 P는이 배열 A를 두 부분으로 분할합니다 (A [0], A [1], \u0026hellip;, A [P − 1] 및 A [P], A [ P + 1], \u0026hellip;, A [N-1]) 분할 된 두 부분의 차이는 다음의 값입니다. | (A [0] + A [1] + \u0026hellip; + A [P − 1]) − (A [P] + A [P + 1] + .. . + A [N − 1]) | 즉, 첫 번째 부분의 합과 두 번째 부분의 합 사이의 절대 차이입니다. 달성 할 수있는 최소 차이를 반환합니다.\n  예를 들어, 다음과 같은 배열 A가 제공됩니다.\n  A [0] = 3\rA [1] = 1\rA [2] = 2\rA [3] = 4\rA [4] = 3\r  이 테이프들을 4곳으로 나눌 수 있습니다.\n   P = 1, 차이 = | 3 − 10 | = 7 # A[0] ///// A[1] A[2] A[3] A[4] P = 2, 차이 = | 4 − 9 | = 5 # A[0] A[1] ///// A[2] A[3] A[4] P = 3, 차이 = | 6 − 7 | = 1 # A[0] A[1] A[2] ///// A[3] A[4] P = 4, 차이 = | 10 − 3 | = 7 # A[0] A[1] A[2] A[3] ///// A[4]    N 정수의 비어 있지 않은 배열 A가 주어지면 달성 할 수있는 최소 차이를 반환합니다.\n  A [0] = 3\rA [1] = 1\rA [2] = 2\rA [3] = 4\rA [4] = 3\r  함수는 위에서 설명한대로 1을 반환해야합니다.\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오. N은 [ 2 .. 100,000 ] 범위 내의 정수 이고; 배열 A의 각 요소는 [ -1,000 .. 1,000 ] 범위 내의 정수 입니다.   Solution 시도 1  루프를 1번만 사용했지만, sum() 함수를 루프 안에서 처리 했더니 O(N * N)의 시간 복잡도가 나오게 되었다.\n def solution(A):\rminimum = 99999\rfirst = 0;\rfor i in range(0,len(A)-1) :\rfirst += A[i]\rminimum = min(minimum, abs(first-(sum(A)-first)))\rreturn minimum\r  시간 복잡성 O(N * N)\n 시도 2 # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\rminimum = 99999 # 가작작은 차이 값\rfirst = 0; # 첫번째 테이프 그룹\rtotal = sum(A) # A배열 전체의 합\rfor i in range(0,len(A)-1) :\rfirst += A[i] # A[0]~A[i]까지의 합\rsecond = total - first #first를 제외한 나머지 테이프의 합\rminimum = min(minimum, abs(first - second)) #첫번째 그룹의 합과 두번째 그룹의 합의 차이중 가장작은것\rreturn minimum\r  시간 복잡성 O(N)\n TestCase solution([3,1,2,4,3])\r ","description":"Tape Equilibrium","id":126,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - TapeEquilibrium","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/tape-equilibrium/"},{"content":"Perm Missing Elem  Codility - Lesson3 - Time Complexity - PermMissingElem\n Task description  배열 A는 1 ~ N+1의 범위의 정수를 담고 있는 배열이며 1 ~ N+1의 정수중 1개의 숫자(요소)가 빠져있다.\n  예를 들면 다음과 같습니다.\n  A[0] = 2\rA[1] = 3\rA[2] = 1\rA[3] = 5\r  1~5까지의 숫자중 4가 빠져 있기 때문에 4를 반환\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오. N은 [ 0 .. 100,000 ] 범위 내의 정수입니다. A의 요소는 모두 구별됩니다. 배열 A의 각 요소는 [1 .. (N + 1)] 범위 내의 정수입니다.   Solution   N은 배열의 길이+1 (인덱스가 0부터 시작하기 때문에 +1) Sum(range(N+1)) - Sum(A) (1 ~ N+1 까지의 합) - (배열의 요소의 합) = 1 부터 N+1 까지의 숫자중 빠진 수   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, Y, D):\rN = len(A)+1\rreturn sum (range(N+1)) - sum(A)\rpass\r  시간 복잡성 O(N) or O(N * log(N))\n TestCase  ","description":"PermMissingElem","id":127,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - PermMissingElem","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-missing-elem/"},{"content":"Frog Jmp  Codility - Lesson3 - Time Complexity - Frog Jmp\n Task description  세 개의 정수 X, Y, D를 입력받는 함수를 작성합니다.\n X는 개구리의 위치 Y는 개구리의 목표 위치 Y는 개구리의 이동거리 위치 X에서 D씩 최소의 이동을 하여 목표를 Y에 도달하거나 넘어가기 위하여 이동하는 최소 횟수 반환    예를 들면 다음과 같습니다.\n  X = 10\rY = 85\rD = 30\r  개구리는 다음과 같이 위치하므로 함수는 3을 반환해야합니다.\n  첫 번째 점프 후 위치 10 + 30 = 40\r두 번째 점프 후 위치 10 + 30 + 30 = 70\r세 번째 점프 후 위치 10 + 30 + 30 + 30 = 100\r Condition   def solution(X, Y, D) X, Y 및 D는 [ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 . X ≤ Y. 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 .   Solution   Y == X 이 경우 개구리가 뛸 필요가 없기 때문에 0을 반환 (이 테스트 케이스를 생각하지 못해서 틀렸었다.)    Y-X = (목표위치 - 시작위치 =남은 거리) (Y-X) % D == 0 (\u0026ldquo;남은 거리 // D가 0으로 떨어지는지 나머지가 있는지 조건\u0026rdquo;) True(나머지 0) : (Y-X) // D False(나머지 0아님) : ((Y-X) // D) + 1   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, Y, D):\rif (Y == X) :\rreturn 0\rreturn (Y-X) % D == 0 and (Y-X) // D or ((Y-X) // D) + 1 pass\r  시간 복잡성 O(1)\n TestCase solution(10, 75, 30)\rsolution(2, 2, 1)\rsolution(1, 101, 10)\r ","description":"Frog Jmp","id":128,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Frog Jmp","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-frog-jmp/"},{"content":"RESTful API - Docker의 Mysql과 Mybatis 연동 Docker  Docker에 Mysql을 올리는 것은 저번 포스팅에서 진행하였기 때문에 도커에 Mysql 올리기 링크를 남기고 다음부터 진행합니다.\n  지난 포스트에서 생성한 Docker의 Mysql 컨테이너를 실행\n   docker ps -a (\u0026ldquo;컨테이너 조회\u0026rdquo;)    docker start (\u0026ldquo;컨테이너 시작\u0026rdquo;)  docker restart (\u0026ldquo;컨테이너에 재시작하기\u0026rdquo;) docker stop (\u0026ldquo;컨테이너에 종료하기\u0026rdquo;) docker attach (\u0026ldquo;현재 실행중인 컨테이너에 접속하기\u0026rdquo;)      sudo docker exec -it /bin/bash (\u0026ldquo;컨테이너의 CLI 접속\u0026rdquo;)   PS C:\\WINDOWS\\system32\u0026gt; docker ps -a\rCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\r4b6fb99160bf mysql:5.6 \u0026quot;docker-entrypoint.s…\u0026quot; 9 days ago Exited (255) 2 days ago 0.0.0.0:9876-\u0026gt;3306/tcp, :::9876-\u0026gt;3306/tcp test_mysql\rPS C:\\WINDOWS\\system32\u0026gt; docker start test_mysql\rtest_mysql\rPS C:\\WINDOWS\\system32\u0026gt; sudo docker exec -it test_mysql /bin/bash\r DBeaver 연결 및 테이블 생성  지난 포스트 Mysql DBeaver 설치 참조\n  UserProfile table 생성\n -- test.UserProfile definition\rCREATE TABLE `UserProfile` (\r`id` varchar(64) NOT NULL DEFAULT '',\r`name` varchar(64) DEFAULT NULL,\r`phone` varchar(64) DEFAULT NULL,\r`address` varchar(256) DEFAULT NULL,\rPRIMARY KEY (`id`)\r) ENGINE=InnoDB DEFAULT CHARSET=latin1;\r Dependency 추가 Dependency란 ?  자바 프로젝트 관리 도구인 아파치 메이븐의 XML형태의 라이브러리(의존성) 정의이며, Spring에서 Pom.xml에 추가하는 것을 의존성 주입이라 하며, Pom.xml에 xml 형식으로 추가하면 Maven Repositoy에서 라이브러리 파일을 자동으로 받아준다.\n pom.xml에 MysqlJ Dependency 추가  pom.xml은 /demo/pom.xml 프로젝트 최상단에서 찾아볼수 있습니다. SpringBoot에 Mysql과 Mybatis를 추가하기 위하여 pom.xml에 해당 dependency를 추가할 것입니다.\n  pom.xml은 아래와 같은 구조로 되어있으며, dependencies 밑의 dependency들 처럼 mysqlj와 mybatis를 추가하면 됩니다.\n Maven Repositiry  dependency를 추가하기 위하여 Maven Repositiry를 접속합니다.  MysqlJ (Mysql Connector for Java)  mysql connector를 받기 위하여 mysql j 를 검색합니다. mysqlj는 Mysql을 위한 JDBC 입니다.\n  Maven dependency xml 소스를 복사합니다.\n  pom.xml에 붙여넣고\n  Mysql Connector의 버전을 제거합니다. Spring Boot에서는 자주 사용하는 라이브러리에 한해서 SpringBoot 버전과 가장 호환이 잘되는 버전으로 빌드를 해주는 기능이 있기 때문에 버전은 제거해둡니다. 버전을 남겨두면 버전에 따라 waring이 뜰 수 있습니다.\n pom.xml에 Mybatis Dependency 추가 Mybatis  mybatis를 검색하고 Mybatis Spring Boot Starter를 선택합니다. 마이바티스(MyBatis)는 자바 퍼시스턴스 프레임워크의 하나로 XML 서술자나 애너테이션(annotation)을 사용하여 저장 프로시저나 SQL 문으로 객체들을 연결시키는데 도움을 줍니다.\n  마찬가지로 Mybatis Maven dependency xml pom.xml에 붙여넣습니다.\n application.properties 설정  /demo/src/main/resources/application.properties 파일을 수정합니다.\n  application.properties 파일에 Mysql 접속 정보를 추가합니다.\n spring.datasource.url = jdbc:mysql://localhost:[port]/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;serverTimezone=Asia/Seoul\u0026amp;useSSL=false\rspring.datasource.username = [userId]\rspring.datasource.password = [password]\r  프로젝트 우클릭 \u0026gt; Maven \u0026gt; Update Poject를 통하여 추가한 라이브러리들을 받습니다.\n UserProfile 테이블 생성  기존에 만들었던 com.example.demo.model.UserProfile의 필드들을 토대로 UserProfile 테이블을 생성합니다.\n UserProfile.java package com.example.demo.model;\rpublic class UserProfile {\rprivate String id;\rprivate String name;\rprivate String phone;\rprivate String address;\rpublic UserProfile(String id, String name, String phone, String address) {\rsuper();\rthis.id = id;\rthis.name = name;\rthis.phone = phone;\rthis.address = address;\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getPhone() {\rreturn phone;\r}\rpublic void setPhone(String phone) {\rthis.phone = phone;\r}\rpublic String getAddress() {\rreturn address;\r}\rpublic void setAddress(String address) {\rthis.address = address;\r}\r}\r UserProfile 테이블 엔티티  Id를 키로 잡고 나머지  UserProfile 테이블 생성쿼리 CREATE TABLE `UserProfile` (\r`id` varchar(64) NOT NULL DEFAULT '',\r`name` varchar(64) DEFAULT NULL,\r`phone` varchar(64) DEFAULT NULL,\r`address` varchar(256) DEFAULT NULL,\rPRIMARY KEY (`id`)\r) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r Mapper 생성 Mapper  Mybatis 매핑XML에 기재된 SQL을 호출하기 위한 인터페이스입니다. 스프링부트, mybatis 3.0이상에서는 Mapper를 통하여 SqlSession을 등록을 생략하고, DAO 인터페이스와 인터페이스 구현을 하지 않고 바로 SQL을 호출 할 수 있습니다. @mapper 어노테이션을 이용해 메서드명과 xml 파일의 id를 매핑시켜 편리하게 사용 할 수 있습니다.\n UserProfileMapper.java 파일 생성  /demo/src/main/java/com/example/demo/mapper 패키지를 생성합니다.\n UserProfileMapper  interface로 UserProfileMapper를 생성하고 @Mapper를 붙여서 스프링에서 Mapper로 인식하게 합니다.\n UserProfileMapper 작성 package com.example.demo.mapper;\rimport java.util.List;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.apache.ibatis.annotations.Param;\rimport com.example.demo.model.UserProfile;\r@Mapper\rpublic interface UserProfileMapper {\r}\r getUserProfile 작성   @select를 사용하여 select 쿼리를 정의합니다 Mybatis를 통하여 파라미터인 id와 ${id}를 매핑합니다.   \t@Select(\u0026quot;SELECT * FROM UserProfile WHERE id = ${id}\u0026quot;)\rUserProfile getUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r getUserProfileList 작성   @select를 사용하여 select 쿼리를 정의합니다.   \t@Select(\u0026quot;SELECT * FROM UserProfile\u0026quot;)\rList\u0026lt;UserProfile\u0026gt; getUserProfileList();\r putUserProfile 작성   @Insert를 사용하여 insert 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Insert(\u0026quot;INSERT INTO UserProfile VALUES(${id},${name},${phone},${address})\u0026quot;) int putUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r postUserProfile 작성   @Update를 사용하여 update 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Update(\u0026quot;UPDATE UserProfile SET name = ${name}, phone = ${phone}, address = ${address} WHERE id = ${id})\u0026quot;) int postUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r deleteUserProfile 작성   @Delete를 사용하여 delete 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Delete(\u0026quot;DELETE UserProfile WHERE id = ${id}\u0026quot;)\rint deleteUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r UserProfileMapper.java package com.example.demo.mapper;\rimport java.util.List;\rimport org.apache.ibatis.annotations.Insert;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.apache.ibatis.annotations.Param;\rimport org.apache.ibatis.annotations.Select;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport com.example.demo.model.UserProfile;\r@Mapper\rpublic interface UserProfileMapper {\r@Select(\u0026quot;SELECT * FROM UserProfile WHERE id = #{id}\u0026quot;)\rUserProfile getUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r@Select(\u0026quot;SELECT * FROM UserProfile\u0026quot;)\rList\u0026lt;UserProfile\u0026gt; getUserProfileList();\r@Insert(\u0026quot;INSERT INTO UserProfile VALUES(#{id},#{name},#{phone},#{address})\u0026quot;) int putUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r@Update(\u0026quot;UPDATE UserProfile SET name = #{name}, phone = #{phone}, address = #{address} WHERE id = #{id}\u0026quot;) int postUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r@Delete(\u0026quot;DELETE FROM UserProfile WHERE id = #{id}\u0026quot;)\rint deleteUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r}\r UserProfileController 수정  UserMap을 만들어 메모리상에서 사용자 정보를 GET, POST, PUT, DELETE 하던것을 새롭게 추가한 UserProfileMapper를 사용하여 GET, POST, PUT, DELETE 하게 수정합니다.\n  UserProfileMapper를 파라미터로 전달받아 내부 참조변수에 저장하는 생성자를 만들면, SpringBoot가 알아서 Mapper 클래스를 만들어 객체를 UserProfileController를 생성하면서 생성자로 전달합니다.\n  이후 전달된 UserProfileMapper 클래스 객체를 통해 메서드를 사용할 수 있습니다.\n UserProfileController.java package com.example.demo.controller;\rimport org.apache.catalina.User;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.web.bind.annotation.DeleteMapping;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport org.springframework.web.bind.annotation.PostMapping;\rimport org.springframework.web.bind.annotation.PutMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RequestParam;\rimport org.springframework.web.bind.annotation.RestController;\rimport com.example.demo.mapper.UserProfileMapper;\rimport com.example.demo.model.UserProfile;\rimport java.util.ArrayList;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport javax.annotation.PostConstruct;\r@RestController\rpublic class UserProfileController {\rprivate UserProfileMapper mapper;\rpublic UserProfileController(UserProfileMapper mapper) {\rthis.mapper = mapper;\r}\r@GetMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic UserProfile getUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\r//return userMap.get(id);\t//변경전\rreturn mapper.getUserProfile(id);\r}\r@GetMapping(\u0026quot;/users/all\u0026quot;)\rpublic List\u0026lt;UserProfile\u0026gt; getUserProfileList() {\r//return new ArrayList\u0026lt;UserProfile\u0026gt;(userMap.values()); //변경전\rreturn mapper.getUserProfileList();\r}\r@PutMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void putUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rint resultCnt = mapper.putUserProfile(id, name, phone, address);\r}\r@PostMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void postUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rint resultCnt = mapper.postUserProfile(id, name, phone, address);\r}\r@DeleteMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void deleteUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\rint resultCnt = mapper.deleteUserProfile(id);\r}\r}\r 테스트  제일 먼저 PUT 을 통해서 사용자 1건을 추가합니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  GET의 getUserProfile를 통해 사용자가 입력이 잘 되었는지 확인해 봅니다.\n  Mysql에 잘 저장되었는지 확인해 봅니다.\n  제일 먼저 POST를 통해서 입력한 사용자의 정보를 수정해 봅니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  Mysql에서 잘 수정되었는지 확인해 봅니다.\n  GET의 getUserProfileList를 통해 수정이된 내용을 확인해 봅니다.\n  DELETE를 통하여 추가한 사용자를 삭제합니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  GET의 getUserProfileList를 통해 삭제된 내용을 확인해 봅니다.\n  Mysql에서 잘 삭제되었는지 확인해 봅니다.\n End ","description":"레스트풀 API","id":129,"section":"blog","tags":["Restful","Api","Docker","Mysql","Mybatis"],"title":"RESTful API에 Docker Mysql 컨테이너와 Mybatis 연동","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-2/"},{"content":"Odd Occurrences In Array  Codility - Lesson2 - Array - Odd Occurrences In Array\n Task description  N개의 정수가 담긴 배열 A를 입력받습니다 배열에는 홀수 개의 요소가 포함됩니다. 배열의 각 요소는 짝을 이루지 않는 한 요소를 제외하고 동일한 값을 가진 다른 요소와 짝을 가지고 있습니다. 짝이 없는 요소를 찾으면 해결됩니다\n  예를 들어, 주어진 A 배열은 이렇습니다.\n  A [0] = 9 A [1] = 3 A [2] = 9\rA [3] = 3 A [4] = 9 A [5] = 7\rA [6] = 9\r   인덱스 0과 2에있는 요소의 값은 9입니다. 인덱스 1과 3에있는 요소의 값은 3이고, 인덱스 4와 6에있는 요소의 값은 9이고 인덱스 5의 요소는 값 7을 가지며 짝을 이루지 않습니다.\nCondition   N은 [1..1,000,000] 범위 내의 홀수 정수이고; 배열 A의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 . A의 값 중 하나를 제외하고 모두 짝수 번 발생합니다. 다음 가정에 대한 효율적인 알고리즘을 작성하십시오   Solution 1회차   A의 배열을 0부터 N까지 리스트를 조회하며 현재값 curr = A[i]를 기억해 두고 첫번째 요소 pop(0) 남은 A배열와 체크된 숫자 배열 B에 curr가 있는지 확인해서 없으면 짝이 없기 때문에 curr 값 리턴 아니라면 B배열에 curr 추가   def solution(A):\r# write your code in Python 3.6\rB = []\rfor i in range (0, len(A)) :\rcurr = A[0]\rA.pop(0)\rif curr not in A and curr not in B :\rreturn curr\rB.append(curr)\rpass\r  시간 복잡성 O (N ** 2)으로 n = 100,003, n = 999,999 시간 초과\n  for 안에서 in을 통해 다시 조회하는 것이 시간 복잡성을 늘린거 같다\n 2회차   A배열을 A.sort()를 사용해 asc 정렬 정렬을 하고 0 ~ len(A)까지의 반복문중 인덱스가 홀수면 값저장, 짝수면 홀수와 비교 마지막 인덱스가 홀수고 마지막 까지 짝이 없는 값이 없다면 마지막 값이 짝이 없는 값이므로 반환   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\r# write your code in Python 3.6\rA.sort()\rodd = 0\rfor i in range (0, len(A)) :\rif i % 2 == 0 :\rif i+1 != len(A) :\rodd = A[i]\relse :\rreturn A[i] else :\rif odd != A[i] : return odd pass\r  시간 복잡성 O(N) or O(N*log(N)) 하나의 for에서 처리를 해서 timeout에 걸리지 않았다.\n 다른 사람 풀이  풀이 방식이 비슷하나 A.sort()와 sorted(A)의 차이가 있다.\n sort와 sorted의 차이  따로 정리하며 포스팅 해야겠지만,\n list.sort()   list.sort()는 list 클래스의 메서드입니다. 실행 시 기본적으로 오름차순으로 리스트 객체 자체를 정렬하며 반환하는 값은 None입니다. 추가로 key와 reverse 파라미터를 조정하여 정렬기준을 변경할 수 있습니다.   \tlist.sort()\r sorted(list)   sorted 메서드는 list, tuple, string, dict, set 등 iterable 객체를 파라미터로 받아 정렬된 iterable를 반환합니다. sort 메서드처럼 key와 reverse파라미터를 조정해서 정렬 기준을 변경 할 수 있다.   \tlist1 = sorted(list)\r sort vs sorted?  데이터가 많으면 많을 수록 sorted는 새로운 객체를 생성해야하는 내부 처리가 있어서 sort보다 시간이 더 걸린다. 도긴 개긴이지만 sort 메서드가 미세하게 더 빠르다.\n  하지만 list가 아닌 iterable인 경우에서는 어쩔 수 없이 sorted를 사용해야 합니다.\n def test3(A):\rif len(A) == 1:\rreturn A[0]\rA = sorted(A)\rprint(A)\rfor i in range(0, len(A), 2):\rif i+1 == len(A):\rreturn A[i]\rif A[i] != A[i+1]:\rreturn A[i]\r 다른 사람 풀이2  시간 복잡성 O(N) or O(N*log(N)) lambda와 reduce() 메서드를 공부해 봐야겠다.\n 다른사람 코드 2\rdef solution(A):\rreturn reduce(lambda x,y: x^y, A)\r TestCase solution([9, 3, 9, 3, 9, 7, 9])\rsolution([9, 3, 9, 3, 9])\r ","description":"Odd Occurrences In Array","id":130,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Odd Occurrences In Array","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-odd-occurrences-in-array/"},{"content":"CyclicRotation  Codility - Lesson2 - Array - CyclicRotation\n Task description  N 개의 정수로 구성된 배열 A와 오른쪽으로 회전할 횟수 K가 제공됩니다. A의 각 요소가 오른쪽으로 K 번 이동합니다. N 개의 정수와 K로 구성된 배열 A가 주어지면 배열 A가 K 번 회전 된 배열을 반환합니다.\n  예를 들어, 주어진\n   A = [3, 8, 9, 7, 6] K = 3    함수는 [9, 7, 6, 3, 8]을 반환해야합니다. 세 가지 회전이 이루어졌습니다.\n  [3, 8, 9, 7, 6]-\u0026gt; [6, 3, 8, 9, 7]\r[6, 3, 8, 9, 7]-\u0026gt; [7, 6, 3, 8, 9]\r[7, 6, 3, 8, 9]-\u0026gt; [9, 7, 6, 3, 8]\r Condition   함수 작성 : class Solution {public int [] solution (int [] A, int K); } N 및 K는 [ 0 .. 100 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ -1,000 .. 1,000 ] 범위 내의 정수 입니다.   Solution # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A, K):\rN = len(A)\rfor value in A :\rif not (-1000 \u0026lt;= value \u0026lt;= 1000) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\rif not (0 \u0026lt;= N \u0026lt;= 100) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\relif not (0 \u0026lt;= K \u0026lt;= 100) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\relse :\rB = []\rfor i in range(0,N) :\rB.append(0) for i in range(0,N) :\rrotate = (i+K) % N\rB[rotate] = (A[i])\rA = B\rreturn A\rpass\r TestCase \r ","description":"Cyclic Rotation","id":131,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Cyclic Rotation","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-cyclic-rotation/"},{"content":"Mysql DBeaver 설치 DBeaver 다운로드  DBeaverinstall file 다운로드 운영체제에 맞는 DBeavr 인스톨파일을 다운받아 실행시킨다.   Mysql을 선택한다.   자신의 서버정보에 맞게 입력하면 Mysql을 사용할 수 있다.  ","description":"Mysql DBeaver 설치","id":132,"section":"blog","tags":["Mysql","Developer","DBeaver","Tools"],"title":"Mysql DBeaver 설치","uri":"https://offetuoso.github.io/blog/develop/database/mysql/mysql-dbeaver-install/"},{"content":"Mysql Developer 설치 SQL Developer 다운로드  SQL Developer 다운로드 운영체제에 맞는 SQL Developer를 다운받아 압축을 풀어 실행시킨다.  mysql-connector-java 설치  mysql connector j 다운로드 링크\n  Archives   Platform Independent를 선택하고 zip으로 받습니다.  Oracle Developer 설정  도구 \u0026gt; 환경설정 데이터베이스 \u0026gt; 타사JDBC드라이버 \u0026gt; 항목추가  신규 접속 생성  Mysql이 추가된것을 확인할 수 있다.   자신의 서버정보에 맞게 입력하면 Mysql Developer를 사용할 수 있다.  ","description":"Mysql Developer 설치","id":133,"section":"blog","tags":["Mysql","Developer","MysqlDeveloper","OracleDevelop","Tools"],"title":"Mysql Developer 설치","uri":"https://offetuoso.github.io/blog/develop/database/mysql/mysql-developer-install/"},{"content":"Maven error “Failure to transfer…” 문제 Failure to transfer com.google.guava:guava:jar:10.0.1 from https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempte from/to central (https://repo.maven.apache.org/maven2): The operation was cancelled.\r  https://repo.maven.apache.org/maven2에서 디펜던시를 전송하지 못하는 오류가 발생하였고, 로컬 저장소에 캐시되었습니다.\n 해결책 1   프로젝트 우클릭 -\u0026gt; Run as -\u0026gt; Maven Install 프로젝트 우클릭 -\u0026gt; Refresh 프로젝트 우클릭 -\u0026gt; Update Project (옵션 클릭 force update of snapshots/releases)   해결책 2   실행중인 IDE(이클립스, Sts) 종료 로컬 레퍼지토리 삭제\nC:\\Users{userNm}.m2\\repository   참조 https://stackoverflow.com/questions/5074063/maven-error-failure-to-transfer\n","description":"메이븐 에러","id":134,"section":"blog","tags":["Troubleshooting"],"title":"Maven Error - Failure to transfer..","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/spring/maven-error-repository/"},{"content":"SpringBoot를 이용한 RESTful API SpringBoot  스프링 프레임워크 기반 프로젝트를 복잡한 설정없이 쉽고 빠르게 만들어주는 라이브러리입니다. 사용자가 일일이 모든 설정을 하지 않아도 자주 사용되는 기본설정을 알아서 해줍니다.\n  Spring Boot 장점\n   라이브러리 관리의 자동화 라이브러리 버전 자동 관리 설정의 자동화 내장 Tomcat 독립적으로 실행 가능한 JAR   간단한 RESTful API 생성 Spring Starter Project로 프로젝트 생성  스프링STS4를 실행 하고, file \u0026gt; new \u0026gt; Spring Starter Project를 선택\n  서비스에 대한 설정을 할 수 있는 화면이 나오며 Demo라는 프로젝트명 그대로 \u0026lsquo;next\u0026rsquo; 진행   Spring Starter 구성 시 추가할 web \u0026gt; Spring Web Dependency를 추가   next를 눌러 진행하면, 스프링스타터의 서비스를 이용해서 방금전 입력한 항목들을 이용해 템플릿을 만들어 달라고 요청할 URL이며 URL을 호출하여, ZIP파일 형태로도 제공 받을수 있습니다. finish를 눌러 마무리합니다.   프로젝트 우클릭 \u0026gt; Run as \u0026gt; Spring Boot App을 눌러 실행   콘솔창으로 정상적으로 서비스가 올라가는 것을 볼 수 있습니다.   서비스될 Port가 :8080으로 설정된 것도 확인 가능합니다.   http://localhost:8080/ 로 접속해 보면 매핑되는 URI가 없기 때문에 오류 페이지대신 Whitelabel Error Page 페이지가 보이게 됩니다.  RESTful API 작성 Model - UserProfile.java 생성  com.example.demo 밑에 com.example.demo.model 패키지를 생성하고 그 안에 UserProfile이라는 VO 객체(Value Obeject)를 생성   String 형의 id, name, phone, address를 Private로 추가   생성자는 에디터 우클릭 \u0026gt; source \u0026gt; generate constructor using fields 를 사용하여 자동 생성   소스에 생성자가 추가된 것을 확인   private로 생성된 field들에 접근하기 위하여, getter와 setter 또한 generator를 이용하여 생성   소스에 getter, setter가 추가된 것을 확인  package com.example.demo.model;\rpublic class UserProfile {\rprivate String id;\rprivate String name;\rprivate String phone;\rprivate String address;\rpublic UserProfile(String id, String name, String phone, String address) {\rsuper();\rthis.id = id;\rthis.name = name;\rthis.phone = phone;\rthis.address = address;\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getPhone() {\rreturn phone;\r}\rpublic void setPhone(String phone) {\rthis.phone = phone;\r}\rpublic String getAddress() {\rreturn address;\r}\rpublic void setAddress(String address) {\rthis.address = address;\r}\r}\r Controller - UserProfileController.java 생성  Spring에서 컨트롤러를 지정해주기 위한 어노테이션은 @Controller와 @RestController가 있습니다. 하지만 여기서는 @RestController를 추가합니다.\n  UserMap을 만들어 메모리상에서 사용자 정보를 GET, POST, PUT, DELETE 할 수 있게 세팅합니다.  package com.example.demo.controller;\rimport org.apache.catalina.User;\rimport org.springframework.web.bind.annotation.RequestParam;\rimport org.springframework.web.bind.annotation.RestController;\rimport com.example.demo.model.UserProfile;\rimport java.util.ArrayList;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport javax.annotation.PostConstruct;\r@RestController\rpublic class UserProfileController {\rprivate Map\u0026lt;String, UserProfile\u0026gt; userMap;\r@PostConstruct\rpublic void init() {\ruserMap = new HashMap\u0026lt;String, UserProfile\u0026gt;();\ruserMap.put(\u0026quot;1\u0026quot;, new UserProfile(\u0026quot;1\u0026quot;, \u0026quot;홍길동\u0026quot;, \u0026quot;111-1111\u0026quot;, \u0026quot;서울시 영등포구 신길1동\u0026quot;));\ruserMap.put(\u0026quot;2\u0026quot;, new UserProfile(\u0026quot;2\u0026quot;, \u0026quot;김근로\u0026quot;, \u0026quot;111-1112\u0026quot;, \u0026quot;서울시 영등포구 신길2동\u0026quot;));\ruserMap.put(\u0026quot;3\u0026quot;, new UserProfile(\u0026quot;3\u0026quot;, \u0026quot;박영업\u0026quot;, \u0026quot;111-1113\u0026quot;, \u0026quot;서울시 영등포구 신길3동\u0026quot;));\r}\r}\r  아래 표와 같은 기능을 Controller에서 간단히 작성해 보려합니다.\n    Resource GET(read) PUT(create) POST(update) DELETE(delete)     /users 사용자 전체 조회 - - -   /users/{id} {id}사용자 조회 {id} 신규 사용자 추가 {id} 사용자 수정 {id} 사용자 삭제    GET  GET : /users/1 과 GET : /users/all 을 구현\n   @PathVariable은 String3에서 추가된 기능으로 URL에서 {특정값}을 변수로 받아 올 수 있다.    @GetMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic UserProfile getUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\rreturn userMap.get(id);\r}\r@GetMapping(\u0026quot;/users/all\u0026quot;)\rpublic List\u0026lt;UserProfile\u0026gt; getUserProfile() {\rreturn new ArrayList\u0026lt;UserProfile\u0026gt;(userMap.values());\r}\r  REST API Client Postman을 이용한 테스트 GET : http://localhost:8080/users/1 GET : http://localhost:8080/users/all  PUT  PUT : /users/1?name=\u0026amp;phone=\u0026amp;address=\n   @PathVariable은 String3에서 추가된 기능으로 URL에서 {특정값}을 변수로 받아 올 수 있다. @RequestParam 또한 @PathVariable과 비슷하지만, request의 parameter에서 가져오는 것이다. ?name=홍길동 과 같은 쿼리스트링을 파라미터로 파싱해준다.    @PutMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void putUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rUserProfile userProfile = new UserProfile(id,name,phone,address);\ruserMap.put(id,userProfile);\r}\r  PUT : http://localhost:8080/users/4?name=정운영\u0026amp;phone=111-4444\u0026amp;address=서울시 영등포구 신길4동   GET : http://localhost:8080/users/4  POST  POST : /users/1?name=\u0026amp;phone=\u0026amp;address=\n  @PostMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void postUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rUserProfile userProfile = userMap.get(id);\ruserProfile.setName(name);\ruserProfile.setPhone(phone);\ruserProfile.setAddress(address);\r}\r  POST : http://localhost:8080/users/1?name=첫번째\u0026amp;phone=010-1111\u0026amp;address=서울시 영등포구 영등포1동   GET : http://localhost:8080/users/1  DELETE  DELETE : /users/1\n  @DeleteMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void deleteUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\ruserMap.remove(id);\r}\r  DELETE : http://localhost:8080/users/1   GET : http://localhost:8080/users/all  참고   SpringBoot spring.io Dependency Annotation @Controller vs @RestController   ","description":"레스트풀 API","id":135,"section":"blog","tags":["Restful","Api"],"title":"SpringBoot를 이용한 RESTful API","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-1/"},{"content":"레스트풀 API(Restful Api) REST (Representational state transfer)  REST(Representational State Transfer)는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다. REST는 로이 필딩(Roy Fielding)의 2000년 박사학위 논문에서 소개 엄격한 의미로 REST는 네트워크 아키텍처 원리의 모음이다. 여기서 \u0026lsquo;네트워크 아키텍처 원리\u0026rsquo;란 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반을 일컫는다. 간단한 의미로는, 웹 상의 자료를 HTTP위에서 SOAP이나 쿠키를 통한 세션 트랙킹 같은 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스를 말한다.\n REST 구성  1.자원(RESOURCE) - URI 2.행위(Verb) - HTTP METHOD 3.표현(Representations)\n REST의 목표  REST의 목표는 성능, 확장 성, 단순성, 수정 가능성, 가시성, 이식성 및 안정성을 높이는 것. 이는 REST 아키텍처에 적용되는 제약 조건을 통해 달성됩니다.\n REST 아키텍처 원칙(아키텍처 스타일, 아키텍처의 제약 조건)  해당 6가지 원칙을 모두 만족한다면, REST하다 이야기 할 수 있습니다.\n   인터페이스 일관성 (using a uniform interface): URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.    무상태성(Stateless): 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.    캐시 가능(Cacheability): REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다.    클라이언트/서버 구조 (client–server architecture): REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.    계층화(Layered System): REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.    Code on demand (optional) - 클라이언트는 리소스에 대한 표현을 응답으로 받고 처리해야 하는데, 어떻게 처리해야 하는지에 대한 Code를 서버가 제공하는 것을 의미한다. Html에서의 javascript가 가장 대표적인 예이다. 하지만 서버에서 제공되는 코드를 실행해야 하기 때문에 보안 문제를 야기할 수 있습니다. (이 제약조건은 필수는 아님.)   REST가 필요한 이유   애플리케이션 분리 및 통합 다양한 클라이언트의 등장 최근의 서버 프로그램은 다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다. 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.   RESTful API ?  RESTful은 위의 REST 아키텍처의 원칙을 모두 만족하는 것을 의미한다. RESTful API란 REST라는 아키텍처 스타일과 원칙을 모두 만족하는 모두 만족하는 API라는 뜻이다.\n REST API 디자인   URL을 심플하고 직관적으로 만들자   REST API를 URL만 보고도, 직관적으로 이해할 수 있어야 한다 URL을 길게 만드는것 보다, 최대 2 depth 정도로 간단하게 만드는 것이 이해하기 편하다.     BAD   http://restapi.example.com/customerUsers\rhttp://restapi.example.com/sellerUsers\r   Good   http://restapi.example.com/users/customer\rhttp://restapi.example.com/users/seller\r  소문자를 사용한다.   도메인 주소명은 대소문자를 구분하지 않는다. 디렉터리 명 이하의 주소는 서버의 운영체제에 따라 다르다. 대소문자를 혼용하여 사용하는 주소는 권장되지 않는다.     BAD   http://restapi.example.com/users/customer/\r   Good   http://restapi.example.com/users/customer/get-adress\r  언더바를 대신 하이픈을 사용한다. 가급적 하이픈의 사용도 최소화하며, 정확한 의미나 표현을 위해 단어의 결합이 불가피한 경우에 사용한다.     Bad   http://restapi.example.com/users/customer/get_adress\r   Good   http://restapi.example.com/users/customer/get-adress\r  마지막에 슬래시를 포함하지 않는다.   슬래시는 계층을 구분하는 것으로, 마지막에는 사용하지 않는다.     Bad   http://restapi.example.com/users/customer/\r   Good   http://restapi.example.com/users/customer\r  행위는 포함하지 않는다.   행위(동사)는 URL대신 Method를 사용하여 전달한다.(GET, POST, PUT, DELETE 등)      Resource GET(read) PUT(create) POST(update) DELETE(delete)     /goods 상품목록 상품추가 - -   /goods/{id} {id}값 상품상세 - {id}값 상품 수정 {id}값 상품 삭제      Bad   POST : http://restapi.example.com/users/customer/delete-post/1\r   Good   DELETE : http://restapi.example.com/users/customer/post/1\r  가급적 명사를 사용하되, 제어 자원을 의미하는 경우 예외적으로 동사를 허용한다.     Bad   POST : http://restapi.example.com/users/customer/duplication\r   Good   POST : http://restapi.example.com/users/customer/duplicate\r  7.파일 확장자는 URI에 포함시키지 않는다.\n REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않습니다. Accept header를 사용하도록 한다.     Bad   GET : http://restapi.example.com/users/customer/profile.png\r   Good   GET http://restapi.example.com/users/customer/profile\rHTTP/1.1 Host: restapi.example.com Accept: image/jpg\r   오류 처리를 명확하게 해라.\r    HTTP 상태코드를 정하고(많아도 안좋음), 다른 개발자들을 위한 오류 메시지 정의, 상세 정보 링크 등을 넣어주면 도움이 된다.   참고   REST wiki   ","description":"레스트풀 API","id":136,"section":"blog","tags":["REST","RESTful","Api"],"title":"RESTFULL API (RESTful API)","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api/"},{"content":"도커에 Mysql 올리기 도커 버전 체크  cmd창 또는 Windows PowerShell을 싱행한다.  도커 초기화  일단 도커의 이미지/컨테이너들을 모두 지워주는 것 부터 시작하겠습니다.\n PS C:\\\u0026gt; sudo docker rm -f `sudo docker ps -a -q`\rPS C:\\\u0026gt; sudo docker rmi -f `sudo docker images`\r 도커 이미지 가져오기 (get Mysql Image for Docker)  Mysql의 경우 DockerHub에 있기 때문에, 쉽게 이미지를 받아 올 수 있습니다.\n DockerHub에서 mysql 이미지 받아오기   PS C:\\\u0026gt; docker pull mysql\rUsing default tag: latest\rlatest: Pulling from library/mysql\rDigest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969\rStatus: Image is up to date for mysql:latest\rdocker.io/library/mysql:latest\r   다운받은 도커 이미지 확인   PS C:\\\u0026gt; docker images\rREPOSITORY TAG IMAGE ID CREATED SIZE\rmysql latest c0cdc95609f1 13 days ago 556MB\rdocker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB\r Mysql 컨테이너 설정  sudo docker run -d -p 9876:3306 -e MYSQL_ROOT_PASSWORD= \u0026ndash;name test_mysql mysql:5.6\n PS C:\\\u0026gt; sudo docker run -d -p 9876:3306 -e MYSQL_ROOT_PASSWORD=passw0rd --name test_mysql mysql:5.6\r  docker run \u0026ndash;name mysql-test -e MYSQL_ROOT_PASSWORD= -d -p 3306:3306 mysql:5.7\n PS C:\\\u0026gt; docker run --name mysql-test -e MYSQL_ROOT_PASSWORD=passw0rd -d -p 3306:3306 mysql:5.7\rfb4e8d8a5dd23d2c2b8068b311105f28bd8bd97067e78a7f4779d7da5bb3a483\r docker 옵션   -d 는 컨테이너를 백그라운드에서 동작하는 어플리케이션으로 실행    -p 9876:3306 는 -p 옵션은 호스트와 컨테이너 간의 포트(port) 배포(publish)/바인드(bind)를 위해서 사용되는데요. 호스트(host) 컴퓨터에서 컨테이너에서 리스닝하고 있는 포트로 접속할 수 있도록 설정해줍니다. 위 커맨드는 컨테이너 내부에서 3306 포트로 리스닝하고 있는 HTTP 서버를 호스트 컴퓨터에서 9876 포트로 접속할 수 있도록 해줍니다.    -e 는 Docker 컨테이너의 환경변수를 설정하기 위해서는 -e 옵션을 사용합니다. 또한, -e 옵션을 사용하면 Dockerfile의 ENV 설정도 덮어써지게 됩니다. 아래 커맨드는 FOO 환경 변수를 bar로 세팅을 하고, 환경 변수를 출력하고 있습니다.    MYSQL_ROOT_PASSWORD=passw0rd는 mysql의 기본 비밀번호를 설정합니다.    \u0026ndash;name test_mysql은 Docker 컨테이너를 제어할 때 컨테이너 ID를 사용하면 읽거나 기억하기가 어려워서 불편하게 느껴집니다. 이럴 경우, \u0026ndash;name 옵션을 사용해서 컨테이너에 이름을 부여해주면 해당 test_mysql 이름으로 컨테이너를 식별할 수 있습니다.   생성된 Mysql 컨테이너 확인  docker ps -a 명령어 실행\n PS C:\\\u0026gt; docker ps -a\rCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\raf3dd622e753 mysql \u0026quot;docker-entrypoint.s…\u0026quot; 28 hours ago Up 32 minutes 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp test_mysql\r Mysql 컨테이너 test_mysql의 CLI 접속  sudo docker exec -it test_mysql /bin/bash 명령어 실행\n PS C:\\\u0026gt; sudo docker exec -it test_mysql /bin/bash\r Mysql 테스트 설치시 등록한 암호 입력  mysql -u root -p\n root@4b6fb99160bf:/# mysql -u root -p\rEnter password:\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 1\rServer version: 5.6.51 MySQL Community Server (GPL)\rCopyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\rmysql\u0026gt;\r Mysql user 생성 및 권한 부여  개발에 사용할 developer라는 유저 생성\n mysql\u0026gt; CREATE USER 'developer'@'%' IDENTIFIED BY 'passw0rd';\rQuery OK, 0 rows affected (0.00 sec)\r  developer에게 모든 권한 부여\n mysql\u0026gt; GRANT ALL PRIVILEGES ON *.* TO 'developer'@'%';\rQuery OK, 0 rows affected (0.00 sec)\rmysql\u0026gt;\r 유저 변경 mysql\u0026gt; quit\rBye\rroot@4b6fb99160bf:/# mysql -u developer -p\rEnter password:\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 2\rServer version: 5.6.51 MySQL Community Server (GPL)\rCopyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\rmysql\u0026gt;\r 데이터베이스 생성 mysql\u0026gt; create database test;\rQuery OK, 1 row affected (0.00 sec)\rmysql\u0026gt; show databases;\r+--------------------+\r| Database |\r+--------------------+\r| information_schema |\r| mysql |\r| performance_schema |\r| test |\r+--------------------+\r4 rows in set (0.00 sec)\rmysql\u0026gt;\r  참고 :\n 도커 웹 페이지   ","description":"도커에 Mysql 올리기","id":137,"section":"blog","tags":["Docker","Mysql"],"title":"도커에 Mysql 올리기-1 (Docker Mysql)","uri":"https://offetuoso.github.io/blog/develop/backend/docker/docker-mysql/"},{"content":"도커 (Docker) 도커란 ?  도커란 리눅스의 응용 프로그램들을 프로세스 격리 기술을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트. 도커 웹 페이지의 기능을 인용하면 다음과 같다:\n 도커 컨테이너는 일종의 소프트웨어를 소프트웨어의 실행에 필요한 모든 것을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는\r무엇이든 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.\r 도커의 특징   도커의 컨테이너는 각각 독립적이다. 독립적으로 존재하기 때문에 원하는 어떤 환경이든 모듈적으로 관리 가능하다. 하나의 서버에 각각의 여러개의 컨테이너를 갖을 수 있다. 컨테이너는 줄이거나 늘릴 수 있다. 예를 들면 자바 서버의 트래픽이 늘어 난다면, 장고 서버를 줄이고 자바를 더 싣을 수 있다. 도커를 사용하면 서버를 늘릴 때마다 서버를 구매하고 다시 설치할 필요가 없어진다 원하는 개발 환경 파일에 저장을 하면, docker는 이를 원하는 어떤 머신이든 해당 환경을 시뮬레이션 해준다.   도커의 장/단점 ####장점\n  빠른 실행 환경 구축 가볍고 빠른 실행 속도 하드웨어 자원 절감 공유 환경 제공, DockerHub를 통해 검증된 많은 이미지들 사용가능 쉬운 배포(Deploy) 제공   ####단점\n  초기 진입장벽에 의한 업무효율 감소 리눅스 기반   도커 설치 (Window 10) 1. 도커 설치를 위한 준비  Windows 10에서 도커를 설치 하기 위해서는 Hyper-V를 설치해야 합니다. Hyper-V를 사용하면 Windows에서 가상 머신으로 여러 운영 체제를 실행할 수 있습니다.\n 2. 도커 다운로드 및 설치   도커 웹 페이지에서 Get Docker 클릭 하여 다운로드      Ok를 눌러 넘어갑니다. WSL2(Windows Subsystem for Linux 2)란?     설치가 완료 되면 \u0026ldquo;Close and log out\u0026rdquo; 를 클릭하여 재접속 합니다.      재접속 후에는 Host에 docker의 Localhost가 추가 되어 Window에서 악성코드에 의하여 Host파일이 변경되었다고 알람이 뜰 수도 있습니다. Host 내용 한번 확인하시고 아래와 같은 내용이라면 무시해도 됩니다.      도커가 실행되며,  윈도우 트레이 아이콘에서도 확인 할 수 있습니다.    윈도우에서 sudo 사용하기  Docker를 공부하는 도중 명령어 중에 sudo가 포함된 명령어를 실행시 cmd 기준 아래와 같은 화면이 나타났다.   윈도우에서는 기본적으러 sudo를 지원하지 않기 때문인거같아 choco라는 패키지 관리자를 이용하여 설치를 하여 해결하였다.\n  choco라는 패키지 관리자를 통하여 sudo 패키지를 설치하면 된다.\n choco install sudo\rchoco upgrade sudo\r  참고 :\n 도커 웹 페이지   ","description":"도커 설치","id":138,"section":"blog","tags":["Docker","Install"],"title":"도커 설치 (Docker Install) ","uri":"https://offetuoso.github.io/blog/develop/backend/docker/docker-install/"},{"content":"   The A is about the B (\u0026lsquo;A는 B에 관한것\u0026rsquo;)  The video is about the effect of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향)\n the effect of A on B (\u0026lsquo;A가 B에 미치는 영향\u0026rsquo;) = the influence of A on B  the effect of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향.)\n the influence of A on B (\u0026lsquo;A가 B에 미치는 영향\u0026rsquo;)  the influence of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향.)\n I want more A, so I can B (\u0026lsquo;더 많은 A를 원해, 그래서 B 할 수 있도록\u0026rsquo;)  I want more time, so I can exercise/work out (더 운동할 수 있는 더 많은 시간을 원한다.)\n give numbers to ~ → to rank ('-에 순위를 매기다')  give numbers to hobby (취미에 순위를 매기다.)\n choose priority (\u0026lsquo;우선 순위 선택\u0026rsquo;) I went to the ~ ('-에 갔다')  I went to 횡성 웰리힐리파크 for skiing. (횡성 웰리힐리파크에 스키타러 갔었다.) I went to 웰리힐리파크 for night snow boarding at 10pm. (10시에 심야 스노우 보드를 타기 위해 웰리 힐리 파크에갔습니다.) I went to the library to study. (공부하러 도서관을 갔었다.)\n ~ days a week. (\u0026lsquo;일주일에 -일\u0026rsquo;)  A year ago, I worked out three days a week. (1년 전에는, 1주일에 3일 운동하러 나갔다.) I went skate boarding three days(times) a week. (1주일에 3일씩 스케이트 보드를 탔다.)\n It was bright from the strong lights (\u0026lsquo;강한 불빛에 비추어 밝았다.')  The light was very strong. → It was bright from the strong lights.\n Q. How does effect of exercising regularly on our body? (\u0026lsquo;규칙적인 운동이 우리 몸에 미치는 영향을 미치는가?')  when I regularly exercise, I had more energy and less stress at that time. (규칙적으로 운동 할 때 그 당시에는 더 많은 에너지와 스트레스를 덜 받았습니다.)\n ##Grammar Error:\nstarting exercising regularly effect on body. → The video is about the effect of exercising regularly on our body. the effect of A on B the influence of A on B I want more exercise → I want more time so exercise. → I want more time, so I can exercise/work out. so hard → so difficult Working out is too hard. I’d like to go swimming. I went to 횡성 웰리힐리파크 for skiing. / I went to the library to study. I went to 횡성 웰리힐리파크 at 10pm for night snowboarding. The light was very strong. → It was bright from the strong lights. One years ago, I was three days on week. → (About) A year ago, I worked out three days a week. / I went skateboarding three days(times) a week. I think decreased stress → I have more stress now. / I had less stress at that time. /I think the amount of stress has increased. I was more energetic at that time.\u0026ndash;\u0026gt; I had more energy ~. I was more energetic and had less stress at that time. / I had more energy and less stress at that time.\n##New expressions learned today: give numbers to sth → to rank choose priority\n본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":139,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.05.14","uri":"https://offetuoso.github.io/blog/english/202105/20210514-english-speak/"},{"content":"탐색 알고리즘 탐색(search)  탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는과정. 그래프 또는 트리의 자료구조에서 데이터를 찾는 문제가 주로 나온다. 대표적으로 DPS, BPS가 있으며, 원리를 제대로 이해해야 코딩테스트 문제를 풀 수 있다. 그런데 DPS와 BPS를 이해하기 위해서 기본 자료구조인 스택, 큐, 재귀 함수 등을 이해가 전제로 되어야한다.\n 자료구조  자료구조란 데이터를 표현하고 관리하고 처리하기 위한 구조 스택과 큐는 삽입(Push)과 출력(Pop)이라는 두 핵심적인 함수로 구성 실제 구현할땐 오버플로우와 언더플로우를 고민해야한다.\n 스택  스택의 구조는 선입후출 또는 후입선출구조. 스택은 박스 쌓기로 비유할 수 있다.\n 스택의 요소    기능  명칭  설명      push(x) 삽입 스택의 마지막에 엘리먼트를 추가(append)하며, 마지막에 삽입된 인덱스(top)가 증가한다.   pop() 추출(삭제) 스택의 마지막 엘리먼트를 반환하고 삭제(del)하며, 마지막에 삽입된 인덱스(top)가 감소한다.   peak() 스택의 마지막 엘리먼트 반환 스택의 마지막 엘리먼트를 반환한다, 마지막에 삽입된 인덱스(top)는 변화가 없다.   top() 스택의 top 반환 마지막에 삽입된 인덱스(top)를 반환한다. 엘리먼츠(리스트)의 사이즈 -1   isEmpty() 스택이 비어있는지 체크 엘리먼츠(리스트)가 비어있으면 True/ 비어있지 않으면 False 반환   clear() 스택 초기화 엘리먼츠(리스트)를 초기화, 마지막에 삽입된 인덱스(top)도 -1   size() 스택의 사이즈 반환 엘리먼츠(리스트) 사이즈 반환   contains() 엘리먼츠(리스트) 초기화 엘리먼츠를 초기화, 마지막에 삽입된 인덱스(top)도 -1   search() 엘리먼츠(리스트) 초기화 엘리먼츠를 초기화, 마지막에 삽입된 인덱스(top)도 -1    \rstack.py class Stack :\r#초기화\rdef __init__(self) :\rself.elements = [] #stack 엘리먼츠 생성\r#데이터 추가\rdef push(self, x) :\rself.elements.append(x) #stack 엘리먼트 추가\r#최근에 추가된(Top) 데이터 삭제\rdef pop(self) :\rif self.isEmpty() :\rreturn \u0026quot;stack underflow!\u0026quot;\relse : del self.elements[self.top()]\rreturn self.elements[self.top()]\r#최근에 추가된(Top) 데이터 삭제\rdef peek(self) : return(self.elements[self.top()])\r#최근에 추가된 인덱스 반환 def top(self) :\rreturn self.size()-1 #인덱스 = (사이즈-1) #stack의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif (self.top() == -1) :\rreturn True\relse :\rreturn False\r#stack 초기화\rdef clear(self) : self.elements = [] #엘리먼츠 초기화\r#stack의 길이 반환\rdef size(self) :\rreturn (len(self.elements))\r#stack의 값이 포함되어있는지 확인, 비었으면 true, 아니면 false\rdef contains(self, x) :\rif(x in self.elements) : #x가 엘리먼츠에 포함되어있는지\rreturn True else :\rreturn False\r#엘리먼트를 보관한 인덱스 반환(리스트 인덱스의 역방향, 1부터 시작)\rdef search(self, x) :\rresult = -1\rfor i in range(1,self.size()+1) :\rif x == self.elements[(self.size()-i)] : result = i\rreturn result\rstack = Stack() print(stack.elements)\rstack.push(1)\rprint(stack.elements)\rstack.push(2)\rprint(stack.elements)\rstack.push('banana')\rprint(stack.elements)\rstack.push(4)\rprint(stack.elements)\rstack.push(5)\rprint(stack.elements)\rprint(\u0026quot;size() \u0026quot;, stack.size())\rprint(\u0026quot;contains(1) \u0026quot;, stack.contains(1))\rprint(\u0026quot;search(1) \u0026quot;, stack.search(1))\rprint(\u0026quot;search(2) \u0026quot;, stack.search(2))\rprint(\u0026quot;peek() \u0026quot;, stack.peek())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;stack.clear() \u0026quot;)\rstack.clear() print(\u0026quot;size() \u0026quot;, stack.size())\rprint(\u0026quot;top() \u0026quot;, stack.top())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\r 큐  큐는 대기줄에 비유할 수 있는 공정한 자료구조, 단 새치기는 없다고 가정. 이러한 스택의 구조를 선입선출구조.\n    기능  명칭  설명      enQueue(x) 삽입 큐의 마지막에 엘리먼트를 추가하며, 마지막에 삽입된 인덱스(rear)가 증가한다.   deQueue() 추출(삭제) 큐의 첫번째 엘리먼트를 반환하고 삭제(빈값으로 세팅 None)하며 , 마지막에 삽입된 인덱스(front-1)가 감소한다. 큐가 마지막의 인덱스에 도달했다면 초기화 (or 삭제 시 한칸씩 땡긴다.)   peak() 큐의 첫번째 엘리먼트 반환 큐의 첫번째 엘리먼트를 반환한다, front 변화 없음   isEmpty() 큐가 비어있는지 체크 프론트와 리어가 같으면 True/ 프론트와 리어가 같지 않으면 False 반환   size() 큐의 사이즈 반환 사용된 엘리먼츠 리스트의 숫자 반환 (rear - front)    \r선형 큐  선형 큐는 데이터를 입력하면 rear가 증가하고 삭제를 통해 front도 증가, 하지만 여러번의 삽입과 삭제를 하면, 삭제된 이후 배열의 앞 공간은 사용할 수 없게 된다.\n linearQueue.py 리스트로 만든 선형큐 MAX = 5\rclass LinearQueue :\r#초기화 def __init__(self, max = MAX) :\rself.maxSize = max\rself.elements = [None] * self.maxSize #비어있는 배열은 None으로 초기화\rself.front = -1 #queue의 앞쪽 인덱스, 삭제 시 증가 self.rear = -1 #queue의 뒤쪽 인덱스 , 삽입 시 증가\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif self.front == self.rear : #front와 rear가 같으면 비어있음\rresult = True\relse : result = False return result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rif(self.rear+1 == self.maxSize) : #rear+1이 maxSize면 오버플로우\rprint(\u0026quot;queue Overflow!\u0026quot;)\relse :\rself.rear += 1 self.elements[self.rear] = x #rear+1에 새로운 데이터 추가\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse :\rself.front += 1\rresult = self.elements[self.front]\rself.elements[self.front] = 'None' #front+1의 데이터 None으로 삭제\rreturn result\r#queue가 비어있으면서 front가 마지막 인덱스(maxSize-1) 까지 도달\rif(self.isEmpty() and self.front == self.maxSize-1) :\rself.front = -1 #front를 초기화\rself.rear = -1 #rear를 초기화\r\u0026quot;\u0026quot;\u0026quot;\r# 삭제 후 한 칸씩 옮기는 로직\rfor i in range(0,self.maxSize) :\rif(i+1 != self.maxSize) :\rself.elements[i] = self.elements[i+1]\relse : self.elements[i] = None\rself.front -= 1\rself.rear -= 1\r\u0026quot;\u0026quot;\u0026quot;\r#queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[self.front+1]\r#queue의 사이즈 반환\rdef size(self) :\rreturn self.rear - self.front queue = LinearQueue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r linearDequeue.py  파이썬의 deque를 이용한 선형큐\n MAX = 5\rfrom collections import deque\rclass LinearDequeue :\r#초기화 def __init__(self, max = MAX) :\rself.elements = deque()\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif len(self.elements) == 0 : result = True\relse : result = False return result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rself.elements.append(x)\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse : return self.elements.popleft() #queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[0]\r#queue의 사이즈 반환\rdef size(self) :\rreturn len(self.elements)\rqueue = LinearDequeue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r 환형큐  선형큐의 공간 낭비의 문제점을 해결하기 위해 고안된 환형큐지만 역시나 문제점이 있다. front 와 rear가 같으면 비어(isEmpty) 있는 상태이지만, 환형 큐가 꽉찬(isFull) 상태 또한 front와 rear가 같아 문제점이 발생한다.\n  front와 rear의 위치만으로 큐의 비어있는 상태와 꽉찬 상태를 구분할 수 없기 때문에 이를 위해 큐의 한칸을 비어둔다. 한칸을 비움으로써 큐의 비어있는 상태와 꽉찬 상태의 front와 rear 위치를 다르게 하여 해결한다.\n circularQueue.py MAX = 5\rclass CircularQueue :\r#초기화 def __init__(self, max = MAX) :\rself.maxSize = max\rself.elements = [None] * self.maxSize #비어있는 배열은 None으로 초기화\rself.front = 0 #queue의 앞쪽 인덱스, 삭제 시 증가 self.rear = 0 #queue의 뒤쪽 인덱스 , 삽입 시 증가\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif self.front == self.rear : #front와 rear가 같으면 비어있음\rresult = True\relse : result = False return result\rdef isFull(self) :\rif self.front == (self.rear+1) % self.maxSize :\rresult = True\relse :\rresult = False\rreturn result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rif(self.isFull()) : #rear+1이 maxSize면 오버플로우\rprint(\u0026quot;queue Overflow!\u0026quot;)\relse :\rself.rear = (self.rear+1) % self.maxSize\rself.elements[self.rear] = x #rear+1에 새로운 데이터 추가\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse :\rself.front = (self.front+1) % self.maxSize\rresult = self.elements[self.front]\rself.elements[self.front] = 'None' #front+1의 데이터 None으로 삭제\rreturn result\r#queue가 비어있으면서 front가 마지막 인덱스(maxSize-1) 까지 도달\rif(self.isEmpty() and self.front == self.maxSize-1) :\rself.front = -1 #front를 초기화\rself.rear = -1 #rear를 초기화\r\u0026quot;\u0026quot;\u0026quot;\r# 삭제 후 한 칸씩 옮기는 로직\rfor i in range(0,self.maxSize) :\rif(i+1 != self.maxSize) :\rself.elements[i] = self.elements[i+1]\relse : self.elements[i] = None\rself.front -= 1\rself.rear -= 1\r\u0026quot;\u0026quot;\u0026quot;\r#queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[self.front+1]\r#queue의 사이즈 반환\rdef size(self) :\rreturn self.rear - self.front queue = CircularQueue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rqueue.enQueue(6)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rqueue.enQueue(6)\rprint(queue.elements)\rqueue.enQueue(7)\rprint(queue.elements)\rqueue.enQueue(8)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r 재귀 함수  자기 자신을 다시 호출하는 함수. 재귀 함수의 종료조건을 반드시 명시해야 한다. 컴퓨터 내부적인 스택 자료구조를 이용한다. 마지막 함수까지 끝나고 나서야 다시 역순으로 돌아가 종료된다.\n  아래 예제는 입력받은 숫자만큼 부터 카운트다운을 하는 소스이다.\n countdown.py (재귀함수 사용) m = int(input())\rdef coountdwon(n) :\rif(n ==0 ) :\rreturn 'Happy new year!'\relse : print(n)\rreturn coountdwon(n-1)\rcoountdwon(m)\r countdown2.py (반복문사용) for i in range(0, m) :\rprint(m-i)\rif (m-i) == 1 :\rprint('Happy new year!')\r 유클리드 호제법 이 자료는 나동빈님의 이코테 서적과 유튜브 영상을 보고 정리한 자료입니다.\n참고 : http://www.yes24.com/Product/Goods/91433923\n  ","description":"탐색 알고리즘.","id":140,"section":"blog","tags":["Algorithm"],"title":"탐색 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/search/search-algorithm/"},{"content":"[문제1] 왕실의 기사 [문제] 왕실의 기사 : 문제 설명  행복 왕국의 왕실 정원은 체스판과 같은 8 × 8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다 나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다 나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있다\n   수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기   수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기   이처럼 8 × 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라. 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a 부터 h로 표현한다\n  c2에 있을 때 이동할 수 있는 경우의 수는 6가지이다 a1에 있을 때 이동할 수 있는 경우의 수는 2가지이다 d4에 있을 때 이동할 수 있는 경우의 수는 8가지이다.\n [문제] 조건  조건 풀이시간 20분 시간제한 1초, 메모리 128mb\n  입력 첫째 줄에 8x8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1 처럼 열과 행으로 이뤄진다.\n  출력 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오.\n  입력 예시 a1\n  출력 예시 2\n 아이디어   모든 경우를 탐색하는 완전탐색 유형의 문제이다 문자 -\u0026gt; 아스키 코드를 반환 하는 ord(\u0026lsquo;a\u0026rsquo;) 를 알아야 한다.\n참고 \u0026lt;-\u0026gt; chr(97)   royal_knight.py n = str(input())\rx = ord(n[0:1])\ry = n[1:2]\r#print(n[0:1])\r#print(n[1:2])\r#print(chr(104))\r#print(ord('a'))\rmv = [0 , 1, 2, 3, 4, 5, 6, 7]\rdx = [-1, +1, +2, +2, +1, -1, -2, +2]\rdy = [-2, -2, -1, +1, +2, +2, +1, -1]\rcount = 0\rfor move in mv :\rif( ord('a') \u0026lt;= int(x)+dx[move] \u0026lt;= ord('h')\rand 1 \u0026lt;= int(y)+dy[move] \u0026lt;= 8) :\rcount += 1\rprint(count)  royal_knight2.py input_data = input()\rrow = input_data[1]\rcolumn = int(ord(input_data[0]))- int(ord('a')) +1\rsteps = [(-2, -1), (-2, +1), (-1, +2), (+1,+2), (+2, +1), (+2, -1), (+1, -2), (-1, +2)]\rcount = 0\rfor step in steps :\rif( 1 \u0026lt;= step[0]+int(row) \u0026lt;= 8 and 1 \u0026lt;= step[1]+int(column) \u0026lt;= 8 ) :\rcount += 1\rprint(count)  파이썬 모범답안 input_data = input()\rrow = int(input_data[1])\rcolumn = int(ord(input_data[0]))- int(ord('a')) +1\rsteps = [(-2, -1), (-2, +1), (-1, +2), (+1,+2), (+2, +1), (+2, -1), (+1, -2), (-1, +2)]\rresult = 0\rfor step in steps :\rnext_row = step[0]+row\rnext_column = step[0]+column\rif( 1 \u0026lt;= next_row \u0026lt;= 8 and 1 \u0026lt;= next_column \u0026lt;= 8 ) :\rresult += 1\rprint(result)  놓친 아이디어   input_data = input(), input_data[0],input_data[1] 로 접근 할 수 있는것을 더 복잡하게 잘라냈다. int(ord(input_data[0])) - int(ord(input_data[a])) + 1 을 사용하여 1 ~ 8로 더 간편히 조회가능. 이동 관련해서 dx,dy 각각 배열을 만들었지만, row, column을 하나의 데이터로 묶어서 사용할 수도 있다.   RoyalKnight.java package ex.algorithm.implement;\rimport java.util.ArrayList;\rimport java.util.Scanner;\rpublic class RoyalKnight{\rpublic static void main(String[] args) {\rint result = 0;\rScanner sc = new Scanner(System.in);\rString input_data = sc.nextLine();\rint row = Integer.parseInt(input_data.substring(1,2));\rint column = (int)input_data.substring(0,1).charAt(0) - (int) 'a' + 1;\rArrayList steps = new ArrayList\u0026lt;ArrayList\u0026lt;Integer[]\u0026gt;\u0026gt;();\rsteps.add(new Integer[]{-2,-1});\rsteps.add(new Integer[]{-2,+1});\rsteps.add(new Integer[]{-1,+2});\rsteps.add(new Integer[]{+1,+2});\rsteps.add(new Integer[]{+2,+1});\rsteps.add(new Integer[]{+2,-1});\rsteps.add(new Integer[]{+1,-2});\rsteps.add(new Integer[]{-1,-2});\rfor (Object obj : steps) {\rInteger[] step = (Integer[])obj;\rint next_row = row + step[0];\rint next_column = column + step[1];\rif((1 \u0026lt;= next_row \u0026amp;\u0026amp; next_row \u0026lt;= 8) \u0026amp;\u0026amp; (1 \u0026lt;= next_column \u0026amp;\u0026amp; next_column \u0026lt;= 8)) {\rresult++;\r}\r}\rSystem.out.println(result);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 왕실의 기사","id":141,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"왕실의 기사 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/royal_knight/"},{"content":"Education Interest Fields Project KTDS 2019.10 ~ Present  Actual Expense Calculation System [Development, Operation]\n Introduction :  Develop and operate a system that calculates the actual construction expenses of subcontractors such as expenses for employee insurance, safety management, waste disposal, and private inventory storage based on submitted data and evidence for KT.\n Technical  Web backend (Java, ExtJs Framework, OracleDB) Web frontend (html, css, JS, jQuery, Jsp) Versioning : Subversion (feature branch, code review) DevOps : Provide a reliable integrated automation system by building, testing, distributing, etc. using Jenkins Dependency Management : Increase maintenance and decrease dependency using Maven  Task (Skills)  Employee Attendance and Approval System  Develop a system that calculates actual expenses for National Health Insurance, National Pension Service, and Long-Term Care Insurance Develop a statement of accounts exporting function Decrease expenses through payment of calculated insurance expenses with the exact number of working days Deliver standardized and intuitive reports, decreased time consumption, and supported decision making with provision of the statement of accounts Optimize management of attendance through digitization and digitalization   Diagnose and Improve Source Vulnerability and Security  Diagnose source vulnerability regularly Prepare for hacking attacks through analysis and application of the latest hacking trends   Integrate Subcontracts of Guarantee and of Guarantor  Collaborate with other agencies through interfaces Ensure reliable real-time safe trading using the guarantee system   Achievement :  Since the opening of the actual cost settlement system on January, 2021, 5,603 cases of actual cost settlement have been paid, and 6,493 cases are under process.    TSK [2019.06 ~ 2019.10] Electronic Purchase System [Development]\no\tIntroduction : Developed an electronic purchasing system that provides electronic bidding, contracts, and orders for water treatment, waste disposal construction, and material delivery between TSK affiliates and partners. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask (Skills) •\tDeveloped systems for business registration, certification, and approval of partner companies\n Assisted in optimization •\tDeveloped electronic contract and contract report system Provide reliability to counterparties •\tIssued KTNET electronic tax invoice and installed certificate signing toolkit (tradesign) Integrated interface with other institutions Ensured reliability of the contract through issuance of electronic tax invoice  SK Home\u0026amp;service [2018.11 ~ 2019.05] Inventory Management System [Development, Operation]\no\tIntroduction : Developed a system for product management process and approval system, such as product application, order, and distribution, used by internal agents and equipment engineers\no\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of inventory application system\n Developed inventory management and application systems Ensure accurate measurement of inventory volume by systemizing inventory management Accelerated inventory management support for applying, ordering, transferring, etc. •\tDevelopment of (integrated) approval system Improved maintenance of collaborative usage of inventory and credit card by modularizing POS system Stabilized system Detected issues and updated system through periodic monitoring Distributed and created backup using shell scripts on Linux  SK Broadband [2018.08 ~ 2018.11] Advancement of HR System [Development]\no\tIntroduction : Developed an internal open recruiting system that recruits experts within the company in case of manpower issues at a particular department and a 52-hour flextime policy application process.\no\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of an internal open recruiting system process\n Partook in enabling reusage of repeated windows through modularization Reduced development time, increased reusage and improved maintenance •\tDevelopment of flextime policy application process Provided intuitive management of schedule by developing calendar-based window Maximized employee autonomy and work efficiency  KYOBO Life [2018.06 ~ 2018.07] Integrated Monitoring System [Development]\no\tIntroduction : Developed an interface, which receives data from other systems and equipment, for an integrated monitoring system, which provides figures such as status and traffic of infrastructure equipment, in the form of dashboards. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tIntegration with other systems\n Increased scalability by developing a variety of interfaces, including TUI, DB2DB, and File2DB •\tDevelopment of batch management system Enabled convenient and easy setting of batches by developing batch management system •\tDevelopment of Dashboard Assisted fast decision making by enabling intuitive log analysis through visualization of logs •\tSSO integration Provided convenient accessibility though shared sessions  Heungkuk Fire \u0026amp; Marine Insurance [2018.02 ~ 2018.05] Audit Information System [Development]\no\tIntroduction : Responsible for continuous monitoring to alert any anomaly in audit information system, Implements of audit process, and development of follow-up and approval process o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of continuous monitoring\n Detected and notified abnormal transactions through scenario-based data analysis Reduced the cost of time and maintaining reliability by preventing accidents in advance •\tImplements of audit Provided efficient management of the person in charge through history management and organization of an audit team Enabled convenient management of outputs, such as audit plans, audit checklist, review points, reports, etc. •\tDevelopment of follow-up process Assisted decision making by providing examples of outputs and decisions of prior audit cases as reference •\tDevelopment of approval process Increased efficiency through development of approval system Enabled collection and management of approval data  Korea Safety \u0026amp; Health Agency [2017.11 ~ 2018.01] Industrial Accident Prevention Information System ERP [Development]\no\tIntroduction : Developed protective equipment certification review process for the Industrial Accident Prevention Information System o\tTechnical •\tWeb Backend (Java, Spring Framework, Tibero, ibatis) •\tWeb Front (Nexacro Platform, Jsp, HTML5, CSS3, Ajax, JS Es6, jQuery) •\tVersioning : Subversion (feature branch, code review) o\tTask •\tProtective equipment certification application and approval\n Increased efficiency in management of certified equipment through registration Provided convenient registration and application process based on the approval status and processing order of certification tasks such as written examination, technical capability and production system examination, product examination by type, verification examination, autonomous safety verification report, etc.  Namsung Shipping [2017.08 ~ 2017.10] Cargo Trace Mobile [Development]\no\tIntroduction : Developed a contract management process that manages customer fares on site and contact management process that enables convenient searching and contacting of responsible department and personnel of Namsung Shipping. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tContract Management\n Increased speed and improved convenience for immediate response through customer fare management •\tDevelopment of Contact Us Developed a system that visualizes contact information of responsible department and personnel and that provides quick access to responsible personnel through phone calls and SNS  Samsung Asset Management [2017.04 ~ 2017.07] Development of Fund Solution [Development]\no\tIntroduction : Partook in development of fund products, home screens, research \u0026amp; insight, topic search, products of interest, and integrated search for fund solutions\no\tTechnical •\tWeb backend (Java, Struts Framewrk, racleDB) •\tWeb frntend (html, css, JS, jQuery, Jsp) •\tVersining : Subversin (feature branch, cde review) •\tDevps : Prepared for large volume of traffic using Lad Balancing •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tConfiguration of home screen in dashboard form to provides required information at a quick glance\n Developed themed-specific home screens such as main screen, solution, ETF focus, and research \u0026amp; insight Improved efficiency of response time through asynchronous processing method using AJAX •\tFund Products Developed detailed advanced search function that enables custom searches Provided intuitive interfaces by visualizing important indicators of the fund, including its type, operator, risk indicator, and yield Developed fund product lists with dynamic sorting capabilities using jqGrid Developed a user-friendly look-up by including a function to align funds by short-term and long-term returns •\tFund Comparison Developed fund comparison function that allows comparisons up to three products on one screen Improved efficiency of response time through asynchronous processing method using AJAX Provided the rate of return graphs for each fund using HighChart and the annual rate of return graphs for all funds being compared on one screen Optimized the range, legend, and form of reactive information of the graph\u0026rsquo;s x-axis y-axis through close collaboration with fund planners •\tResearch \u0026amp; Insight Improved maintenance and reduced development time through joint development of an integrated function that enables multiple dashboards to operate under the same module Provided user convenience by adding topics(tags) to each post to search for filtered results •\tIntegrated search Developed an integrated search engine with keyword searching function which provides all contents, that include the keyword, from Fund, ETF Focus, Research \u0026amp; Insight, and Knowledge PLUS Provided more detailed search capabilities by enabling searching within the search results Optimized SQL through query tuning o\tAchievement : •\tReceived Web Awards Korea 2017 Best Asset Management Award in the Financial Sector Link  JEJUair [2017.02 ~ 2017.04] Development of Pre-in-flight Meal Reservation System [Development]\no\tIntroduction : Developed a statistical system for in-flight meals sold by JEJUair. Statistics consisted of data by country/airport and the number of meal orders by meal supplier on pivot table, and detailed search conditions, such as period, flight number, supplier, in-flight meal, etc., provided desired statistical data at a glance.\no\tTechnical •\tWeb backend (Java, Spring Framework, Aws Aurora DB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of Statistical System\n Developed a statistical table using pivot queries that aggregate columns into rows Minimized response time through optimization and tuning of queries and increased efficiency through reduction of resource usage Developed jointly with SAP a system that collects data such as air schedules, countries, airports, in-flight meals, etc. through the Saf Jco Library •\tDiagnosed security vulnerabilities and developed security solutions using Coderay  Audien [2016.08 ~ 2017.01] Development of Web Streaming System [Development]\no\tIntroduction : Developed a back-end and front-end domain for all customer services, including product development, streaming, and escrow payment, at Audien (an audio book streaming content hybrid app company).\no\tTechnical\t\tWeb backend (Java, Spring Framework, OracleDB) \tWeb frontend (html, css, JS, jQuery, Jsp) \tVersioning : Subversion (feature branch, code review) \tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask \tDeveloped services for all products, such as home screen, list, detailed screen, shopping basket, purchase of voucher, and coupon registration, using audiobook as a product \tDeveloped with efficient response time through asynchronous processing using AJAX \tProvided the same functionality on WEB, Android, and IOS by developing a hybrid app \tCreated new customer value by launch audiobook web services that are not in the marketplace in collaboration with project managers \tDeveloped audio book categories, product lists, and detailed screens similar to e-libraries or online bookstores for convenient access by consumers. \tDevelopment of streaming player using opensource product \tDeveloped audio player using Video.js, an opensource product \tImplemented streaming tool using HLS(Http Live Streaming) protocol \tIntegration of payment service with escrow \tImplemented a secure payment system that asks the purchase intention once more to eliminate inefficient aspects such as simple change of mind, etc. before payment \tDeveloped, validated, and secured consumer-friendly and efficient systems by conducting integrated testing and unit testing \tAssisted transaction management through success processing and rollback processing by coherently combining the success and failure of payment services and business logic into one process\nFiNMART [2016.04 ~ 2016.07] Development of Loan Comparative Quote Hybrid App Service [Development]\no\tIntroduction : Developed a hybrid platform that provides loan quotes and developed a credit and real estate loan application system using used car dealer certification and dealer management in B2B format and customer credit information in B2C format.\no\tTechnical \tWeb backend (Java, Spring Framework, Maria DB) \tWeb frontend (html, css, JS, jQuery, Jsp) \tVersioning : Subversion (feature branch, code review) \tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask \tDevelopment of B2B used car dealer certification and dealer member management \tIncreased service credibility by developing used car dealer registration system that only registers vetted dealers \tDeveloped sale management system to enable dealers to register their vehicles for sale \tDevelopment of credit and real estate loan application functions \tDeveloped an intuitive user interface that divides loan applications into steps for convenient registration process on mobile screen \tImproved convenience by providing temporary saving in filling out loan applications \tDeveloped identity verification and credit score verification through KCB identity verification \tProvided optimal loan products from various financial institutions based on customer verification information \tDeveloped back-office processes after customer loan applications to facilitate bank and customer connectivity o\tAchievement : \tReceived Internet Biz Eco Award Grand Prize in Business Sector \tReceived Smart App Award Special Grand Prize \tReceived JB Financial Holding FinTech Competition Excellence Award\nSaerom Information Systems [2013.04 ~ 2015.07] Development of Groupware [Development]\no\tIntroduction : While working at Saerom Information Systems, a groupware company, partook in 9 groupware development projects for Yujin Machinery, the Supreme Court, Woongjin Holdings, Chunhajeil Feed, Leehan, Gamevil, Kelim Ceramics, Nasung Shipping, and Danal. In-house, developed, tested, and maintained solutions, worked on groupware porting and groupware customization, and assisted further development upon additional requests. o\tTechnical •\tWeb backend (Java, Spring Framework, IBM Lotus, IBM Notes, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) o\tTask •\tPortal\n Provided default menus and portlet based on user’s responsibility Improved convenience to users by developing portlet individualization function Provided intuitive services by visualizing payment progress •\tMail Provided collaboration and work efficiency through mail service Provided mail backup service using archive Prevented spams and strengthened security through mail monitoring •\tElectronic Approval Improved convenience by providing various basic templates to create additional required forms Enable detailed settings through options for each approval form •\tProject/Task Management Provided intuitive data on progression through visualization of data in Gantt Chart forms Provided systematic task management and inquiry functions •\tCommunity Developed survey function Developed popular post function Provided list function for responses to posts (comments, replies, interests) •\tIntegrated search Developed system menus and contact search functions •\tHR management Configured organizational chart using LDAP Developed tree-type organizational chart Developed restructuring and departmental management system •\tMultilingual Support Provided Korean/English as default languages Enabled infinite multilingual expansion capability through language packs Improved multilingual management convenience  ","description":"about me","id":142,"section":"","tags":[],"title":"About Me","uri":"https://offetuoso.github.io/about/"},{"content":"Git 캐시(cache) 삭제 // 원격 저장소와 로컬 저장소 파일을 삭제\r$ git rm 파일명\r// 원격 저장소에 있는 파일만 삭제하고, //로컬 저장소에 있는 파일은 삭제하지 않음\r$ git rm --cached 파일명\r rm -r 옵션\r// 파일 삭제\r$ git rm --cached 파일명\r// 폴더 하위의 모든 파일을 삭제\r$ git rm -r --cached 폴더명\r ","description":"깃 캐시 삭제","id":143,"section":"blog","tags":["Git"],"title":"Git 캐시 삭제","uri":"https://offetuoso.github.io/blog/develop/git/202105/time/"},{"content":"[문제1] 시각 [문제] 시각 : 문제 설명  정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하라. 예를 들어 1을 입력했을 때\n  다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다 00시 00분 03초 00시 13분 30초\n  반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다 00시 02분 55초 01시 27분 45초\n [문제] 조건  조건 풀이시간 15분 시간제한 2초, 메모리 128mb\n  입력 첫째 줄에 정수 N이 입력된다.(0\u0026lt;=N\u0026lt;=23)\n  출력 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.\n  입력예시 5\n  출력예시 11475\n 아이디어  복잡하게 생각할 필요없이 하루는 86,400초로 00시00분00초 -\u0026gt; 23시59분59초 까지 모든 경우는 86,400로 경우의 수가 100,000 개도 되지 않기 때문에 모든 초를 센다 하여도 2초가 넘지 않는다.\n  모든 초를 조회하는 완전탐색 유형으로 생각하면된다.\n  모든 시간 분 초를 순회하며, 합쳐서 문자로 합쳐서 포함 여부를 조회한다.\n  파이썬 if(\u0026lsquo;3\u0026rsquo; in str(hour)+str(minute)+str(second)) : #활용\n  자바 if((\u0026quot;\u0026quot;+hour+minute+second).contains(\u0026ldquo;3\u0026rdquo;)){} //활용\n time1.py n = int(input())\rcount, hour, minute, second = 0, 0, 0, 0\rwhile True :\rif('3' in str(hour)+str(minute)+str(second)):\rcount += 1\rsecond += 1\rif second == 60 :\rminute += 1\rsecond = 0\rif minute == 60 :\rhour += 1\rminute = 0\rif hour == n+1 :\rbreak\rprint(count)  파이썬 모범답안 n = int(input())\rresult = 0;\rfor h in range(n+1) :\rfor m in range(60) :\rfor s in range(60) :\rif('3' in str(h)+str(m)+str(s)) :\rresult += 1\rprint(result)\r Time.java package ex.Algorithm.implement;\rimport java.util.Scanner;\rpublic class Time{\rpublic static void main(String args[]) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint hour = 0;\rint minute = 0;\rint second = 0;\rint count = 0;\rwhile (true) {\rif((\u0026quot;\u0026quot;+hour+minute+second).contains(\u0026quot;3\u0026quot;)) {\rcount++;\r}\rsecond++;\rif(second == 60){\rminute ++;\rsecond = 0;\r}\rif(minute == 60){\rhour ++;\rminute = 0;\r}\rif(hour == n+1){\rbreak;\r}\r}\rSystem.out.println(count);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 시각","id":144,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"시각 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/time/"},{"content":"[문제1] 상하좌우 [문제] 상하좌우 : 문제 설명  여행가 A는 N × N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다\n  계획서에는 하나의 줄에 띄어쓰기를 기준으로 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다. 각 문자의 의미는 다음과 같다\n  L: 왼쪽으로 한 칸 이동 R: 오른쪽으로 한 칸 이동 U: 위로 한 칸 이동 D: 아래로 한 칸 이동\n  이때 여행가 A가 N × N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다 예를 들어 (1, 1)의 위치에서 L 혹은 U를 만나면 무시된다 다음은 N = 5인 지도와 계획이다\n [문제] 조건  조건 풀이시간 15분 시간제한 1초, 메모리 128mb\n  입력 첫째 줄에 공간의 크기를 나타내는 N이 주어집니다. (1\u0026lt;=N\u0026lt;=100) 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어집니다. (1\u0026lt;=이동 횟수\u0026lt;=100)\n  출력 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X,Y)를 공백으로 구분하여 출력한다.\n  입력예시 5 R R R U D D 출력예시 3 4\n up-down-left-right1.py n = int(input()) # map의 최대 크기\rm = list(map(str, input().split())) #공백으로 구분된 이동플랜\rx, y = 1, 1\t# 시작위치\rfor move in m: # 입력받은 이동 커맨드\rif (move == \u0026quot;U\u0026quot;) and (x - 1) \u0026gt; 0: # U (x-1, y)를 x-1이 1보다 작아지지 않는 선에서 수행 x -= 1\relif (move == \u0026quot;D\u0026quot;) and (x + 1) \u0026lt;= n : # D (x+1, y)를 x+1이 n보다 커지지 않는 선에서 수행 x += 1\relif (move == \u0026quot;L\u0026quot;) and (y - 1) \u0026gt; 0: # L (x, y-1)를 y-1이 1보다 작아지지 않는 선에서 수행 y -= 1\relif (move) == \u0026quot;R\u0026quot;) and (y + 1) \u0026lt;= n : # R (x, y+1)를 y+1이 n보다 커지지 않는 선에서 수행 y += 1\rprint(x,' ',y)  up-down-left-right1.py n = int(input())\rm = input().split()\rx, y = 1, 1\rmove_type = ['U','D','L','R']\rdx = [-1, +1, 0, 0]\rdy = [0, 0, -1, +1]\rfor move in m:\rfor i in range(0, len(move_type)) :\rif move == move_type[i] :\rif( 1 \u0026lt;= x+dx[i] \u0026lt;= n and 1 \u0026lt;= y+dy[i] \u0026lt;= n ) :\rx += dx[i]\ry += dy[i]\rprint(x,' ',y)\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 상하좌우","id":145,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"상하좌우 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202104/up-down-left-right/"},{"content":"[문제1] 숫자 카드 게임 [문제] 숫자 카드 게임 : 문제 설명  숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.\n  숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.   모든 행을 순회 하여, 행의 가장 작은 수중에 가장큰 수를 찾기\n  카드들이 N X M 형태로 놓여 있을 때, 게임의 룰에 맞게 카드를 뽑는 프로그램을 만드시오.\n [문제] 조건  조건 시간 1초, 메모리 120mb\n  입력조건 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다. (1 \u0026lt;= N,M \u0026lt;= 100) 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수이다.\n  출력조건 첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다\n  입력예시 3 3 3 1 2 4 1 4 2 2 2\n  출력예시 2\n  입력예시 2 4 7 3 1 8 3 3 3 4\n  출력예시 3\n 아이디어  각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수 찾기 list에서 가장 작은 원소를 찾아주는 min() 함수 이용 입력 파라메터 중에서 가장 큰 원소를 찾아주는 max(a, b) 함수 이용\n game_of_number_card.py n, m = map(int, input().split())\rresult = 0\rfor i in range(n):\rdata = list(map(int, input().split()))\rminumum = min(data)\rresult = max(result, minumum)\rprint(result)  GameOfCard.java package ex.Algorithm.greedy;\rimport java.util.Arrays;\rimport java.util.Scanner;\rpublic class GameOfCard {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint result = 0;\rString n = sc.nextLine();\rString m = null;\rString arr[] = n.split(\u0026quot; \u0026quot;);\rint maximum = 0;\rfor (int i = 0; i \u0026lt; Integer.parseInt(arr[0]); i++) {\rm = sc.nextLine();\rString row[] = m.split(\u0026quot; \u0026quot;);\r//자바 String배열 -\u0026gt; int배열로 변경 Java8 기준\rint[] nums = Arrays.asList(row).stream().mapToInt(Integer::parseInt).toArray();\r/*\rint[] nums = new int[row.length];\rfor(int j=0; j\u0026lt;row.length; j++) {\rnums[j] = Integer.parseInt(row[j]);\r}\r*/\rArrays.sort(nums);\rif(maximum \u0026lt; nums[0]) {\rmaximum = nums[0];\r}\r}\rSystem.out.println(maximum);\r}\r}\r 파이썬 모범답안 1 #n, m을 공백으로 구분하여 입력받기\rn, m = map(int, input().split())\rresult = 0\r#한 줄씩 입력받아 확인\rfor i in range(n):\rdata = list(map(int, input().split(\u0026quot; \u0026quot;)))\r# 현재 줄에서 '가장 작은 수' 찾기\rmin_value = min(data)\r# '가장 작은 수'들 중에서 가장 큰 수 찾기\rresult = max(result, min_value)\rprint(result)\r 파이썬 모범답안 2 #n, m을 공백으로 구분하여 입력받기\rn, m = map(int, input().split())\rresult = 0\r#한 줄씩 입력받아 확인\rfor i in range(n):\rdata = list(map(int, input().split()))\rmin_value = 10001\r#현재 줄에서 '가장 작은 수' 찾기\rfor a in data :\rmin_value = min(min_value, a)\r#'가장 작은 수 중'에서 가장 큰 수 찾기 result = max(result, min_value)\rprint(result)\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 숫자 카드 게임","id":146,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"숫자 카드 게임 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/games-of-number-card/"},{"content":"[문제1] 큰 수의 법칙 [문제] 큰 수의 법칙 : 문제 설명  출제자는 큰 수의 법칙을 본인만의 방식으로 다르게 사용하고 있다. 이 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙이다. 단 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.\n  예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.\n  배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 출제자의 큰 수의 법칙에 따른 결과를 출력하시오\n [문제] 조건  조건 시간 1초, 메모리 120mb\n  입력조건 첫째 줄에 N(2 \u0026lt;= N \u0026lt;= 1,000), M(1 \u0026lt;= M \u0026lt;= 10,000), K(1 \u0026lt;= K \u0026lt;= 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다. 입력으로 주어지는 K는 항상 M보다 작거나 같다\n  출력조건 첫째 줄에 큰 수 의 법칙에 따라 더해진 답을 출력한다\n  입력예시 5 8 3 2 4 5 4 6\n  출력예시 46\n 아이디어  최초 while 안에 k번의 반복문을 두어 큰수를 반복시키려고 했다만 문제 조건의 시간과 메모리의 조건이 있어 최대 입력값인 1000, 10000, 10000 이라면 열심히 풀고도 오답이 나올것이다.\n  n m k 5 7 2 2 1 5 4 3\n  {5, 5, 4, 5, 5, 4, 5}\n  코딩문제인줄 알았으나 수열문제 였다. 일단 5의 갯수를 세어 count * 5로 반복문 없이 계산을 하려한다.\n  첫번째로 반복되는 수열중 5의 갯수를 구하는 법이다. 반복되는 5, 5, 4는 (k+1) 3이며 전체의 총 개수에서 몇번 사용할 수 있는지 생각해 보면 m // (k+1) 몫은 2가 나온다. 여기에 k를 다시 곱해준다 (m // (+1) 2)*k 여기까지 계산하면 반복되는 수열중의 제일 큰 수를 계산한다.\n  하지만 수열에 포함되지 않은 5의 갯수를 더해줘야한다. 딱 나눠떨어지면 0, 나머지가 있다면 나머지 만큼의 5를 더해 줘야한다. 여기에 자주 쓰이는 % 연산자가 있다\n  m % (k+1) 으로 1이나온다. 나머지의 갯수를 계산하는 식 m % (k+1)\n  count = (m // (+1) 2)*k count += m % (k+1)\n  이렇게 하면 {(5), (5), 4, (5), (5), 4, (5)} 5의 개수를 얻었고 이제 4의 개수를 얻어보자 아까 구했던 수열이 반복되는 (m // (k+1)) 만큼 4를 곱해준다\n  count2 = (m // (k+1)) 나머지는 2번째 수가 나오지 못하여, 몫으로 안떨어지고 나머지가 된것이기 때문에 2번째 큰수는 나머지 추가로 더해줄게 없다\n  result = (count첫번째큰수)+(count2두번째큰수)\n law_of_large_number.py n, m, k = map(int, input().split()) l = list(map(int, input().split()));\rl.sort();\rfirst = l[n-1] second = l[n-2]\rcount = (m // (k+1))*k count += m % (k+1)\rcount2 = (m // (k+1)) #m-count\rresult = (count*first) + (count2*second)\rprint(result)\r LawOfLargeNumber.java package ex.Algorithm.greedy;\rimport java.util.Arrays;\rimport java.util.Collections;\rimport java.util.Scanner;\rpublic class LawofLargeNumber {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint result = 0;\rString str1 = sc.nextLine();\rString str2 = sc.nextLine();\rint n = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[0]);\rint m = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[1]);\rint k = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[2]);\rString list[] = str2.split(\u0026quot; \u0026quot;);\rArrays.sort(list);\rint first = Integer.parseInt(list[n-1]);\rint second = Integer.parseInt(list[n-2]);\r//System.out.println(\u0026quot;n\u0026quot;+n);\r//System.out.println(\u0026quot;m\u0026quot;+m);\r//System.out.println(\u0026quot;k\u0026quot;+k);\r//System.out.println(\u0026quot;first\u0026quot;+first);\r//System.out.println(\u0026quot;second\u0026quot;+second);\r//5 5 4 5 5 4 5\rint count = (m/(k+1))*k;\rcount += m%(k+1);\rint count2 = m-count; //System.out.println(count);\rresult = (count*first) + (count2*second);\rSystem.out.println(result);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 큰수의 법칙","id":147,"section":"blog","tags":["Algorithm","Greedy","이코테","수열"],"title":"큰수의 법칙 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/law-of-large-number/"},{"content":"   a. touching (\u0026lsquo;감동시키는\u0026rsquo;) a. entertaining (\u0026lsquo;재미있는\u0026rsquo;)  It was really entertaining and the storyline was also a bit touching(sad). (정말 재미 있었고 스토리 라인도 약간 감동적이었습니다.)\n These days (\u0026lsquo;요즘\u0026rsquo;) = Nowadays  These day , I go to bed in 1 am and (get up) 7 am (요즘은 새벽 1시에 자고 아침 7시에 일어나)\n On weekends (\u0026lsquo;주말에\u0026rsquo;) get up at (~ time) ('-시에 일어나') still (\u0026lsquo;여전히\u0026rsquo;)  On weekends, I get up at 1 pm and still go to bed the same (주말에는 오후 1시에 일어나도 똑같이 잠자리에 든다)\n ~ hours ('-시간')  I sleep for 9 hours (난 9시간 동안 잔다.)\n When A, then B. (\u0026lsquo;A 하면 B합니다.')  When I very tired, then has insomnia. (내가 매우 피곤하면 불면증이 생깁니다.) → I have a hard time falling asleep quickly, especially when I’m very tired. (나는 특히 내가 매우 피곤할 때 빨리 잠들기가 힘듭니다.)\n especially (\u0026lsquo;특히\u0026rsquo;) I am always (\u0026lsquo;난 항상\u0026rsquo;) ~I always a little tired and I drinking a lot of coffee.~\n I am always a little tired and I drink a lot of coffee. (나는 항상 조금 피곤하고 커피를 많이 마신다.)\n a lot (\u0026lsquo;많이\u0026rsquo;)  I watch Netflix a lot. (나는 넷플릭스를 많이 봅니다.) I had drinking a lot of coffee. (나는 커피를 많이 마셨다.)\n Have p.p ('-했다.\u0026rsquo; 현재완료 시점)  I have be growth (나는 성장했다.)\n Have been p.p ('-되어졌다.' 현재완료 시점)  I Have been healthed (나는 건강해졌다.) I Have been fired (나는 해고당했다.)\n Have been ~ing ('-해 오고 있다.' 현재완료 진행형으로)  I have been learning English for three weeks. (저는 3 주 동안 영어를 배우고 있습니다.)\n be ~ing ('-하고 있어')  I am drinking a coffee (나는 커피를 마시고 있다) I am trying to get some sleep (잠을 좀 자려고 해요) I am learning English (나 영어 배우고 있어) I am having a talk with A (나 A와 이야기 하고 있어요)\n how I can get to A / how to get to A (\u0026lsquo;A에가는 방법\u0026rsquo;)  how I can get to 안양천 how to get to 안양천\n remain (\u0026lsquo;남다\u0026rsquo;)  the question remains (문제가 남아있다.)\n remaining (\u0026lsquo;남아있는\u0026rsquo;)  The remaining amount (남은 금액)\n recommend (\u0026lsquo;추천하다/권장하다\u0026rsquo;) recommended (\u0026lsquo;추천하는/권장되는\u0026rsquo;)  recommended posts, groups that are relative to you\n strongly recommend (\u0026lsquo;강력추천\u0026rsquo;) The recommended amount of ~ ('-권장량')  The recommended amount of sleep (권장 수면량)\n I had a hard time (\u0026lsquo;나는 힘들었다.') fluently (\u0026lsquo;유창한\u0026rsquo;)  I have a hard time speaking English fluently (영어를 유창하게 말하는 것이 힘들다)\n frustrating (\u0026lsquo;좌절/실망\u0026rsquo;)  This solution is so frustrating. (이 솔루션은 너무 실망 스럽습니다)\n 문법오류 It was so funny and also sad. → It was really entertaining and the storyline was also a bit sad/touching.\rThese days (Nowadays) , I go to bed in 1 am and (get up) 7 am → at + time\rWhen I weekend, then I get up at 1pm but I still go to bed at 1 am. → On weekends, I get up at 1 pm and still go to bed the same.\r9 o’clock → 9 hours\rweak insomnia. When I very tired, then has insomnia.\r→ I have a hard time falling asleep quickly, especially when I’m very tired.\rI always a little tired and I drinking a lot of coffee. → I am always a little tired and I drink a lot of coffee. I watch Netflix a lot.\rI had drinking a lot of coffee.\rhave V-ing. → have been V-ing\rI have been learning English for three weeks.\rI have tried watching Mr. Sunshine, but it’s not my style.\rHave you tried bungee jumping? No, I haven’t.\rbe V-ing. ; I am drinking a coffee, I am trying to get some sleep, I am learning English (I’m learning how to speak in English), I am having a talk with Kihun.\rc.f. how I can get to 안양천, how to get to 안양천\rShe is having a rest → She is taking a rest.\rWhat are you doing? → I am doing ~.  새로배운 표현 remain 남다, remaining 남아있는\rthe question remains = there lies the question, the question is “-”\rThe remaining amount\rrecommend (v) → recommended (a) 1. 추천하다 (추천하는), 2. 권장하다 (권장되는)\rrecommended posts, groups that are relative to you\rI really/strongly recommend ~. (I strongly recommend (watching) Mr. Sunshine)\rThe recommended amount of _____.\rinfluence (v) → have an influence on sth\rhave a hard time V-ing\rI have a hard time speaking English fluently.\rWhen I was in middle school, I had a hard time getting up early.\rWhen I was a high school student, I had a hard time studying at school.\rfrustrating (a)\rThis problem set is so frustrating.\rCoding is so frustrating. / Coding really frustrates me.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":148,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.08","uri":"https://offetuoso.github.io/blog/english/202104/20210408-english-speak/"},{"content":"go to ~ ('-에 간다')  I go to company. (나는 회사에 간다.)\n be going to ~ ('-에 갈꺼다')  I\u0026rsquo;m going to market. (나는 마트에 간다. 갈예정이 있음 )\n be going to go to ~ ('-에 갈꺼야')  I\u0026rsquo;m going to go to korea. (나는 한국에 갈꺼야. 아직 계획은 세우지 않았음 )\n went to ~ ('- 갔었다 \u0026lsquo;)  I went to starfield. (나는 스타필드에 갔었다.)\n how can I get to the ~ ? ('- 까지 어떻게 가나요?')  Excuse me, how can I get to the \u0026lsquo;동대문 market\u0026rsquo;? (동대문 시장까지 어떻게 가나요?)\n Can you tell me where the ~ is ? ('-가 어디에 있는지 말해 줄 수 있습니까?')  Can you tell me where the bus station is? (버스 정류장이 어디인지 말해 줄 수 있나요?)\n Can you tell me how I can ~ ? (\u0026lsquo;어떻게 - 할 수 있는지 말씀해 주시겠습니까?')  Can you tell me how I can use this machine? (이 기계를 어떻게 사용할 수 있는지 말해 줄 수 있습니까?)\n I’d like to know how to get to the ~. ('-에가는 방법을 알고 싶습니다.')  I’d like to know how to get to the 안양천 (안양천에가는 방법을 알고 싶습니다.)\n purpose (\u0026lsquo;목적\u0026rsquo;) Grammar Error: I go to the workspace and → I went to the company and there were flowers (cherry blossoms) on the side of the roads nearby the company building.\rNew expressions learned today: strategy (n) 요령 → 전략\rskills vs. strategies\rpurpose 목적\rWhich subway station should I go to / to get to 안양천?\rCould you tell me how to spell it?\rExcuse me, how can I get to the _(location)_?\rCan I ask you a question?\rDo you know where _(location)_ is?\rCan you tell me where the bus station is? / how I can get to (location)?\rCan you tell me how I can use this machine?\rCan you tell me how to use this machine?\rI’d like to know how to get to the _(location)_.\rPardon me for asking, but ...\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":149,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.07","uri":"https://offetuoso.github.io/blog/english/202104/20210407-english-speak/"},{"content":"[문제1] 1이 될때까지 [문제] 1이 될때까지 : 문제 설명  어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n [문제] 조건  입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n make_one.py n, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  MakeOne.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"모험가 파티를 만드는 알고리즘","id":150,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"모험가 길드 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/adventurer-guild/"},{"content":"prepare (\u0026lsquo;준비하다\u0026rsquo;)  Pick/Choose two questions and prepare your answers. (두 가지 질문을 고르고 답을 준비하십시오.)\n the meaning of the ~ ('-의 의미')  the meaning of the name. (이름의 의미) The meaning of one’s name may have an influence on their life. (이름의 의미가 그들의 삶에 영향을 미칠 수 있습니다.)\n to have influence on ~ ('-에 영향을 미치다')  to have influence on life (삶에 영향을 미치다)\n v. affect ~ ('-에 영향을 미치다')  affect life (삶에 영향을 미치다)\n to affect positively/negatively = to bring a positive/negative effect on sth n. effect (\u0026lsquo;효과\u0026rsquo;)  effect of sleep (수면의 효과)\n strategy (\u0026lsquo;전략\u0026rsquo;)  skills and strategies (기술과 전략)\n Naming center (\u0026lsquo;작명소\u0026rsquo;)  It would be difficult to name my child based on astrology. (점성술에 근거하여 내 아이의 이름을 짓는 것은 어려울 것입니다.)\n make sure (\u0026lsquo;확실한\u0026rsquo;)  Make sure you do the dishes right after you eat. (식사 후 바로 설거지를하세요.) Make sure you give me the file by tomorrow. (내일까지 파일을 주셔야합니다.) = You must give me the file ~\n sure  Are you sure? (\u0026lsquo;확실합니까?') Are you sure you sent me the file via email? (이메일로 파일을 보냈습니까?)\n can you tell me again? (\u0026lsquo;다시 말해줄래?') = Can you repeat it once more? 문법오류 My name has an influence on positive effects on my life. (내 이름은 내 삶에 긍정적 인 영향을 미칩니다.)\r→ My name has an influence on my life. (내 이름은 내 삶에 영향을 미칩니다.)\r/ My name has a positive effect on my life. (내 이름은 내 삶에 긍정적 인 영향을 미칩니다.)\r→ My name gave/brought a positive effect on my life. (내 이름은 내 삶에 긍정적 인 영향을 미쳤습니다.)\r 새로배운 표현 to affect positively/negatively = to bring a positive/negative effect on sth\rmean (v) → meaning (n)\rS(n) + V (+ O(n) / + Adj.) (+ Adv.)\rone (n) 대명사로 쓰일 경우 → 그것, 한 사람\r조동사 - must, may/might, should/shall, would/will, have, celebrity (n) stars, famous people - Celebrity (IU) 셀럽\rCardi B - Culture, / North~West\rmake sure\rMake sure you do the dishes right after you eat.\rMake sure you give me the file by tomorrow. = You must give me the file ~\rsure → Are you sure? / Are you sure you sent me the file via email?\rI’m sure.\rSure. (Of course. No problem.)\rstrategy - skills and strategies\rCan you tell me again? = Can you repeat it once more?\rI’d like to know when the due date is.\rPardon me for asking, but where can I sign up for the membership?\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":151,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.02","uri":"https://offetuoso.github.io/blog/english/202104/20210402-english-speak/"},{"content":"##have influence on ~ ('-에 영향을 미치다')\n 동학개미 had some influence on the national stock market. (\u0026lsquo;동학 개미는 전국 주식 시장에 영향을 미쳤습니다.') I think, he has achievement that influence on some developer (\u0026lsquo;그는 일부 개발자에게 영향을 미치는 업적을 가지고 있다고 생각합니다.') I think, his achievement has some influence on [software developers/engineers.] (\u0026lsquo;그는 일부 개발자에게 영향을 미치는 업적을 가지고 있다고 생각합니다.') Netflix now has a huge influence on the media industry. (\u0026lsquo;Netflix는 이제 미디어 산업에 큰 영향력을 미치고 있습니다. \u0026lsquo;)\n say/ speak/ talk/ tell \u0026gt;\tsay (말하는 내용에 집중) 말하다\r- \u0026quot;i'm so tired \u0026quot; he said. (그가 \u0026quot;나는 피곤해\u0026quot; '라고 말했다')\r\u0026gt;\tspeak (1.말하는 행위, 2.언어를 사용할 수 있는 능력)말하다\r1. The teacher will speak about the test tomorrow (1. 선생님은 내일 시험에 대해 말할 것입니다)\r2. I can speak English (2. 나는 영어를 사용할 수 있습니다)\r\u0026gt; talk (말을 주고 받는 행위) 이야기하다, 말하다\r-\the talks too much (그는 말이 너무 많다)\r- We talked about the our future (우리는 우리의 미래에 대하여 이야기 했습니다)\r\u0026gt; tell (말하는 대상과 내용에 초점) 말하다 -\tI'll tell you what happened. (무슨 일이 있었는지 말씀 드리겠습니다.)\r 각 동사마다 표현하는 방법이 다르다 \u0026gt;\tsay\r1. 말하는 내용은 that\r- I say \u0026lt;mark\u0026gt;(that)\u0026lt;/mark\u0026gt; ~ (that 생략가능)\r2. 말하는 대상은 전치사 to 사용 - I say that ~ \u0026lt;mark\u0026gt;to\u0026lt;/mark\u0026gt; you (to를 붙여서 말하는 대상 추가)\r\u0026gt;\tspeak /talk\r1. 말하는 내용은 about\r- We speak \u0026lt;mark\u0026gt;about\u0026lt;/mark\u0026gt; the money\r- We talk \u0026lt;mark\u0026gt;about\u0026lt;/mark\u0026gt; the money\r2. 말하는 대상은 to 사용\r- They speak to me about the money\r- please talk to me about the money\r\u0026gt;\ttell *tell은 말하는 대상과 내용이 다 나와야 합니다\r1. 대상 tell [내용/명사] / 대상 tell about [내용/명사] 3형식 - she tells me the our future\r- they told him their product\r- she tells me about the our future\r- they told him about their product\r2. tell (대상) that (내용, 문장 형태(Phrase, 구))\r*내용이 ‘누가 뭘 했다’ 등 긴 내용을 말할 때 사용. (주어와 동사 필요)\r– Paul tells me that he likes to visit the new house.\r– They told him that they didn’t buy it.\r3. tell (대상) to do (something)\r*이 경우에는 주로 ‘(누구)에게 (무엇을 하라고)명령하다’라는 뜻으로 사용됩니다.\r– Paul tells me to clean my room.\r– They told him to show them his ID card.\r 전치사를 사용한 표현 \u0026gt;\t1. talk over: ~에 대해 (깊이) 이야기 하다\r– We talked over the new project.\r– Jason talked over his plan to Paris. \u0026gt;\t2. talk (대상) into (동명사): ~하도록 설득하다\r– He talked me into buying his new painting.\r– She talked him into sending a letter.\t say-speak-talk-tell은 아래 홈페이지에서 참조\r참고 : http://cafeclass.kr/say-speak-talk-tell-%EC%B0%A8%EC%9D%B4/\rAmerica(US)\u0026rsquo;s third gender \u0026gt; 1. He\r2. She\r3. Them\r plural (\u0026lsquo;복수형 more than one\u0026rsquo;) - a. the first person plural\r- n. the first person plural\r singular (\u0026lsquo;단수형 one\u0026rsquo;) - a. the third person singular form of the verb\r- n. the first person singular\r pass down (\u0026lsquo;전달받다, 물려받다\u0026rsquo;) (casual)  One of the parents’ family names is passed down to the child in Korea. (\u0026lsquo;한국에서는 부모의 성이 아이에게 전해집니다.')\n inherit (\u0026lsquo;상속하다\u0026rsquo;) (formal)  Instead of inheriting all the financial assets to his children, he donated 70% to the society. (\u0026lsquo;모든 금융 자산을 자녀들에게 물려주는 대신 사회에 70 %를 기부했습니다.')\n refer to (\u0026lsquo;인용하다\u0026rsquo;)  he was refer to sentence of poem (\u0026lsquo;그는시의 문장을 언급했다\u0026rsquo;)\n n. ancestor (\u0026lsquo;선조\u0026rsquo;) n. descendent (\u0026lsquo;후손\u0026rsquo;) \u0026gt; (de/di- : minus, later → decline, diminish)\r n. occupation (\u0026lsquo;직업\u0026rsquo;) prince and princess → princes and princesses (plural -es: is) 발음주의 연도읽기   1908 - nineteen-o-eight \u0026gt; nineteen-hundred and eight - The Olympics was held in Pyeongchang in 2018. - 2582 B.C. 2080, 2090   본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":152,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.01","uri":"https://offetuoso.github.io/blog/english/202104/20210401-english-speak/"},{"content":"[문제1] 곱하기 혹은 더하기 [문제] 곱하기 혹은 더하기 : 문제 설명  각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 \u0026lsquo;x\u0026rsquo; 혹은 \u0026lsquo;+\u0026rsquo; 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성. 단, + 보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정.\n   예를 들어, 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2)x 9)x 8)x 4) = 576이다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어짐.   [문제] 조건  입력조건 첫째 줄에 여러개의 숫자로 구성된 하나의 문자열 S가 주어집니다.(1\u0026lt;=S의 길이 \u0026lt;=20)\n  출력조건 첫째 줄에 만들어 질 수 있는 가장 큰 수를 출력합니다.\n  입력예시\n02984\n  출력예시\n576\n  문자열 내 연산자 계산 가능 메소드  eval()\rresult = eval('(3+5)*7')\rprint(result) # 56\r- 리스트 내 item들을 하나의 문자열로 만들어주는 메소드 list = ['a', 'b', 'c'] print(''.join(list)) # print: abc\r- 리스트에 item 추가 시, 위치 선정이 가능토록하는 메소드\r# list = ['a', 'b', 'c'] list.insert(0, \u0026quot;new\u0026quot;)\rprint(list) # ['new', 'a', 'b', 'c']  sum_or_multiply.py s = input()\rresult=0\rfor n in list(s) :\rif result == 0 or n == 0 or result == 1 or n == 1 : result += int(n)\relse :\rresult *= int(n)\rprint(result)\r 모범답안 파이썬 data = input()\rresult = int(data[0])\rfor i in range(1,len(data)) :\rnum = int(data[i])\rif num \u0026lt;= 1 or result \u0026lt;= 1:\rresult += num\relse:\rresult *= num\rprint(result)\r SumOrMultiply.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class SumOrMultiply {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rString s = sc.nextLine();\rint result = 0;\rfor (int i = 0; i \u0026lt; s.length(); i++) {\rint n = Integer.parseInt(s.substring(i, i+1));\rif(result == 0 || n == 0 || result == 1 || n == 1) {\rresult += n;\r}else {\rresult *= n;\r}\r}\rSystem.out.println(result);\r}\r}\r 모범답안 자바 package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class SumOrMultiply {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rString str = sc.nextLine();\rlong result = str.charAt(0) - '0';\rfor(int i=1; i \u0026lt; str.length();i++) {\rint num = str.charAt(i) - '0';\rif (num \u0026lt;= 1 ||result \u0026lt;= 1) {\rresult += num;\r}else {\rresult *= num;\r}\r}\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  곱하는 것보다 더하는 것이 더 큰 값을 얻을 수 있다. 곱해서 0또는 1이되는 상황보다, 곱하는게 큰 값을 얻는다\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"최고의 숫자가 되기 위하여 더하기 혹은 곱하기를 진행","id":153,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"더하기 혹은 곱하기 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/sum-and-multiply/"},{"content":"prefers a to b (\u0026lsquo;b 보다 a를 더 선호\u0026rsquo;)  we are prefers apple to banana (\u0026lsquo;우리는 바나나보다 사과를 선호합니다.')\n giving birth (\u0026lsquo;출산\u0026rsquo;) = when the baby was born  when the mother was giving birth (\u0026lsquo;어머니가 출산 할때\u0026rsquo;)\n n. name (\u0026lsquo;이름을 지어주다\u0026rsquo;)  How do American Indian women name their babies? (\u0026lsquo;아메리칸 인디언 여성들은 아기의 이름을 어떻게 지어주나요?')\n compound words (\u0026lsquo;합성어\u0026rsquo;)  handphone is compound word that Consists of two word? (\u0026lsquo;handphone은 두 단어로 구성된 합성어입니다.')\n consists of ~ ('-로 구성된\u0026rsquo;)  notebook consists of many material (\u0026lsquo;노트북은 많은 재료로 구성됩니다.')\n v. believe (\u0026lsquo;믿다\u0026rsquo;) n. belief (\u0026lsquo;신뢰\u0026rsquo;)  belief is very important (\u0026lsquo;믿음은 매우 중요합니다.')\n tend to do (\u0026lsquo;경향이 있다.')  Believer is tend to pray before have a eating (\u0026lsquo;신자는 먹기 전에기도하는 경향이 있습니다 \u0026lsquo;)\n 새로운 단어  belief 신뢰\rgiving birth 신뢰\rprefers 선호하다\rtend to do 경향이 있다.\r 문법오류 Yes, each culture has using same names. → I think there are some common names used in many cultures. For example, Yujin , Suzan, and Susie.\rbackground → American Indian women (tend to) choose their babies’ names from what they saw while giving birth. = American Indian women tend to name their babies from what they saw while giving birth.\rthere are believe the stars and planets influence → because there are beliefs that the stars and plants have important influence (on their lives).\rthey believe astrology and Zodiac.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":154,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.26","uri":"https://offetuoso.github.io/blog/english/202103/20210326-english-speak/"},{"content":"Introduction (\u0026lsquo;소개, 서론\u0026rsquo;) Introduction → Body → Conclusion  This pagraph is book of Introduction (\u0026lsquo;이 단락은 서론입니다.')\n topic sentence (\u0026lsquo;주제 문장\u0026rsquo;)  this is topic sentence in paragraph (\u0026lsquo;이것은 단락의 주제 문장입니다\u0026rsquo;)\n Q. What is a must-included item when you summarize a text? (\u0026lsquo;글을 요약할때 꼭 포함되어야 하는것?')  main points, paraphrase the topic sentence\n plagiarism (\u0026lsquo;표절\u0026rsquo;)  this book has relate to rumor of plagiarism (\u0026lsquo;이 책은 표절 소문과 연루되어 있습니다\u0026rsquo;)\n customize  (1) to personalize to make sth fit for a certain purpose/situation/…\n  (2) 관습 each culture has its favorite names and naming-customs, so here are some from around the world.\n traditions vs. custom (\u0026lsquo;전통과 관습\u0026rsquo;) occupation (n) (\u0026lsquo;직업, Job보다 캐쥬얼 하지 않은 뜻\u0026rsquo;)  job categories → occupation categories main occupation My main occupation is a programmer, but I also work as a part-time teacher.\n elder (\u0026lsquo;무리의 가장큰 어른\u0026rsquo;) all in all - in general, most of the time (\u0026lsquo;전체적으로 \u0026lsquo;) 새로운 단어 custom 관습\roccupation 직업\rplagiarism 표절\r 문법오류 name’s meaning → meaning of names\rWhat did we do yesterday? / We learned about the meaning of names from many cultures (around the world)\rThird paragraph is the topic’s examples. Topic is culture’s names\r→ This text is introducing different naming cultures around the world. It gives/includes examples of Mongolian, North American Indian, Eskimo, and Russian cultures.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":155,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.25","uri":"https://offetuoso.github.io/blog/english/202103/20210325-english-speak/"},{"content":"Read the sentences (\u0026lsquo;문장 읽기\u0026rsquo;)  you must to read the sentences in book (\u0026lsquo;책에있는 문장을 읽어야합니다\u0026rsquo;)\n Read the sentences (\u0026lsquo;문장 읽기\u0026rsquo;)  you must to read the sentences in book (\u0026lsquo;책에있는 문장을 읽어야합니다\u0026rsquo;)\n some (\u0026lsquo;약간, 전체는 아니고, 아예 아닌것도 아님\u0026rsquo;)  some people who attempt to change (\u0026lsquo;변화를 시도하는 사람들\u0026rsquo;)\n 새로운 단어 passage 문구 / 통로\rsilently 잠자코, 조용히\rrepeat 반복\rintonation 말의 높낮이\rsome not all but not none\r 문법오류 I was weekends also studying English and.. --\u0026gt; I spudied during the weekends.\r--\u0026gt; I had to study during the weekends.\r(Subject Noun+ Action Verb + etc)\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":156,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.24","uri":"https://offetuoso.github.io/blog/english/202103/20210324-english-speak/"},{"content":"[문제1] 1이 될때까지 [문제] 1이 될때까지 : 문제 설명  어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n [문제] 조건  입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n make_one.py n, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  MakeOne.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"1이 될때까지 알고리즘.","id":157,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"1이 될때까지 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/make-one/"},{"content":"[문제1] 거스름돈 [문제] 거스름돈 : 문제 설명  당신은 음식점의 계산을 도와주는 점원입니다. 카운트에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈은 N은 항상 10의 배수입니다.\n [문제] 거스름돈 : 문제 해결 아이디어   최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐의 단위부터 돈을 거슬러 주면 됩니다. N원을 거슬러 줘야 할 때, 가장먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러줍니다. 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러주면 됩니다. N = 1,260일 때의 예시를 확인해 봅시다.    1,260 원을 500원부터 거슬러 준다면 아래와 같이\n    화페단위 500 100 50 10     손님이 받은 개수 2 2 1 1    [문제] 거스름돈 : 정당성 분석   가장큰 화폐단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요? 가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다. 만약 800원을 거슬러 주어야 하는데 화폐 단위가 500원 400원 100원이라면 어떻게 될까요 ? -\u0026gt; 400원 짜리 2개가 정답이됨 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 합니다.   reverse_change.py n =1260\rcount = 0 array = [500,100,50,10]\rfor coin in array:\rcount += n / coin\rn %= coin print(count)\r ReverseCharge.java package ex.Algorithm.greedy;\rpublic class ReverseCharge {\rpublic static void main(String[] args) {\rint n = 1260;\rint[] coins = {500,100,50,10};\rint count = 0;\rfor (int coin : coins) {\rcount += n/coin;\rn %= coin;\r}\rSystem.out.println(count);\r}\r}\r [문제] 거스름돈 : 시간 복잡도 분석   화폐의 종류가 K라고 할때, 소스코드의 시간복잡도는 O(K)이다. 이 알고리즘의 시간복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":158,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"거스름돈 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/reverse-charge/"},{"content":"그리디 알고리즘(탐욕법) 그리디 알고리즘이란 ?  그리디 알고리즘이란\n 그리디 알고리즘(탐욕법)은 현재상황에서 가장 좋은 것만 고르는 방법을 의미. 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 있는 능력을 요구. 그리디 해법은 그 정당성 분석이 중요. 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토 필요.   [문제 상황] 루트 노드로 부터 시작하여 가는 노드의 합을 최대로 만들고 싶습니다.  Q. 최적의 해는 무엇인가요 ?\n  Q. 단순히 매 상황에서 가장큰 값을 고른다면 어떻게 될까요?\n   일반적인 상황에서 그리디알고리즘은 최적의 해를 보장할 수 없을때가 많다. 하지만 코딩 테스트에서의 대부분의 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됨.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":159,"section":"blog","tags":["Algorithm","Greedy"],"title":"그리디 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/greedy-algorithm/"},{"content":"do you mind?  (1) Are you okay/fine with it? (\u0026lsquo;괜찮나요?') Do you mind if I change the schedule? 괜찮다면, 스케쥴을 변경해도 될까요? (2) Mind your own business. (\u0026lsquo;니 일이나 신경써.') Do you mind? 니 일이나 신경써.\n attempt to ~ ('-를 시도하다.')  they are attempt to find something 그들은 무언갈 찾으려 한다. i attempt to speaking english 나는 영어로 말하길 시도한다.\n I had a meeting ~ ('-를 만났다.')  I had a meeting with english teacher 나는 영어 선생님과 Meeting을 가졌다.(만났다.) I had a meeting with my friends 나는 친구를 만났다\n - means ~ ('-의 뜻은 -입니다\u0026rsquo;)  **my name\u0026rsquo;s means a victory ** 내 이름은 승리를 의미합니다. **\u0026lsquo;팽-하\u0026rsquo; means \u0026lsquo;펭수 하이\u0026rsquo; ** \u0026lsquo;펭-하\u0026rsquo;는 \u0026lsquo;펭수-하이\u0026rsquo;를 뜻합니다.\n a. accurate (\u0026lsquo;정확한\u0026rsquo;)  **Do you think the information on the table is accurate? ** 테이블의 정보가 정확하다고 생각하나요?\n familiar with (\u0026lsquo;익숙한\u0026rsquo;)  **familiar with the technical terms ** 기술 용어에 익숙 함\n n. accuracy (\u0026lsquo;정확\u0026rsquo;) v. intend (\u0026lsquo;의도하다\u0026rsquo;)  **I didn’t intend to offend you(her) when I laughed at your(her) new haircut. ** 당신의 새 머리를 보고 웃은 것은 마음을 상하게 할 의도는 없었어요.\n 새로운 단어 honorable contribution 명예로운 공헌\rachievement 업적\rmaterial 재료\rconversation 대화\rjudgement 판단\rnervous 긴장한\r 문법오류 one time ago → an hour ago\rI has → had a meeting with Sophia an hour ago\rI have a class with June today.\rWe call him an old-fashioned man. Olivia is meaning → Olivia means Olive and peace.\rI have heard of ~\rI’ve heard of Jack from the book, I’m also familiar with the name Charlie.\rI think the Korea column is not that accurate.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":160,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.19","uri":"https://offetuoso.github.io/blog/english/202103/20210319-english-speak/"},{"content":"Did you take a look at ~? ('-보셨나요?')  Did you take a look at the Book 책 보셨나요? Did you take a look at sky? 하늘을 보셨나요?\n I took a look at ~ (\u0026lsquo;나는 -를 보았다.')  I took a look at the book, 1 hour ago 1 시간 전에 책을 봤어요. I was took a look at sky last day 나는 어제 하늘을 봤어요\n a. impressed (\u0026lsquo;깊은 인상\u0026rsquo;) n. impression (\u0026lsquo;인상\u0026rsquo;) I’m impressed by ~ (\u0026lsquo;나는 당신의 -에 감동받았습니다.')  I’m impressed by your letter 나는 당신의 편지에 감동받았습니다. I’m impressed by your passion 나는 당신의 열정에 감동받았습니다.\n related to ~ ('-와 연관되다.')  I think, he is related to crime 그는 범죄와 관련된 것 같아요. my homework relate to math 나의 숙제는 수학과 관련있다.\n v. skim  He always skimmed the book 그는 항상 책을 훑어보았다.\n v. scan a. intermediate (중급의) beginners → intermediate → high/advanced level\r  He was in intermediate class, 3 month ago 그는 3개월 전에 중급반이였다.\n 영어 8품사 사전 표기법 \rn. 명사 (noun [naun] )\r-모든 사람, 사물, 동물의 이름을 나타내는 단어\r-문장에서 주어, 보어, 목적어가 된다.\r*C : 가산명사\r*U : 불가산명사\r*CU : 주로 가산명사\r*UC : 주로 불가산명사\r*sing. : 단수형\r*pl. : 복수형\r*n.pl. : 복수명사\r*fem. : 여성형\r*neg. : 부정형\rpron. 대명사 (pronoun [próunàun] )\r-인칭대명사: I, my, me, mine, myself, she, her, he, his, him 등\r-지시대명사: it, this, these, that, those 등\r*obj : 목적격\r*poss : 소유격\rv. 동사 (verb [vəːrb] )\rvtr. 타동사 (Transitive Verb)\rvi. 자동사 (Intransitive Verb)\r-동작이나 상태를 나타내는 단어\r-be동사 : am, are, is, was, were 등\r-일반동사 : be동사와 조동사를 제외한 나머지 동사\r*auxil. v. : 조동사 - can, may, will, should, must 등\r*p. : 과거형\r*p.p. : 과거분사형\r*pres.p. : 현재분사\r※목적어로 구분하는 자동사와 타동사\r자동사 : 목적어를 취하지 않는 동사\r타동사 : 목적어를 취하는 동사\r동사뒤에 목적어(영향을 받는 사람이나 사물)(이)가 필요한지 여부에 따라서\r자동사(Intransitive Verb)와 타동사(Transitive Verb)로 구분할 수 있습니다. adj. (or a.) 형용사 (adjective [ǽdʒiktiv] )\r-명사나 대명사를 수식하거나 보충 설명하는 단어\r-우리말에서 보통 \u0026lt; ~ㄴ, ~한\u0026gt; 으로 해석되는 단어\radv. (or ad.) 부사 (adverb [ǽdvəːrb] )\r-형용사, 다른 부사, 동사, 문장전체를 수식하는 단어\r-① 형용사 / 다른 부사 수식 : This is a very very delicious cake.\r-② 동사 수식 : She can run fast.\r-③ 문장 전체 수식 : Luckily, I passed the exam.\rprep. 전치사 (preposition [prèpəzíʃən] ) -명사나 대명사 앞에 쓰여서 장소, 시간 등을 나타내는 단어\r-in, at\r*pref. : 접두사\r*suf. : 접미사\rconj. 접속사 (conjunction [kəndʒΛŋkʃən] )\r-단어와 단어, 문장과 문장 등을 연결하는 단어\r-when, or, and\rinterj. (or int.) 감탄사 (interjection [ìntərdʒékʃən] )\r-놀람, 기쁨 등 감정을 나타내는 단어\r-Oh, Wow\r출처: https://fireball.tistory.com/409 [What's up]\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":161,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.17","uri":"https://offetuoso.github.io/blog/english/202103/20210317-english-speak/"},{"content":"I use ~ (\u0026lsquo;난 -를 사용한다.')  I use Java 난 자바를 사용한다. I use Korean 난 한국어를 사용한다.\n I’m preparing ~ ('-를 준비중입니다\u0026rsquo;)  ** I’m preparing to change job ** 나는 이직을 준비중입니다. ** I’m preparing to party in my house ** 우리 집에서 파티를 준비하고 있어요.\n ~ is intense ('-이 ~빡세다~힘들다.')\n Work is not intense 일은 힘들지 않다. Always Study is intense 공부는 힘들다.\n I learned ~ (\u0026lsquo;나는 -배웠다\u0026rsquo;)  I learned computer science in my University 나는 대학에서 컴퓨터를 전공했다. I learned baking bread 나는 빵굽기를 배웠다.\n I want to ~ ('-하고 싶습니다.')  I want to hold your hand 당신의 손을 잡고 싶습니다. I want to change job! 이직하고 싶어요!\n I\u0026rsquo;m good at ~ (\u0026lsquo;나는 -잘해\u0026rsquo;)  I\u0026rsquo;m good at make smile 나는 미소를 잘 짓습니다. I\u0026rsquo;m good at cleaning my room 나는 내방 청소를 잘해요\n I\u0026rsquo;m about to ~ (\u0026lsquo;나는 -할 예정이다\u0026rsquo;)  I\u0026rsquo;m about to go to bed 나는 자러갈 예정이다. I\u0026rsquo;m about to study english 나는 영어공부를 할 예정이다.\n Benefits \u0026amp; Drawbacks (장점 \u0026amp; 단점)\rTake your time (천천히) Achievement (성취감)\rWorking late (야근) Intense (빡센) Regular job = 정규직\rStable job = 안정감 있는 직업 Objective / Goal = 목표\rRegret = 후회\rAge Limit = 나이 제한\rVaccine = 백신\rPandemic = 전국적인 유행병\rGovernance = 통치  본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":162,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.16","uri":"https://offetuoso.github.io/blog/english/202103/20210316-english-speak/"},{"content":"I’m used to ~ (\u0026lsquo;난 -에 익숙해\u0026rsquo;)  I\u0026rsquo;m used to you 난 너에게 익숙해 I\u0026rsquo;m used to working overtime 난 야근에 익숙해\n I\u0026rsquo;m afraid ~ (\u0026lsquo;유감스럽지만,')  I\u0026rsquo;m afraid Rainy outside 유감이지만, 밖에 비가 오는 것 같아 **I\u0026rsquo;m afraid ** 유감이지만, 밖에 비가 오는 것 같아\n I’m working on ~ (\u0026lsquo;지금 -를 하고있어\u0026rsquo;)  I’m working on my English speaking 난 영어 말하기를 공부하고 있어 i\u0026rsquo;m working on study Algorithm 난 알고리즘을 공부하고 있어\n I’m ~ is bad (\u0026lsquo;난 -가 안좋다\u0026rsquo;)  I’m health is bad 난 건강이 안좋다 I\u0026rsquo;m english is bad 난 영어를 잘 못한다.\n My girlfriend is another event. → My girlfriend had a personal schedule (She went out to hang out with her friends.)\rI’m English is tiny → My English is bad. / I’m not that good at English. → I’m still learning English. / I’m working on my English speaking.\r(Q. What is the charm of skateboarding?) A. other skateboarders communication → (full sentence) I think the charm of skateboarding is that I can ride skateboards with other skateboarders. / I enjoy riding skateboards with other people → (shorter) Communicating with other skateboarders is the best. / the greatest charm. skateboarding stage → spot\rshortboard and longboard and skateboard → I started with the shortboard and then the longboard and then the skateboard. / I started with the shortboard and then the longboard. Now I can ride the standard skateboard as well.\rIsn’t/Wasn’t living in other countries tough?\rhave an access to\rhang out (Google HangOut / Meet) - to meet someone or to play with someone, usually friends.\rMy hobby is skateboarding. → I enjoy(love) skateboarding in my free time.\rI started in-door climbing recently. / I’m into sth. = having a great interest in sth\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":163,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.15","uri":"https://offetuoso.github.io/blog/english/202103/20210315-english-speak/"},{"content":"Nothing on this page will be visible. This file exists solely to respond to /search URL.\nSetting a very low sitemap priority will tell search engines this is not important content.\n","description":"","id":164,"section":"","tags":null,"title":"Search Results","uri":"https://offetuoso.github.io/search/"}]