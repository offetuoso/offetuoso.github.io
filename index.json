[{"content":"다양한 연관관계 매핑  목차    연관관계 매핑시 고려사항 3가지 다대일 [N:1] 일대다 [1:N] 일대일 [1:1] 다대다 [N:M]   연관관계 매핑시 고려사항 3가지    다중성 단방향, 양방향 연관관계의 주인   다중성    다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany (실무에서 사용X)    애매한 경우 반대의 경우를 생각해 보면 된다. 다대일의 반대는 일대다, 일대일의 반대는 일대일, 다대다의 반대는 다대다.  단방향, 양방향    테이블  외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음   객체  참조용 필드가 있는 쪽으로 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향     연관관계의 주인   테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A-\u0026gt;B, B-\u0026gt;A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래 키를 관리할 곳을 지정해야함 연관관계의 주인 : 외래 키를 관리하는 참조 주인의 반대편 : 외래 키에 영향을 주지않음, 단순 조회만   다대일 [N:1]  다대일 단방향   Member랑 Team이 있다면 1:N중 N인 Member에 외래 키가 있어야합니다.\n 다대일 단방향 정리   가장 많이 사용하는 연관관계 다대일의 반대는 일대다    Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\rpublic void changeTeam(Team team) {\rthis.team = team;\rteam.getMembers().add(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Team.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 다대일 양방향   Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\rpublic void changeTeam(Team team) {\rthis.team = team;\rteam.getMembers().add(this);\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Team.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;) // 1:N 관계에서 상대편(Member)에 team으로 매핑이 되어있는 것 이라고 지정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic void addMember(Member member){\rmember.setTeam(this);\rmembers.add(member);\r}\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 다대일 양방향 정리   외래 키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발   일대다 [1:N]  일대다 단방향   밑밥을 깔자면 강의를 하시는 김영한님은 이 모델을 추천하지 않는다고 하며, 표준에서 제공하기 때문에 강의에 포함시켰다 하였습니다.\n  팀과 맴버가 있는데 팀을 중심으로 연관관계를 작성하겠다 하는 것입니다. 이전에 N에 연관관계의 주인을 둔다고 하였지만 반대가 되는 상황입니다.\n  팀은 맴버를 알고 싶은테, 맴버는 팀을 알고 싶지 않을때. 개발하다 보면 언젠가는 만나 볼 수 있는 모델입니다.\n  테이블 설계를 보면 N에 무조건 외래 키를 가지게 됩니다. 생각해 보면 팀에 외래 키가 있는 순간 1:N이 아니게 됩니다.\n  Team의 members가 연관관계의 주인이 된다면, Team을 수정하게되면 Member 또한 수정하게 됩니다.\n  Team.java - 연관관계의 주인을 여기에 둠\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r\u0026quot;, members=\u0026quot; + members +\r'}';\r}\r}\r  Member.java - id, name 이외 소스 정리\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  JpaMain.java\n  Member member = new Member();\rmember.setUsername(\u0026quot;member1\u0026quot;);\rem.persist(member);\rTeam team = new Team();\rteam.setName(\u0026quot;teamA\u0026quot;);\rteam.getMembers().add(member); //팀의 members에 member를 추가\rem.persist(team);\rtx.commit();\r  Team 저장할때, TEAM_ID와 NANE은 저장하면 되지만, 외래 키는 TEAM이 아닌 MEMBER에 있기 때문에, 저장할 방법이 없기 때문에 MEMEBER 테이블을 업데이트 하는 수 밖에 없습니다. 업데이트 문을 한번더 실행하기에 성능상에 이슈는 아니여도 조금의 불이익은 있습니다.\n  실무에서 이 모델을 사용하게되면 실제 Member 테이블에 저장만 했을 뿐인데 내가 수정하지 않은 테이블에 Update Sql이 찍히게 되고 혼돈에 빠지게 됩니다.\n  만약 지금처럼 Team에서 Member로 접근이 필요한 경우 다대일의 양방향 연관관계 매핑 사용을 추천드립니다.\n 일대다 단방향 정리   일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조 @JoinColumn을 꼭 하용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함) 일대다 단방향 매핑의 단점  엔티티가 관리하는 외래 키가 다른 테이블에 있음 연관관계 관리를 위해 추가로 Update sql 실행   일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자   일대다 양방향    이런 매핑은 공식적으로 없다. @JoinColumn(insertable=false, updateable=false) 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 다대일 양방향을 사용하자    Team.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\t// 연관관계의 주인\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  Member.java\n @Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false) // 연관관계의 주인과 같지만, 인서트, 업데이트 사용안함으로 읽기전용으로 사용\rprivate Team team;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r 일대일 [1:1]  일대일 관계    일대일 관계는 그 반대도 일대일 주 테이블이나 대상 테이블 중에 외래 키 선택 가능  주 테이블에 외래 키 대상 테이블에 외래 키   외래 키에 데이터베이스 유니크 제약조건 추가   일대일 : 주 테이블에 외래 키 단방향   회원은 사물함 하나를 가질 수 있고 그리고 사물함도 하나의 맴버를 가질 수 있습니다. 이런 룰을 가지고 있을 때, Member 테이블을 주 테이블로 생각하고 연관관계의 주인을 Member로 지정.\n 일대일 : 주 테이블에 외래 키 단방향 정리   다대일(@ManyToOne) 단방향 매핑과 유사    Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Locker.java\n package relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Locker {\r@Id @GeneratedValue\r@Column(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  JpaMain.java 은 지우고 애플리케이션을 실행한다.\n 일대일 : 주 테이블에 외래 키 양방향   Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Locker.java\n package relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Locker {\r@Id @GeneratedValue\r@Column(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\r@OneToOne(mappedBy=\u0026quot;locker\u0026quot;)\rprivate Member member;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 일대일 : 주 테이블에 외래 키 양방향 정리   다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인 반대편은 mappedBy 적용   일대일 : 대상 테이블에 외래 키 단방향   Member 객체를 연관관계의 주인으로 두고 Locker객체를 가지고 LOCKER 테이블에 MEMBER_ID를 관리 하는 방법은 없고 지원도 안해줍니다.\n 일대일 : 대상 테이블에 외래 키 단방향 정리   단방향 관계는 JPA에서 지원안함 양방향 관계는 지원   일대일 : 대상 테이블에 외래 키 양방향   주 테이블을 Member로 생각하지만, 외래 키는 대상 테이블에 있는경우. 외래 키가 있는 대상 테이블을 주 테이블로 매핑\n  이것을 반대로 뒤집은 것과 같음. 1:1 관계를 정리하면 내것은 내가 관리\n 일대일 : 외래키는 어떤 객체가 가져야 할까  매우 민감한 주제이며 DBA와 싸울수도있음. 일대일 관계는 MEMBER에 외래 키가 있든 LOCKER에 있든 어떠한 방법을 써도 연관관계가 유효 합니다.   DBA이라면, DB 설계를 쉽게 바꿀 수 없기 때문에 미래를 대비해서 Locker에 외래 키를 두어 나중에 유니크 제약조건만 제거하면, 한명의 회원이 여러 개의 Locker를 가질 수 있도록 설계를 생각할 것입니다.\n  만약 반대로 MEMBER에 외래 키가 있는 경우 한명의 MEMBER가 여러 Locker를 가질 수 있도록 설계를 변경 한다면 LOCKER에 컬럼을 추가하고 코드 수정이 필요합니다 또한 MEMBER의 외래 키는 의미가 없으니 지워지게 됩니다.\n  또 비즈니스 로직 상에 Locker에 여러명의 Member가 있을 수 있다면, Member에 외래키가 있는 상태가 맞게 됩니다.\n  여기 까지가 DBA가 비즈니스 로직에 변경 또는 미래의 변화에 대비하기 위해 이렇게 생각할 수 있다면 ORM을 사용하는 개발자 입장에서는 Member에 Locker가 있는것이 성능에서나 여러가지 측면에서 장점이 있습니다. 어떠한 장점이 있냐면,\n  Member가 Locker를 가지고 있지 않으면 Null 아니면 Locker가 있는것이고 Member를 더 많이 조회하기 때문에 Locker가 Member를 가지는 것보다 좋습니다.\n  Member를 조회할때 Locker에 의해 분기 되는 로직이 있을때, 대부분 Member를 조회하여야 되기 때문에 이미 Locker를 가지고 있기 때문에 DB쿼리 하나로 Member를 가져왔을때 이미 Locker까지 조회가 됩니다.\n  이런 모든 것을 고려하여 설계를 해야합니다.\n 일대일 정리   주 테이블에 외래 키  주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자 선호 JPA 매칭 편리 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점 : 값이 없으면 외래 키에 null 허용       대상 테이블에 외래 키  대상 테이블에 외래 키가 존재 전통적인 DBA 선호 장점 : 주 테이블과 대상 테아블을 일대일에서 다대다 관계로 변경할 때 테이블 구조 유지 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 (추후 설명)      ORM 개발자 입장에서는 주 테이블에 외래 키가 있는 것이 바람직하지만, DBA와 협의가 잘되어야 한다.\n 다대다 [N:M]   실무에서는 쓰면 안된다고 보면 됩니다. JPA가 매핑을 지원하기 때문에 정리\n 다대다    괸계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계룰 표현할 수 없음 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함 @ManyToMany 사용 @JoinTable로 연결 테이블 지정 다대다 매핑 : 단방향, 양방향 가능    다대다 테이블 관계\n  객체인 Member는 ProductList를 가질 수 있고 Product는 MemberList를 가질 수 있음 그렇기 때문에 딜레마가 생김.\n  객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능\n  중간에 조인 테이블을 사용하여 사용\n  Product.java\n package relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.List;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\r@ManyToMany\r@JoinTable(name=\u0026quot;MEMBER_PRODUCT\u0026quot;)\rprivate List\u0026lt;Product\u0026gt; products;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  JpaMain - 내용지우고 애플리케이션 재시작\n  PRODUCT 테이블과 MEMBER_PRODUCT 테이블이 생성되는걸 확인 할 수 있습니다.\n  단방향을 양방향으로 바꾸려면, Product에 members를 추가하면 됩니다.\n  Product.java\n package relativemapping;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\rimport javax.persistence.ManyToMany;\rimport java.util.List;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\r@ManyToMany(mappedBy = \u0026quot;products\u0026quot;)\rprivate List\u0026lt;Member\u0026gt; members;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 다대다 매핑의 한계   편리해 보이지만 실무에서 사용X 연결 테이블이 단순히 연결만 하고 끝나지 않음 주문시간, 수량 같은 데이터가 들어 올 수 있음    중간 테이블 사용시 조인 쿼리도 예상치 못하게 잘못된 쿼리도 나갈 수 있음\n 다대다 한계 극복   연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) 비즈니스로직상 복잡하기 때문에 연결용 테이블을 쓰기는 불편함과 어려움이 있어 엔티티로 만들어 사용하는 것이 그나마 좋은 방법입니다.     ManyToMany -\u0026gt; @OneToMany, @ManyToOne    중간에 엔티티를 하나더 생성. 예를 들면 MemberProduct.java를 만들어 보겠습니다.\n  MemberProduct.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;)\rpublic class MemberProduct {\r@Id @GeneratedValue\rprivate Long id;\r@ManyToOne\r@JoinColumn(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Member member;\r@ManyToOne\r@JoinColumn(name = \u0026quot;PRODUCT_ID\u0026quot;)\rprivate Product product;\r@Column(name = \u0026quot;ORDERAMOUNT\u0026quot;)\rprivate int orderAmount;\r@Column(name = \u0026quot;ORDERCOUNT\u0026quot;)\rprivate int orderCount;\rpublic Member getMember() {\rreturn member;\r}\r@Column(name = \u0026quot;ORDERDATE\u0026quot;)\rprivate LocalDate orderDate;\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic Product getProduct() {\rreturn product;\r}\rpublic void setProduct(Product product) {\rthis.product = product;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getId() {\rreturn id;\r}\r}\r  @ManyToOne으로 Member와 Product를 생성합니다.\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\rimport java.util.concurrent.locks.Lock;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@ManyToOne\r@JoinColumn(name= \u0026quot;TEAM_ID\u0026quot;, insertable = false, updatable = false)\rprivate Team team;\r@OneToOne\r@JoinColumn(name = \u0026quot;LOCKER_ID\u0026quot;)\rprivate Locker locker;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;MemberProduct\u0026gt; memberProducts = new ArrayList\u0026lt;\u0026gt;();\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  Member에서는 @OneToMany로 mappedBy = \u0026ldquo;member\u0026rdquo; 옵션을 지정한 List memberProducts 를 추가 합니다.\n  Product.java\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Product {\r@Id @GeneratedValue\rprivate Long id;\r@OneToMany(mappedBy = \u0026quot;product\u0026quot;)\rprivate List\u0026lt;MemberProduct\u0026gt; memberProducts;\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  Product에도 @OneToMany로 mappedBy = \u0026ldquo;member\u0026rdquo; 옵션을 지정한 List memberProducts 를 추가 합니다.\n  JpaMember.java - 애플리케이션을 재시작 해봅니다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"다양한 연관관계 매핑","id":0,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 다양한 연관관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapping-various-associations/"},{"content":"실전 예제 2 - 연관관계 매핑 시작 요구사항 분석   실전 예제 1 요구사항 분석과 기본 매핑에서 테이블에 맞춘 설계를 했던 것에 연관 관계 매핑을 적용 시켜 보도록 하겠습니다.\n 테이블 구조   테이블 구조는 이전과 같다.\n 객체 구조   참조를 사용하도록 변경\n  OrderItem과 Item에서 N:1이면서 화살표가 OrderItem에서 Item으로 단방향인 것을 알 수 있는데, 이는 주문된 아이템(OrderItem) 입장에서는 어떠한 아이템(Item)인지 알아야하지만, 아이템 입장에서는 통계 같은 프로그램을 하지 않는 이상 이 아이템이 어떠한 아이템 주문이 되었는지 알 필요가 없습니다.\n  또한 실제 개발을 할때는 Member에 굳이 Orders를 가지지 않는 것이 바람직하다고 합니다. 객체 지향적으로는 Member에 Orders가 있는게 맞지만, Member에 Orders 그리고 Orders에서 Member와 OrderItem을 참조하며 모든 연관관계를 추가 하지 말고 (추가 하다보면 끝이 없습니다.) 적절하게 관심사를 분리하여 Order에 Member를 파라미터로 바로 Order에서 Member와 OrderItem을 참조하면 됩니다.\n  현재는 예제이기 때문에, Member에 Orders를 추가하여 앙뱡향 연관관계를 실습해 보겠습니다.\n 단방향 매핑 추가  우선 단방향 연관관계 매핑부터 진행 하도록 하겠습니다.\n  Order.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne\rprivate Member member;\r}\r  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member {\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\r}\r  OrderItem.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem {\rpublic OrderItem(){}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne\rprivate Order order;\r@ManyToOne\rprivate Item item;\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Item {\rpublic Item(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\r}\r 양방향 매핑 추가  단방향 매핑을 하였으니 Member에서 Order로 Order에서 OrderItem 으로 역방향 매핑을 추가하도록 하겠습니다. 그리고 setter와 getter 또한 추가 하도록 하겠습니다.\n  Order.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport jpabasic.jpashop.domain.Member;\rimport java.time.LocalDateTime;\rimport java.util.ArrayList;\rimport java.util.Date;\rimport java.util.List;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\r@ManyToOne\rprivate Member member;\r@OneToMany(mappedBy = \u0026quot;order\u0026quot;)\rprivate List\u0026lt;OrderItem\u0026gt; orderItems = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\rpublic Member getMember() {\rreturn member;\r}\rpublic void setMember(Member member) {\rthis.member = member;\r}\rpublic List\u0026lt;OrderItem\u0026gt; getOrderItems() {\rreturn orderItems;\r}\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\r}\r  Member.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Member {\rpublic Member(){}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\r@OneToMany(mappedBy = \u0026quot;member\u0026quot;)\rprivate List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); //관례상 초기 값을 두어 NullPointer Exception을 방지\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rpublic void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\rpublic List\u0026lt;Order\u0026gt; getOrders() {\rreturn orders;\r}\rpublic void setOrders(List\u0026lt;Order\u0026gt; orders) {\rthis.orders = orders;\r}\r}\r  OrderItem.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class OrderItem {\rpublic OrderItem(){\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\rprivate int orderPrice;\rprivate int count;\r@ManyToOne\rprivate Order order;\r@ManyToOne\rprivate Item item;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\rpublic Order getOrder() {\rreturn order;\r}\rpublic void setOrder(Order order) {\rthis.order = order;\r}\rpublic Item getItem() {\rreturn item;\r}\rpublic void setItem(Item item) {\rthis.item = item;\r}\r}\r  Item.java\n package jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.util.List;\r@Entity\rpublic class Item {\rpublic Item(){\r}\rpublic Item(String name, int price, int stockQuantity) {\rthis.name = name;\rthis.price = price;\rthis.stockQuantity = stockQuantity;\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r 연관관계 편의 메소드 추가  JpaMain.java 에서\n  메소드 생성을 하여 Order의 addOrderItem 편의 메소드 작성\n  Order.java\n \t...\rpublic void setOrderItems(List\u0026lt;OrderItem\u0026gt; orderItems) {\rthis.orderItems = orderItems;\r}\r...\r  Order.java\n \t...\rpublic void addMember(Member member) {\rthis.member = member;\rmember.getOrders().add(this);\r}\r...\r  할 수 있다면 최대한 단방향으로 개발하여도 상관은 없으나 이후 복잡한 JPQL등 사용할때 그때 가서 고려해도 상관 없다. 그렇기 때문에 단방향 설계를 잘하는 것이 중요하다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"연관관계 매핑 시작","id":1,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 실전 예제 2 - 연관관계 매핑 시작","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-2/"},{"content":"Database C:/Users/user/dbname not found, either pre-create it or allow remote database creation 오류 발생 문제  H2 데이터베이스 신규 생성 및 연결시 아래 오류가 나오며 생성이 안되는 경우\n Database `C:/Users/user/dbname` not found, either pre-create it or allow remote database creation\r 해결방법   C:/Users/user/ 경로에 dbname.mv.db 파일을 생성 jdbc:h2:~/dbname을 입력후 연결을 해본다.(처음 생성시에만)\n- 이후 jdbc:h2:tcp://localhost/~/dbname 으로 접속   ","description":"Database `C:/Users/offetuoso/jpashop` not found, either pre-create it or allow remote database creation","id":2,"section":"blog","tags":["Troubleshooting"],"title":"Database `C:/Users/user/dbname` not found, either pre-create it or allow remote database creation","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/database/h2/h2-create-db/"},{"content":"연관관계 매핑   테이블에 맞춰서 외래키를 가져오면서 설계하는 방식이 아닌 order.getMember()이런식으로 연관관계를 맺어서 좀더 객체지향 식으로 설계할 수 있는지 알아보겠습니다. 여태 까지는 어려움이 없었겠지만, 관계형 DB와 객체지향 사이에서 오는 간극이 크고 각각의 패러다임이 다르기 때문에 어려움이 있습니다.\n 목표    객체와 테이블 연관관계 차이를 이해 객체의 참조와 테이블의 외래 키를 매핑 용어 이해  방향(Direction) : 단방향, 양방향 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)의 이해 연관관계의 주인(Owner) : 객체의 양방향 관계는 괸리 주인이 필요     목차    연관관계가 필요한 이유 단방향 연관관계 양방향 연관관계와 연관관계의 주인 실전예제 - 2. 연관관계 매핑 시작   연관관계가 필요한 이유  예제 시나리오   회원과 팀이 있다. 회원은 하나의 팀에만 소속 될 수 있다. 회원과 팀은 다대일 관계다. 회원(n:1)팀   객체를 테이블에 맞추어 모델링  (연관관계가 없는 객체)\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long teamId;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\rpublic Long getTeamId() {\rreturn teamId;\r}\rpublic void setTeamId(Long teamId) {\rthis.teamId = teamId;\r}\r}\r  Team.java\n package relativemapping;\rimport javax.persistence.Column;\rimport javax.persistence.Entity;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  JpaMain.java\n package relativemapping;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;relavicemapping\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;relativemapping\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;!--\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.MySQL5Dialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert relativemapping.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r  console\n Hibernate: drop table Member if exists\rHibernate: drop table Team if exists\rHibernate: drop sequence if exists hibernate_sequence\rHibernate: create sequence hibernate_sequence start with 1 increment by 1\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rTEAM_ID bigint,\rUSERNAME varchar(255),\rprimary key (MEMBER_ID)\r)\rHibernate: create table Team (\rTEAM_ID bigint not null,\rNAME varchar(255),\rprimary key (TEAM_ID)\r)\r  테이블 구조를 따라 객체를 만들면 외래키를 포함하게 되는 것을 볼 수있습니다. 문제점이 무엇이냐면,\n  JpaMain.java\n \t...\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeamId(team.getId());\rem.persist(member);\rtx.commit();\r...\r  member.setTeamId()가 member.setTeam()으로 객체 자체를 참조하여 가져올 수 있다면 좀더 객체지향적인 방법이 될꺼같습니다.\n  지금 상황은 외래키 식별자를 직접 다루게 되는데 조회할때도 이슈가 있습니다.\n  JpaMAin.Java\n \t...\rMember findMember = em.find(Member.class, member.getId());\rLong findTeamId = findMember.getTeamId();\rTeam findTeam = em.find(Team.class, findTeamId);\r...\r  맴버를 조회하고 그 맴버가 속한 팀을 가져오고 싶을때 찾은 맴버에서 TeamId를 이용해 Team을 찾아야 하는 번잡스러움이 있습니다.\n 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력관계를 만들 수 없다.   테이블은 외래키 키로 조인 을 사용해서 연관된 테이블을 찾는다. 객체는 참조를 사용해서 연관된 객체를 찾는다. 테이블과 객체 사이에는 이런 큰 간격이 있다.   단방향 연관관계  객체 지향 모델링  (객체 연관관계 사용)\n  Member.java\n package relativemapping;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\rpublic Member(Long id, String username){\rthis.id = id;\rthis.username = username;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;USERNAME\u0026quot;)\rprivate String username;\r//@Column(name = \u0026quot;TEAM_ID\u0026quot;)\r//private Long teamId;\r@ManyToOne //Member 입장에서 Member가 N 팀이 1, 1팀에 여러 맴버가 있을 수 있다.\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;) // 조인할 컬럼 명\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUsername() {\rreturn username;\r}\rpublic void setUsername(String username) {\rthis.username = username;\r}\r}\r  관계가 먼지  @ManyToOne //Member 입장에서 Member가 N 팀이 1, 1팀에 여러 맴버가 있을 수 있다. 조인하려는 컬럼은  @JoinColumn(name = \u0026ldquo;TEAM_ID\u0026rdquo;) // 조인할 컬럼 명\n 객체 지향 모델링  (ORM 매핑)\n 객체 지향 모델링  (연관관계 저장)\n  JpaMain.java\n  // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 단방향 연관관계 설정, 참조 저장\r// 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\r// 조회 Member findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r  findMember.getTeam(); 을 이용하여 Team을 객체 지향 답게 레퍼런스 들을 가져 올수 있는것을 확인 할 수 있었습니다.\n  영속성 컨텍스트 1차 캐시에 추가되어있기 때문에 select 하는 쿼리가 보이지 않지만, select 하는 쿼리도 보고싶다면\n  // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 단방향 연관관계 설정, 참조 저장\r// 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\r// 조회 Member findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r  Jpa가 Member와 Team을 조인하여 한번에 가져온것을 알 수 있습니다.\n  Member.java\n \t...\r@ManyToOne(fetch = FetchType.LAZY) //default : fetch = FetchType.EAGER\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\rpublic Team getTeam() {\rreturn team;\r}\rpublic void setTeam(Team team) {\rthis.team = team;\r}\r...\r  ManyToOne의 fetch default 옵션은 FetchType.EAGER 이지만, fetch = FetchType.LAZY 로 변경하면\n  select 문을 분리하여, 각각 조회해 오는 것을 알 수 있습니다.\n  만약 Team을 변경한다면\n  JpaMain.java\n // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rTeam teamB = new Team();\rteamB.setName(\u0026quot;TeamB\u0026quot;);\rem.persist(teamB);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\rmember.setTeam(teamB);\rem.persist(member);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\r// 조회\rMember findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r  Update 문을 통해 Member의 TEAM_ID 즉 외래키가 업데이트 되는 것을 확인할 수 있습니다.\n 양방향 연관관계  양방향 연관관계와 연관관계의 주인 1 - 기본 양방향 매핑  Member에서 Team을 불러올수 있지만 Team에서 Member를 가져올 수는 없습니다. 현재 Team의 속성에도 추가 되어있지 않고, 연관관계도 없기 때문에 데이터 또한 없습니다. 양방향 매핑 이미지를 보면 Member에서 Team으로 Team에서 Member로 레퍼런스만 넣어둔 다면 가능한데 이런것을 양방향 연관관계 라고 합니다.\n  양방향 객체 연관관계는 변화가 있었지만 테이블 연관관계는 변함이 없습니니다.\n  MEMBER입장에서 TEAM을 가져올때는 MEMBER의 TEAM_ID로 TEAM을 조인해서 가져오면 되고 TEAM입장에서 MEMBER을 가져올때는 MEMBER의 TEAM_ID 중 나의 TEAM_ID를 가지고 있는 회원들만 조인하여 가져오면 됩니다.\n  테이블의 연관관계는 TEAM_ID 라는 외래키 하나로 양방향 연관관계가 됩니다. 테이블에선 양방향이라는 개념이 없고 외래키를 사용하여 양쪽의 연관을 다 알수 있는 것입니다.\n  문제는 객체입니다. Member는 Team을 가지고 있고 Team에서 Member로 갈 수 있는 방법이 없었습니다.\n  Team에 List 타입의 members를 넣어줘야 양쪽으로 참조하여 갈 수 있습니다.\n  테이블은 외래키 하나로 양쪽을 참조할 수 있지만, 객체는 Team team과 List members를 추가해 줘야 양쪽을 참조할 수 있는것이 테이블과 객체의 가장큰 차이점 입니다.\n  Team.java - members 추가\n package relativemapping;\rimport javax.persistence.*;\rimport java.util.ArrayList;\rimport java.util.List;\r@Entity\rpublic class Team {\rpublic Team(){\r}\rpublic Team(Long id, String username){\rthis.id = id;\rthis.name = name;\r}\r@Id @GeneratedValue\r@Column(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;NAME\u0026quot;)\rprivate String name;\r@OneToMany(mappedBy = \u0026quot;team\u0026quot;) // 1:N 관계에서 상대편(Member)에 team으로 매핑이 되어있는 것 이라고 지정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\rpublic List\u0026lt;Member\u0026gt; getMembers() {\rreturn members;\r}\rpublic void setMembers(List\u0026lt;Member\u0026gt; members) {\rthis.members = members;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  JpaMain.java - Team에 2명의 유저를 넣고, Team을 조회해서 Team의 모든 유저들을 조회\n  // 저장\r// 팀 저장\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\r// 회원 저장\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeamId(team.getId());\rmember.setTeam(team); // 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member);\rMember member1 = new Member();\rmember1.setUsername(\u0026quot;Member2\u0026quot;);\r//member.setTeamId(team.getId());\rmember1.setTeam(team); // 저장한 팀을 setTeam을 하게 되면 조회할때 Team의 TEAM_ID를 외래키로 사용하게 됩니다.\rem.persist(member1);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\r// 해당 소스가 없으면, 영속 컨텍스트의 1차 캐시에서 바로 가져오기 때문에 select 쿼리가 나오지 안습니다.\rMember findMember = em.find(Member.class, member.getId());\r//Long findTeamId = findMember.getTeamId();\r//Team findTeam = em.find(Team.class, findTeamId);\rTeam findTeam = findMember.getTeam();\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;findUser = \u0026quot;+m.getUsername());\r}\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+findTeam.getName());\rtx.commit();\r 양방향 매핑  (반대 방향으로 객체 그래프 탐색)\n \t// 조회\rTeam findTeam = em.find(Team.class, team.getId());\rint memberSize = findTeam.getMembers().size() //역방향 조회\r  작성했던 코드를 보며 궁금증이 생기는데\n  Member.java\n  @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;)\rprivate Team team;\r  Team.java\n  @OneToMany(mappedBy = \u0026quot;team\u0026quot;) private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r  둘의 차이는 멀까 어떠한 것은 JoinCoulmn이고 어떠한것은 mappedBy를 쓰는걸까\n 연관관계의 주인과 mappedBy   mappedBy = JPA의 첫번째 시련(C의 포인터 같은..) mappedBy는 처음에는 이해하기 어렵다. 객체와 테이블간에 연관관계를 맺는 차이를 이해해야한다.   객체와 테이블의 관계를 맺는 차이   객체 연관관계 = 2개  회원 -\u0026gt; 팀 연관관계 1개 (단방향) 팀 -\u0026gt; 회원 연관관계 1개 (단방향)       Member 에서 Team team(참조)을 이용해 Team으로 가는 연관관계 1개 Team 에서 List Members(참조)를 이용해 Member로 가는 연관관계 1개     테이블 연관관계 = 1개  회원 \u0026lt;-\u0026gt; 팀의 연관관계 1개 (양방향)      TEAM_ID를 이용해 조인을 하면 MEMBER에서 TEAM을 알 수 있고, TEAM에서도 팀에 포함된 MEMBER들을 알 수 있습니다.\n 객체의 양방향 관계   객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다. 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 반들어야 한다.   테이블의 양방향 연관관계   테이블은 외래 키 하나로 두 테이블의 연관관계를 관리 MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐 (양쪽으로 조인할 수 있다.)   -- MEMBER 관점\rSELECT * FROM MEMBER M\rJOIN TEAM T ON M.MEMBER_ID = T.MEMBER_ID;\r-- TEAM 관점\rSELECT * FROM TEAM T\rJOIN MEMBER M ON T.MEMBER_ID = M.MEMBER_ID;\r 둘 중 하나로 외래 키를 관리해야 한다.  테이블의 MEMBER의 TEAM_ID를 변경하기 위해서 Member 객체의 team 을 수정해야 할지, Team객체의 members를 수정해야할지 애매한 점이 생깁니다. 테이블 입장에서는 어떠한 객체에서 TEAM_ID 외래키를 Update를 해도 다르지 않으니까요. 이러한 아이러니한 점을 해결하기 위해 연관관계의 주인이라는 개념이 사용됩니다.\n 연관관계의 주인  양방향 매핑 규칙\n 객체의 두 관계중 하나를 연관관계의 주인으로 지정 연관관계의 주인만이 외래 키를 관리 (등록, 수정) 주인이 아닌 쪽은 읽기만 가능 주인은 mappedBy(수동적) 속성 사용하지 않는다. 주인이 아니면 mappedBy 속성으로 상대 객체를 주인으로 지정   누구를 주인으로 해야할까 ?   외래 키가 있는 곳을 주인으로 정해라 여기서는 Member.team이 연관관계의 주인 ManyToOne 에서 Many 쪽이 연관관계의 주인 (OneToOne에서도 와래 키 있는곳이 주인)    Member.java\n  @ManyToOne\r@JoinColumn(name = \u0026quot;TEAM_ID\u0026quot;) //연관관계를 여기서 관리하겠다.\rprivate Team team;\r  Team.java\n  @OneToMany(mappedBy = \u0026quot;team\u0026quot;) // 1:N 관계에서 상대편(Member)에 team으로 매핑이 되어있는 것 이라고 지정\rprivate List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r 만일 외래 키가 없는 테이블을 주인으로 지정할 때의 문제점  만일 외래 키가 없는 객체를 주인으로 설정할 경우 값을 변경한다면\n외래 키가 있는 테이블을 수정하기 때문에 내가 수정한 객체는 Team 이지만, Member의 객체 Update Sql이 나가는 황당한 경우가 있을 수 있습니다.\n  1:N에서 1이 연관관계의 주인일때 1을 수정하면 N의 수정이 일어나기 때문에 성능 이슈가 발생할 수 있습니다.\n 양방향 매핑시 가장 많이 하는 실수  (연관관계의 주인에 값을 입력하지 않음)\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member()\rmember.setName(\u0026quot;member1\u0026quot;);\r//역방향 (주인이 아닌 방향)만 값 세팅\rteam.getMembers().add(member);\tem.persist(member)\r  JpaMain.java\n  Member member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rem.persist(member);\rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rteam.getMembers().add(member);\rem.persist(team);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\rtx.commit();\r  Insert SQL은 2건이 나갔고, DB에서 확인해보면\n  Member와 Team이 저장되었지만, MEMBER의 MEMBER_ID는 null 인것을 확인 할 수 있습니다.\nTeam의\n @OneToMany(mappedBy = \u0026quot;team\u0026quot;) private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;();\r  은 가짜 매핑이기 때문에 저장, 수정은 안되고 조회만 가능 !\n  JpaMain.java\n \tTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\r//team.getMembers().add(member);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\rtx.commit();\r  연관관계의 주인인 Member에 Team 값을 넣고 저장을 하게 되면 TEAM_ID의 값에 1로 저장되는 것을 확인할 수 있습니다.\n 그러면 연관관계의 주인에만 데이터를 넣으면 될까 ?  JPA 입장에서는 연관관계의 주인에만 데이터를 입력하면 되지만..\n  JpaMain.java\n \rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\r//team.getMembers().add(member); // 안넣어도 된다.\rem.flush(); // 영속성 컨텍스트 플러시\rem.clear(); // 영속성 컨텍스트 초기화\rTeam findTeam = em.find(Team.class, team.getId());\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rtx.commit();\r  당연히 getMembers로 가져온 Member들에도 추가한 member가 있습니다. JPA 지연로딩의 기능인데 Team을 조회하고 Member를 한번더 조회하는것을 볼 수 있습니다.\n  실제 members를 사용하는 시점에 조회 SQL을 수행하게 됩니다.\n  //team.getMembers().add(member); // 안넣어도 된다. team의 getMembers()에 새로운 member를 추가 하지 않아도 문제가 없었지만 em.flush();과 em.clear();를 제거 한다면\n  JpaMain.java\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member);\r//em.flush(); // 영속성 컨텍스트 플러시\r//em.clear(); // 영속성 컨텍스트 초기화\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  Insert문 이후에 아까와 달리 Select 문을 수행하지 않으며, members 루프를 수행하지 않는 것을 확인 할 수 있습니다.\n  Member의 값이 DB에 저장되기 전이며, 현재 Team이 가지고 있는 members에는 추가한 member의 값이 없기 때문에 출력해도 아무 것도 나오지 않는다.\n  이러한 문제점이 있을 수 있고, 객체 지향적으로 생각을 해보면 Team 또한 team.getMembers().add(member); 를 이용해 값을 세팅해 주는것이 맞다.\n  그리고 테스트케이스 작성중 JPA 없이도 순수하게 자바 코드 상태로도 테스트케이스를 수행하게 되는데 member.getTeam()은 되는데 team.getMembers() 할경우 null로 이상하게 동작하게 됩니다.\n  JpaMain.java \u0026ndash; Team.getMembers()에 member 추가\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rmember.setTeam(team);\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rteam.getMembers().add(member);\r//em.flush(); // 영속성 컨텍스트 플러시\r//em.clear(); // 영속성 컨텍스트 초기화\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  members에 추가한 member가 있는것을 확인할 수 있다.\n  결론은 양쪽 객체에 값을 세팅하는 것이 맞습니다.\n 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.  (순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야한다.)\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\rteam.getMembers().add(member); // 값 설정 **\rmember.setTeam(team); // 연관관계 주인에 값 설정 ***\rem.persist(member);\r 양방향 연관관계 주의 - 실습   순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 1차 캐시에는 값이 없는 상태이므로 최악의 경우 버그가 발생할 수있습니다.    연관관계 편의 메소드를 생성하자    Member.java \u0026ndash; setTeam에서 getMemebers().add(this)를 추가\n \t...\rpublic void changeTeam(Team team) {\rthis.team = team;\rteam.getMembers().add(this); // 자기 자신(Member)를 team의 members에 추가\r}\r...\r  JpaMain.java \u0026ndash; team.getMembers().add(member); 는 삭제\n Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.setTeam(team); // ***\rmember.changeTeam(team); // ***\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member); // **\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  이 연관관계 편의 메소드를 이용하면 한쪽만 세팅해도, 양쪽으로 데이터가 들어가 관리가 편하게 됩니다.\n  또 setTeam이라는 setter의 관습적인 네이밍 말고, changeTeam으로 만들어 단순히 set 하는 메소드가 아닌 다른 비지니스로직이 포함된 메소드라는 것을 명시합니다.\n  chageTeam을 실제로 개발하여 사용하면 딥하게 생각해서 team안에 추가하는 member가 있는지 체크하거나 team이 null인지도 체크 해야하고 신경써야 할 부분도 있고 Member를 수정한다면, 기존의 member를 제거하고 수정한 member로 세팅하는 그런 로직도 필요합니다.\n  Team에서도 연관관계 편의 메소드를 이용해 Member를 세팅할 수가 있는데,\n  Team.java\n  public void addMember(Member member){\rmember.setTeam(this);\rmembers.add(member);\r}\r  JpaMain.java\n \rTeam team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.changeTeam(team); // ***\rteam.addMember(member); // ***\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member); // **\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\rList\u0026lt;Member\u0026gt; members = findTeam.getMembers();\rfor (Member m : members){\rSystem.out.println(\u0026quot;m = \u0026quot;+ m.getUsername());\r}\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  양쪽에서 편의 메소드를 이용해 값을 설정할 수 있지만 최악의 경우 무한루프에 걸릴 수도 있으니 한쪽을 정해서 한쪽에서만 사용하는게 좋습니다.\n  양방향 매핑시에 무한 루프를 조심하자 - 예) toString(), lombok, Json 생성 라이브러리    Member.java \u0026ndash; toString() 추가\n  @Override\rpublic String toString() {\rreturn \u0026quot;Member{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, username='\u0026quot; + username + '\\'' +\r\u0026quot;, team=\u0026quot; + team +\t// team.toString() 과 같음\r'}';\r}\r  Team.java \u0026ndash; toString() 추가\n  @Override\rpublic String toString() {\rreturn \u0026quot;Team{\u0026quot; +\r\u0026quot;id=\u0026quot; + id +\r\u0026quot;, name='\u0026quot; + name + '\\'' +\r\u0026quot;, members=\u0026quot; + members + // members의 앨리먼츠들 모두 출력함.\r'}';\r}\r  JpaMain Team을 출력해봄 (.toString())\n  Team team = new Team();\rteam.setName(\u0026quot;TeamA\u0026quot;);\rem.persist(team);\rMember member = new Member();\rmember.setUsername(\u0026quot;Member1\u0026quot;);\r//member.changeTeam(team); // ***\rteam.addMember(member); // ***\rem.persist(member);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\r//team.getMembers().add(member); // **\rTeam findTeam = em.find(Team.class, team.getId()); // DB 저장전 1차 캐시\r//System.out.println(\u0026quot;findTeam = \u0026quot;+ findTeam.toString()); //아래와 동일\rSystem.out.println(\u0026quot;findTeam = \u0026quot;+ findTeam);\rSystem.out.println(\u0026quot;=========================\u0026quot;);\rtx.commit();\r  또한 lombok에서 자동으로 toString()을 생성하거나, Json 생성라이브러리에서 객체를 쭉 읽어오면서 무한루프에 갇히게 되면 어마 어마한 장애로 이어질 수 있습니다. 실제 Json 생성라이브러리는 컨트롤러에서 엔티티를 직접 리스폰스로 보내게 되면 양방향으로 연관관계가 설정되어있으면 그때 Json으로 생성시 Member를 보며 Team이 있네 하고 Team으로 가서 Member가 있네 하고 또 다시 Member로 계속 타고 들어가게 됩니다.\n 무한루프를 최대한 피할 수 있는 방법   lombok에서 toString 만드는거 쓰지마라. 쓰려면 객체 레퍼런스 빼고 사용해야 한다. API 컨트롤러에서는 엔티티를 바로 반환하지 마라. DTO로 변환해서 반환하여 사용해야 한다.    이러한 무한루프에 빠질 수 있다.    엔티티가 변경될 수 있는데 변경하게 되면 API SPEC이 변경된다. (사용하는 입장에서는 논의 없던 컬럼이 추가/삭제에 고통받을 수 있습니다.)       양방향 매핑 정리   단방향 매핑만으로도 이미 연관관계 매핑은 완료 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐 JPQL에서 역방향으로 탐색할 일이 많음 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)    최초 개발을 하게되면 단방향 매핑부터 설계를 끝내놓고 양방향에 대해서 작업을 해야합니다. Jpa에서 단방향 매핑만으로 객체와 테이블 매핑하는 것은 완료가 된것입니다. 객체 입장에서는 양방향 매핑을 추가하면 연관관계 편의 메소드나 생각해야 할 것이 많아집니다. 그러면 언제 양방향 매핑을 추가해야 하냐면 JPQL에서 역방향으로 탐색할 일이 많아질때 필요할 때 추가하면 됩니다.   추후 추가를 하여도 자바 코드 추가되는 것도 많지 않으며, 제일 중요한 테이블에 변화가 없기 때문에 개발하다 진짜 필요할때 아니면 단방향으로 개발을 진행하여도 문제가 없습니다.\n 연관관계의 주인을 정하는 기준   비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함   참고- 자바 ORM 표준 JPA - 김영한 ","description":"연관관계 매핑","id":3,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 연관관계 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/relation-mapping/"},{"content":"기본키 매핑  기본 키 매핑 어노테이션    @Id @GeneratedValue   @Id @GeneratedValue(strategy = GenerationTpye.AUTO)\rprivate Long id;\r 기본 키 매핑 방법    직접 할당 : @Id 만 사용 자동 생성(@GeneratedValue)  IDENTITY : 데이터베이스에 위임, MySLQ) SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE  @SequenceGenerator 필요     TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용  @TableGenerator 필요   AUTO: 방언에 따라 자동 지정, 기본값   Id 직접할당 - @Id 사용   Member.java 기본 키 매핑에 좀더 집중하기 위해 Memeber의 Id를 String 으로 변경하고, Id, name을 제외한 나머지를 일단 제거합니다.\n  package hellojpa;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\rprivate String id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) private String userName;\rpublic Member() {\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getUserName() {\rreturn userName;\r}\rpublic void setUserName(String userName) {\rthis.userName = userName;\r}\r}\r  JpaMain.java\n \tMember member1 = new Member();\rmember1.setId(\u0026quot;USER_A\u0026quot;); // 아이디 채번을 직접하여 할당\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rMember member2 = new Member();\rmember2.setId(\u0026quot;USER_B\u0026quot;);\rmember2.setUserName(\u0026quot;유저B\u0026quot;);\rem.persist(member2);\rtx.commit();\r Id 자동할당 - @GeneratedValue   GeneratedValue의 전략은 AUTO, IDENTITY, SEQUENCE, TABLE가 있으며, AUTO는 방언에 따라 다르게 생성\n  @GeneratedValue(strategy = GenerationType.AUTO) @GeneratedValue(strategy = GenerationType.IDENTITY) 위임함\r@eneratedValue(strategy = GenerationType.SEQUENCE) @GeneratedValue(strategy = GenerationType.TABLE)  GenerationType.IDENTITY  GenerationType.IDENTITY - 특징   기본 키 생성을 데이터베이스에 위임 주로 MySQL, PostgreSQL, SQL Server. DB2에서 사용 예) MySQL의 AUTO_INCREMENT JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행 AUTO_INCREMENMT는 데이터베이스에 INSERT SQL을 실헹한 이후에 ID 값을 알 수 있음 IDENTITY 전략은 em.persist() 시점에 즉시 INSERT_SQL 실행하고 DB에서 식별자를 조회    @Id\r@GeneratedValue(strategy = GenerationType.IDENTITY) private String id;\r Hibernate: drop table Member if exists\rHibernate: create table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r)\r12월 26, 2021 10:48:37 오후 org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection\rINFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@2a2da905] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.\r12월 26, 2021 10:48:37 오후 org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection\rINFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@1b11ef33] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.\r12월 26, 2021 10:48:37 오후 org.hibernate.tool.schema.internal.ExceptionHandlerLoggedImpl handleException\rWARN: GenerationTarget encountered exception accepting command : Error executing DDL \u0026quot;\rcreate table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r)\u0026quot; via JDBC Statement\rorg.hibernate.tool.schema.spi.CommandAcceptanceException: Error executing DDL \u0026quot;\rcreate table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r)\u0026quot; via JDBC Statement\rat org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:67)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.applySqlString(SchemaCreatorImpl.java:440)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.applySqlStrings(SchemaCreatorImpl.java:424)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.createFromMetadata(SchemaCreatorImpl.java:315)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.performCreation(SchemaCreatorImpl.java:166)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.doCreation(SchemaCreatorImpl.java:135)\rat org.hibernate.tool.schema.internal.SchemaCreatorImpl.doCreation(SchemaCreatorImpl.java:121)\rat org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.performDatabaseAction(SchemaManagementToolCoordinator.java:155)\rat org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.process(SchemaManagementToolCoordinator.java:72)\rat org.hibernate.internal.SessionFactoryImpl.\u0026lt;init\u0026gt;(SessionFactoryImpl.java:310)\rat org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:467)\rat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:939)\rat org.hibernate.jpa.HibernatePersistenceProvider.createEntityManagerFactory(HibernatePersistenceProvider.java:56)\rat javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:79)\rat javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:54)\rat hellojpa.JpaMain.main(JpaMain.java:12)\rCaused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: \u0026quot;CHARACTER VARYING(255)\u0026quot;; SQL statement:\rcreate table Member (\rid varchar(255) generated by default as identity,\rname varchar(10),\rprimary key (id)\r) [50100-202]\rat org.h2.message.DbException.getJdbcSQLException(DbException.java:556)\rat org.h2.message.DbException.getJdbcSQLException(DbException.java:477)\rat org.h2.message.DbException.get(DbException.java:223)\rat org.h2.message.DbException.get(DbException.java:199)\rat org.h2.message.DbException.getUnsupportedException(DbException.java:287)\rat org.h2.command.ddl.SequenceOptions.getBounds(SequenceOptions.java:313)\rat org.h2.command.ddl.SequenceOptions.getBounds(SequenceOptions.java:244)\rat org.h2.schema.Sequence.\u0026lt;init\u0026gt;(Sequence.java:101)\rat org.h2.table.Column.initializeSequence(Column.java:459)\rat org.h2.command.ddl.CommandWithColumns.generateSequences(CommandWithColumns.java:103)\rat org.h2.command.ddl.CreateTable.update(CreateTable.java:110)\rat org.h2.command.CommandContainer.update(CommandContainer.java:173)\rat org.h2.command.Command.executeUpdate(Command.java:247)\rat org.h2.server.TcpServerThread.process(TcpServerThread.java:413)\rat org.h2.server.TcpServerThread.run(TcpServerThread.java:190)\rat java.base/java.lang.Thread.run(Thread.java:834)\rat org.h2.message.DbException.getJdbcSQLException(DbException.java:507)\rat org.h2.engine.SessionRemote.done(SessionRemote.java:611)\rat org.h2.command.CommandRemote.executeUpdate(CommandRemote.java:237)\rat org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:228)\rat org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:201)\rat org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase.accept(GenerationTargetToDatabase.java:54)\r... 15 more\r12월 26, 2021 10:48:37 오후 org.hibernate.tool.schema.internal.SchemaCreatorImpl applyImportSources\rINFO: HHH000476: Executing import script 'org.hibernate.tool.schema.internal.exec.ScriptSourceInputNonExistentImpl@1eba372c'\r  Member.java\n  persistence.xml에서 MySQL 방언으로 다시 실행\n  AUTO_INCREMENT로 키를 생성하겠다 설정이 된것을 볼 수 있습니다.\n  H2 1.4.202 버전을 사용하고 있는데, @GeneratedValue(strategy = GenerationType.IDENTITY) 가 적용이 안되고, ERROR: NULL not allowed for column \u0026ldquo;ID\u0026rdquo;; SQL statement: /* insert hellojpa.Member */ insert into Member (id, name) values (null, ?) [23502-200] 오류가 발생하여 검색을 해보니 최신 H2 DB에 버그라고 하네요.\n h2 데이터베이스는 꼭 다음 링크에 들어가서 1.4.200 버전을 설치해주세요.\r최근에 나온 2.0.202 버전을 설치하면 일부 기능이 정상 동작하지 않습니다\r\r 2.0.200 버전으로 다시 설치 하였습니다.\n Hibernate: /* insert hellojpa.Member\r*/ insert into\rMember\r(id, name) values\r(null, ?)\r12월 26, 2021 11:09:52 오후 org.hibernate.engine.jdbc.spi.SqlExceptionHelper logExceptions\rWARN: SQL Error: 23502, SQLState: 23502\r12월 26, 2021 11:09:52 오후 org.hibernate.engine.jdbc.spi.SqlExceptionHelper logExceptions\rERROR: NULL not allowed for column \u0026quot;ID\u0026quot;; SQL statement:\r/* insert hellojpa.Member */ insert into Member (id, name) values (null, ?) [23502-200]\r12월 26, 2021 11:09:52 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl stop\rINFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]\rProcess finished with exit code 0\r IDENTITY 전략 애매한점  strategy = GenerationType.IDENTITY를 사용할 경우 Key를 Null로 하여 DB에 인서트할 당시에 키가 생성하게됩니다. 영속성 컨텍스트에서 관리를 하기 위해서는 PK값이 있어야 합니다. 하지만 이 전략은 DB에 들어가봐야 PK를 알 수 있습니다. 그래서 제약이 생기게 됩니다.\n  GeneratedValue 전략을 다시 GenerationType.IDENTITY로 바꿔서 테스트 해보겠습니다.\n  Memeber.java\n @Entity\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.IDENTITY)\rprivate Long id;\r  JpaMain.java\n  System.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rSystem.out.println(\u0026quot;member1.id : \u0026quot; +member1.getId());\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member2);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  persist() 시점에 Insert SQL 이 날라가게 됩니다. 그리고 바로 영속성 컨텍스트의 1차 캐시에 Id 값을 가져올 수 있는 것 을 확인 할 수 있습니다.\n GenerationType.SEQUENCE  GenerationType.SEQUENCE - 특징   데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트( 예) 오라클 시퀀스) 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용    Member.java GeneratedValue 전략을 GenerationType.SEQUENCE 로 변경\n  @Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE)\rprivate String id;\r  GeneratedValue(strategy = GenerationType.SEQUENCE) 적용시 오류 발생이 되었고 오류는 아래와 같습니다.\n \rjavax.persistence.PersistenceException: org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:154)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:181)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:188)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:807)\rat org.hibernate.internal.SessionImpl.persist(SessionImpl.java:785)\rat hellojpa.JpaMain.main(JpaMain.java:22)\rCaused by: org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String\rat org.hibernate.id.IdentifierGeneratorHelper.getIntegralDataTypeHolder(IdentifierGeneratorHelper.java:224)\rat org.hibernate.id.enhanced.SequenceStructure$1.getNextValue(SequenceStructure.java:98)\rat org.hibernate.id.enhanced.NoopOptimizer.generate(NoopOptimizer.java:40)\rat org.hibernate.id.enhanced.SequenceStyleGenerator.generate(SequenceStyleGenerator.java:482)\rat org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:119)\rat org.hibernate.event.internal.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:192)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:135)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:62)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:800)\r... 2 more\r  Caused by: org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String\n  알 수 없는 정수 데이터 유형 : String\n  Member.java의 Id 가 현재 String이라 나오던 문제였습니다.\n  Member.java - String Id -\u0026gt; Long Id로 변경\n package hellojpa;\rimport javax.persistence.*;\rimport java.time.LocalDate;\rimport java.time.LocalDateTime;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE)\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) // 엔티티 명은 userName으로, DB 컬럼명을 name으로 매핑하여 사용 지정\rprivate String userName;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUserName() {\rreturn userName;\r}\rpublic void setUserName(String userName) {\rthis.userName = userName;\r}\r}\r  call next value for hibernate_sequence 기본 시퀀스를 사용해서 새로운 키값을 생성하게 되는데, 테이블 마다 시퀀스를 따로 관리하고 싶다면 @SequnceGenerator를 사용하면 됩니다.\n Sequence 전략 - 매핑  Member.java\n @Entity\r@SequenceGenerator(\rname = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;\r, sequenceName = \u0026quot;MEMBER_SEQ\u0026quot; // 매핑할 데이터베이스 시퀀스 이름\r, initialValue = 1, allocationSize = 1\r)\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE\r, generator = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;) //사용할 Generator 매핑\rprivate Long id;\r SEQUENCE - @SequenceGenerator   주의 allocationSize 기본 값 = 50      속성 설명 기본값     name 식별자 생성기 이름 필수   sequenceName 데이터베이스에 등록되어있는 시퀀스 이름 hibernate_sequence   initialValue DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 시작하는 수를 1로 지정한다. 1   allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨) 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다 50   catalog, schema 데이터베이스 catalog, schema 이름     SEQUENCE - 추가 설명  GeneratedValue의 전략을 GenerationType.SEQUENCE로 사용하게 되면 sequence를 생성하게 되는데\n Hibernate: drop table Member if exists\rHibernate: drop sequence if exists MEMBER_SEQ\rHibernate: create sequence MEMBER_SEQ start with 1 increment by 1 // 1부터 시작하여, 1씩 증가한다.\rHibernate:   JpaMain.java\n  System.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rSystem.out.println(\u0026quot;member1.id : \u0026quot; +member1.getId());\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member2);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  SEQUECE 전략도 영속성 컨텍스트에 저장할 당시 PK 값이 필요하기 때문에,\n ----------- 0\rHibernate: call next value for MEMBER_SEQ\rmember1.id : 1\r----------- 1\r  \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 0 과 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 1 사이에서 call next value for MEMBER_SEQ 시퀀스 nextVal으로 키값을 받아, 영속성 컨텍스트의 1차 캐시에 이미 id와 userName이 들어간 상태이고 2번째 유저 또한 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 1 과 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 2 영속성 컨텍스트에 저장됩니다. 이후 commit()을 하게되면 Insert를 하게됩니다.\n  IDENTITY에서는 안되지만, SEQUENCE에서는 JDBC BATCH를 이용한 버퍼를 이용할 수 있습니다.\n  이렇게 보다보니 성능에 한번에 인서트 하는게 아니라 seq 얻어올때, Insert 할때 자꾸 DB에 네트워킹을 통해 성능적으로 떨어지는 것 아닌가 싶기도합니다. 그래서 성능 최적화를 위하여 JPA에 allocationSize로 성능을 최적화 하는 방법이 있습니다. 자세한 설명은 뒤에서 하겠습니다.\n GenerationType.TABLE  GenerationType.TABLE - 특징   키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략 장점 : 모든 데이터베이스에 적용 가능 단점 : 성능   Table 전략 - 매핑  Member.java\n @Entity\r@TableGenerator(\rname = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;\r, table = \u0026quot;MY_SEQUENCE\u0026quot; // 매핑할 테이블명\r, pkColumnValue = \u0026quot;MEMBER_SEQ\u0026quot; , allocationSize = 1)\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.TABLE\r, generator = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;) //사용할 Generator 매핑\rprivate Long id;\r ctrate table MY_SEQUENCE (\rsequence_name varchar(255) not null,\rnext_val bigint,\rprimary ket (sequence_name)\r)\r  수정하고 애플리케이션 재시작 하면, JPA가 자동으로 MY_SEQUENCE 테이블을 생성해준다.\n @TableGenerator - 속성    속성 설명 기본값     name 식별자 생성기 이름 필수   table 키 생성 테이블 이름 hibernate_sequences   pkColumnName 시퀀스 컬럼명 sequence_name   valueColumnName 시퀀스 값 컬럼명 next_val   pkColumnValue 키로 사용할 값 이름 엔티티 이름   initalValue 초기 값, 마지막으로 생성된 값이 기준이다. 0   allocationSize 시퀀스 한 번 호출에 증가하는 수 50   catalog, schema 데이터베이스 catalog, schema 이름    uniqueConstains(DDL) 유니크 제약 조건을 지정할 수 있다.      운영에서는 table 전략을 사용하기는 부담스럽고 각 테이블의 sequence를 사용한 sequence 전략을 적극 채용하여 사용한다고 합니다.\n 권장하는 식별자 생성 전략    기본 키 제약 조건 : null 아님, 유일, 변하면 안된다. 미래까지 이 조건을 만족하는 자연키를 찾기 어렵다. 대리키(대체키)를 사용하자. ( 비즈니스와 상관없는 랜덤키) 예를 들어 주민등록번호도 기본 키로 적절하지 않다. 권장 : Long형 + 대체키 + 카 생성전략 사용    10억이 넘어도 동작해야 하니까 Long형, 시퀀스를 쓴다던가, uuid를 쓴다던가 대체키를 쓰시고, 카생성 전략들을 조합해서 사용하는 것을 권장\nAUTO-INCREMENT나 SEQUENCE Object 둘중 하나를 사용하시고 아니면 때에 따라서 uuid, 랜덤 값을 조합한 회사내의 룰을 따르길 권장. 절대 비즈니스 로직을 키로 끌고 오는것을 권장하지는 않는다고 합니다.\n allocationSize를 이용한 성능향상   allocationSize를 1로 설정하여 1씩 증가하게 세팅을 해두었는데, 기본 값은 50 입니다. 기본 값이 50인 이유는 JPA는 새로운 키 50개를 한번에 만들어 놓고, DB에 50으로 세팅하고 메모리 상에서 1부터 50 까지 순차적으로 사용합니다. 이후 50개를 모두 사용하면, call next를 하여 51 부터 100까지 미리 만들어 사용합니다.\n또 대단한 것이 어떤 DB를 사용해도 이슈 없이 동작한다고 합니다.\n @Entity\r@SequenceGenerator(\rname = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;\r, sequenceName = \u0026quot;MEMBER_SEQ\u0026quot; // 매핑할 데이터베이스 시퀀스 이름\r, initialValue = 1, allocationSize = 50)\rpublic class Member {\r@Id\r@GeneratedValue(strategy = GenerationType.SEQUENCE,\rgenerator = \u0026quot;MEMBER_SEQ_GENERATOR\u0026quot;)\rprivate Long id;\r  현재 값은 -1이고 증가는 50 인것을 볼 수 있습니다.\n  JpaMain.java는 객체 생성 및 persist() 모두 삭제\n call next value for MEMBER_SEQ;\r  위 SQL을 통항 next value를 가져오면 1이 되길 원하는 것입니다.\n  JpaMain.java\n  System.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rem.persist(member1);\rSystem.out.println(\u0026quot;member1.id : \u0026quot; +member1.getId());\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저B\u0026quot;);\r//em.persist(member2);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rMember member3 = new Member();\rmember3.setUserName(\u0026quot;유저C\u0026quot;);\r//em.persist(member3);\rSystem.out.println(\u0026quot;member2.id : \u0026quot; +member2.getId());\rSystem.out.println(\u0026quot;----------- 3\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  처음 call next value for MEMBER_SEQ;를 호출하고 1이면 50개의 키를 메모리로 가져온 것이 아니기 때문에 1번더 호출합니다.\n  다시 JpaMain에 persist를 추가하여 테스트 해보면\n \tSystem.out.println(\u0026quot;----------- 0\u0026quot;);\rMember member1 = new Member();\rmember1.setUserName(\u0026quot;유저A\u0026quot;);\rSystem.out.println(\u0026quot;----------- 1\u0026quot;);\rMember member2 = new Member();\rmember2.setUserName(\u0026quot;유저B\u0026quot;);\rSystem.out.println(\u0026quot;----------- 2\u0026quot;);\rMember member3 = new Member();\rmember3.setUserName(\u0026quot;유저C\u0026quot;);\rSystem.out.println(\u0026quot;----------- 3\u0026quot;);\rem.persist(member1); // call next value for MEMBER_SEQ; DB SEQ = 1 , Key = 1\rem.persist(member2); // call next value for MEMBER_SEQ; DB SEQ = 51 , Key = 2\rem.persist(member3); // memory; DB SEQ = 51 , Key = 3\rSystem.out.println(\u0026quot;----------- 4\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;----------- commit\u0026quot;);\r  allocationSize를 크게 잡아 메모리에 두고 사용할 수 있지만, 애플리케이션이 내려가게 되면 사용하지 않았던 Id 값들의 구멍이 생겨 낭비가 될 수 있기 때문에 50 ~ 100 정도가 적당합니다.\n  Table 전략 또한 동일하며, 테이블의 데이터를 미리 설정한 값 만큼 미리 세팅하고 키를 메모리에서 생성하여 사용합니다. 물론 서버가 여러대인 경우에도 서버 각각 중복되지 않고 호출한 순서대로 1~50 , 50 ~100 씩 할당받아 메모리에 키를 두고 사용합니다. 때문에 동시성 문제가 발생하지 않고 문제없이 동작합니다.\n 참고- 자바 ORM 표준 JPA - 김영한 ","description":"기본키 매핑","id":4,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 기본키 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/primary-key-mapping/"},{"content":"실전 예제 1 - 요구사항 분석과 기본 매핑  요구사항 분석    회원은 상품을 주문할 수 있다. 주문 시 여러 종류의 상품을 선택할 수 있다.   기능 목록    회원 기능  회원등록 회원조회       상품 기능  상품등록 상품수정 상품조회       주문 기능  상품주문 주문내역조회 주문취소     도메인 모델 분석    회원과 주문의 관계 : 회원은 여러 번 주문할 수 있다. (1:n)     주문과 상품의 관계 : 주문할 때 여러 상품을 선택할 수 있다. 반대로 같은 상픔도 여러번 주문될 수 있다. 주문상품 이라는 모델을 만들어서 다대다 관계를 일대다, 다대일 괸계로 풀어냄   테이블 설걔  엔티티 설계와 매핑  Maven Project 생성  pom.xml - 수정 depency 추가\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;jpa-basic\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jpa-shop\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- JPA 하이버네이트 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.3.10.Final\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- H2 데이터베이스 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/project\u0026gt;\r  jpashop \u0026gt; src \u0026gt; main \u0026gt; resources \u0026gt; persistence.xml 생성\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;jpashop\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/jpashop\u0026quot;/\u0026gt;\r\u0026lt;!--\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.MySQL5Dialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r```\r\u0026gt; jpa-shop \u0026gt; src \u0026gt; java \u0026gt; jpabasic \u0026gt; jpashop \u0026gt; domain - 패키지 생성\r\u0026gt; domain 패키지 안에 엔티티 추가 \u0026gt; Member.java 생성\r```\rpackage jpabasic.jpashop.domain;\rimport javax.persistence.*;\r@Entity\rpublic class Member {\rpublic Member(){\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate String cicy;\rprivate String street;\rprivate String zipcode;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getCicy() {\rreturn cicy;\r}\rpublic void setCicy(String cicy) {\rthis.cicy = cicy;\r}\rpublic String getStreet() {\rreturn street;\r}\rpublic void setStreet(String street) {\rthis.street = street;\r}\rpublic String getZipcode() {\rreturn zipcode;\r}\rpublic void setZipcode(String zipcode) {\rthis.zipcode = zipcode;\r}\r}\r```\r\u0026gt; Order.java\r```\rpackage jpabasic.jpashop.domain;\rimport javax.persistence.*;\rimport java.time.LocalDateTime;\rimport java.util.Date;\r@Entity\r@Table(name = \u0026quot;ORDERS\u0026quot;) // DB에 따라 ORDER가 예약어일 경우가 있어 ORDERS\rpublic class Order {\rpublic Order(){\r}\r@Id\r@GeneratedValue\r@Column(name=\u0026quot;ORDER_ID\u0026quot;)\rprivate Long id;\r@Column(name=\u0026quot;MEMBER_ID\u0026quot;)\rprivate Long memberId;\rprivate LocalDateTime orderDate;\r@Enumerated(EnumType.STRING)\rprivate OrderStatus status;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getMemberId() {\rreturn memberId;\r}\rpublic void setMemberId(Long memberId) {\rthis.memberId = memberId;\r}\rpublic LocalDateTime getOrderDate() {\rreturn orderDate;\r}\rpublic void setOrderDate(LocalDateTime orderDate) {\rthis.orderDate = orderDate;\r}\rpublic OrderStatus getStatus() {\rreturn status;\r}\rpublic void setStatus(OrderStatus status) {\rthis.status = status;\r}\r}\r```\r\u0026gt; OrderStatus.java\r package jpabasic.jpashop.domain;\npublic enum OrderStatus { ORDER, CANCEL }\n\r\u0026gt; Item.java\r```\rpackage jpabasic.jpashop.domain;\rimport javax.persistence.Column;\rimport javax.persistence.GeneratedValue;\rimport javax.persistence.Id;\r@Entity\rpublic class Item {\rpublic Item(){\r}\r@Id @GeneratedValue\r@Column(name=\u0026quot;ITEM_ID\u0026quot;)\rprivate Long id;\rprivate String name;\rprivate int price;\rprivate int stockQuantity;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getPrice() {\rreturn price;\r}\rpublic void setPrice(int price) {\rthis.price = price;\r}\rpublic int getStockQuantity() {\rreturn stockQuantity;\r}\rpublic void setStockQuantity(int stockQuantity) {\rthis.stockQuantity = stockQuantity;\r}\r}\r```\r\u0026gt; OrderItem.java\r package jpabasic.jpashop.domain;\nimport javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id;\n@Entity public class OrderItem { public OrderItem(){ }\n@Id @GeneratedValue\r@Column(name = \u0026quot;OFDER_ITEM_ID\u0026quot;)\rprivate Long id;\r@Column(name = \u0026quot;ORDER_ID\u0026quot;)\rprivate Long orderId;\r@Column(name = \u0026quot;ITEM_ID\u0026quot;)\rprivate Long itemId;\rprivate int orderPrice;\rprivate int count;\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic Long getOrderId() {\rreturn orderId;\r}\rpublic void setOrderId(Long orderId) {\rthis.orderId = orderId;\r}\rpublic Long getItemId() {\rreturn itemId;\r}\rpublic void setItemId(Long itemId) {\rthis.itemId = itemId;\r}\rpublic int getOrderPrice() {\rreturn orderPrice;\r}\rpublic void setOrderPrice(int orderPrice) {\rthis.orderPrice = orderPrice;\r}\rpublic int getCount() {\rreturn count;\r}\rpublic void setCount(int count) {\rthis.count = count;\r}\r }\n\r\u0026gt; jpashop \u0026gt; src \u0026gt; main \u0026gt; java \u0026gt; jpabasic \u0026gt; jpashop \u0026gt; JpaMain.java 생성 ```\rpackage jpabasic.jpashop;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;jpashop\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\r}catch (Exception e){\re.printStackTrace();\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r```\r\u0026gt; 애플리케이션 재시작 ```\rHibernate: drop table Item if exists\rHibernate: drop table Member if exists\rHibernate: drop table OrderItem if exists\rHibernate: drop table ORDERS if exists\rHibernate: drop sequence if exists hibernate_sequence\rHibernate: create sequence hibernate_sequence start with 1 increment by 1\rHibernate: create table Item (\rITEM_ID bigint not null,\rname varchar(255),\rprice integer not null,\rstockQuantity integer not null,\rprimary key (ITEM_ID)\r)\rHibernate: create table Member (\rMEMBER_ID bigint not null,\rcicy varchar(255),\rname varchar(255),\rstreet varchar(255),\rzipcode varchar(255),\rprimary key (MEMBER_ID)\r)\rHibernate: create table OrderItem (\rOFDER_ITEM_ID bigint not null,\rcount integer not null,\rITEM_ID bigint,\rORDER_ID bigint,\rorderPrice integer not null,\rprimary key (OFDER_ITEM_ID)\r)\rHibernate: create table ORDERS (\rORDER_ID bigint not null,\rMEMBER_ID bigint,\rorderDate timestamp,\rstatus varchar(255),\rprimary key (ORDER_ID)\r)\rProcess finished with exit code 0\r```\r\u0026gt; 엔티티 매핑을 하고 이상한 점을 발견하게 되었는데 Order에서 주문한 memberId를 조회하려면 \u0026gt; JpaMain.java\r```\r...\rOrder order = em.find(Order.class, 1L); //오더를 찾고 Long memberId = order.getMemberId();\t//오더에서 memberId를 찾아서\rMember member = em.find(Member.class, memberId); //member를 찾는다. ... ```\r\u0026gt; 뭔가 복잡하고 객체지향적이지 않습니다.\r\u0026gt; Order.java\r```\r...\rprivate Member member; public Member getMember() {\rreturn member;\r}\r...\r```\r\u0026gt; JpaMain.java\r```\r...\rOrder order = em.find(Order.class, 1L); //오더를 찾고 Member member = order.getMember(); //member를 찾는다. Long memberId = member.getMemberId();\r... ```\r\u0026gt; 이런 설계를 데이터 중심 설계라고 합니다.\r### 데이터 중심 설계의 문제점\r---------------------\r\u0026gt; - 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식\r\u0026gt; - 테이블의 외래키 객체에 그대로 가져옴\r\u0026gt; - 객체 그래프 탐색이 불가능\r\u0026gt; - 참조가 없으므로 UML도 잘못됨\r### 해결법\r\u0026gt; 이것을 해결하기 위해 연관관계 매핑을 사용하게 됩니다.\r#### 참고- \u0026lt;a href=\u0026quot;https://www.inflearn.com/course/ORM-JPA-Basic\u0026quot;\u0026gt;자바 ORM 표준 JPA - 김영한\u0026lt;/a\u0026gt; ","description":"요구사항 분석과 기본 매핑","id":5,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 실전 예제 1 - 요구사항 분석과 기본 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-1/"},{"content":"객체와 매핑  객체와 테이블 매핑  목차    객체와 테이블 매핑 필드와 컬럼 매핑 기본 키 매핑 실전 예제 - 1. 요구사항 분석과 기본 매핑   엔티티 매핑 소개    객체와 테이블 매핑 : @Entity, @Table 필드와 컬럼 매핑 : @Column 기본키 매핑 : @Id 연관관계 매핑 : @ManyToOne, @JoinColumn   객체와 테이블 매핑  @Entity    @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 부른다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의  기본 생성자 필수 (파라미터가 없는 public 또는 proteted 생성자) final 클래스, enum, interface, inner 클래스 사용 X 저장할 필드에 final 사용 X     @Entity 속성 정리   속성 : name  JPA에서 사용할 엔티티 이름을 지정한다. 기본값 : 클래스 이름을 그대로 사용 같은 클래스 이름이 없으면 가급적 기본값을 사용한다.     package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity //JPA가 관리하는 객체 Entity\r//@Entity(name=\u0026quot;Member\u0026quot;) //기본 값이 아닌 다른 이름으로 Entity 명을 지정할때 사용\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r @Table    @Table은 엔티티와 매핑할 테이블 지정      속성 기능 기본값     name 매핑할 이름 엔티티 이름을 사용   catalog 데이터베이스 catalog 매핑    schema 데이터베이스 schema 매핑    uniqueConstraints(DDL) DDL 생성시에 유니크 제약조건 생성      JpaMain.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity @Table(name=\u0026quot;MBR\u0026quot;) //데이터베이스의 MBR 테이블로 매핑하여, SQL이 MBR로 생성\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r 데이터베이스 스키마 자동 생성    DDL을 애플리케이션 실행 시점에 자동 생성 테이블 중심 -\u0026gt; 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 이렇게 생성된 DDL은 개발장비에서만 사용 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용   데이터베이스 스키마 자동 생성 - 속성   persistence.xml 옵션   \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r    옵션 설명     create 기존테이블 삭제 후 다시 생성 (Drop + Create)   create-drop create와 같으나 종료시점에 테이블 Drop   update 변경분만 반영(운영 DB에는 사용하면 안됨)   validation 엔티티와 테이블이 정상 매핑되어있는지만 확인   none 사용하지 않음    Create  persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r  Member 테이블을 먼저 drop하고 create 문을 실행\n Create - 컬럼 추가 후 애플리케이션 재실행  Member.Java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rprivate int age; // 추가된 컬럼\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name, int age){\rthis.id = id;\rthis.name = name;\rthis.age = age;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r}\r  이후 다시 애플리케이션을 다시 실행시켜보면,\n  추가된 컬럼을 포함하여 Member 테이블이 다시 생성된다.\n create-drop  create와 같지만 종료시점에 생성한 테이블 모두 drop, 예를들어 테스트 케이스 수행후 삭제할때 사용가능\n  persistence.xml\n ...\r\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create-drop\u0026quot; /\u0026gt;\r...\r  종료시에 drop을 하는것을 볼 수 있다.\n update  추가 했던 age를 잠깐 다시 돌려두고, create 후 update를 실행해 보겠습니다.\n  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r  Member.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  다시 update로 수정후 애플리케이션 재시작\n  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;update\u0026quot; /\u0026gt;\r  Member.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\rprivate int age;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name, int age){\rthis.id = id;\rthis.name = name;\rthis.age = age;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic int getAge() {\rreturn age;\r}\rpublic void setAge(int age) {\rthis.age = age;\r}\r}\r  추가된 컬럼만 alter table을 통하여 스키마 수정됩니다.\n  만약, 컬럼을 삭제한 뒤의 update 상태에서 애플리케이션 재시작할 경우에는\n  Memeber.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  삭제된 컬럼은 update 옵션에 의해 alter table로 수정되지 않습니다. H2 데이터베이스에서 확인하면\n  변경이 안된 테이블을 확인 할 수 있습니다.\n  실수라도 테이블 컬럼을 삭제하여, 데이터가 날아갈 수 있기 때문에 컬럼 삭제는 update 옵션에서 변경을 지원하지 않습니다.\n validate  테이블과 entity가 정상 매핑되어있는지 확인해 줍니다.\n  새로운 컬럼을 추가하고\n  Memeber.java\n  private String address;\r  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;validate\u0026quot; /\u0026gt;\r  애플리케이션 재시작\n  Schema-validation: missing column [address] in table [Member] MEMBER 테이블에 address가 없다고 오류가 발생하게 됩니다.\n none  스키마 자동 생성 사용안함으로 설정\n주석으로 해두는 것과 비슷하며, create, create-drop, update, validate가 아닌 어떤 문자열이 들어가 있어도 none과 같음\n 데이터베이스 방언 별로 달라지는것 확인 (varchar)  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;\r  create로 스키마 자동생성 옵션을 설정해 두고 재실행\n  persistence.xml - H2 방언 설정\n \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r  persistence.xml - Oracle 방언 설정\n \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r  방언에 따라서 적절하게 데이터베이스에 맞게 해석을 해서 실행을 해주는 것을 확인 할 수 있습니다. 다시 H2로 되돌려둠\n  persistence.xml - H2 방언 설정\n \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r 데이터베이스 스키마 자동 생성 - 주의   운영 장비에는 절대 create, create-drop, update 사용하면 안된다. 개발 초기 단계는 create 또는 update 테스트 서버는 update 또는 validate 스테이징과 운영 서버는 validate 또는 none   DDL 생성 기능  DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.\n  제약조건 추가 : 회원 이름은 필수, 10자 초과 X\n @Column(nullable = false, length = 10)     유니크 제약조건 추가  @Table(uniqueConstraints = {@UniqueConstraint( name = \u0026ldquo;NAME_AGE_UNIQUE\u0026rdquo;, columnNames = {\u0026ldquo;NAME\u0026rdquo;, \u0026ldquo;AGE\u0026rdquo;} )})   제약조건 추가  Member.java\n  @Column(unique = true, length = 10)\rprivate String name;\r  Member entity의 name 사이즈가 varchar(10)으로 생성되고, alter table을 통해 제약조건을 추가한 것을 확인 할 수 있습니다.\n 필드와 컬럼 매핑  요청사항 추가   회원은 일반 회원과 관리자로 구분해야 한다. 회원 가입일과 수정일이 있어야 한다. 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.    Member.java\n package hellojpa;\rimport javax.persistence.*;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) // 엔티티 명은 userName으로, DB 컬럼명을 name으로 매핑하여 사용 지정\rprivate String userName;\rprivate Integer age; // Integer 타입으로 생성하면 DB에서도 가장 Integer랑 가장 적절한 컬럼으로 숫자 타입 생성\r@Enumerated(EnumType.STRING) // 객체에서 ENUM 타입을 쓰고싶을때, DB에는 이넘 타입이 없음(비슷한 것이 있는 DB도 있음)\rprivate RoleType roleType;\r@Temporal(TemporalType.TIMESTAMP) // 날짜타입생성 Date, Time, Timestamp 3가지 타입이 있음\rprivate Date createdDate;\r@Temporal(TemporalType.TIMESTAMP)\rprivate Date modifiedDate;\r@Lob // DB에 varchar를 넘어서는 문자를 넣고 싶을때, 예를 들면 게시판 contents, 파일 바이너리 등\rprivate String description;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\r}\r  RoleType.java\n package hellojpa;\rpublic enum RoleType {\rUSER, ADMIN\r}\r  JpaMain.java 의 tx.transaction 내부 소스를 지우고 실행한다.\n 매핑 어노테이션 정리 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-ㄴ\n   어노테이션 설명     @Column 컬럼 매핑   @Temporal 날짜 타입 매핑   @Enumerated enum 타입 매핑   @Lob BLOB, CLOB 매핑   @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)    @Column 옵션 정리     속성 설명 기본값     name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름   inertable 등록 가능여부 Ture   updatable 변경 가능여부 Ture   nullable(DDL) null 값의 허용 여부 설정. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.    unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용 한다.    columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다. ex) varchar(100) default \u0026lsquo;EMPTY\u0026rsquo; 필드의 자바 타입과 방언 정보를 사용   length(DDL) 문자 길이 제약조건, String 타입에만 사용 255   percision,\nscale(DDL) BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다).\nprecision은 소수점을 포함한 전체 자릿수를, scale은 소수의 자리수다. 참고로 double, float 타입에는 적용되지 않는다. 정밀한 소수를 다루어야 할 때만 사용한다.      insertable과 updateable은 기본적으로 True로 되어있으며, updateable = false 라면, JPA를 통하여 inesert를 하지만, 변경에 대해서 update를 하지 않는다.   nullable은 기본적으로 true이며, false로 설정하면, name varchar(255) not null DDL에 not null 제약조건이 걸린다.\n  unique는 잘 사용하지 않는다. 제약조건 생성시 alter table Member add constraint UK_ektea8vp6e3low620iewuxhlq unique (name) 이런식으로 임의의 유니크 키가 생성되어 오류가 났을때 바로 알아보기가 힘들기 때문. 그래서 @Table를 사용해 제약조건을 지정하여 사용합니다.\n \u0026gt; - @Table(uniqueConstraints = {@UniqueConstraint( name = \u0026quot;NAME_AGE_UNIQUE\u0026quot;,\rcolumnNames = {\u0026quot;NAME\u0026quot;, \u0026quot;AGE\u0026quot;} )})\r @Enumerated   자바 enum 타입을 매피할 때 사용\n  주의 ! ORDINAL 사용 X\n    속성 설명 기본값     value EnumType.ORDINAL : enum 순서를 데이터 베이스에 저장 EnumType.ORDINAL   value EnumType.STRING : enum 이름를 데이터 베이스에 저장 EnumType.ORDINAL    EnumType.ORDINAL 와 EnumType.STRING 비교 EnumType.ORDINAL 일때  Member.java - EnumType.ORDINAL으로 설정 (Setter Getter 추가)\n package hellojpa;\rimport javax.persistence.*;\rimport java.util.Date;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;, length = 10) // 엔티티 명은 userName으로, DB 컬럼명을 name으로 매핑하여 사용 지정\rprivate String userName;\rprivate Integer age; // Integer 타입으로 생성하면 DB에서도 가장 Integer랑 가장 적절한 컬럼으로 숫자 타입 생성\r@Enumerated(EnumType.ORDINAL) // Enum의 인덱스가 들어감\r//@Enumerated(EnumType.STRING) // 객체에서 ENUM 타입을 쓰고싶을때, DB에는 이넘 타입이 없음(비슷한 것이 있는 DB도 있음)\rprivate RoleType roleType;\r@Temporal(TemporalType.TIMESTAMP) // 날짜타입생성 Date, Time, Timestamp 3가지 타입이 있음\rprivate Date createdDate;\r@Temporal(TemporalType.TIMESTAMP)\rprivate Date modifiedDate;\r@Lob // DB에 varchar를 넘어서는 문자를 넣고 싶을때, 예를 들면 게시판 contents, 파일 바이너리 등\rprivate String description;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getUserName() {\rreturn userName;\r}\rpublic void setUserName(String userName) {\rthis.userName = userName;\r}\rpublic Integer getAge() {\rreturn age;\r}\rpublic void setAge(Integer age) {\rthis.age = age;\r}\rpublic RoleType getRoleType() {\rreturn roleType;\r}\rpublic void setRoleType(RoleType roleType) {\rthis.roleType = roleType;\r}\rpublic Date getCreatedDate() {\rreturn createdDate;\r}\rpublic void setCreatedDate(Date createdDate) {\rthis.createdDate = createdDate;\r}\rpublic Date getModifiedDate() {\rreturn modifiedDate;\r}\rpublic void setModifiedDate(Date modifiedDate) {\rthis.modifiedDate = modifiedDate;\r}\rpublic String getDescription() {\rreturn description;\r}\rpublic void setDescription(String description) {\rthis.description = description;\r}\r}\r  JpaMain.java\n \rMember member = new Member();\rmember.setId(21L);\rmember.setAge(27);\rmember.setUserName(\u0026quot;테스트 A\u0026quot;);\rmember.setRoleType(RoleType.ADMIN);\rem.persist(member);\rtx.commit();\r  roleType가 Integer로 생성된 것이 확인 됩니다. DB에 어떻게 저장되었는지 확인 해보겠습니다.\n  EnumType.ORDINAL 로 설정시 DB에는 roleType enum의 인덱스가 들어갑니다. EnumType.ORDINAL을 사용하면 안되는 점이 요구사항으로 Guest가 추가되었다고 생각하게 되면 일반적으로 권한의 중요도에 따라 Guest, User, Admin 순으로 수정을 하였다고 생각하면, DB에 저장되어있는 roleType은 User가 0, Admin이 1인 상태라 데이터의 매핑이 잘못된 데이터가 생기게 됩니다.\n  RoleType.java\n package hellojpa;\rpublic enum RoleType {\rGUEST, USER, ADMIN\r}\r  persistence.xml\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;update\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r  JpaMain.java\n  Member member3 = new Member();\rmember3.setId(23L);\rmember3.setAge(29);\rmember3.setUserName(\u0026quot;테스트 C\u0026quot;);\rmember3.setRoleType(RoleType.GUEST);\rem.persist(member3);\rtx.commit();\r  enum의 0번째 인덱스에 GUEST가 추가되면서 DB의 RoleType이 3번째 사용자 빼고 전부 잘못된 것을 확인할 수 있습니다.\n EnumType.STRING 일때  persistence.xml - 다시 create로 바꿔 설정\n \u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt; \u0026lt;!-- create, create-drop, update, validate, none --\u0026gt;\r  Memeber.java - EnumType.STRING 으로 설정\n  // 객체에서 ENUM 타입을 쓰고싶을때, DB에는 이넘 타입이 없음(비슷한 것이 있는 DB도 있음)\r//@Enumerated(EnumType.ORDINAL) // Enum의 인덱스가 들어감\r@Enumerated(EnumType.STRING)\rprivate RoleType roleType;\r  재실행\n  roleType 가 varchar(255)로 생성된 것을 확인\n  roleType의 데이터가 GUEST로 들어간 것을 확인할 수 있습니다. 몇자 아끼려다 큰 장애를 경험할 수 있기 때문에 ORDINAL이 아니라 STRING으로 사용하길 권장드립니다.\n @Temporal   날짜 타입(java.util.Date, java.util.Canendar)를 매핑할 때 사용   참고 : LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)\n  Member.java\n  private LocalDate createdAt;\rprivate LocalDate modifiedAt;\rprivate LocalDateTime createdTime;\rprivate LocalDateTime modifiedTime;\r  createdAt, modifiedAt 은 DATE 타입으로 생성되었고, createdTime, modifiedTime은 TIMESTAMP로 생성된 것을 확인 할 수 있습니다.\n @Lob   데이터베이스 BLOB, CLOB 타입과 매핑\n @Lob에는 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑  CLOB : String, char[], java.sql.CLOB BLOB : byte[], java.sql.BLOB     @Transient    필드 매핑 사용 X 데이터베이스에 저장X, 조회X 주로 메모리상에서만 임시로 어떤 값을 보관하고 싶을 때 사용   \t@Transient\rprivate Integer temp;\r 참고   자바 ORM 표준 JPA - 김영한   ","description":"객체와 매핑","id":6,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 객체와 매핑","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/entity-mapping/"},{"content":"JPA 영속성 관리 - 내부 동작 방식  영속성 컨텍스트  JPA에서 가장 중요한 2가지    객체와 관계형 데이터베이트 매핑하기 (Object Relational Mapping) 영속성 컨텍스트   엔티티 매니저 팩토리와 앤티티 매니저   요청이 오면 앤티티 매니저 팩토리를 통해 엔티티 매니저를 생성하고, 앤티티 매니저는 커넥션풀을 이용해 DB에 접근 합니다.\n 영속성 컨텍스트    JPA를 이해하는데 가장 중요한 용어 \u0026ldquo;엔티티를 영구 저장하는 환경\u0026quot;이라는 뜻 EntitiyManager.persist(entity); // persist 메소드는 DB에 저장하는게 아니라 entity를 영속성 컨텍스트에 저장한다는 것   엔티티 매니저? 영속성 컨텍스트?    영속성 컨텍스트는 논리적인 개념 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근   J2SE 환경  엔티티 매니저와 영속성 컨텍스트가 1:1  J2EE, 스프링 프레임워크 같은 컨테이너 환경  엔티티 매니저와 영속성 컨텍스트가 N:1  엔티티의 생명주기    비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태     영속 (managed) 영속성 컨텍스트에 관리되는 상태     준영속 (datached) 영속성 컨텍스트에 저장되었다가 분리된상태     삭제 (removed) 삭제된 상태   비영속 (new/transient)  객체만 생성하고 세팅한 상태\n  JpaMain.java\n ...\r// 객체를 생성한 상태(비영속)\rMember member = new Mamber();\rmember.setId(2L);\rmember.setName(\u0026quot;회원2\u0026quot;)\r...\r 영속 (managed)  객체만 생성하고 세팅한 상태\n  JpaMain.java\n // 객체를 생성한 상태(비영속)\rMember member = new Mamber();\rmember.setId(2L);\rmember.setName(\u0026quot;회원2\u0026quot;)\rEntitiyManager em = emf.createEntityManager();\rem.getTransaction().begin();\r// 객체를 저장한 상태(영속)\rem.persist(member);\r// 객체를 비영속 상태로 변경\r//em.detach(member) // 객체를 DB에서 삭제\r//em.remove(member) tx.commit(); // 실제 쿼리가 실행되는 지점\r 영속성 컨텍스트의 이점   영속성 컨텍스트는 객체와 DB 사이에 하나의 계층이 있는것\n   1차 캐시 동일성(identity) 보장 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 변경 감지(dirty checking) 지연 로딩(lazy loading)   엔티티 조회, 1차 캐시  영속성 컨텍스트는 내부에 1차 캐시를 가지고 있습니다. @Id가 키가 되고 값은 member객체 자체인 Map이라 생각하면 됩니다.\n  JpaMain.java\n // 엔티티를 생성한 상태(비영속)\rMember member = new Member();\rmember.setId(3L);\rmember.setName(\u0026quot;회원3\u0026quot;);\r// 엔티티를 영속\rem.persist(member);\r 1차 캐시에서 조회  JpaMain.java\n // 엔티티를 생성한 상태(비영속)\rMember member = new Member();\rmember.setId(3L);\rmember.setName(\u0026quot;회원3\u0026quot;);\r// 1차 캐시에 저장됨\rem.persist(member);\rMember findMemeber = em.find(Member.class, \u0026quot;3L\u0026quot;);\r  조회를 실행시 우선적으로 1차 캐시에 값으로 객체가 있는지 확인 후 있으면 캐시에서 바로 가져오고, 없는 경우 DB에서 조회를 하여 1차 캐시에 저장하고 객체를 가져오게 됩니다.\n DB에서 조회  JpaMain.java\n ...\rMember findMemeber = em.find(Member.class, \u0026quot;10L\u0026quot;);\r...\r  commit()이후에 Insert를 하지만, Select문이 나오지 않는다. 이미 1차 캐시에서 조회하여 커밋 이전에 출력한다.\n  같은 객체를 여러번 조회를 하면, 1번만 Select 문을 날리고 이후 1차 캐시에서 조회\n 영속 엔티티의 동일성 보장   JpaMain.java\n  Member findMember1 = em.find(Member.class, 10L);\rMember findMember2 = em.find(Member.class, 10L);\rSystem.out.println(findMember1 == findMember2);\r  같은 트랜잭션 안에서는 조회한 같은 객체는 동일한 객체로 인식 보장\n 엔티티 등록 - 트랜잭션을 지원하는 쓰기 지연   JpaMain.java\n  EntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\rtry{\rMember meber1 = new Member();\rMember meber2 = new Member();\rmeber1.setId(11L);\rmeber1.setName(\u0026quot;회원11\u0026quot;);\rmeber2.setId(12L);\rmeber2.setName(\u0026quot;회원12\u0026quot;);\r// 영속\rSystem.out.println(\u0026quot;=== BEFORE ===\u0026quot;);\rem.persist(meber1);\rem.persist(meber2);\rSystem.out.println(\u0026quot;=== AFTER ===\u0026quot;);\r// 여기까지 DB에 Insert 하지 않는다.\rtx.commit(); // [트랜잭션] 카밋\r  em.persist()로 memberA와 memberB를 저장할때, 영속 컨텍스트안의 쓰기지연 SQL 저장소에 memberA를 Insert SQL을 저장하고\n그리고 이후에 memberB에 대한 Insert SQL을 쓰기지연 SQL 저장소에 저장합니다. 여기 까지 DB에 저장하지 않고 commit과 함께 DB에 저장합니다.\n transaction.commit();  트랜잭션이 커밋될때 좀더 자세히 그림으로 설명하면 아래와 같습니다.\n  커밋을 하게되면 쓰기지연 저장소에 있는 SQL들을 flush하며, DB에 SQL문들을 DB에 커밋하게 됩니다.\n  Member.java\n package hellojpa;\rimport javax.persistence.Entity;\rimport javax.persistence.Id;\r@Entity\rpublic class Member {\r@Id\rprivate Long id;\rprivate String name;\r// JPA 기본적으로 동적으로 객체를 생성하는 기능이 있어, 기본 생성자도 추가해줘야 된다.\rpublic Member() {\r}\rpublic Member(Long id, String name){\rthis.id = id;\rthis.name = name;\r}\rpublic Long getId() {\rreturn id;\r}\rpublic void setId(Long id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r}\r  굳이 하나씩 보내도 되는데 왜 커밋과 함께 DB에 Insert 하느냐 하면 성능을 위해 설정하여 튜닝할 수 있는 여지를 주기 위함이라 합니다.   JPA의 옵션중\n  persistence.xml - hibernate.jdbc.batch_size\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r...\r\u0026lt;!-- 한번에 같은 데이터 베이스에 데이터를 집어넣을때 모아서 한번에 인서트 하는 jdbc batch의 수를 지정--\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.jdbc.batch_size\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt;\r...\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r  옵션 하나로 JPA의 성능에 대한 이점을 챙길 수 있습니다.\n 엔티티 수정 - 변경 감지(dirty checking)   JPA에서는 컬렉션에서 값을 수정하는 것처럼 따로 저장하지 않아도 변경 감지를 통해 commit시 Update 문을 자동으로 수행\n  JpaMain.java\n EntityMananger em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // [트랜잭션] 시작\r// 영속 엔티티 조회\rMember MemberA = em.find(Member.class, 10L);\r// 영속 엔티티 데이터 수정\rMemberA.setName(\u0026quot;사용자10\u0026quot;);\r// 이런 코드가 필요하지 않을까?\r//em.update(member);\rtx.commit(); // [트랜잭션] 커밋\r  DB에서 값을 Select 하고 값을 수정만 하고 저장을 따로 하지 않았지만, Update 쿼리까지 실행됩니다.\n 변경 감지(dirty checking)  커밋하는 시점에 변경 감지를 통해 벌어지는 일을 그림으로 그리면 아래와 같습니다.\n커밋을 하게 되면 내부적으로 flush()를 실행하게 되고, 엔티티와 스냅샷을 비교하게됩니다. 스냅샷은 객체를 읽어올 당시의 값을 스냅샷으로 저장합니다. 트랜잭션에서 커밋하는 시점에 플러시가 호출되며 엔티티와 스냅샷을 비교하여, 변경사항을 쓰기 지연 SQL 저장소에 Update SQL을 저장합니다. 그리고 DB에 Update SQL을 반영하고 commit()을 수행합니다.\n 엔티티 삭제   JpaMain.java\n // 삭제할 대상 엔티티 조회\rMember memberA = em.find(Member.class, 11L);\rem.remove(memberA); // 엔티티 삭제\r 플러시   영속성 컨텍스트의 변경내용을 데이터베이스에 반영\n 플러시 발생   트랜잭션이 커밋되면 자동적으로 플로시가 발생되며, 1차 캐시의 변동없음(다른 flush의 비우는 기능과 다름.)\n   변경감지(dirty checking) 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터 베이스에 전송(등록, 수정, 삭제 쿼리)   영속성 컨텍스트를 플러시 하는 방법    em.flush() - 직접 호출 (잘 사용은 안되지만, 테스트 시 알아두면 유용) 트랜잭션 커밋 - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출    다른 예제들과 다르게 라인 \u0026ldquo;===========\u0026rdquo; 보다 이전에 flush()를 실행항 당시 변경 사항의 SQL이 로그에 찍히게됨.\n JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유   JpaMain.java\n em.persist(memberA);\rem.persist(memberB);\rem.persist(memberC);\r//중간에 JPQL 실행 query = em.createQuery(\u0026quot;select m from Member m\u0026quot;, Member.class);\rList\u0026lt;Member\u0026gt; members = query.getResultList();\r  만일 memberA, memberB, memberC를 영속화 하고, Member 테이블의 전체 리스트를 조회하면 아무 결과가 안나올 것입니다. 아직 commit()을 통한 flush()가 실행 되기 이전이기 떄문입니다. 이러한 문제점을 해결하기 위해 JPA에서는 JPQL을 실행할 때 우선 flush()를 실행합니다.\n 플러시 모드 옵션   JpaMain.java\n em.setFlushMode(FlushModeType.COMMIT);\r   FlushModeType.AUTO - 트랜잭션 커밋이나 쿼리(JPQL)를 실행할 때 플러시(기본값) FlushModeType.COMMIT - 커밋할 때만 플러시   플러시는 !    영속성 컨텍스트를 비우지 않음 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 트랜잭션이라는 작업 단위가 중요 -\u0026gt; 커밋 직전에만 동기화하면 됨   준영속 상태    영속 -\u0026gt; 준영속 1차 캐시에 있고 JPA가 관리하는 상태     영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 영속성 컨텍스트가 제공하는 기능을 사용 못함   준영속 상태로 만드는 방법    em.detach(entity) - 특정 엔티티만 준영속 상태로 전환 em.claer() - 영속성 컨텍스트를 완전히 초기화 em.close() - 영속성 컨텍스트를 종료   참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 내부 동작 방식","id":7,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 영속성 관리","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/persistence-manage/"},{"content":"JPA 시작하기  Hello JPA - 프로젝트 생성  H2 Database 설치   H2 홈페이지에서 OS에 맞는 설치 파일을 다운로드한다.\n  C:\\Program Files (x86)\\H2\\bin\\h2.bat 실행\n  http://localhost:8082/login.jsp 에서 연결버튼 클릭\n SpringBoot 프로젝트 생성  pom.xml  hibernate와 h2database dependency 추가\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot;\rxmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;jpa-basic\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;ex1-hello-jpa\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- JPA 하이버네이트 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;hibernate-entitymanager\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;5.6.1.Final\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- H2 데이터베이스 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt; \u0026lt;!-- 설치한 H2 database 버전과 동일, 202 버전 설치 하였지만 202 버전은 없어 200으로 설치 --\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/project\u0026gt;\r 스프링부트에 맞는 Dependency 버전확인  JPA 설정하기 - persistence.xml    JPA 설정 파일 /META-INF/persistence.xml 위치 /ex1-hello-jpa/src/main/resources/META-INF/persistence.xml     persistence-unit name으로 이름 지정 javax.persistence로 시작: JPA 표준 속성 hibernate로 시작: 하이버네이트 전용 속성    persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;persistence version=\u0026quot;2.2\u0026quot; xmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt; \u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- 필수 속성 --\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt; \u0026lt;!-- 옵션 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;--\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/persistence-unit\u0026gt; \u0026lt;/persistence\u0026gt;  데이터베이스 방언   SQL 표준을 지치지 않는 특정 데이터베이스의 고유한 기능\n   JPA는 특정 데이터베ㅔ이스에 종속 X 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다름 \u0026gt; - 가변 문자 : MySQL은 VARCHAR, Oracle은 Varchar2 \u0026gt; - 문자열을 자르는 함수 : SQL 표준은 SUBSTRING(), Oracle은 SUBSTR() \u0026gt; - 페이지 : MySQL은 LIMIT, Oracle은 ROWNUM   데이터베이스 방언 옵션   hibernate.dialect 속성에 지정 H2 : org.hibernate.dialect.H2Dialect Oracle 10g : org.hibernate.dialect.Oracle10gDialect MySQL : org.hibernate.dialect.MySQL5InnoDBDialect 하이버네이트는 40가지 이상의 데이터베이스 방언 지원   JPA 구동 방식  실습 - JPA 동작 확인    JpaMain 클래스 생성 JPA 동작 확인    persistence.xml 설정이 잘되어 있어야 Persistence. 했을때 뜸, PersistenceUnitName은 persistence.xml에 설정된 persistence-unit의 name\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.H2Dialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;--\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r EntitiyManagerFactory 생성 후 실행  JpaMain.java\n \rpackage hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\r// 실제 구현 위치\r// 사용 후 닫아줘야한다 em.close();\temf.close(); }\r}\r 객체 테이블을 생성하고 매핑하기    @Entity : JPA가 관리할 객체 @Id : 데이터베이스 PK와 패밍    Member.java\n package hellojpa; import javax.persistence.Entity; // 비슷한게 나오면 javax import javax.persistence.Id; @Entity // 중요\rpublic class Member { @Id private Long id; private String name; //Getter, Setter … } create table Me\r  MEMBER CREATE SQL\n create table Member ( id bigint not null, name varchar(255), primary key (id) )\r H2 Database에서 SQL 실행 Member.java 생성  main과 같은 경로에 생성\n Member에 데이터 Insert   Member.java 생성후 실행\n  Id를 추가 하지 않았기 때문에 JPA에서 Id를 포함하라고 오류를 발생\n Exception in thread \u0026quot;main\u0026quot; javax.persistence.PersistenceException: org.hibernate.id.IdentifierGenerationException: ids for this class must be manually assigned before calling save(): hellojpa.Member\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:154)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:181)\rat org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:188)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:807)\rat org.hibernate.internal.SessionImpl.persist(SessionImpl.java:785)\rat hellojpa.JpaMain.main(JpaMain.java:16)\rCaused by: org.hibernate.id.IdentifierGenerationException: ids for this class must be manually assigned before calling save(): hellojpa.Member\rat org.hibernate.id.Assigned.generate(Assigned.java:33)\rat org.hibernate.event.internal.AbstractSaveEventListener.saveWithGeneratedId(AbstractSaveEventListener.java:119)\rat org.hibernate.event.internal.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:192)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:135)\rat org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:62)\rat org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:800)\r... 2 more\r  JpaMain.java - member.id, memeber.name 세팅\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rMember member = new Member();\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rem.close();\remf.close();\r}\r}\r  하지만 그래도 오류가 발생..\n \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_271\\bin\\java.exe\u0026quot; \u0026quot;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\lib\\idea_rt.jar=52200:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\bin\u0026quot; -Dfile.encoding=UTF-8 -classpath \u0026quot;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_271\\jre\\lib\\rt.jar;C:\\develop\\Git\\jpa-basic\\ex1-hello-jpa\\target\\classes;C:\\Users\\offetuoso\\.m2\\repository\\org\\hibernate\\hibernate-entitymanager\\5.3.10.Final\\hibernate-entitymanager-5.3.10.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\jboss\\logging\\jboss-logging\\3.3.2.Final\\jboss-logging-3.3.2.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\hibernate\\hibernate-core\\5.3.10.Final\\hibernate-core-5.3.10.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\javassist\\javassist\\3.23.2-GA\\javassist-3.23.2-GA.jar;C:\\Users\\offetuoso\\.m2\\repository\\antlr\\antlr\\2.7.7\\antlr-2.7.7.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\jboss\\jandex\\2.0.5.Final\\jandex-2.0.5.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\com\\fasterxml\\classmate\\1.3.4\\classmate-1.3.4.jar;C:\\Users\\offetuoso\\.m2\\repository\\javax\\activation\\javax.activation-api\\1.2.0\\javax.activation-api-1.2.0.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\dom4j\\dom4j\\2.1.1\\dom4j-2.1.1.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\hibernate\\common\\hibernate-commons-annotations\\5.0.4.Final\\hibernate-commons-annotations-5.0.4.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\javax\\persistence\\javax.persistence-api\\2.2\\javax.persistence-api-2.2.jar;C:\\Users\\offetuoso\\.m2\\repository\\net\\bytebuddy\\byte-buddy\\1.9.5\\byte-buddy-1.9.5.jar;C:\\Users\\offetuoso\\.m2\\repository\\org\\jboss\\spec\\javax\\transaction\\jboss-transaction-api_1.2_spec\\1.1.1.Final\\jboss-transaction-api_1.2_spec-1.1.1.Final.jar;C:\\Users\\offetuoso\\.m2\\repository\\com\\h2database\\h2\\1.4.200\\h2-1.4.200.jar\u0026quot; hellojpa.JpaMain\r12월 19, 2021 9:58:07 오후 org.hibernate.jpa.internal.util.LogHelper logPersistenceUnitInformation\rINFO: HHH000204: Processing PersistenceUnitInfo [\rname: hello\r...]\r12월 19, 2021 9:58:07 오후 org.hibernate.Version logVersion\rINFO: HHH000412: Hibernate Core {5.3.10.Final}\r12월 19, 2021 9:58:07 오후 org.hibernate.cfg.Environment \u0026lt;clinit\u0026gt;\rINFO: HHH000206: hibernate.properties not found\r12월 19, 2021 9:58:08 오후 org.hibernate.annotations.common.reflection.java.JavaReflectionManager \u0026lt;clinit\u0026gt;\rINFO: HCANN000001: Hibernate Commons Annotations {5.0.4.Final}\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl configure\rWARN: HHH10001002: Using Hibernate built-in connection pool (not for production use!)\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator\rINFO: HHH10001005: using driver [org.h2.Driver] at URL [jdbc:h2:tcp://localhost/~/test]\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator\rINFO: HHH10001001: Connection properties: {user=sa}\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator\rINFO: HHH10001003: Autocommit mode: false\r12월 19, 2021 9:58:09 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PooledConnections \u0026lt;init\u0026gt;\rINFO: HHH000115: Hibernate connection pool size: 20 (min=1)\r12월 19, 2021 9:58:09 오후 org.hibernate.dialect.Dialect \u0026lt;init\u0026gt;\rINFO: HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\r12월 19, 2021 9:58:10 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl stop\rINFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]\rProcess finished with exit code 0\r  JPA에서는 Transaction이 매우 중요한데, JPA의 모든 작업은 Transaction 안에서 이루어져야한다.\n EntityTransaction 추가  JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin(); // 트랜잭션 시작\rMember member = new Member();\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit(); // 트랜잭션 커밋\rem.close();\remf.close();\r}\r}\r  Transaction을 추가후 실행\n  persistence.xml 옵션 설명\n  \u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r  그래고 H2 DataBase에 어떠한 테이블로 저장하겠다 설정을 하지 않았지만, 관례에 따라 @Entity의 Class명에 Insert 합니다. 또한 테이블 명을 지정하고 싶다면 @Table(name = \u0026ldquo;테이블명\u0026rdquo;)을 이용해 저장될 테이블을 세팅할 수 있습니다. 그리고 @Column(name=\u0026ldquo;컬럼명\u0026rdquo;)을 통해 저장할 컬럼을 매핑 할 수도 있습니다.\n  Member.java\n \r@Entity\r@Table(name = \u0026quot;Member\u0026quot;)\rpublic class Member {\r@Id\rprivate Long id;\r@Column(name=\u0026quot;name\u0026quot;)\rprivate String name;\r  그리고 문제가 있을때를 대비해서 Try Catch문도 포함해 줍니다.\n  JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rMember member = new Member();\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\rem.find(Member.class, 1L);\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r Member 데이터 Select   JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rMember member = new Member();\r/*\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(\u0026quot;findMember.id = \u0026quot; + findMember.getId());\rSystem.out.println(\u0026quot;findMember.name = \u0026quot; + findMember.getName());\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r Member 데이터 Update   JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rMember member = new Member();\r/*\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(\u0026quot;findMember.id = \u0026quot; + findMember.getId());\rSystem.out.println(\u0026quot;findMember.name = \u0026quot; + findMember.getName());\rfindMember.setName(\u0026quot;김철수\u0026quot;);\rtx.commit();\rSystem.out.println(\u0026quot;findMember.id = \u0026quot; + findMember.getId());\rSystem.out.println(\u0026quot;findMember.name = \u0026quot; + findMember.getName());\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r  변경된 것을 확인 할 수 있습니다. commit을 할때 set()을 통해 변경사항이 있는경우 JPA가 자동으로 Update를 해준다.\n 주의    엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유 엔티티 매니저는 쓰레드간 공유하면 절대 안됨 (사용하고 버려야한다.) JPA는 모든 데이터 변경은 트랜잭션 안에서 실행   JPQL 소개   간단 조회는 키값을 넣고 findMember하고 데이터 불러다 사용하면 되는데, 조건을 사용한 검색을 해야할때 어떻게 해야할까? 나이가 18살 이상인 회원을 모두 검색하고 싶다면?\n   가장 단순한 조회 방법 \u0026gt; - EntityManager.find() \u0026gt; - 객체 그래프 탐색 (a.getB().getC())   실습 - JPQL 소개    JPQL로 전체 회원 검색 JPQL로 ID가 2개 이상인 회원만 검색 JPQL로 이름이 같은 회원만 검색 JPQL에 대해 자세한 내용은 객체지향 쿼리에서 학습   실습  JpaMain.java\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rList\u0026lt;Member \u0026gt; resultList = em.createQuery(\u0026quot;select m from Member as m\u0026quot;, Member.class).getResultList();\rfor(Member member : resultList){\rSystem.out.println(\u0026quot;member.name = \u0026quot; + member.getName());\r}\r/*\r// Insert\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\r/*\r// Select\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r/*\r//Update\rfindMember.setName(\u0026quot;김철수\u0026quot;);\rtx.commit();\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r 결과 Hibernate: /* select\rm -- member 엔티티\rfrom\rMember as m */ select\rmember0_.id as id1_0_,\rmember0_.name as name2_0_ from\rMember member0_\rmember.name = 김철수\r  추가로 페이징을 추가할 경우\n package hellojpa;\rimport javax.persistence.EntityManager;\rimport javax.persistence.EntityManagerFactory;\rimport javax.persistence.EntityTransaction;\rimport javax.persistence.Persistence;\rimport java.util.List;\rpublic class JpaMain {\r//psvm 단축키로 생성 가능\rpublic static void main(String[] args) {\rEntityManagerFactory emf = Persistence.createEntityManagerFactory(\u0026quot;hello\u0026quot;);\rEntityManager em = emf.createEntityManager();\rEntityTransaction tx = em.getTransaction();\rtx.begin();\rtry{\rList\u0026lt;Member \u0026gt; resultList = em.createQuery(\u0026quot;select m from Member as m\u0026quot;, Member.class)\r.setFirstResult(1) // 로우 1 부터\r.setMaxResults(8)\t// 로우 8 까지\r.getResultList();\rfor(Member member : resultList ){\rSystem.out.println(\u0026quot;member.name = \u0026quot; + member.getName());\r}\r/*\r// Insert\rmember.setId(1L);\rmember.setName(\u0026quot;홍길동\u0026quot;);\rem.persist(member);\rtx.commit();\r*/\r/*\r// Select\rMember findMember = em.find(Member.class, 1L);\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r/*\r//Update\rfindMember.setName(\u0026quot;김철수\u0026quot;);\rtx.commit();\rSystem.out.println(findMember.getId());\rSystem.out.println(findMember.getName());\r*/\r}catch (Exception e){\rtx.rollback();\r}finally {\rem.close();\r}\remf.close();\r}\r}\r 페이징 추가 결과 Hibernate: /* select\rm from\rMember as m */ select\rmember0_.id as id1_0_,\rmember0_.name as name2_0_ from\rMember member0_ limit ? offset ?\r  H2 SQL로 결과가 나오지만, persistence.xml의 hibernate.dialect를 오라클로 변경하면\n  persistence.xml\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;persistence version=\u0026quot;2.2\u0026quot;\rxmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\rxsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\u0026quot;\u0026gt;\r\u0026lt;persistence-unit name=\u0026quot;hello\u0026quot;\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;!-- 필수 속성 --\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.driver\u0026quot; value=\u0026quot;org.h2.Driver\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.user\u0026quot; value=\u0026quot;sa\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.password\u0026quot; value=\u0026quot;\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;javax.persistence.jdbc.url\u0026quot; value=\u0026quot;jdbc:h2:tcp://localhost/~/test\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.dialect\u0026quot; value=\u0026quot;org.hibernate.dialect.Oracle8iDialect\u0026quot;/\u0026gt;\r\u0026lt;!-- 옵션 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.show_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 로깅 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.format_sql\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!-- 실행 sql 포메팅 --\u0026gt;\r\u0026lt;!-- /* insert hellojpa.Member */ JPA가 Inser 를 해서 이 쿼리가 나왔다는 것을 주석으로 설명 --\u0026gt;\r\u0026lt;property name=\u0026quot;hibernate.use_sql_comments\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;!--\u0026lt;property name=\u0026quot;hibernate.hbm2ddl.auto\u0026quot; value=\u0026quot;create\u0026quot; /\u0026gt;--\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;/persistence-unit\u0026gt;\r\u0026lt;/persistence\u0026gt;\r 결과  oracle 방언으로 변경된 SQL이 나온다.\n Hibernate: /* select\rm from\rMember as m */ select\r* from\r( select\rrow_.*,\rrownum rownum_ from\r( select\rmember0_.id as id1_0_,\rmember0_.name as name2_0_ from\rMember member0_ ) row_ ) where\rrownum_ \u0026lt;= ? and rownum_ \u0026gt; ?\r JPQL    JPA를 사용하면, 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 검색을 할 때에도 테이블이 아닌 엔티티 객체를 대상으로 검색 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요   JPQL    JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공 SQL과 문법 유사, Select, From, Where, Group By, Having, Join 지원 JPQL은 엔티티 객체를 대상으로 쿼리 SQL을 추상화해서 특정 데이터베이스 SQL에 의존X 테이블이 아닌 객체를 대상으로 검색하는 객체 지향쿼리 JPQL을 한마디로 정의하면 객체 지향 SQL \u0026lt;\u0026ndash;\u0026gt; SQL은 데이터베이스 테이블 대상으로 쿼리   참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 시작","id":8,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 시작","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/start-jpa/"},{"content":"JPA 애플리케이션   지금 시대는 객체를 관계형 DB에 관리 객체 지향 언어를 사용한 프로젝트라고 하여도 결국엔 SQL이 제일 중요할 수 밖에 없다. 관계형 DB가 알아 들을 수 있는 것은 SQL이니까\n SQL 중심적인 개발의 문제점    무한 반복, 지루한 코드   CRUD    INSERT UPDATE SELECT DELETE 자바 객체를 SQL로 .. SQL을 자바 객체로 ..   객체 CRUD   간단히 Member라는 객체를 생성하고, sql로 CRUD를 개발하였다고 생각하자.\n public class Member {\rprivate Long memberId;\rprivate String name;\r...\r}\rINSERT INTO MEMBER(MEMBER_ID, NAME) VALUES // 인서트 쿼리 변경\rSELECT MEMBER_ID, NAME FROM MEMBER M // 셀렉트 쿼리 변경\rUPDATE MEMBER SET … // 업데이트 쿼리 변경\r 객체 CRUD - 필드추가   개발이 끝났을때, 기획에서 연락처를 추가해 달라는 요청이 왔다\n public class Member {\rprivate Long memberId;\rprivate String name;\r/* 신규추가 tel */\rprivate String tel; ...\r}\r/*\rINSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUES -- 신규추가 tel\rSELECT MEMBER_ID, NAME, TEL FROM MEMBER M -- 신규추가 tel\rUPDATE MEMBER SET … , TEL = ? -- 신규추가 tel\r*/\r SQL에 의존적인 개발을 피하기 어렵다.   관계형 DB를 사용하는 이상 SQL에 의존적이며, DB의 테이블 또는 컬럼에 따라 SQL을 계속 수정하고 작성하게 되어있다.\n 패러다임의 불일치   관계형 데이터베이스의 사상과 객체 지향의 사상이 매우 다름\n 객체 VS 관계형 데이터베이스  관계형 데이터베이스  데이터를 잘 정규화 해서 보관\n 객체  속성과 기능을 묶어서 캡슐화 하여 객체간 유기적으로 사용\n 객체를 영구 보관하는 다양한 저장소    RDB NoSql File etc    현실적 대안은 RDB\n 객체를 관계형 데이터베이스에 저장  객체 -\u0026gt; SQL 변환 -\u0026gt; RDB   이렇게 객체를 SQL로 변환하여 주는 업무를 개발자가 한다. 출근해서 SQL을 하루종일 작성하고 있는것이.. SQL 매퍼의 일을 개발자가 하고 있다.\n 객체와 관계형 데이터베이스의 차이    상속 객체의 상속관계 같은 것은 없고 유사한 것은 있지만, 없다고 본다.      연관관계 객체 참조와 RDB의 PK, FK를 이용해 조인하여 연관관계를 찾을 수 있음      데이터 타입 데이터 식별 방법   상속 Album 저장   객체 분해 INSERT INTO ITEM \u0026hellip; INSERT INTO ALBUM ..   Album 조회   각각의 테이블에 따른 조인 SQL 작성 상속 관계에 따라 각각 객체 생성 SQL 조회결과에 따라 각각 객체에 데이터 세팅.. 등 복잡 그래서 DB에 저장할 객체에는 상속 관계 안쓴다   자바 컬렉션에 저장하면?  객체를 담을 수 있는 특별한 컬렉션이 있다고 가정하면 !\n list.add(album);\r 자바 컬렉션에서 조회하려면? Album album = list.get(albumId);\r//보모 타입으로 조회 후 다형성 활용\rItem item = list.get(albumId);\r  컬렉션에 넣고 빼는 것은 심플하지만, 관계형 DB에 넣고 빼는 순간 중간에서 SQL 매핑작업을 개발자가 손수 작업을 해줘야 한다.\n 연관관계   객체는 참조를 사용 : member.getTeam() 테이블은 외래 키를 사용 : JOIN ON M.TEAM_ID = T.TEAM_ID   객체를 테이블에 맞추어 모델링 class Member {\rLong id; // MEMBER_ID 컬럼 사용\rLong teamId;\t// TEAM_ID FK 컬럼 사용\rString username; // USERNAME 컬럼 사용\r}\rclass Team {\rLong id;\t// TEAM_ID PK 사용\rString name; // NAME 컬럼 사용\r}\r 테이블에 맞춘 객체 저장 객체다운 모델링 class Member {\rLong id; // MEMBER_ID 컬럼 사용\rTeam team;\t// 참조로 연관관계를 맺는다.\rString username; // USERNAME 컬럼 사용\rTeam getTeam(){\rreturn team;\r}\r}\rclass Team {\rLong id;\t// TEAM_ID PK 사용\rString name; // NAME 컬럼 사용\r}\r 객체 모델링 저장 객체 모델링 조회 --select.member.info\rSELECT M.*, T.*\rFROM MEMBER M\rJOIN TEAM T ON M.TEAM_ID = T.TEAM_ID\rpublic Member find(Long memberId){\r// SQL 실행\rMap result = sql.executeQuery(\u0026quot;select.member.info\u0026quot;);\r// 데이터베이스에서 조회한 회원 관련 정보 세팅\rMeber member = new Member();\rmember.set(\u0026quot;id\u0026quot;, result.get(\u0026quot;id\u0026quot;));\r...\r...\r// 데이터베이스에서 조회한 팀관련 정보를 모두 입력\rTeam team = new Team();\rteam.set(\u0026quot;id\u0026quot;, result.get(\u0026quot;teamId\u0026quot;));\r...\r...\r// 회원과 팀 관계 설정\rmember.setTeam(team);\r// 회원 객체 반환\rreturn member;\r}\r  이러한 번잡함을 해결하기 위해 Meber와 Team을 모두 포괄하는 SuperDto(MemberTeamDto) 등 으로 한번에 받음\n 객체 모델링, 자바 컬렉션에 관리  list.add(member);\rMember member = list.get(memberId);\rTeam team = member.getTeam();\r  자바 컬렉션에 넣는다고 생각하면 이러한 형태가 객체지향적으로 설계하기 괜찮음\n 객체 그래프 탐색  객체는 자유롭게 객체 그래프를 탐색 할 수 있어야 한다.\n 처음 실행하는 SQL에 따라 탐색 범위 결정 --select.member.info\rSELECT M.*, T.*\rFROM MEMBER M\rJOIN TEAM T ON M.TEAM_ID = T.TEAM_ID\rmember.getTema() //OK\rmember.getOrder() // null\r  조회한 sql에 따라 order 테이블엔 값이 있어도 sql에서 order를 조회 하지 않았기 때문에 getOrder()에서는 null이 발생\n 엔티티 신뢰 문제 class meberService {\r...\rpublic void process(){\rMember member = memberDAO.find(memberId);\rmember.getTeam();\t// ???\rmember.getOrder().getDelivery(); // ???\r}\r}\r  누군가 개발해둔 소스를 보고 Meamber를 조회하고, getTeam과 getOrder로 Team과 Order를 사용하면 되겠다 생각이 들겠지만, 실제로 memberDAO.find()를 열어서 실제 조회하는 sql을 확인하고 내부동작이 어떻게 되어있는지 확인 하지 않는 이상 어떤 결과가 있을지 모른다. 이러한 계층구조 객체를 레이어드 아키텍처라 하는데, 레이어드 아키텍처는 다음 레이어에서 신뢰하고 사용을 할 수 있어야 한다. 하지만 이경우 엔티티 신뢰 문제가 발생.\n 모든 객체를 미리 로딩할 수는 없다.  상황에 따라 동일한 회원 조회 메서드를 여러벌 생성\n memberDAO.getMember(); // Member만 조회\rmemberDAO.getMemberWithTeam(); // Member와 Team 조회\r// Member, Team, Delivery 조회\rmemberDAO.getMemberWithTeamWithDelivery();  계층형 아키텍처  진정한 의미의 계층 분할이 어렵다.\n 비교하기  비교하기 - 자바 객체로 조회 Long memberId = 100;\rMember member1 = memberDAO.getMember(memberId); Member member2 = memberDAO.getMember(memberId);\rmember1 == member2; //다르다. (getMember에서 sql로 조회된 데이터는 같아도 return되는 객체는 new로 새로 만들기 때문에 다름)\rclass MemberDAO {\rpublic Member getMember(Long memberId) {\rString sql = \u0026quot;SELECT * FROM MEMBER WHERE MEMBER_ID = ?\u0026quot;;\r...\r//JDBC API, SQL 실행\rreturn new Member(...); //객체를 새로만듬\r}\r}\r 비교하기 - 자바 컬렉션에서 조회  이러한 특수한 컬렉션이 있다고 가정\n Long memberId = 100;\rMember member1 = list.get(memberId);\rMember member2 = list.get(memberId);\rmember1 == member2; //같다. (참조 값이 같다)\r  sql에서 다룰때랑, 자바 컬렉션에서 다룰때랑, 자바 객체에서 다룰때, 관계형 DB에서 다룰때 중간에 많은 믹스매치가 발생\n 객체답게 모델링 할수록 매핑 작업만 늘어난다.   객체지향을 배우고 객체지향을 토대로 설계하고 구현할 경우 번잡한 매핑 작업만 들어난다. 그래서 sql에 맞춰서 데이터 전송하는 객체로 만들 수 밖에 없음. (만들 수 있지만, 개발 퍼포먼스 측면에서 지옥이다.)\n 객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수 없을까   1980 년대 부터 많은 개발자들이 고민을 해왔다고합니다. 자바 진영에서는 그 고민의 결과 !\n JPA - Java Persistence API   JPA란 Java Persistence API로 자바 진영의 ORM 기술 표준\n ORM ?    Object Relational mapping(객체 관계 매칭) 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설계 ORM 프레임 워크가 중간에서 매핑 대중적인 언어에는 대부분 ORM 기술이 존재   JPA는 애플리케이션과 JDBC 사이에서 동작  JPA 동작 - 저장  JPA에게 Meber객체를 넘기면, JPA가 Member 객체를 분석하고, Insert 쿼리를 생성해서 DB에 전달하고 결과를 받음\n JPA 동작 - 조회  JPA에게 Meber객체를 넘기면, JPA가 Member 객체를 분석하고, Select 쿼리를 생성해서 DB에 전달하고 결과를 받음\n  중요한것은 패러다임 불일치 해결\n JPA 소개   과거 EJB - 엔티티 빈(자바 표준)에도 JPA와 비슷한 ORM 기술이 있었지만 높은 가격에 기능이 떨어지며, 기능 동작도 안되고 안쓰였다고 합니다.\n  SI 개발자인 개빈 킹(Gavin King)이 EJB의 기능을 만족하지 못하여 만든 기술이 하이버네이트입니다. 이후 많은 개발자들이 동참하여 오픈소스화 하였습니다. EJB는 서서히 몰락하게 되었습니다.\n  자바 진영에서 하이버네이트를 만든 개빈킹을 데려다 하이버네이트를 똑닮은 표준을 만들었는데 그것이 JPA입니다.\n JPA는 표준 명세    JPA는 인터페이스의 모음 JPA 2.1 표준 명세를 구현한 3가지 구현체 하이버네이트, EclipseLink, DataNucleus   JPA 버전    JPA 1.0(JSR 220) 2006년 : 초기 버전. 복합 키와 연관관계 기능이 부족 JPA 2.0(JSR 317) 2009년 : 대부분의 ORM 기능을 포함, JPA Criteria 추가 JPA 2.1(JSR 338) 2013년 : 스토어드 프로시저 접근, 컨버터(Converter), 엔티 티 그래프 기능이 추가   JPA를 왜 사용해야 하는가?    SQL 중심적인 개발에서 객체 중심으로 개발 생산성 유지보수 패러다임의 불일치 해결 성능 데이터 접근 추상화와 벤더 독립성 표준   생산성 - JPA와 CRUD   저장 : jpa.persist(member) //영구 저장하다라는 뜻 조회 : Member member = jpa.find(memberId) 수정 : member.setName(\u0026ldquo;변경할 이름\u0026rdquo;) // 객체의 이름을 set으로 변경하면 update 문이 자동으로 날라감 삭제 : jpa.remove(member)   유지보수 - JPA : 필드만 추가하면 됨 SQL은 JPA가 처리  개발이 끝났을때, 기획에서 연락처를 추가해 달라는 요청이 왔다\n public class Member {\rprivate Long memberId;\rprivate String name;\r/* 신규추가 tel */\rprivate String tel; ...\r}\r/*\t//더이상 sql들을 수정할 필요 없음\rINSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUES -- 신규추가 tel\rSELECT MEMBER_ID, NAME, TEL FROM MEMBER M -- 신규추가 tel\rUPDATE MEMBER SET … , TEL = ? -- 신규추가 tel\r*/\r JPA와 패러다임의 불일치 해결  1.JPA와 상속 2.JPA와 연관관계 3.JPA와 객체 그래프 탐색 4.JPA와 비교하기\n JPA와 상속 JPA와 상속 - 저장  ALBUM 객체를 DB에 저장하고 싶을때, jpa.persist()에 album 객체를 넘기면 JPA가 Insert 쿼리를 나누어서 작성\n // 개발자가 할일 jpa.persist(album);\r // 나머진 JPA가 처리\rInsert Into ITEM ...\rInsert Into ALBUM ...\r JPA와 상속 - 조회  Album 객체를 조회하고 싶을때 jpa.find()에 Album의 클래스, PK 값을 넘기면 JPA가 자동으로 ITEM과 ALBUM을 조인하여 데이터를 퍼올려줍니다.\n // 개발자가 할일 Album album = jpa.find(Album.class, albumId);\r // 나머진 JPA가 처리\rSelect I.*\r, A.*\rFROM ITEM I\rJOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID\r JPA와 연관관계, 객체 그래프 탐색  member에 팀을 세팅하고 member를 저장하면 team을 포함한 member가 저장됨.\n // 연관관계 저장\rmember.setTeam(team);\rjpa.persist(member);\r  저장된 team을 가져올때도, 자바 컬렉션에서 데이터를 가져오듯이 member.getTeam()을 이용해 team을 가져올수 있음.\n // 객체 그래프 탐색\rMember member = jpa.find(Member.class, memberId);\rTeam team = member.getTeam();\r 신뢰 할 수 있는 엔티티, 계층  JPA를 이용하면, find()를 이용해 객체 그래프 탐색을 통해서 getTeam()나 getOrder().getDelivery()를 사용하여, 각각의 객체를 자유롭게 조회할 수 있습니다. 또한 Lazy Loading 이라는 기능을 이용하여, 실제 코드를 수행할 당시에 데이터를 불러와 member객체에 하위 계층 객체를 세팅해줍니다. JPA를 이용하면, DB에 데이터가 없지 않는 이상 신뢰 하고 하위 계층을 사용하면 됩니다.\n class MemberService{\r...\rpublic void process(){\rMember member = memberDAO.find(memberId);\rmember.getTeam();\rmember.getOrder().getDelivery();\r}\r}\r JPA와 객체 비교하기  동일한 트랜잭션에서는 조회한 엔티티는 같음 보장\n Long memberId = 100;\rMember member1 = jpa.find(member.class, memberId);\rMember member2 = jpa.find(member.class, memberId);\rmember1 == member2; // 같다\r jpa의 성능 최적화 기능  JPA를 사용하면 성능이 저하되는 것이 아닌가 고민을 할 수 있을수도 있지만, JPA는 성능을 최적화 하기 위해 여러가지 기능을 제공합니다.\n   1차 캐시와 동일성(identity) 보장 트랜잭샨을 지원하는 쓰기 지연(transational write-behind) 지연 로딩(Laze Loading)g   1차 캐시와 동일성 보장   같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상 ``` Long memberId = 100; Memeber member1 = jpa.find(Member.class, memberId); // SQL 조회 Memeber member2 = jpa.find(Member.class, memberId); // 캐시    member1 == member2 // 같다\r```\r  SQL 1번만 실행\n  DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장   트랜잭션을 지원하는 쓰기 지연 - Insert   트랜잭션을 커밋할 때까지 Insert SQL을 모음 JDBC Batch SQL 기능을 사용해서 한번에 SQL을 전송   \ttransction.begin(); // 트랜잭션 시작\rjpa.persist(memberA)\t// 메모리에 적재\rjpa.persist(memberB) // 메모리에 적재\rjpa.persist(memberC) // 메모리에 적재\r// 여기까지 Insert SQL을 DB에 보내지 않는다.\r// 커밋하는 순간 DB에 SQL을 모아서 보낸다.\rtransction.commit(); // 트랜잭션 커밋\r  JPA 이전에도 JDBC Batch라는 기능이 있었고 그것을 쓰면 되지만, 코드가 정말 지저분해집니다. JPA가 하나의 트랜잭션에서 memberA, B, C를 메모리에 쌓았다가 Commit 시점에 동일한것을 모아 한번에 JDBC Batch 기능을 이용하여 네트워크를 통해 DB로 데이터를 전송합니다. JPA 옵션으로 설정해 두면 개발자가 신경 쓰지 않아도 이러한 기능을 지원해 줍니다.\n 지연 로딩과 즉시 로딩   지연 로딩 : 객체가 실제 사용될 때 로딩 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회   // 지연 로딩\rMember member = memberDAO.find(memberId); // SELECT * FROM MEMBER\rTeam team = member.getTeam(); // SELECT * FROM TEAM String teamName = team.getName();   JPA를 통해 객체를 조회할때, team 객체를 사용하는 시점에 TEAM 조회 SQL을 통하여 member객체의 team 객체에 데이터를 세팅\n  member를 조회할 때, 항상 team을 사용한다면 JPA 옵션을 통해서 member를 조회할 때 team을 같이 가져오게 설정을 할 수 있습니다. 옵션을 사용하면 쿼리가 MEMBER외 TEAM을 조인한 이래와 같은 쿼리로 변경해서 사용하게 됩니다.\n // 즉시 로딩\rMember member = memberDAO.find(memberId); // SELECT M.* ,T.* FROM MEMBER M JOIN Team T On ...\rTeam team = member.getTeam(); String teamName = team.getName();   JPA를 사용하지 않은 상태에서 MEMBER와 TEAM의 각각의 쿼리를 조인된 하나의 쿼리로 변경하거나, 조인된 각각의 쿼리를 개별의 쿼리로 나누려 작업한다면 진짜 많은 쿼리를 수정해야 될텐데 JPA를 이용하면 어마 어마한 것들을 간단히 사용할 수 있습니다.\n ORM은 객체와 RDB의 두 기둥위에 있는 기술  어느하나 소홀해서는 안되며 균형있게 두가지 지식이 쌓여 있어야 안전안 애플리케이션을 설계할 수 있습니다.\n 참고   자바 ORM 표준 JPA - 김영한   ","description":"JPA 소개","id":9,"section":"blog","tags":["Java","JPA","ORM","인프런","김영한","자바 ORM 표준 JPA"],"title":"JPA 소개","uri":"https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/about-jpa/"},{"content":"Elements in iteration expect to have \u0026lsquo;v-bind:key\u0026rsquo; directives 문제  이전 버전의 강좌를 보고 따라 하던 도중 vue template에서 li 에 v-for 를 이용해서 v-for=\u0026ldquo;t in tries\u0026rdquo; 루프를 생성하고 싶었으니 오류를 만나게 되었습니다.\n \r\u0026lt;!-- 문제가 발생한 코드 --\u0026gt;\r\u0026lt;li v-for=\u0026quot;item in tries\u0026quot;\u0026gt; {{item}}\r\u0026lt;/li\u0026gt;\r 2.2.0 이상에서 v-for는 key 가 필수 입니다.   \u0026lt;my-component\rv-for=\u0026quot;(item, index) in items\u0026quot;\rv-bind:item=\u0026quot;item\u0026quot;\rv-bind:index=\u0026quot;index\u0026quot;\rv-bind:key=\u0026quot;item.id\u0026quot;\r\u0026gt;\u0026lt;/my-component\u0026gt;\r 수정사항적용 \u0026lt;li v-for=\u0026quot;(item, index) in tries\u0026quot; :key=\u0026quot;index\u0026quot;\u0026gt;\r{{ item }}\r\u0026lt;/li\u0026gt;\r 참조 [Vue.js 에러] Custom elements in iteration require \u0026lsquo;v-bind:key\u0026rsquo; directives 뷰 공식 문서\n","description":"NPM init 패키지명 입력시 오류","id":10,"section":"blog","tags":["Troubleshooting"],"title":"Vue v-for Elements in iteration expect to have 'v-bind:key' directives 문제","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/vue/vue-v-for/"},{"content":"NPM init 패키지명 입력시 오류 발생 문제  npm init 명령어를 사용할때, node를 처음 접하게 되어 발생하였던 문제에 대해 정리\n Sorry, name can no longer contain capital letters. \u0026gt; npm init\r\u0026gt; package name: (3_끝말잇기) WordRelay\r\u0026gt; Sorry, name can no longer contain capital letters.\r package name : UpperCamelCase로 입력 시 오류 발생 Sorry, name can no longer contain capital letters. \u0026gt; npm init\r\u0026gt; package name: (3_끝말잇기) wordRelay\r\u0026gt; Sorry, name can no longer contain capital letters.\r package name : CamelCase로 입력 시 오류 발생 해결방법  npm init을 실행할때, kebab-csse를 사용해야한다. node.js를 포함한 vue의 컴포넌트 Dom 템플릿, Componet evet 등 kebab-case를 사용해야만 하는 경우가 있다.\n why  언젠가는 폴더나 파일이 자체 패키지로 추출될 수 있다고 상상해야 합니다. 패키지는 대문자를 포함할 수 없습니다. 새 패키지는 이름에 대문자가 없어야 합니다. https://docs.npmjs.com/files/package.json#이름 따라서 camelCase절대 사용해서는 안됩니다. snake_case과 kebab-case. kebab-case오늘날 가장 일반적인 협약입니다. 밑줄의 유일한 사용은 내부 노드 패키지용이며 이는 단순히 초기부터의 관례입니다.\n 참조 StackOverFlow kebab-case vuejs guide\n","description":"NPM init 패키지명 입력시 오류","id":11,"section":"blog","tags":["Troubleshooting"],"title":"NPM init 패키지명 입력시 오류, `Sorry, name can no longer contain capital letters.` and `Sorry, name can no longer contain capital letters.`","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/vue/npm-init/"},{"content":"Vue.js WebPack 설정하기 Node.js 설치   node 설치 최신의 LTS 버전 설치 최신버전 보다 안정화가 되어 검증된 LTS 버전 설치 권장   Vue 프로젝트에 WebPack 적용 순서 1. npm init  1.1. webpack을 적용할 vue project의 경로에서 터미널을 열음.\n  1.2. npm init 명령을 실행해서 node_modules을 설치하고, package.json 생성됨 npm init을 실행하고 package 명을 입력하고 그 뒤로는 엔터, 엔터로 끝까지 진행 주의할점은 package name은 kebab-case로 작성 ex) word-relay, camelCase나 UpperCamelCase 시 오류 하단 참조\n  생성된 package.json 설정\n /* package.json */\r{\r\u0026quot;name\u0026quot;: \u0026quot;word-relay\u0026quot;,\t// \u0026lt;\u0026lt;-- 입력한 package \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;\r},\r\u0026quot;author\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;\r}\r  해당 파일은 npm으로 필요한 패키지(디팬던시, 라이브러리 또는 플러그인)를 설치시 package.json에 자동으로 등록되며 이름과 패키지의 버전이 명시되어 빌드나 배포 시 사용된다.\n 2. 필요 패키지 설치 npm install vue -D //뷰 설치\rnpm i vue-loader -D\t//뷰 로더 설치\rnpm i vue-template-compiler@{vue version ex-2.6.14} -D //뷰 템플릿 컴파일러 설치 npm i vue-style-loader -D //뷰 스타일 로더 설치\rnpm i css-loader -D\t//CSS 로더 설치\r  설치 이후\n \r/* package.json */\r{\r\u0026quot;name\u0026quot;: \u0026quot;word-relay\u0026quot;,\r\u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r// \u0026lt;\u0026lt;-- 직접 수정해주어야함, npm run build 시 webpack을 사용함\r\u0026quot;build\u0026quot;: \u0026quot;webpack --watch\u0026quot; //\u0026lt;-- 자동빌드 옵션 },\r\u0026quot;author\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;,\r\u0026quot;devDependencies\u0026quot;: {\r\u0026quot;css-loader\u0026quot;: \u0026quot;^6.5.1\u0026quot;,\r\u0026quot;vue\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;vue-loader\u0026quot;: \u0026quot;^15.9.8\u0026quot;,\r\u0026quot;vue-style-loader\u0026quot;: \u0026quot;^4.1.3\u0026quot;,\r\u0026quot;vue-template-compiler\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;webpack\u0026quot;: \u0026quot;^5.64.0\u0026quot;,\r\u0026quot;webpack-cli\u0026quot;: \u0026quot;^4.9.1\u0026quot;\r\u0026quot;style-loader\u0026quot;: \u0026quot;^3.3.1\u0026quot;\r}\r}\r 3. html 파일 생성  프로젝트의 root 디렉토리에 html 파일 생성 ex) WordRelay.html\n \u0026lt;!-- WordRelay.html --\u0026gt;\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot; /\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;끝말잇기\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;끝말잇기\u0026lt;/h2\u0026gt;\r\u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\t// vue의 인스턴스를 연결할 root div \u0026lt;script src=\u0026quot;./dist/app2.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; //webpack을 통해 생성될 통합 app.js의 경로 webpack 빌드후 추가 해도됨\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r 4. vue 파일 생성  프로젝트의 root 디렉토리에 vue 파일 생성 ex) WordRelay.vue  \u0026lt;!-- WordRelay.vue --\u0026gt;\r\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;h3\u0026gt;제시어: {{ word }}\u0026lt;/h3\u0026gt;\r\u0026lt;form @submit.prevent=\u0026quot;onSubmitForm\u0026quot;\u0026gt;\r\u0026lt;input ref=\u0026quot;answer\u0026quot; minlength=\u0026quot;2\u0026quot; maxlength=\u0026quot;3\u0026quot; v-model=\u0026quot;value\u0026quot; /\u0026gt;\r\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;입력\u0026lt;/button\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;div\u0026gt;{{ result }}\u0026lt;/div\u0026gt;\r\u0026lt;br /\u0026gt;\r\u0026lt;p\u0026gt;사용한 단어는 사용할 수 없습니다.\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rlet arr = new Array();\rlet first_word = \u0026quot;공부\u0026quot;;\rarr.push(first_word);\rexport default {\rdata() {\rreturn {\rword: first_word,\rvalue: \u0026quot;\u0026quot;,\rresult: \u0026quot;\u0026quot;,\rhistory: arr,\r};\r},\rmethods: {\ronSubmitForm() {\rif (\rthis.word.charAt(this.word.length - 1) ===\rthis.value.charAt(0) \u0026amp;\u0026amp;\r!this.history.includes(this.value)\r) {\rthis.result = \u0026quot;\u0026quot;;\rthis.history.push(this.value);\rthis.word = this.value;\rthis.value = \u0026quot;\u0026quot;;\r} else if (this.history.includes(this.value)) {\rthis.result = \u0026quot;땡, 이전에 사용한 단어입니다.\u0026quot;;\r} else {\rthis.result = \u0026quot;땡\u0026quot;;\r}\r},\r},\r};\r\u0026lt;/script\u0026gt;\r\u0026lt;style\u0026gt;\r\u0026lt;/style\u0026gt;\r 5. main.js 생성  프로젝트의 root 디렉토리에 vue 인스턴스를 생성할 js 파일 생성 ex) main.js  import Vue from 'vue' //npm으로 설치후 node_modules에 설치된 vue를 임포트\rimport WordRelay from './WordRelay.vue';\t// 프로젝트에 생성한 .vue 파일 이후 webpack.config.js 의 resolve, extensions 속성에 .vue 추가하면\r// extensions import WordRelay from './WordRelay'; 로 .vue 생략가능\rnew Vue(WordRelay).$mount('#root'); //Vue(.vue 파일 객체).$mount(.html root div id)\r 6. webpack.config.js 생성  프로젝트의 root 디렉토리에 webpack.config.js 생성\n const { VueLoaderPlugin } = require('vue-loader'); // @@@ plugins에 추가해야됨 @@@\rconst path = require('path');\rmodule.exports = { //웹패킹을 할때 모듈을 사용\rmode : 'development', // 프로젝트의 모드 설정 개발 'development', 운영 'production'\rdevtool : 'eval',\t// 하단 링크 참조\rresolve : {\t// 모듈을 해석하는 방식을 설정\rextensions : ['.js','.vue','.html'],\t//사용자가 import 할 때 확장자를 생략 할 수 있도록 함\r},\rentry : { //하나로 합쳐질 파일의 이름 스크립트 및 그외 파일들 rules로 js로 변환해서 통합 저장됨\rapp2 : path.join(__dirname,'main.js') // [name] (합쳐질 파일의 이름) : main.js (vue의 인스턴스가 선언된 js) 의 위치 },\rmodule : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\ttest : /\\.vue$/, // 정규식으로 .vue 파일인 경우 캐치 loader : 'vue-loader', // vue-loader로 변환하여 app.js에 적용\r}],\r},\rplugins : [\rnew VueLoaderPlugin(),\r],\routput : {\t// 프로젝트 산출물 filename : '[name].js',//'app2.js',\rpath : path.join(__dirname, 'dist'),\r}\r};\r devtool 옵션\n7. 빌드 및 webpack 실행 npm run build\r 성공시 출력 PS C:\\develop\\Git\\vue\\example\\3_끝말잇기\u0026gt; npm run build\r\u0026gt; word-relay@1.0.0 build\r\u0026gt; webpack\rasset app2.js 246 KiB [compared for emit] (name: app2)\rruntime modules 891 bytes 4 modules\rcacheable modules 229 KiB\rmodules by path ./*.vue 2.73 KiB\r./WordRelay.vue 1.1 KiB [built] [code generated]\r./WordRelay.vue?vue\u0026amp;type=template\u0026amp;id=39324767\u0026amp; 204 bytes [built] [code generated]\r./WordRelay.vue?vue\u0026amp;type=script\u0026amp;lang=ts\u0026amp; 268 bytes [built] [code generated]\r./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./WordRelay.vue?vue\u0026amp;type=template\u0026amp;id=39324767\u0026amp; 1.05 KiB [built] [code generated]\r./node_modules/vue-loader/lib/index.js??vue-loader-options!./WordRelay.vue?vue\u0026amp;type=script\u0026amp;lang=ts\u0026amp; 126 bytes [built] [code generated]\rmodules by path ./node_modules/ 226 KiB\r./node_modules/vue/dist/vue.runtime.esm.js 223 KiB [built] [code generated]\r./node_modules/vue-loader/lib/runtime/componentNormalizer.js 2.71 KiB [built] [code generated]\r./main.js 189 bytes [built] [code generated]\rwebpack 5.64.0 compiled successfully in 911 ms\r webpack 자동빌드 1. package.json 설정 {\r\u0026quot;name\u0026quot;: \u0026quot;number-baseball\u0026quot;,\r\u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;main\u0026quot;: \u0026quot;index.js\u0026quot;,\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;build\u0026quot;: \u0026quot;webpack --watch\u0026quot; // \u0026lt;\u0026lt;-- --watch 옵션 추가\r},\r\u0026quot;author\u0026quot;: \u0026quot;\u0026quot;,\r\u0026quot;license\u0026quot;: \u0026quot;ISC\u0026quot;,\r\u0026quot;devDependencies\u0026quot;: {\r\u0026quot;css-loader\u0026quot;: \u0026quot;^6.5.1\u0026quot;,\r\u0026quot;vue\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;vue-loader\u0026quot;: \u0026quot;^15.9.8\u0026quot;,\r\u0026quot;vue-style-loader\u0026quot;: \u0026quot;^4.1.3\u0026quot;,\r\u0026quot;vue-template-compiler\u0026quot;: \u0026quot;^2.6.14\u0026quot;,\r\u0026quot;webpack\u0026quot;: \u0026quot;^5.64.0\u0026quot;,\r\u0026quot;webpack-cli\u0026quot;: \u0026quot;^4.9.1\u0026quot;\r}\r}\r 2. webpack.config.js 설정 module.exports = { //웹패킹을 할때 모듈을 사용\rwatch: true,\rwatchOptions: {\rignored: '**/node_modules',\r},\r};\r CSS를 사용해 보자  .vue 파일에서 스타일을 적용하기 위해서는 새로운 로더가 필요하다\n \u0026lt;style\u0026gt;\r#screen {\rwidth: 300px;\rheight: 200px;\rtext-align: center;\ruser-select: none;\r}\r#screen .waiting {\rbackground-color: pink;\r}\r#screen .ready {\rbackground-color: yellow;\r}\r#screen .now {\rbackground-color: rgb(79, 128, 0);\r}\r\u0026lt;/style\u0026gt;\r style-loader npm i style-loader -D\r  webpack.config.js 모듈에 추가, 임포트, 플러그인 추가 안해도됨\n module : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\ttest : /\\.css$/, use : ['style-loader']\r}\r],\r css-loader npm i css-loader -D\r  webpack.config.js 모듈에 추가, 임포트, 플러그인 추가 안해도됨\n module : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\ttest : /\\.css$/, use : ['style-loader','css-loader']\r}\r],\r webpack wacth 옵션\nnom run build 시 나올 수 있는 오류 정리 configuration.output.path: The provided value \u0026ldquo;./dist\u0026rdquo; is not an absolute path! , The output directory as absolute path (required). Debugger attached.\r[webpack-cli] Invalid configuration object. Webpack has been initialized using a configuration object that does not match the API schema.\r- configuration.output.path: The provided value \u0026quot;./dist\u0026quot; is not an absolute path!\r-\u0026gt; The output directory as **absolute path** (required).\r  webpack.config.js의 path : \u0026lsquo;./dist\u0026rsquo;, \u0026laquo; 이부분을 절대경로로\n \rconst path = require('path'); /// 추가\rmodule.exports = { //웹패킹을 할때 모듈을 사용\rentry : {\rapp : path.join(__dirname,'main.js') //하나로 합쳐질 파일의 이름 스크립트 및 그외 파일들 js로 변환해서 통합 저장됨\r},\rmodule : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\r}],\r},\rplugins : [],\routput : {\rfilename : '[name].js',//'app.js',\rpath : path.join(__dirname, 'dist'), ///변경 }\r};\r 오류 없이 빌드 되지만 실행시 html에 root가 그리드 되지 않는 경우 main.js에 뷰 인스턴스 생성시 파라미터로 .vue 파일 객체 안넘긴 경우 import Vue from 'vue'\rimport WordRelay from './WordRelay.vue';\rnew Vue().$mount('#root'); //\u0026lt;\u0026lt;\u0026lt; Vue(WordRelay).$mount('#root');\r html에 webpack이 생성한 파일 ex) app2.js 추가 안한경우 \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt;\r\u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot; /\u0026gt;\r\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt;\r\u0026lt;title\u0026gt;끝말잇기\u0026lt;/title\u0026gt;\r\u0026lt;style ref=\u0026quot;./dist/style.css\u0026quot;\u0026gt;\u0026lt;/style\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;끝말잇기\u0026lt;/h2\u0026gt;\r\u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;!-- \u0026lt;script src=\u0026quot;./dist/app.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r WARNING in configuration The \u0026lsquo;mode\u0026rsquo; option has not been set, webpack will fallback to \u0026lsquo;production\u0026rsquo; for this value. Set \u0026lsquo;mode\u0026rsquo; option to \u0026lsquo;development\u0026rsquo; or \u0026lsquo;production\u0026rsquo; to enable defaults for each environment. WARNING in configuration\rThe 'mode' option has not been set, webpack will fallback to 'production' for this value.\rSet 'mode' option to 'development' or 'production' to enable defaults for each environment.\rYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/\r  이런 경고가 계속 뜰경우 webpack.config.js module.exports 에 mode : \u0026lsquo;development\u0026rsquo; 추가\n You may need an additional loader to handle the result of these loaders.  loader 모듈이 필요하다는 오류,\n Debugger attached.\r\u0026gt; example@1.0.0 build\r\u0026gt; webpack\rDebugger attached.\rassets by status 64.6 KiB [cached] 1 asset\rorphan modules 227 KiB [orphan] 4 modules\rruntime modules 221 bytes 1 module\rmodules with errors 228 KiB [errors]\r./main.js + 4 modules 227 KiB [built] [code generated] [1 error]\r./example.vue?vue\u0026amp;type=template\u0026amp;id=063a7d4c\u0026amp; 217 bytes [built] [code generated] [1 error]\rERROR in ./example.vue?vue\u0026amp;type=template\u0026amp;id=063a7d4c\u0026amp; 2:0\rModule parse failed: Unexpected token (2:0)\rFile was processed with these loaders:\r* ./node_modules/vue-loader/lib/index.js\rYou may need an additional loader to handle the result of these loaders.\r|\r\u0026gt; \u0026lt;div\u0026gt;\r| \u0026lt;h1\u0026gt;{{result}}\u0026lt;/h1\u0026gt;\r| \u0026lt;form v-on:submit=\u0026quot;onSubmitForm\u0026quot;\u0026gt;\r@ ./example.vue 1:0-86 10:2-8 11:2-17\r@ ./main.js 2:0-36\rERROR in ./example.vue\rModule Error (from ./node_modules/vue-loader/lib/index.js):\rvue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config.\rError: vue-loader was used without the corresponding plugin. Make sure to include VueLoaderPlugin in your webpack config.\rat Object.module.exports (C:\\develop\\Git\\vue\\example\\0.WebPack\\node_modules\\vue-loader\\lib\\index.js:36:29)\r@ ./main.js 2:0-36\r  아래의 부분을 처리할 수 없으며, 로더가 필요하다는 뜻\n |\r\u0026gt; \u0026lt;div\u0026gt;\r| \u0026lt;h1\u0026gt;{{result}}\u0026lt;/h1\u0026gt;\r| \u0026lt;form v-on:submit=\u0026quot;onSubmitForm\u0026quot;\u0026gt;\r  로더를 import 했지만 오류가 나던 상황이여서 골치를 앓고 있었는데, 내가 발생했던 이유는 webpack.config.js plugins에 VueLoaderPlugin()를 넣지 않아서 오류\n //const VueLoaderPlugin = require('vue-loader/lib/plugin')\rconst { VueLoaderPlugin } = require('vue-loader')\rconst path = require('path');\rmodule.exports = { //웹패킹을 할때 모듈을 사용\rentry : {\rapp : path.join(__dirname,'main.js') //하나로 합쳐질 파일의 이름 스크립트 및 그외 파일들 rules로 js로 변환해서 통합 저장됨\r},\rmodule : { //모듈의 핵심 어떻게 합칠것인지 rules : [{\rtest : /\\.vue$/,\rloader : 'vue-loader', }],\r},\rplugins : [\rnew VueLoaderPlugin() // \u0026lt;\u0026lt;--- 이것이 빠져있었음\r], output : {\rfilename : '[name].js',//'app.js',\rpath : path.join(__dirname, 'dist'),\r}\r};\r ","description":"Vue.js WebPack 설정하기","id":12,"section":"blog","tags":["Front","Vue","framework"],"title":"Vue.js WebPack 설정하기","uri":"https://offetuoso.github.io/blog/develop/frontend/vue/vue-webpack/"},{"content":"Programmers - 12915 문자열 내 마음대로 정렬하기 Task description 원문 : Programmers 12915 링크\n문제 설명  문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [\u0026ldquo;sun\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;car\u0026rdquo;]이고 n이 1이면 각 단어의 인덱스 1의 문자 \u0026ldquo;u\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;a\u0026quot;로 strings를 정렬합니다.\n Condition   strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.   ###입력 형식\n 입출력 예\n    strings n return     [\u0026ldquo;sun\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;car\u0026rdquo;] 1 [\u0026ldquo;car\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;sun\u0026rdquo;]   [\u0026ldquo;abce\u0026rdquo;, \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;] 2 [\u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;abce\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;]    Solution import java.util.ArrayList;\rimport java.util.Collections;\rclass SortStringAtWill {\rpublic static void main(String[] args) {\rString[] strings = {\u0026quot;car\u0026quot;, \u0026quot;bed\u0026quot;, \u0026quot;sun\u0026quot;};\rString[] result = new SortStringAtWill().solution(strings, 1);\rfor(int i=0; i\u0026lt;result.length;i++) {\rSystem.out.println(result[i]);\r}\r}\rpublic String[] solution(String[] strings, int n) {\rArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;();\rfor(int i=0;i\u0026lt;strings.length;i++) {\rlist.add(strings[i].charAt(n)+strings[i]);\r}\rCollections.sort(list);\rfor(int i=0; i\u0026lt;list.size();i++) {\rstrings[i] = list.get(i).substring(1);\r}\rreturn strings;\r}\r}\r TestCase    strings n return     [\u0026ldquo;sun\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;car\u0026rdquo;] 1 [\u0026ldquo;car\u0026rdquo;, \u0026ldquo;bed\u0026rdquo;, \u0026ldquo;sun\u0026rdquo;]   [\u0026ldquo;abce\u0026rdquo;, \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;] 2 [\u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;abce\u0026rdquo;, \u0026ldquo;cdx\u0026rdquo;]    ","description":"12915 문자열 내 마음대로 정렬하기","id":13,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12915 문자열 내 마음대로 정렬하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12915-sort-string-at-will/"},{"content":"Programmers - 12917 문자열 내림차순으로 배치하기 Task description 원문 : Programmers 12917 링크\n문제 설명  문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.\n Condition   str은 길이 1 이상인 문자열입니다.   ###입력 형식\n 입출력 예\n    s return     \u0026ldquo;Zbcdefg\u0026rdquo; \u0026ldquo;gfedcbZ\u0026rdquo;    Solution import java.util.Arrays;\rclass Solution {\rpublic String solution(String s) {\rString answer = \u0026quot;\u0026quot;;\rchar[] ch = s.toCharArray();\rint[] list = new int[ch.length];\rfor(int i = 0 ; i\u0026lt; ch.length; i++) {\rlist[i] = ch[i];\r}\rArrays.sort(list);\rfor(int i=list.length-1;i\u0026gt;-1;i--){\ranswer = answer+String.valueOf((char)list[i]);\r}\rreturn answer;\r}\r}\r Others Solution import java.util.Arrays;\rclass Solution {\rpublic String solution(String s) {\rpublic String solution2(String s) {\rString answer = \u0026quot;\u0026quot;;\rchar[] ch = s.toCharArray();\rArrays.sort(ch);\rreturn new StringBuilder(new String(ch)).reverse().toString();\r}\r}\r TestCase \u0026quot;Zbcdefg\u0026quot;\t\u0026quot;gfedcbZ\u0026quot;\r ","description":"12917 문자열 내림차순으로 배치하기","id":14,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12917 문자열 내림차순으로 배치하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12917-descending-order/"},{"content":"Programmers - 12951 JadenCase 문자열 만들기 Task description 원문 : Programmers 12951 링크\n문제 설명  JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.\n Condition   s는 길이 1 이상인 문자열입니다. s는 알파벳과 공백문자(\u0026quot; \u0026ldquo;)로 이루어져 있습니다. 첫 문자가 영문이 아닐때에는 이어지는 영문은 소문자로 씁니다. ( 첫번째 입출력 예 참고 )   ###입력 형식\n 입출력 예\n    s return     \u0026ldquo;3people unFollowed me\u0026rdquo; \u0026ldquo;3people Unfollowed Me\u0026rdquo;   \u0026ldquo;for the last week\u0026rdquo; \u0026ldquo;For The Last Week\u0026rdquo;    Solution class JadenCase {\rpublic static void main(String[] args) {\rSystem.out.println(new JadenCase().solution(\u0026quot;3people unFollowed me\u0026quot;));\r}\rpublic String solution(String s) {\rString answer = \u0026quot;\u0026quot;;\rs = s.toLowerCase();\rint idx = 0;\rfor(int i=0; i \u0026lt; s.length() ;i++) {\rchar ch = s.charAt(i);\rif(ch == ' ') {\ridx = 0;\r}else {\ridx ++;\r}\rif(idx == 1) {\ranswer += String.valueOf(ch).toUpperCase();\r}else {\ranswer += String.valueOf(ch);\r}\r}\rreturn answer;\r}\r}\r Others Solution class JadenCase {\rpublic static void main(String[] args) {\rSystem.out.println(new JadenCase().solution(\u0026quot;3people unFollowed me\u0026quot;));\r}\rpublic String solution(String s) {\rString answer = \u0026quot;\u0026quot;;\rString[] sp = s.toLowerCase().split(\u0026quot;\u0026quot;);\rboolean flag = true;\rfor(String ss : sp) {\ranswer += flag ? ss.toUpperCase() : ss;\rflag = ss.equals(\u0026quot; \u0026quot;) ? true : false;\r}\rreturn answer;\r}\r}\r TestCase \r\u0026quot;3people unFollowed me\u0026quot;\t\u0026quot;3people Unfollowed Me\u0026quot;\r\u0026quot;for the last week\u0026quot;\t\u0026quot;For The Last Week\u0026quot;\r ","description":"12951 JadenCase 문자열 만들기","id":15,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12951 JadenCase 문자열 만들기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12951-jaden-case/"},{"content":"Programmers - 12981 영어 끝말잇기 Task description 원문 : Programmers 12981 링크\n문제 설명  1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.\n  1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.\n  tank → kick → know → wheel → land → dream → mother → robot → tank\n  위 끝말잇기는 다음과 같이 진행됩니다.\n 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.\r2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.\r3번 사람이 자신의 첫 번째 차례에 know를 말합니다.\r1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.\r(계속 진행)\r끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.\r  사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.\n Condition   끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.   ###입력 형식\n 입출력 예\n    n words result     3 [\u0026ldquo;tank\u0026rdquo;, \u0026ldquo;kick\u0026rdquo;, \u0026ldquo;know\u0026rdquo;, \u0026ldquo;wheel\u0026rdquo;, \u0026ldquo;land\u0026rdquo;, \u0026ldquo;dream\u0026rdquo;, \u0026ldquo;mother\u0026rdquo;, \u0026ldquo;robot\u0026rdquo;, \u0026ldquo;tank\u0026rdquo;] [3,3]   5 [\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;observe\u0026rdquo;, \u0026ldquo;effect\u0026rdquo;, \u0026ldquo;take\u0026rdquo;, \u0026ldquo;either\u0026rdquo;, \u0026ldquo;recognize\u0026rdquo;, \u0026ldquo;encourage\u0026rdquo;, \u0026ldquo;ensure\u0026rdquo;, \u0026ldquo;establish\u0026rdquo;, \u0026ldquo;hang\u0026rdquo;, \u0026ldquo;gather\u0026rdquo;, \u0026ldquo;refer\u0026rdquo;, \u0026ldquo;reference\u0026rdquo;, \u0026ldquo;estimate\u0026rdquo;, \u0026ldquo;executive\u0026rdquo;] [0,0]   2 [\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;one\u0026rdquo;, \u0026ldquo;even\u0026rdquo;, \u0026ldquo;never\u0026rdquo;, \u0026ldquo;now\u0026rdquo;, \u0026ldquo;world\u0026rdquo;, \u0026ldquo;draw\u0026rdquo;] [1,3]     입출력 예 설명\n  입출력 예 #1 3명의 사람이 끝말잇기에 참여하고 있습니다.\n  1번 사람 : tank, wheel, mother 2번 사람 : kick, land, robot\n3번 사람 : know, dream, tank\n와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.\n  입출력 예 #2\n5명의 사람이 끝말잇기에 참여하고 있습니다.\n 1번 사람 : hello, recognize, gather\r2번 사람 : observe, encourage, refer\r3번 사람 : effect, ensure, reference\r4번 사람 : take, establish, estimate\r5번 사람 : either, hang, executive\r와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.\r  입출력 예 #3 2명의 사람이 끝말잇기에 참여하고 있습니다.\n 1번 사람 : hello, even, now, draw\r2번 사람 : one, never, world\r와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.\r Solution def solution(n, words):\ranswers = []\rprev = \u0026quot;\u0026quot;\rfor i in range(len(words)):\rturn = (i // n) + 1\rplayer = (i % n) +1 curr = words[i]\rif prev != \u0026quot;\u0026quot; and prev[-1] != curr[0] or curr in answers:\rreturn [player, turn]\relse:\ranswers.append(curr)\rprev = curr\rreturn [0, 0]\r Others Solution def solution(n, words):\rfor p in range(1, len(words)):\rif words[p][0] != words[p-1][-1] or words[p] in words[:p]: return [(p%n)+1, (p//n)+1]\relse:\rreturn [0,0]\r TestCase \rprint(\rsolution(\r3, [\u0026quot;tank\u0026quot;, \u0026quot;kick\u0026quot;, \u0026quot;know\u0026quot;, \u0026quot;wheel\u0026quot;, \u0026quot;land\u0026quot;, \u0026quot;dream\u0026quot;, \u0026quot;mother\u0026quot;, \u0026quot;robot\u0026quot;, \u0026quot;tank\u0026quot;]\r)\r)\rprint(\rsolution(\r5, [\u0026quot;hello\u0026quot;, \u0026quot;observe\u0026quot;, \u0026quot;effect\u0026quot;, \u0026quot;take\u0026quot;, \u0026quot;either\u0026quot;, \u0026quot;recognize\u0026quot;, \u0026quot;encourage\u0026quot;, \u0026quot;ensure\u0026quot;, \u0026quot;establish\u0026quot;, \u0026quot;hang\u0026quot;, \u0026quot;gather\u0026quot;, \u0026quot;refer\u0026quot;, \u0026quot;reference\u0026quot;, \u0026quot;estimate\u0026quot;, \u0026quot;executive\u0026quot;]\r)\r)\rprint(\rsolution(\r2,\t[\u0026quot;hello\u0026quot;, \u0026quot;one\u0026quot;, \u0026quot;even\u0026quot;, \u0026quot;never\u0026quot;, \u0026quot;now\u0026quot;, \u0026quot;world\u0026quot;, \u0026quot;draw\u0026quot;]\r)\r)\r ","description":"12981 영어 끝말잇기","id":16,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12981 영어 끝말잇기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-12981-end-talk/"},{"content":"Programmers - 42586 기능개발 Task description 원문 : Programmers 42586 링크\n문제 설명  프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.\n  먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.\n 입출력 예 #2 모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.\n따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.\n※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다.\nCondition   작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.   입력 형식  입출력 예\n    progresses speeds return     [93, 30, 55] [1, 30, 5] [2, 1]   [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2]    입출력 예 설명  입출력 예 #1 첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\n두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다. 세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\n Solution from collections import deque\rimport copy\rdef solution(progresses, speeds):\rrequired_time = []\rfor i in range(len(progresses)):\rprint(progresses[i], speeds[i])\rrequired = (100 - progresses[i]) // speeds[i]\rif (100 - progresses[i]) % speeds[i] != 0:\rrequired += 1\rrequired_time.append(required)\rque = deque(required_time)\ranswer = []\rwhile que:\rstack = []\rtmp = copy.deepcopy(que)\rfirst_job = que[0]\rfor i in range(len(tmp)):\rif i == 0 or first_job \u0026gt;= tmp[i]:\rstack.append(tmp[i])\rque.popleft()\relse:\rbreak\ranswer.append(len(stack))\rreturn answer\r Others Solution 1 from math import ceil\rdef solution(progresses, speeds):\rdaysLeft = list(map(lambda x: (ceil((100 - progresses[x]) / speeds[x])), range(len(progresses))))\rcount = 1\rretList = []\rfor i in range(len(daysLeft)):\rtry:\rif daysLeft[i] \u0026lt; daysLeft[i + 1]:\rretList.append(count)\rcount = 1\relse:\rdaysLeft[i + 1] = daysLeft[i]\rcount += 1\rexcept IndexError:\rretList.append(count)\rreturn retList\r 2 def solution(progresses, speeds):\rQ=[]\rfor p, s in zip(progresses, speeds):\rif len(Q)==0 or Q[-1][0]\u0026lt;-((p-100)//s):\rQ.append([-((p-100)//s),1])\relse:\rQ[-1][1]+=1\rreturn [q[1] for q in Q]\r TestCase print(solution([93, 30, 55], [1, 30, 5]), [2, 1])\rprint(solution([95, 90, 99, 99, 80, 99], [1, 1, 1, 1, 1, 1]), [1, 3, 2])\r ","description":"42586 기능개발","id":17,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42586 기능개발","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-42586-function-development/"},{"content":"Programmers - 20426 복서 정렬하기 Task description 원문 : Programmers 20426 링크\n문제 설명  복서 선수들의 몸무게 weights와, 복서 선수들의 전적을 나타내는 head2head가 매개변수로 주어집니다. 복서 선수들의 번호를 다음과 같은 순서로 정렬한 후 return 하도록 solution 함수를 완성해주세요.\n   전체 승률이 높은 복서의 번호가 앞쪽으로 갑니다. 아직 다른 복서랑 붙어본 적이 없는 복서의 승률은 0%로 취급합니다. 승률이 동일한 복서의 번호들 중에서는 자신보다 몸무게가 무거운 복서를 이긴 횟수가 많은 복서의 번호가 앞쪽으로 갑니다. 자신보다 무거운 복서를 이긴 횟수까지 동일한 복서의 번호들 중에서는 자기 몸무게가 무거운 복서의 번호가 앞쪽으로 갑니다. 자기 몸무게까지 동일한 복서의 번호들 중에서는 작은 번호가 앞쪽으로 갑니다.   Condition   weights의 길이는 2 이상 1,000 이하입니다. weights의 모든 값은 45 이상 150 이하의 정수입니다. weights[i] 는 i+1번 복서의 몸무게(kg)를 의미합니다. head2head의 길이는 weights의 길이와 같습니다. head2head의 모든 문자열은 길이가 weights의 길이와 동일하며, \u0026lsquo;N\u0026rsquo;, \u0026lsquo;W\u0026rsquo;, \u0026lsquo;L\u0026rsquo;로 이루어진 문자열입니다. head2head[i] 는 i+1번 복서의 전적을 의미하며, head2head[i][j]는 i+1번 복서와 j+1번 복서의 매치 결과를 의미합니다. \u0026lsquo;N\u0026rsquo; (None)은 두 복서가 아직 붙어본 적이 없음을 의미합니다. \u0026lsquo;W\u0026rsquo; (Win)는 i+1번 복서가 j+1번 복서를 이겼음을 의미합니다. \u0026lsquo;L\u0026rsquo; (Lose)는 i+1번 복사가 j+1번 복서에게 졌음을 의미합니다. 임의의 i에 대해서 head2head[i][i] 는 항상 \u0026lsquo;N\u0026rsquo;입니다. 자기 자신과 싸울 수는 없기 때문입니다. 임의의 i, j에 대해서 head2head[i][j] = \u0026lsquo;W\u0026rsquo; 이면, head2head[j][i] = \u0026lsquo;L\u0026rsquo;입니다. 임의의 i, j에 대해서 head2head[i][j] = \u0026lsquo;L\u0026rsquo; 이면, head2head[j][i] = \u0026lsquo;W\u0026rsquo;입니다. 임의의 i, j에 대해서 head2head[i][j] = \u0026lsquo;N\u0026rsquo; 이면, head2head[j][i] = \u0026lsquo;N\u0026rsquo;입니다.   ###입력 형식\n 입출력 예\n    n result     6 8   16 4   626331 -1       weights head2head result     [50,82,75,120] [\u0026ldquo;NLWL\u0026rdquo;,\u0026ldquo;WNLL\u0026rdquo;,\u0026ldquo;LWNW\u0026rdquo;,\u0026ldquo;WWLN\u0026rdquo;] [3,4,1,2]   [145,92,86] [\u0026ldquo;NLW\u0026rdquo;,\u0026ldquo;WNL\u0026rdquo;,\u0026ldquo;LWN\u0026rdquo;] [2,3,1]   [60,70,60] [\u0026ldquo;NNN\u0026rdquo;,\u0026ldquo;NNN\u0026rdquo;,\u0026ldquo;NNN\u0026rdquo;] [2,1,3]    입출력 예 #1\n다음은 선수들의 정보를 나타낸 표입니다.\n   선수 번호 vs 1번 vs 2번 vs 3번 vs 4번 승률 자기보다 무거운 복서를 이긴 횟수 몸무게     1 1번 - 패배 승리 패배 33.33% 1회 50kg   2 2번 승 - 패배 패배 33.33% 0회 82kg   3 3번 패 승리 - 승리 66.66% 2회 75kg   4 4번 승 승리 패배 - 66.66% 0회 120kg    Solution def solution(weights, head2head):\ranswer = []\rplayer = []\rfor i in range(len(weights)):\rwin_cnt = 0\rtotal_cnt = 0\rwin_heavier_cnt = 0\rfor j in range(len(head2head[i])):\rif head2head[i][j] != \u0026quot;N\u0026quot;: total_cnt += 1\rif head2head[i][j] == \u0026quot;W\u0026quot;:\rwin_cnt += 1\rif weights[i] \u0026lt; weights[j]:\rwin_heavier_cnt += 1\rdata = []\rtry:\rrate = (win_cnt / total_cnt) * 1000000\rexcept:\rrate = 0\rdata.append(rate) # 승률\rdata.append(win_heavier_cnt) # 무거운 사람에게 승수\rdata.append(weights[i]) # 무게\rdata.append(i + 1) # 번호\rplayer.append(data)\rfor i in sorted(player, key=lambda x: (-x[0], -x[1], -x[2], x[3])):\ranswer.append(i[3])\rreturn answer\r Others Solution def solution(weights, head2head):\rresult = []\rl = len(weights)\r# 한 번에 정렬해서 풀어봅시다!\rans = [[0 for _ in range(4)] for _ in range(l)] # 승률, 무거운복서 이긴횟수, 자기 몸무게, 번호(음수로)\rfor i in range(l):\rans[i][2] = weights[i]\rans[i][3] = -(i+1)\rcnt = 0 # 판수\rfor j in range(l):\rif head2head[i][j] == 'W':\rans[i][0] += 1 # 일단 이김\rcnt += 1\rif weights[i] \u0026lt; weights[j]:\rans[i][1] += 1 # 무거운 복서 이김\relif head2head[i][j] == 'L':\rcnt += 1 # 판수만 늘려준다\rif cnt == 0:\rans[i][0] = 0\relse:\rans[i][0] /= cnt\rans.sort(reverse=True) # 역순으로 정렬하면 모든 조건이 한 번에 정렬된다\rfor i in range(l):\rresult.append(-ans[i][3])\rreturn result\r TestCase print(solution([50, 82, 75, 120], [\u0026quot;NLWL\u0026quot;, \u0026quot;WNLL\u0026quot;, \u0026quot;LWNW\u0026quot;, \u0026quot;WWLN\u0026quot;]), [3, 4, 1, 2])\rprint(solution([145, 92, 86], [\u0026quot;NLW\u0026quot;, \u0026quot;WNL\u0026quot;, \u0026quot;LWN\u0026quot;]), [2, 3, 1])\rprint(solution([60, 70, 60], [\u0026quot;NNN\u0026quot;, \u0026quot;NNN\u0026quot;, \u0026quot;NNN\u0026quot;]), [2, 1, 3])\r ","description":"20426 복서 정렬하기","id":18,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 20426 복서 정렬하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-20426-boxer-sorting/"},{"content":"Programmers - 129343 콜라츠 추측 Task description 원문 : Programmers 129343 링크\n문제 설명 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.\n 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다. 2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.\n  예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.\n 제한 사항 Condition   입력된 수, num은 1 이상 8000000 미만인 정수입니다.   ###입력 형식\n 입출력 예\n    n result     6 8   16 4   626331 -1    입출력 예 #2\r16 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 이되어 총 4번만에 1이 됩니다.\r입출력 예 #3\r626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.\r Solution def collatz(num):\rcnt = 0\rwhile(True) :\rif cnt \u0026gt;= 500 :\rreturn -1\relif num == 1 :\rreturn cnt\rif num % 2 == 0 : #짝\rnum = num//2\relse : num = num * 3 + 1\rcnt += 1\rprint(collatz(6))\r Others Solution def collatz(num):\rif num == 1 :\rreturn 0\rfor i in range(500):\rnum = num / 2 if num % 2 == 0 else num*3 + 1\rif num == 1:\rreturn i + 1\rreturn -1\rprint(collatz(6))\r TestCase print(collatz(6))\rprint(collatz(16))\rprint(collatz(626331))\rprint(collatz(1))\r ","description":"129343 콜라츠 추측","id":19,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 129343 콜라츠 추측","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202110/programmers-129343-collatz/"},{"content":"Programmers - 83201 상호평가 Task description 원문 : Programmers 83201 링크\n 대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.\n    No. 0 1 2 3 4     0 100 90 98 88 65   1 50 45 99 85 77   2 47 88 95 80 67   3 61 57 100 80 65   4 24 90 94 75 65   평균 45.5 81.25 97.2 81.6 67.8   학점 F B A B D     위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.\n  0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다.\n0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.\n2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다.\n2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.\n당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.\n만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.\n  0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다. 0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.\n4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다. 4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.\n제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.\n    평균 학점     90점 이상\tA   80점 이상 90점 미만\tB   70점 이상 80점 미만\tC   50점 이상 70점 미만\tD   50점 미만\tF     학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.\n Condition   제한사항 2 ≤ scores의 행의 길이(학생 수) ≤ 10 scores의 열의 길이 = scores의 행의 길이 즉, scores는 행과 열의 길이가 같은 2차원 배열입니다. 0 ≤ scores의 원소 ≤ 100   ###입력 형식\n   scores result     [[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]] FBABD\u0026quot;   [[50,90],[50,87]] A\u0026quot;   [[70,49,90],[68,50,38],[73,31,100]] CFD\u0026quot;     출력 예 설명\n입출력 예 #1\n  문제 예시와 같습니다.\n  입출력 예 #2\n    No. 0 1     0 50 90   1 50 87   평균 50 90   학점 D A     1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.\n  입출력 예 #3\n    No. 0 1 2     0 70 49 90   1 68 50 38   2 73 31 100   평균 70.33… 40 64   학점 C F D     1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n  2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.\n  return 값 형식\n0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.\n Solution   테이블을 피봇하여 n번학생이 평가한 항목 리스트가 아닌, n번 학생에 대한 평가 리스트로 변경 자신이 평가한 최대값 또는 최소값이 유일한 최소, 최대값이라면 리스트에서 제거 2.의 리스트의 평균을 구하여, 등급을 메겨서 문자열로 붙여서 반환    몇가지 케이스를 통과하지 못해서 좀더 풀어봐야 할거같다.\n def solution(scores):\ranswer = ''\rpivot = []\rfor i in range(0, len(scores)) :\rfor j in range(0, len(scores)) :\rif j == 0 :\rtemp = []\rtemp.append(scores[j][i])\rpivot.append(temp)\ranswer = ''\rfor i in range(0, len(pivot)) : score = pivot[i]\rmin_value = min(score)\rmin_cnt = score.count(min_value)\rmax_value = max(score)\rmax_cnt = score.count(max_value)\r_score = [ score[k] for k in range(0, len(score)) if i != k or not ( (i == k and min_value == score[k] and min_cnt == 1) or (i == k and max_value == score[k] and max_cnt == 1) )]\ravg = sum(_score)/len(_score)\rif 90 \u0026lt;= avg:\ranswer += 'A'\relif 80 \u0026lt;= avg \u0026lt; 90 : answer += 'B'\relif 70 \u0026lt;= avg \u0026lt; 80 : answer += 'C'\relif 50 \u0026lt;= avg \u0026lt; 70 : answer += 'D'\relif avg \u0026lt; 50 : answer += 'F'\rreturn answer\r Others Solution def solution(scores):\ranswer = ''\rfor i, score in enumerate(zip(*scores)):\ravg = (sum(score) - score[i]) / (len(score) - 1) if score[i] in (min(score), max(score)) and score.count(score[i]) == 1 else sum(score) / len(score)\ranswer += \u0026quot;%s\u0026quot; % (\r\u0026quot;A\u0026quot; if 90 \u0026lt;= avg else\r\u0026quot;B\u0026quot; if 80 \u0026lt;= avg else\r\u0026quot;C\u0026quot; if 70 \u0026lt;= avg else\r\u0026quot;D\u0026quot; if 50 \u0026lt;= avg else\r\u0026quot;F\u0026quot;\r)\rreturn answer\r from collections import Counter\rdef solution(scores): answer = ''\rfor idx, score in enumerate(list(map(list, zip(*scores)))):\rlength = len(score)\rif Counter(score)[score[idx]] == 1 and (max(score) == score[idx] or min(score) == score[idx]):\rdel score[idx]\rlength -= 1\rgrade = sum(score) / length\rif grade \u0026gt;= 90:\ranswer += 'A'\relif grade \u0026gt;= 80:\ranswer += 'B'\relif grade \u0026gt;= 70:\ranswer += 'C'\relif grade \u0026gt;= 50:\ranswer += 'D'\relse:\ranswer += 'F'\rreturn answer\r TestCase print(solution([[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]),\t\u0026quot;FBABD\u0026quot;)\rprint(solution([[50,90],[50,87]]),\t\u0026quot;DA\u0026quot;)\rprint(solution([[70,49,90],[68,50,38],[73,31,100]]),\t\u0026quot;CFD\u0026quot;)\rprint(solution([[0,50,0],[50,0,0],[50,0,0]]),\t\u0026quot;CFD\u0026quot;)\r ","description":"83201 상호평가","id":20,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 83201 상호평가","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-83201-mutual-evaluation/"},{"content":"Programmers - 12910 나누어 떨어지는 숫자 배열 Task description 원문 : Programmers 12910 링크\n array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.\ndivisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.\n Condition   arr은 자연수를 담은 배열입니다. 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다. divisor는 자연수입니다. array는 길이 1 이상인 배열입니다.   ###입력 형식\n   arr divisor return     [5, 9, 7, 10] 5 [5, 10]   [2, 36, 1, 3] 1 [1, 2, 3, 36]   [3,2,6] 10 [-1]     입출력 예 설명\n입출력 예#1 arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다.\n  입출력 예#2\narr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다.\n  입출력 예#3\n3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다.\n Solution   배열의 요소 i를 divisor로 나눠떨어지면 배열에 담는다. 반환된 배열을 정렬한다. 배열이 비어있다면, [-1]로 반환한다.    def solution(arr, divisor):\rreturn sorted([i for i in arr if i%divisor == 0]) if len([i for i in arr if i%divisor == 0]) != 0 else [-1]\r Others Solution  마지막 [] 이면 이라는 조건을 단지 or로 사용\n def solution(arr, divisor): return sorted([n for n in arr if n%divisor == 0]) or [-1]\r TestCase print(solution([5, 9, 7, 10],\t5),\t[5, 10])\rprint(solution([2, 36, 1, 3],\t1),\t[1, 2, 3, 36])\rprint(solution([3,2,6],\t10),\t[-1])\r ","description":"12910 나누어 떨어지는 숫자 배열","id":21,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12910 나누어 떨어지는 숫자 배열","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-12910-divisible-array-of-numbers/"},{"content":"Programmers - 72412 순위 검색 Task description 원문 : Programmers 72412 링크\n 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.\n  코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다. 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다. 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다. 인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다. 예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다. 코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?   물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.   코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가? 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가? 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가? 즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.   * [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가? [문제] 지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때, 각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.\n Condition   info 배열의 크기는 1 이상 50,000 이하입니다. info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 \u0026ldquo;개발언어 직군 경력 소울푸드 점수\u0026rdquo; 형식입니다. 개발언어는 cpp, java, python 중 하나입니다. 직군은 backend, frontend 중 하나입니다. 경력은 junior, senior 중 하나입니다. 소울푸드는 chicken, pizza 중 하나입니다. 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. query 배열의 크기는 1 이상 100,000 이하입니다. query의 각 문자열은 \u0026ldquo;[조건] X\u0026rdquo; 형식입니다. [조건]은 \u0026ldquo;개발언어 and 직군 and 경력 and 소울푸드\u0026rdquo; 형식의 문자열입니다. 언어는 cpp, java, python, - 중 하나입니다. 직군은 backend, frontend, - 중 하나입니다. 경력은 junior, senior, - 중 하나입니다. 소울푸드는 chicken, pizza, - 중 하나입니다. \u0026lsquo;-\u0026rsquo; 표시는 해당 조건을 고려하지 않겠다는 의미입니다. X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. 예를 들면, \u0026ldquo;cpp and - and senior and pizza 500\u0026quot;은 \u0026ldquo;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 \u0026gt;- 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026ldquo;를 의미합니다.   ###입력 형식\n   info query result     [\u0026ldquo;java backend junior pizza 150\u0026rdquo;,\u0026ldquo;python frontend senior chicken 210\u0026rdquo;,\u0026ldquo;python frontend senior chicken 150\u0026rdquo;,\u0026ldquo;cpp backend senior pizza 260\u0026rdquo;,\u0026ldquo;java backend junior chicken 80\u0026rdquo;,\u0026ldquo;python backend senior chicken 50\u0026rdquo;] [\u0026ldquo;java and backend and junior and pizza 100\u0026rdquo;,\u0026ldquo;python and frontend and senior and chicken 200\u0026rdquo;,\u0026ldquo;cpp and - and senior and pizza 250\u0026rdquo;,\u0026quot;- and backend and senior and - 150\u0026rdquo;,\u0026quot;- and - and - and chicken 100\u0026rdquo;,\u0026quot;- and - and - and - 150\u0026rdquo;] [1,1,1,1,2,4]     입출력 예에 대한 설명 지원자 정보를 표로 나타내면 다음과 같습니다.\n    언어 직군 경력 소울 푸드 점수     java backend junior pizza 150   python frontend senior chicken 210   python frontend senior chicken 150   cpp backend  senior pizza   java backend junior chicken 80   python backend senior chicken 50      \u0026ldquo;java and backend and junior and pizza 100\u0026rdquo; : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다. \u0026ldquo;python and frontend and senior and chicken 200\u0026rdquo; : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다. \u0026ldquo;cpp and - and senior and pizza 250\u0026rdquo; : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다. \u0026ldquo;- and backend and senior and - 150\u0026rdquo; : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다. \u0026ldquo;- and - and - and chicken 100\u0026rdquo; : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다. \u0026ldquo;- and - and - and - 150\u0026rdquo; : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.   Solution  테스트 케이스를 통과하였지만, 효율성을 통과하지 못한 답변 1\n  def solution(info, query):\ranswer = []\rdatas = []\rquery_cnt = 5\rfor i in range(0,len(info)) :\rdatas.append(re.split(r' ',info[i]))\rfor i in range(0,len(query)) :\r_datas = datas order = str(query[i].replace('and ', '', query_cnt)).split()\rfor k in range(0,query_cnt) :\rif k \u0026lt; query_cnt-1 :\r_datas = [user for user in _datas if order[k] == user[k] or order[k] == '-'] else : _datas = [user for user in _datas if int(order[k]) \u0026lt;= int(user[k]) or order[k] == '-'] answer.append(len(_datas))\rreturn answer\r  테스트 케이스를 통과하였지만, 효율성을 통과하지 못한 답변 2\n import re\rdef solution(info, query):\ranswer = []\rdatas = []\rquery_cnt = 5\rfor i in range(0,len(info)) :\rdatas.append(re.split(r' ',info[i]))\rfor i in range(0,len(query)) :\r_datas = datas order = str(query[i].replace('and ', '', query_cnt)).split()\r_datas = [user for user in _datas if order[0] == user[0] or order[0] == '-'] _datas = [user for user in _datas if order[1] == user[1] or order[1] == '-'] _datas = [user for user in _datas if order[2] == user[2] or order[2] == '-'] _datas = [user for user in _datas if order[3] == user[3] or order[3] == '-'] _datas = [user for user in _datas if int(order[4]) \u0026lt;= int(user[4]) or order[4] == '-'] answer.append(len(_datas))\rreturn answer\r  -까지 포함된 모든 경우의 수를 키로 만들어 dic 으로 점수를 저장 dic을 정렬하고 2진검색을 사용하여 검색\n def solution(info, query):\ranswer = []\rdic = {}\rcomb = [0, 1, 2, 3]\rfor i in info:\rdata = i.split()\rconditions = data[:-1]\rscore = int(data[-1])\rfor j in range(5):\rfor k in list(combinations(comb, j)):\rtemp = conditions.copy()\rfor idx in k:\rtemp[idx] = '-'\rkey = ''.join(temp)\rif key in dic:\rdic[key].append(score)\relse:\rdic[key] = [score]\rfor value in dic.values(): value.sort()\rfor i in query:\rq_list = []\rfor j in i.split():\rif j == 'and':\rcontinue\rq_list.append(j)\rkey = ''.join(q_list[:-1])\rvalue = int(q_list[-1])\rif key in dic:\rdic_list = dic[key]\rindex = bisect_left(dic_list, value)\ranswer.append(len(dic_list) - index)\relse:\ranswer.append(0)\rcontinue\rreturn answer\r Others Solution from itertools import combinations\rdef solution(info, query):\ranswer = []\rdb = {}\rfor i in info: # info에 대해 반복\rtemp = i.split()\rconditions = temp[:-1] # 조건들만 모으고, 점수 따로\rscore = int(temp[-1]) for n in range(5): # 조건들에 대해 조합을 이용해서 combi = list(combinations(range(4), n))\rfor c in combi:\rt_c = conditions.copy()\rfor v in c: # '-'를 포함한 새로운 조건을 만들어냄.\rt_c[v] = '-'\rchanged_t_c = '/'.join(t_c)\rif changed_t_c in db: # 모든 조건의 경우에 수에 대해 딕셔너리\rdb[changed_t_c].append(score)\relse:\rdb[changed_t_c] = [score]\rfor value in db.values(): # 딕셔너리 내 모든 값 정렬\rvalue.sort()\rfor q in query: # query의 모든 조건에 대해서\rqry = [i for i in q.split() if i != 'and']\rqry_cnd = '/'.join(qry[:-1])\rqry_score = int(qry[-1])\rif qry_cnd in db: # 딕셔너리 내에 값이 존재한다면,\rdata = db[qry_cnd]\rif len(data) \u0026gt; 0: start, end = 0, len(data) # lower bound 알고리즘 통해 인덱스 찾고,\rwhile start != end and start != len(data):\rif data[(start + end) // 2] \u0026gt;= qry_score:\rend = (start + end) // 2\relse:\rstart = (start + end) // 2 + 1\ranswer.append(len(data) - start) # 해당 인덱스부터 끝까지의 갯수가 정답\relse:\ranswer.append(0)\rreturn answer\r TestCase info = [\u0026quot;java backend junior pizza 150\u0026quot;,\u0026quot;python frontend senior chicken 210\u0026quot;,\u0026quot;python frontend senior chicken 150\u0026quot;,\u0026quot;cpp backend senior pizza 260\u0026quot;,\u0026quot;java backend junior chicken 80\u0026quot;,\u0026quot;python backend senior chicken 50\u0026quot;]\tquery = [\u0026quot;java and backend and junior and pizza 100\u0026quot;,\u0026quot;python and frontend and senior and chicken 200\u0026quot;,\u0026quot;cpp and - and senior and pizza 250\u0026quot;,\u0026quot;- and backend and senior and - 150\u0026quot;,\u0026quot;- and - and - and chicken 100\u0026quot;,\u0026quot;- and - and - and - 150\u0026quot;]\rsolution(info, query)\r ","description":"72412 순위 검색","id":22,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 72412 순위 검색","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-72412-rank-search/"},{"content":"Programmers - 67257 수식 최대화 Task description 원문 : Programmers 67257 링크\n IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.\n이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.\n해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, ) 만으로 이루어진 연산 수식이 전달되며,\n참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.\n단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + \u0026gt; - \u0026gt; * 또는 - \u0026gt; * \u0026gt; + 등과 같이\n연산자 우선순위를 정의할 수 있으나 +, \u0026gt; - 또는 * \u0026gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.\n만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.\n  예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.\n  \u0026ldquo;100-200*300-500+20\u0026rdquo;\n  일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * \u0026gt; +,- 로 우선순위가 정의되어 있습니다.\n대회 규칙에 따라 + \u0026gt; - \u0026gt; * 또는 - \u0026gt; * \u0026gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* \u0026gt; - 또는 * \u0026gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.\n수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + \u0026gt; - \u0026gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.\n반면에 * \u0026gt; + \u0026gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.\n  참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.\n Condition   expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, ) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.\n즉, \u0026ldquo;402+-561\u0026ldquo;처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.\nexpression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.\n즉, \u0026ldquo;100-2145*458+12\u0026quot;처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.\n\u0026ldquo;-56+100\u0026quot;처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.\nexpression은 적어도 1개 이상의 연산자를 포함하고 있습니다.\n연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.\n같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.   ###입력 형식\n   expression result     \u0026ldquo;100-200*300-500+20\u0026rdquo; 60420   \u0026ldquo;506-32\u0026rdquo; 300     입출력 예에 대한 설명\n입출력 예 #1\n  * \u0026gt; + \u0026gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\n연산 순서는 아래와 같습니다.\n 100-200*300-500+20\r= 100-(200*300)-500+20\r= 100-60000-(500+20)\r= (100-60000)-520\r= (-59900-520)\r= -60420\r  따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.\n  입출력 예 #2 - \u0026gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\n연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)\n 50*6-3*2\r= 50*(6-3)*2\r= (50*3)*2\r= 150*2\r= 300\r  따라서, 우승 시 받을 수 있는 상금은 300 입니다.\n Solution   숫자와 부호를 배열에 담는다. 숫자와 부호를 부호 우선순위를 완전탐색하여 가장 높은 값을 찾는다.    def solution(expression):\ranswer = 0\rsigns = [\r['*','+','-']\r, ['*','-','+']\r, ['+','*','-']\r, ['+','-','*']\r, ['-','*','+']\r, ['-','+','*']\r]\rexp = []\rtmp = ''\rfor e in expression :\rif e == '' or e not in ['*','+','-'] :\rtmp += e\relse : exp.append(int(tmp))\rexp.append(e)\rtmp =''\rexp.append(int(tmp))\rmaximum = 0\rfor sign in signs :\r_exp = exp\r_stack = []\rtmp = ''\rfor s in sign:\rfor i in range(0,len(_exp)) :\rif _exp[i-1] in ['*','+','-'] and s == _exp[i-1] :\rprv = _stack.pop()\rpprv = _stack.pop()\rif prv == '*' :\r_stack.append(pprv * _exp[i])\relif prv == '+' :\r_stack.append(pprv + _exp[i])\relse :\r_stack.append(pprv - _exp[i])\relse : _stack.append(_exp[i])\rif len(_stack) == 1 :\rmaximum = max(abs(_stack[0]),maximum)\r_exp = _stack\r_stack = []\rreturn maximum\r  새로 배운 기능\n    기능 설명 예     permutations() 순열을 조합해 주는 함수 [\u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;] -\u0026gt; \u0026lsquo;ABC\u0026rsquo;, \u0026lsquo;ACB\u0026rsquo;, \u0026lsquo;BAC\u0026rsquo;, \u0026lsquo;BCA\u0026rsquo;, \u0026lsquo;CAB\u0026rsquo;, \u0026lsquo;CBA\u0026rsquo;   eval() 문자열을 수식으로 계산해주는 함수 eval(\u0026lsquo;100\u0026rsquo;+'+'+\u0026lsquo;200\u0026rsquo;) -\u0026gt;300   re.split(r'(\\D)',expression) 숫자와 문자를 분리 시켜켜 배열로 만들어주는 정규식 \u0026lsquo;10+20\u0026rsquo; -\u0026gt; \u0026lsquo;10\u0026rsquo;,'+'+\u0026lsquo;20\u0026rsquo;    \rimport re\rimport itertools\rdef solution(expression):\rsign = ['*','+','-']\rsigns = list(map(''.join, itertools.permutations(sign))) #sighs : ['*+-', '*-+', '+*-', '+-*', '-*+', '-+*']\rexp = re.split(r'(\\D)',expression)\rmaximum = 0\rfor sign in signs :\r_exp = exp[:]\r_stack = []\rfor s in sign:\rfor i in range(0,len(_exp)) :\rif _exp[i-1] in ['*','+','-'] and s == _exp[i-1] :\rex = str(_stack.pop())\rprev = str(_stack.pop())\rcurr = str(_exp[i])\r_stack.append(eval(prev+ex+curr))\relse : _stack.append(_exp[i])\rif len(_stack) == 1 :\rmaximum = max(abs(_stack[0]),maximum)\r_exp = _stack\r_stack = []\rreturn maximum\r Others Solution import re\rfrom itertools import permutations\rdef solution(expression):\r#1\rop = [x for x in ['*','+','-'] if x in expression]\rop = [list(y) for y in permutations(op)]\rex = re.split(r'(\\D)',expression)\r#2\ra = []\rfor x in op:\r_ex = ex[:]\rfor y in x:\rwhile y in _ex:\rtmp = _ex.index(y)\r_ex[tmp-1] = str(eval(_ex[tmp-1]+_ex[tmp]+_ex[tmp+1]))\r_ex = _ex[:tmp]+_ex[tmp+2:]\ra.append(_ex[-1])\r#3\rreturn max(abs(int(x)) for x in a)\r def solution(expression):\roperations = [('+', '-', '*'),('+', '*', '-'),('-', '+', '*'),('-', '*', '+'),('*', '+', '-'),('*', '-', '+')]\ranswer = []\rfor op in operations:\ra = op[0]\rb = op[1]\rtemp_list = []\rfor e in expression.split(a):\rtemp = [f\u0026quot;({i})\u0026quot; for i in e.split(b)]\rtemp_list.append(f'({b.join(temp)})')\ranswer.append(abs(eval(a.join(temp_list))))\rreturn max(answer)\r TestCase print(solution('100-200*300-500+20'), 60420)\r ","description":"67257 수식 최대화","id":23,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 67257 수식 최대화","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-67257-maximize-formula/"},{"content":"Programmers - 42840 모의고사 Task description 원문 : Programmers 42840 링크\n 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.\n 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...\r2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...\r3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...\r  1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n Condition   시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.   ###입력 형식\n 입출력 예\n    answers return     [1,2,3,4,5] [1]   [1,3,2,4,2] [1,2,3]     입출력 예 설명 입출력 예 #1\n  수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.\n  입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다.\n Solution   문제수와 정답 패턴의 길이를 맞춘다. 길면 자르고 모자라면 붙인다. 정답을 채점한다 최고점을 찾는다. 최고점 맞은 사람을 리스트에 담는다.    def solution(answers):\rlength = len(answers)\ranswer = []\rstudnet = [[1, 2, 3, 4, 5], [2, 1, 2, 3, 2, 4, 2, 5], [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]]\rresult = []\rfor s in studnet :\rarr = []\r[arr.extend(s) for i in range(len(answers)//len(s))]\rif len(answers)%len(s) != 0 :\rarr[len(arr):len(arr)] = s[:len(answers)%len(s)]\rresult.append(arr)\rmax_score = 0\rscore = {}\rfor j in range(0,3) :\rscore[j] = list(map(lambda i : 'O' if result[j][i] == answers[i] else 'X', range(0,len(answers)))).count('O')\rmax_score = max(score[j], max_score)\rprint(score,max_score)\rfor key in score.keys() :\rif score[key] == max_score :\ranswer.append(key+1)\rreturn answer\r Others Solution  cycle 사용\n from itertools import cycle\rdef solution(answers):\rgiveups = [\rcycle([1,2,3,4,5]),\rcycle([2,1,2,3,2,4,2,5]),\rcycle([3,3,1,1,2,2,4,4,5,5]),\r]\rscores = [0, 0, 0]\rfor num in answers:\rfor i in range(3):\rif next(giveups[i]) == num:\rscores[i] += 1\rhighest = max(scores)\rreturn [i + 1 for i, v in enumerate(scores) if v == highest]\r  enumerate 사용\n def solution(answers):\rp = [[1, 2, 3, 4, 5],\r[2, 1, 2, 3, 2, 4, 2, 5],\r[3, 3, 1, 1, 2, 2, 4, 4, 5, 5]]\rs = [0] * len(p)\rfor q, a in enumerate(answers):\rfor i, v in enumerate(p):\rif a == v[q % len(v)]:\rs[i] += 1\rreturn [i + 1 for i, v in enumerate(s) if v == max(s)]\r TestCase print(solution([1,2,3,4,5,1,2,3,4]), [1])\r ","description":"42840 모의고사","id":24,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42840 모의고사","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-42840-mock-exam/"},{"content":"Programmers - 82612 부족한 금액 계산하기 Task description 원문 : Programmers 82612 링크\n 새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\n  놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를\nreturn 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요.\n Condition   놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수 처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수 놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수   ###입력 형식\n 입출력 예\n    price money\tcount result      3 20 4 10     입출력 예 설명\n입출력 예 #1\n이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.\n Solution   1~N 까지 가격을 곱한 값의 배열을 구함, 그후 SUM을 통해 합계를 구함 구한 값을 cost라 하고, 가지고 있는 money와 비교 후 부족한 금액 또는 0 반환    def solution(price, money, count):\rcost = sum([price * i for i in range(1,count+1)])\rif cost - money \u0026gt; 0 :\rreturn cost - money\relse :\rreturn 0\r  def solution(price, money, count):\rreturn sum([price * i for i in range(1,count+1)])-money if sum([price * i for i in range(1,count+1)])-money \u0026gt; 0 else 0\r Others Solution def solution(price, money, count):\rreturn abs(min(money - sum([price*i for i in range(1,count+1)]),0))\r TestCase print(solution(3, 20, 4) , 10)\r ","description":"82612 부족한 금액 계산하기","id":25,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 82612 부족한 금액 계산하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-82612-calculate-the-shortfall/"},{"content":"Programmers - 42883 큰 수 만들기 Task description 원문 : Programmers 42883 링크\n 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.\n  예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.\n  문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.\n Condition   number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다.   ###입력 형식\n 입출력 예\n    number k return     \u0026ldquo;1924\u0026rdquo; 2 \u0026ldquo;94\u0026rdquo;   \u0026ldquo;1231234\u0026rdquo; 3 \u0026ldquo;3234\u0026rdquo;   \u0026ldquo;4177252841\u0026rdquo; 4 \u0026ldquo;775841\u0026rdquo;    Solution def solution(number, k):\rstack = []\rfor i in number:\rwhile stack and stack[-1] \u0026lt; i and k\u0026gt;0:\rk-=1\rstack.pop()\rstack.append(i)\rreturn \u0026quot;\u0026quot;.join(stack[:len(stack)-k])\r Others Solution def solution(number, k):\rstack = [number[0]]\rfor num in number[1:]:\rwhile len(stack) \u0026gt; 0 and stack[-1] \u0026lt; num and k \u0026gt; 0:\rk -= 1\rstack.pop()\rstack.append(num)\rif k != 0:\rstack = stack[:-k]\rreturn ''.join(stack)\r TestCase print(solution(\u0026quot;1924\u0026quot;,\t2),\t\u0026quot;94\u0026quot;)\rprint(solution(\u0026quot;1231234\u0026quot;,\t3),\t\u0026quot;3234\u0026quot;)\rprint(solution(\u0026quot;4177252841\u0026quot;\t,4), \u0026quot;775841\u0026quot;)\r ","description":"42883 큰 수 만들기","id":26,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42883 큰 수 만들기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-42883-make-big-numbers/"},{"content":"Programmers - 43162 네트워크 Task description 원문 : Programmers 43162 링크\n 네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.\n  컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.\n Condition   컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다.   ###입력 형식\n 입출력 예\n    n computers return     3 [[1, 1, 0], [1, 1, 0], [0, 0, 1]] 2   3 [[1, 1, 0], [1, 1, 1], [0, 1, 1]] 1     입출력 예 설명 예제 #1\n아래와 같이 2개의 네트워크가 있습니다.\n Solution #DFS\nfrom collections import deque\rdef dfs(i, visited, computers):\rvisited[i] = True\rfor c in range(0,len(computers[i])) :\rif c != i and visited[c] == False and computers[i][c] == 1:\rdfs(c, visited, computers)\rreturn 0\rdef solution(n, computers):\rcount = 0\rvisited = [False for i in range(0,n)]\rfor i in range(0,n) :\rif not visited[i] : dfs(i, visited, computers)\rcount += 1\rreturn count\r Others Solution def solution(n, computers): def BFS(node, visit):\rque = [node]\rvisit[node] = 1\rwhile que:\rv = que.pop(0)\rfor i in range(n):\rif computers[v][i] == 1 and visit[i] == 0:\rvisit[i] = 1\rque.append(i)\rreturn visit\rvisit = [0 for i in range(n)]\ranswer = 0\rfor i in range(n):\rtry:\rvisit = BFS(visit.index(0), visit)\ranswer += 1\rexcept:\rbreak\rreturn answer\r TestCase solution(3, [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\t)\r ","description":"43162 네트워크","id":27,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 43162 네트워크","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202108/programmers-43162-network/"},{"content":"Programmers - 43165 타겟 넘버 Task description 원문 : Programmers 43165 링크\n n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.\n -1+1+1+1+1 = 3\r+1-1+1+1+1 = 3\r+1+1-1+1+1 = 3\r+1+1+1-1+1 = 3\r+1+1+1+1-1 = 3\r  사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.\n Condition   주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다.   ###입력 형식\n 입출력 예\n    numbers target return     [1, 1, 1, 1, 1] 3 5    입출력 예 설명 문제에 나온 예와 같습니다.\nSolution BFS from collections import deque\rdef solution(numbers, target):\rcount = 0\rqueue = deque()\rqueue.append([0,0])\rwhile queue :\rsum, length = queue.popleft() #print(sum,length)\rif length \u0026gt; len(numbers) :\rbreak\relif length == len(numbers) and sum == target:\rcount += 1\rqueue.append([sum+numbers[length-1],length+1])\rqueue.append([sum-numbers[length-1],length+1])\rreturn count\r DFS\ndef solution(numbers, target):\rif len(numbers) == 0 :\rif target == 0 :\rreturn 1\relse : return 0\rreturn solution(numbers[1:], numbers[0]+target)+solution(numbers[1:], numbers[0]-target)\r Others Solution from itertools import product\rdef solution(numbers, target):\rl = [(x, -x) for x in numbers]\rs = list(map(sum, product(*l)))\rreturn s.count(target)\r TestCase #print(solution([1, 1, 1, 1, 1], 3), 5)\r#print(solution([1, 2, 1, 2], 2), 3)\r#print(solution([1, 2, 1, 2], 6), 1)\r ","description":"43165 타겟 넘버","id":28,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 43165 타겟 넘버","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-43165-target-number/"},{"content":"Programmers - 12906 같은 숫자는 싫어 Task description 원문 : Programmers 12906 링크\n 배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,\n arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.\rarr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.\r배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.\r Condition   배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수   ###입력 형식\n 입출력 예\n    arr answer     [1,1,3,3,0,1,1] [1,3,0,1]   [4,4,4,3,3] [4,3]    Solution def solution(arr):\ranswer = []\rfor x in arr : if len(answer) == 0 : answer.append(x)\relif answer[-1] != x :\ranswer.append(x)\rreturn answer\r Others Solution def no_continuous(s):\rreturn [s[i] for i in range(len(s)) if s[i] != s[i+1:i+2]]\r def no_continuous(s):\rreturn [ v for i,v in enumerate(s) if s[i-1]!=s[i]]\r TestCase  ","description":"12906 같은 숫자는 싫어","id":29,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12906 같은 숫자는 싫어","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-12906-i-hate-the-same-number/"},{"content":"Programmers - 60057 문자열 압축 Task description 원문 : Programmers 60057 링크\n 데이터 처리 전문가가 되고 싶은 \u0026ldquo;어피치\u0026quot;는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.\n간단한 예로 \u0026ldquo;aabbaccc\u0026quot;의 경우 \u0026ldquo;2a2ba3c\u0026rdquo;(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다.\n예를 들면, \u0026ldquo;abcabcdede\u0026quot;와 같은 문자열은 전혀 압축되지 않습니다. \u0026ldquo;어피치\u0026quot;는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.\n  예를 들어, \u0026ldquo;ababcdcdababcdcd\u0026quot;의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 \u0026ldquo;2ab2cd2ab2cd\u0026quot;로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 \u0026ldquo;2ababcdcd\u0026quot;로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.\n  다른 예로, \u0026ldquo;abcabcdede\u0026quot;와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 \u0026ldquo;abcabc2de\u0026quot;가 되지만, 3개 단위로 자른다면 \u0026ldquo;2abcdede\u0026quot;가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.\n  압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.\n Condition   s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s\tresult \u0026ldquo;aabbaccc\u0026rdquo;\t7 \u0026ldquo;ababcdcdababcdcd\u0026rdquo;\t9 \u0026ldquo;abcabcdede\u0026rdquo;\t8 \u0026ldquo;abcabcabcabcdededededede\u0026rdquo;\t14 \u0026ldquo;xababcdcdababcdcd\u0026rdquo;\t17   ###입력 형식\n 입출력 예 #1\n  문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.\n  입출력 예 #2\n  문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.\n  입출력 예 #3\n  문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.\n  입출력 예 #4\n 문자열을 2개 단위로 자르면 \u0026quot;abcabcabcabc6de\u0026quot; 가 됩니다.\r문자열을 3개 단위로 자르면 \u0026quot;4abcdededededede\u0026quot; 가 됩니다.\r문자열을 4개 단위로 자르면 \u0026quot;abcabcabcabc3dede\u0026quot; 가 됩니다.\r문자열을 6개 단위로 자를 경우 \u0026quot;2abcabc2dedede\u0026quot;가 되며, 이때의 길이가 14로 가장 짧습니다.\r  입출력 예 #5\n  문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.\n따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.\n이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.\n Solution   record의 아이디별 최종 변경된 닉네임을 딕셔너리에 등록 record Enter와 Leave의 메시지와 변경된 닉네임으로 결과에 추가   def solution(s):\rindex = 0\rcompression = []\rwhile True:\rcompression.append('')\rif len(s) == index:\rbreak\rarr = [s[i+(i*index):i+(i*index)+(index+1)] for i in range(0,len(s)) ]\rprv = ''\rcnt = 0\rfor i in range(0,len(arr)) :\rif prv == '' : cnt = 1\rprv = arr[i] elif prv == arr[i] :\rcnt += 1\relse :\rif cnt \u0026gt; 1 :\rcompression[index] += str(cnt)\rcompression[index] += prv\rcnt = 1\rprv = arr[i] if i == len(arr)-1 :\rif cnt \u0026gt; 1 :\rcompression[index] += str(cnt)\rcompression[index] += prv\rindex += 1\rminimum = 99999\rfor s in compression :\rif len(s) != 0 :\rminimum = min(len(s),minimum)\rreturn minimum\r Others Solution def compress(text, tok_len):\rwords = [text[i:i+tok_len] for i in range(0, len(text), tok_len)]\rres = []\rcur_word = words[0]\rcur_cnt = 1\rfor a, b in zip(words, words[1:] + ['']):\rif a == b:\rcur_cnt += 1\relse:\rres.append([cur_word, cur_cnt])\rcur_word = b\rcur_cnt = 1\rreturn sum(len(word) + (len(str(cnt)) if cnt \u0026gt; 1 else 0) for word, cnt in res)\rdef solution(text):\rreturn min(compress(text, tok_len) for tok_len in list(range(1, int(len(text)/2) + 1)) + [len(text)])\r TestCase  = [\r\u0026quot;aabbaccc\u0026quot;,\r\u0026quot;ababcdcdababcdcd\u0026quot;,\r\u0026quot;abcabcdede\u0026quot;,\r\u0026quot;abcabcabcabcdededededede\u0026quot;,\r\u0026quot;xababcdcdababcdcd\u0026quot;,\r'aaaaaa',\r]\rfor x in a:\rprint(solution(x))\r ","description":"60057 문자열 압축","id":30,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 60057 문자열 압축","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-60057-string-compression/"},{"content":"Programmers - 42888 오픈 채팅방 Task description 원문 : Programmers 42888 링크\n 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.\n  신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.\n \u0026quot;[닉네임]님이 들어왔습니다.\u0026quot;\r  채팅방에서 누군가 나가면 다음 메시지가 출력된다.\n \u0026quot;[닉네임]님이 나갔습니다.\u0026quot;\r  채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.\n  채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.\n  예를 들어, 채팅방에 \u0026ldquo;Muzi\u0026quot;와 \u0026ldquo;Prodo\u0026quot;라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.\n \u0026quot;Muzi님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r  채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.\n \u0026quot;Muzi님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Muzi님이 나갔습니다.\u0026quot;\r  Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.\n \u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 나갔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r  채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.\n \u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r\u0026quot;Ryan님이 들어왔습니다.\u0026quot;\r\u0026quot;Prodo님이 나갔습니다.\u0026quot;\r\u0026quot;Prodo님이 들어왔습니다.\u0026quot;\r  채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.\n Condition   record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다. 다음은 record에 담긴 문자열에 대한 설명이다. 모든 유저는 [유저 아이디]로 구분한다. [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - \u0026ldquo;Enter [유저 아이디] [닉네임]\u0026rdquo; (ex. \u0026ldquo;Enter uid1234 Muzi\u0026rdquo;) [유저 아이디] 사용자가 채팅방에서 퇴장 - \u0026ldquo;Leave [유저 아이디]\u0026rdquo; (ex. \u0026ldquo;Leave uid1234\u0026rdquo;) [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - \u0026ldquo;Change [유저 아이디] [닉네임]\u0026rdquo; (ex. \u0026ldquo;Change uid1234 Muzi\u0026rdquo;) 첫 단어는 Enter, Leave, Change 중 하나이다. 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다. 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다. 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다. 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.   ###입력 형식\n   record result     [\u0026ldquo;Enter uid1234 Muzi\u0026rdquo;, \u0026ldquo;Enter uid4567 Prodo\u0026rdquo;,\u0026ldquo;Leave uid1234\u0026rdquo;,\u0026ldquo;Enter uid1234 Prodo\u0026rdquo;,\u0026ldquo;Change uid4567 Ryan\u0026rdquo;] [\u0026ldquo;Prodo님이 들어왔습니다.\u0026rdquo;, \u0026ldquo;Ryan님이 들어왔습니다.\u0026rdquo;, \u0026ldquo;Prodo님이 나갔습니다.\u0026rdquo;, \u0026ldquo;Prodo님이 들어왔습니다.\u0026quot;]    Solution   record의 아이디별 최종 변경된 닉네임을 딕셔너리에 등록 record Enter와 Leave의 메시지와 변경된 닉네임으로 결과에 추가   def solution(record):\ranswer = [] user = {}\rfor row in record :\rorder = row.split()[0]\ruid = row.split()[1]\rif order == 'Enter' :\ruser[uid] = row.split()[2]\relif order == 'Change' :\ruser[uid] = row.split()[2]\rfor row in record :\rorder = row.split()[0]\ruid = row.split()[1]\rif order == 'Enter' :\ranswer.append(user[uid]+\u0026quot;님이 들어왔습니다.\u0026quot;)\relif order == 'Leave' :\ranswer.append(user[uid]+\u0026quot;님이 나갔습니다.\u0026quot;)\rreturn answer\r def solution(record):\ruser = { row.split()[1]:row.split()[-1] for row in list(filter(lambda x : x.startswith('Enter') or x.startswith('Change') ,record)) }\rreturn [f'{user[row.split()[1]]}님이 들어왔습니다.' if row.startswith('Enter') else f'{user[row.split()[1]]}님이 나갔습니다.' for row in list(filter(lambda x : not x.startswith('Change') ,record)) ]\r Others Solution def solution(record):\ruser_id = {EC.split()[1]:EC.split()[-1] for EC in record if EC.startswith('Enter') or EC.startswith('Change')}\rreturn [f'{user_id[E_L.split()[1]]}님이 들어왔습니다.' if E_L.startswith('Enter') else f'{user_id[E_L.split()[1]]}님이 나갔습니다.' for E_L in record if not E_L.startswith('Change')]\r TestCase solution([\u0026quot;Enter uid1234 Muzi\u0026quot;, \u0026quot;Enter uid4567 Prodo\u0026quot;,\u0026quot;Leave uid1234\u0026quot;,\u0026quot;Enter uid1234 Prodo\u0026quot;,\u0026quot;Change uid4567 Ryan\u0026quot;])\r ","description":"42888 오픈 채팅방","id":31,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42888 오픈 채팅방","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42888-open-chat-room/"},{"content":"Programmers - 42626 더 맵게 Task description 원문 : Programmers 42626 링크\n 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.\n  섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\nLeo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.\n 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.\nCondition   scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.   ###입력 형식\n   scoville K return     [1, 2, 3, 9, 10, 12] 7 2     입출력 예 설명\n스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\n새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\n가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]\n  스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\n새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\n가진 음식의 스코빌 지수 = [13, 9, 10, 12]\n Solution import heapq\rdef solution(scoville, K):\ranswer = 0\rheapq.heapify(scoville)\rwhile scoville[0] \u0026lt; K :\rtry :\rf = heapq.heappop(scoville)\rs = heapq.heappop(scoville)\rheapq.heappush(scoville, f+(s*2))\ranswer += 1\rexcept :\rreturn -1\rreturn answer\r Others Solution import heapq as hq\rdef solution(scoville, K):\rhq.heapify(scoville)\ranswer = 0\rwhile True:\rfirst = hq.heappop(scoville)\rif first \u0026gt;= K:\rbreak\rif len(scoville) == 0:\rreturn -1\rsecond = hq.heappop(scoville)\rhq.heappush(scoville, first + second*2)\ranswer += 1 return answer\r TestCase  ","description":"42626 더 맵게","id":32,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42626 더 맵게","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42626-more-spicy/"},{"content":"Programmers - 17677 뉴스 클러스터링 Task description 원문 : Programmers 17677 링크\n 뉴스 클러스터링\n여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다.\nDaum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.\n  개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 \u0026ldquo;카카오 신입 개발자 공채\u0026rdquo; 관련 기사를 검색해보았다.\n  카카오 첫 공채..\u0026lsquo;블라인드\u0026rsquo; 방식 채용\n카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용\n카카오, 블라인드 전형으로 신입 개발자 공채\n카카오 공채, 신입 개발자 코딩 능력만 본다\n카카오, 신입 공채.. \u0026ldquo;코딩 실력만 본다\u0026rdquo;\n카카오 \u0026ldquo;코딩 능력만으로 2018 신입 개발자 뽑는다\u0026rdquo;\n기사의 제목을 기준으로 \u0026ldquo;블라인드 전형\u0026quot;에 주목하는 기사와 \u0026ldquo;코딩 테스트\u0026quot;에 주목하는 기사로 나뉘는 걸 발견했다.\n튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.\n  유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 \u0026ldquo;자카드 유사도\u0026quot;라는 방법을 찾아냈다.\n  자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.\n  예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때,\n교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로,\n집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다.\n집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다.\n  자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 \u0026ldquo;1\u0026quot;을 3개 가지고 있고, 다중집합 B는 원소 \u0026ldquo;1\u0026quot;을 5개 가지고 있다고 하자.\n이 다중집합의 교집합 A ∩ B는 원소 \u0026ldquo;1\u0026quot;을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 \u0026ldquo;1\u0026quot;을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로,\n자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다.\n  이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 \u0026ldquo;FRANCE\u0026quot;와 \u0026ldquo;FRENCH\u0026quot;가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(\u0026ldquo;FRANCE\u0026rdquo;, \u0026ldquo;FRENCH\u0026rdquo;) = 2/8 = 0.25가 된다.\n Condition ###입력 형식\n 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.\n입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고,\n기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 \u0026ldquo;ab+\u0026ldquo;가 입력으로 들어오면,\n\u0026ldquo;ab\u0026quot;만 다중집합의 원소로 삼고, \u0026ldquo;b+\u0026ldquo;는 버린다.\n다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. \u0026ldquo;AB\u0026quot;와 \u0026ldquo;Ab\u0026rdquo;, \u0026ldquo;ab\u0026quot;는 같은 원소로 취급한다.\n ###출력 형식\n 입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.\n input output  예제 입출력\n    str1 str2 answer     FRANCE french 16384   handshake shake hands 65536   aa1+aa2 AAAA12 43690   E=M*C^2 e=m*c^2 6553644\u0026rdquo;    Solution import math\rfrom collections import Counter\rdef makeArr(str) :\rarr = [] prv = ''\rfor crr in str : if prv != '' :\rif crr.isalpha() and prv.isalpha() :\rarr.append(prv+crr)\rprv = crr\rreturn sorted(arr)\rdef J(A, B):\ranswer = 0\rintersection = []\runion = []\rtry :\rfor i in range(len(A)) : for j in range(len(B)) : if A[i] == B[j] :\rintersection.append(A[i])\runion.append(A[i])\rB[j] = None\rA[i] = None for a in A : if a is not None :\runion.append(a)\rfor b in B : if b is not None :\runion.append(b)\rif answer == 0 and len(union) != 0:\ranswer = len(intersection)/len(union)\relif answer == 0 and len(union) == 0:\ranswer = 1\rexcept :\ranswer = 1\rreturn math.trunc(answer*65536)\rdef solution(str1, str2):\rstr1 = str1.lower()\rstr2 = str2.lower()\rA = makeArr(str1)\rB = makeArr(str2)\rreturn J(A, B)\r Others Solution import re\rimport math\rdef solution(str1, str2):\rstr1 = [str1[i:i+2].lower() for i in range(0, len(str1)-1) if not re.findall('[^a-zA-Z]+', str1[i:i+2])]\rstr2 = [str2[i:i+2].lower() for i in range(0, len(str2)-1) if not re.findall('[^a-zA-Z]+', str2[i:i+2])]\rgyo = set(str1) \u0026amp; set(str2)\rhap = set(str1) | set(str2)\rif len(hap) == 0 :\rreturn 65536\rgyo_sum = sum([min(str1.count(gg), str2.count(gg)) for gg in gyo])\rhap_sum = sum([max(str1.count(hh), str2.count(hh)) for hh in hap])\rreturn math.floor((gyo_sum/hap_sum)*65536)\r TestCase #solution('11111', '111')\r#solution('FRANCE', 'french')\r#solution('handshake', 'shake hands')\r#solution('AAAA12','aa1+aa2') #43690\r#solution('E=M*C^2', 'e=m*c^2')\r ","description":"17677 뉴스 클러스터링","id":33,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 17677 뉴스 클러스터링","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-17677-news-clustering/"},{"content":"Programmers - 12948 핸드폰 번호 가리기 Task description 원문 : Programmers 12948 링크\n 프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.\n Condition   s는 길이 4 이상, 20이하인 문자열입니다.   input output  입출력 예\n    입출력 예     phone_number return   \u0026ldquo;01033334444\u0026rdquo; \u0026ldquo;*******4444\u0026rdquo;   \u0026ldquo;027778888\u0026rdquo; \u0026ldquo;*****8888\u0026rdquo;    Solution   받아온 숫자를 뒤 4번째 부터 자른다. 1에서 만든 4자리에 원래 받아온 숫자 자리수 까지 왼쪽을 *로 채운다   def solution(phone_number): return phone_number[-4:].rjust(len(phone_number),'*')\r Others Solution def hide_numbers(s):\rreturn \u0026quot;*\u0026quot;*(len(s)-4) + s[-4:]\r TestCase solution(\u0026quot;01033334444\u0026quot;)\rsolution(\u0026quot;027778888\u0026quot;)\rsolution(\u0026quot;4444\u0026quot;)\r ","description":"12948 핸드폰 번호 가리기","id":34,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12948 핸드폰 번호 가리기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-12948-phone-number-masking/"},{"content":"Programmers - 68644 두 개 뽑아서 더하기 Task description 원문 : Programmers 68644 링크\n 정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.\n Condition   numbers의 길이는 2 이상 100 이하입니다. numbers의 모든 수는 0 이상 100 이하입니다.   input output  입출력 예\n    numbers result     [2,1,3,4,1] [2,3,4,5,6,7]   [5,0,2,7] [2,5,7,9,12]     입출력 예 설명\n입출력 예 #1\n  2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다.\n4 = 1 + 3 입니다.\n5 = 1 + 4 = 2 + 3 입니다.\n6 = 2 + 4 입니다.\n7 = 3 + 4 입니다.\n따라서 [2,3,4,5,6,7] 을 return 해야 합니다.\n입출력 예 #2\n  2 = 0 + 2 입니다.\n5 = 5 + 0 입니다.\n7 = 0 + 7 = 5 + 2 입니다.\n9 = 2 + 7 입니다.\n12 = 5 + 7 입니다.\n따라서 [2,5,7,9,12] 를 return 해야 합니다.\n Solution   numbers를 2중 루프로 순회 numbers를 인덱스 i와 j가 같지 않을때 두값을 더한다 set으로 중복제거후 sorted로 정렬 하여 반환   def solution(numbers):\rfor i in range(0,len(numbers)) :\rfor j in range(0,len(numbers)) :\rif i != j :\ranswer.append(numbers[i]+numbers[j])\rreturn sorted(set(answer))\r TestCase # solution([2,1,3,4,1])\r# solution([5,0,2,7])\r ","description":"Programmers 두 개 뽑아서 더하기","id":35,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 68644 두 개 뽑아서 더하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-68644-take-two-and-add/"},{"content":"Programmers - 12973 짝지어 제거하기 Task description 원문 : Programmers 12973 링크\n 짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.\n  예를 들어, 문자열 S = baabaa 라면\n  b aa baa → bb aa → aa →\n  의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.\n Condition   문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다.   input output  입출력 예\n    s result     baabaa 1   cdcd 0     입출력 예 설명 입출력 예 #1\n위의 예시와 같습니다.\n  입출력 예 #2 문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.\n Solution   stack 생성 stack이 비어있거나, stack의 마지막과 현재 순회중인 문자열(S)과 다르면 추가 stack의 마지막과 현재 순회중인 문자열이 같으면 stack의 마지막 pop stack이 비어있으면 1 남아있는게 있으면 0 리턴   def solution(string):\rstack = [] # stack 생성\rfor s in string :\rif len(stack) == 0 or stack[-1] != s: # stack이 비어있거나, stack의 마지막과 현재 순회중인 문자열(S)과 다르면 추가\rstack.append(s)\relif stack[-1] == s : #stack의 마지막과 현재 순회중인 문자열이 같으면 stack의 마지막 pop\rstack.pop()\rif len(stack) == 0 : #stack이 비어있으면 1 return 1\relse :\t#남아있는게 있으면 0 리턴\rreturn 0\r TestCase # solution('baabaa')\r# solution('babaa')\r# solution('cdcd')\r ","description":"Programmers 짝지어 제거하기","id":36,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 12973 짝지어 제거하기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-12973-remove-by-pair/"},{"content":"Programmers - 17681 비밀지도 Task description 원문 : Programmers 17681 링크\n 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n   지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \u0026ldquo;공백\u0026rdquo;(\u0026quot; \u0026ldquo;) 또는 \u0026ldquo;벽\u0026rdquo;(\u0026quot;#\u0026quot;) 두 종류로 이루어져 있다.  전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. \u0026ldquo;지도 1\u0026quot;과 \u0026ldquo;지도 2\u0026quot;는 각각 정수 배열로 암호화되어 있다.\n 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\n    네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n Condition   1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식 원래의 비밀지도를 해독하여 \u0026lsquo;#\u0026rsquo;, 공백으로 구성된 문자열 배열로 출력하라.   input output  입력 형식\n입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.\n  입출력 예제     매개변수 값     n 5   arr1 [9, 20, 28, 18, 11]   arr2 [30, 1, 21, 17, 28]     출력\t[\u0026quot;#####\u0026rdquo;,\u0026quot;# # #\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;# ##\u0026rdquo;, \u0026ldquo;#####\u0026quot;]\n    매개변수 값     n 6   arr1 [46, 33, 33 ,22, 31, 50]   arr2 [27 ,56, 19, 14, 14, 10]     출력\t[\u0026quot;######\u0026rdquo;, \u0026ldquo;### #\u0026rdquo;, \u0026ldquo;## ##\u0026rdquo;, \u0026quot; #### \u0026ldquo;, \u0026quot; #####\u0026rdquo;, \u0026ldquo;### # \u0026ldquo;]\n Solution   map 함수로 arr1, arr2 를 순회하여 변경 arr1의 arr2의 a,b를 bin(a|b) 로 or 연산 0b 를 자르기 위해 [2:] 2부터 나머지 까지 자름 zfill로 n까지 0으로 채움 1을 #으로, 0을 ' \u0026lsquo;으로 변경   def solution(n, arr1, arr2):\rreturn list(map(lambda a,b : (str(bin(a|b))[2:].zfill(n)).replace('1','#').replace('0',' '), arr1, arr2))\r Others Solution solution = lambda n, arr1, arr2: ([''.join(map(lambda x: '#' if x=='1' else ' ', \u0026quot;{0:b}\u0026quot;.format(row).zfill(n))) for row in (a|b for a, b in zip(arr1, arr2))])\r TestCase \u0026quot;\u0026quot;\u0026quot;\rn = 5\rarr1 = [9, 20, 28, 18, 11]\rarr2 =\t[30, 1, 21, 17, 28]\r\u0026quot;\u0026quot;\u0026quot;\r\u0026quot;\u0026quot;\u0026quot;\rn = 6\rarr1 = [46, 33, 33 ,22, 31, 50]\rarr2 = [27 ,56, 19, 14, 14, 10]\rsolution(n, arr1, arr2)\r\u0026quot;\u0026quot;\u0026quot;\r ","description":"Programmers 비밀지도","id":37,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 17681 비밀지도","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-17681-secret-map/"},{"content":"Programmers - 42889 실패율 Task description 원문 : Programmers 42889 링크\n 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.\n  이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.\n  실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.\n Condition   스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\n stages의 길이는 1 이상 200,000 이하이다.\n stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.   input output  입출력 예\n    N stages result     5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5]   4 [4,4,4,4,4] [4,1,2,3]     입출력 예 설명 입출력 예 #1 1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다.\n1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다.\n3 번 스테이지 실패율 : 2/4\n4번 스테이지 실패율 : 1/2\n5번 스테이지 실패율 : 0/1\n각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.\n[3,4,2,1,5]\n  입출력 예 #2\n모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다.\n[4,1,2,3]\n Solution def solution(N, stages):\rfailureRate = {}\rchallenger = len(stages)\rfor stage in range(1,N+1) :\rfailure = stages.count(stage) # stage별 실패자의 카운트\rif challenger == 0 :\t# 도전자가 0이면 실패율 0\rfailureRate[stage] = 0\relse :\r# '실패율 = 실패자 / 도전자' failureRate[stage] = failure / challenger # 실패율 dict에 스테이지별로 실패율 저장\rchallenger = challenger - failure\t# 다음 스테이지 도전자 = '도전자 - 실패자'\rreturn sorted(failureRate, key=lambda x : failureRate[x], reverse=True)  Others Solution def solution(N, stages):\rresult = {}\rdenominator = len(stages)\rfor stage in range(1, N+1):\rif denominator != 0:\rcount = stages.count(stage)\rresult[stage] = count / denominator\rdenominator -= count\relse:\rresult[stage] = 0\rreturn sorted(result, key=lambda x : result[x], reverse=True)\r TestCase #solution(5,\t[2, 1, 2, 6, 2, 4, 3, 3])\r#solution(5, [2,1,2,4,2,4,3,3])\r ","description":"Programmers 실패율","id":38,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42889 실패율","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42889-failure-rate/"},{"content":"Programmers - 17682 다트 게임 Task description 원문 : Programmers 17682 링크\n 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다. 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.\n  다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.\n점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.\n옵션으로 스타상() , 아차상(#)이 존재하며 스타상() 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.\n스타상()은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상()의 점수만 2배가 된다. (예제 4번 참고)\n스타상()의 효과는 다른 스타상()의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상() 점수는 4배가 된다. (예제 4번 참고)\n스타상()의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)\nSingle(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.\n스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.\n0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.\n Condition   점수는 0에서 10 사이의 정수이다. 보너스는 S, D, T 중 하나이다. 옵선은 *이나 # 중 하나이며, 없을 수도 있다. 입력 형식 \u0026ldquo;점수|보너스|[옵션]\u0026ldquo;으로 이루어진 문자열 3세트. 예) 1S2D*3T 출력 형식 3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다. 예) 37   input output    예제 dartResult answer 설명     1 1S2D*3T 37 11 * 2 + 22 * 2 + 33   2 1D2S#10S 9 12 + 21 * (-1) + 101   3 1D2S0T 3 12 + 21 + 03   4 1S2T3S 23 11 * 2 * 2 + 23 * 2 + 31   5 1D#2S*3S 5 12 * (-1) * 2 + 21 * 2 + 31   6 1T2D3D# -4 13 + 22 + 32 * (-1)   7 1D2S3T* 59 12 + 21 * 2 + 33 * 2    Solution   숫자(문자열)은 number에 붙임 SDT 면 number를 숫자로 변경후 해당 dart 값을 거듭제곱 *이면 현재값, 이전값 *2 #이면 현재값 -로 변경 결과 배열합해서 반환   def solution(dartResult):\rdart = {'S':1, 'D':2, 'T':3}\rscore = [0,0,0]\rnumber = ''\rfor i in range(0,len(dartResult)):\rs = dartResult[i]\rif s in dart :\t# SDT는 **1,**2,**3 score.append(int(number) ** dart [s])\tnumber = ''\relif s == '*' :\t# *는 현재 점수 *2, 이전 점수 *2\rscore[-1] *= 2\rscore[-2] *= 2\relif s == '#' :\t# #은 현재 점수 *-1\rscore[-1] *= -1\relse :\t# 숫자 문자열 시 number에 문자열 합침\rnumber += s\rreturn sum(score)\r Others Solution import re\rdef solution(dartResult):\rbonus = {'S' : 1, 'D' : 2, 'T' : 3}\roption = {'' : 1, '*' : 2, '#' : -1}\rp = re.compile('(\\d+)([SDT])([*#]?)')\rdart = p.findall(dartResult)\rfor i in range(len(dart)):\rif dart[i][2] == '*' and i \u0026gt; 0:\rdart[i-1] *= 2\rdart[i] = int(dart[i][0]) ** bonus[dart[i][1]] * option[dart[i][2]]\ranswer = sum(dart)\rreturn answer\r TestCase \rtestcase = ['1S2D*3T','1D2S#10S','1D2S0T','1S*2T*3S','1D#2S*3S','1T2D3D#','1D2S3T*']\rfor test in testcase :\rsolution(test);\r ","description":"Programmers 다트 게임","id":39,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 17682 다트 게임","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-17682-dart-game/"},{"content":"Programmers - 67256 키패드 누르기 Task description 원문 : Programmers 67256 링크\n 스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\n  이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.\n맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\n  엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.\n오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.\n가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.\n4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\n순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.\n Condition   numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 \u0026ldquo;left\u0026rdquo; 또는 \u0026ldquo;right\u0026rdquo; 입니다. \u0026ldquo;left\u0026quot;는 왼손잡이, \u0026ldquo;right\u0026quot;는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.   input output  입출력 예\n    numbers hand result     [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] \u0026ldquo;right\u0026rdquo; \u0026ldquo;LRLLLRLLRRL\u0026rdquo;   [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] \u0026ldquo;left\u0026rdquo; \u0026ldquo;LRLLRRLLLRR\u0026rdquo;   [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] \u0026ldquo;right\u0026rdquo; \u0026ldquo;LLRLLRLLRL\u0026rdquo;     입출력 예에 대한 설명 입출력 예 #1\n  순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다.\n    왼손 위치 오른손 위치 눌러야 할 숫자 사용한 손 설명     * # 1 L 1은 왼손으로 누릅니다.   1 # 3 R 3은 오른손으로 누릅니다.   1 3 4 L 4는 왼손으로 누릅니다.   4 3 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.   5 3 8 L 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다.   8 3 2 R 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다.   8 2 1 L 1은 왼손으로 누릅니다.   1 2 4 L 4는 왼손으로 누릅니다.   4 2 5 R 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다.   4 5 9 R 9는 오른손으로 누릅니다.   4 9 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다.   5 9 - -      따라서 \u0026ldquo;LRLLLRLLRRL\u0026quot;를 return 합니다.\n  입출력 예 #2 왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 \u0026ldquo;LRLLRRLLLRR\u0026quot;이 됩니다.\n  입출력 예 #3 오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 \u0026ldquo;LLRLLRLLRL\u0026quot;이 됩니다.\n Solution def getDistance(n, target):\rkeypad = {}\t# 딕셔너리로 각 좌표를 생성\rkeypad[1] = [0,0]\tkeypad[2] = [0,1]\t#\t1[0,0] 2[0,1] 3[0,2] keypad[3] = [0,2]\tkeypad[4] = [1,0] #\t4[1,0] 5[1,1] 6[1,2] keypad[5] = [1,1] keypad[6] = [1,2] #\t7[2,0] 8[2,1] 9[2,2] keypad[7] = [2,0] keypad[8] = [2,1] #\t*[3,0] 0[3,1] #[3,2] keypad[9] = [2,2] keypad['*'] = [3,0] keypad[0] = [3,1] keypad['#'] = [3,2] targetPosition = keypad[target] # 타겟의 좌표\rnowPosition = keypad[n]\t# 검사할 손의 좌표\r# 타겟과 검사할 손의 좌표를 y축끼리 x축끼리 빼서 절대값 변환후 더해 반환\rreturn (abs(targetPosition[0] - nowPosition[0]) + abs(targetPosition[1] - nowPosition[1])) def solution(numbers, hand):\ranswer = ''\rleftHand = '*'\rrightHand = '#'\rfor number in numbers : if number in [1,4,7] : #1,4,7이면 결과에 L추가, leftHand 위치 변경\ranswer += 'L'\rleftHand = number\relif number in [3,6,9] : #3,6,9이면 결과에 R추가, rightHand 위치 변경\ranswer += 'R'\rrightHand = number\relse :\rleftDistance = getDistance(leftHand, number); # 타겟과의 L거리\rrightDistance = getDistance(rightHand, number); # 타겟과의 R거리\rif leftDistance \u0026lt; rightDistance or (leftDistance == rightDistance and hand == 'left' ): # 거리가 left가 짧거나 거리가 같은데 왼손잡이인 경우\ranswer += 'L'\rleftHand = number\relif leftDistance \u0026gt; rightDistance or (leftDistance == rightDistance and hand == 'right' ): # 거리가 right가 짧거나 거리가 같은데 오른손잡이인 경우\ranswer += 'R'\rrightHand = number\rreturn answer  Others Solution def solution(numbers, hand):\ranswer = ''\rlocation = [[3, 1], [0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\rleft, right = [3, 0], [3, 2]\rfor i in numbers:\rif i % 3 == 1:\ranswer += 'L'\rleft = location[i]\relif i % 3 == 0 and i != 0:\ranswer += 'R'\rright = location[i]\relse:\rl = abs(location[i][0] - left[0]) + abs(location[i][1] - left[1])\rr = abs(location[i][0] - right[0]) + abs(location[i][1] - right[1])\rif l \u0026lt; r:\ranswer += 'L'\rleft = location[i]\relif l \u0026gt; r:\ranswer += 'R'\rright = location[i]\relse:\ranswer += hand[0].upper()\rif hand == 'right':\rright = location[i]\relse:\rleft = location[i] return answer\r TestCase #solution( [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2], 'left')\r#solution([1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5], \u0026quot;right\u0026quot;)  ","description":"Programmers 키패드 누르기","id":40,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 67256 키패드 누르기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-67256-keypad-press/"},{"content":"Programmers - 42862 체육복 Task description 원문 : Programmers 42862 링크\n 점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.\n  전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.\n Condition   전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.   input output  입출력 예\n    n lost reserve return     5 [2, 4] [1, 3, 5] 5   5 [2, 4] [3] 4   3 [3] [1] 2     입출력 예 설명   예제 #1\n1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.\n  예제 #2\n3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.\n Solution filter()  원하는 조건에 맞는 요소만 리스트로 다시 만들어 주는 함수\nfilter(함수, 리스트)\n   자신이 예비를 가져왔지만, 도둑 맞은경우 제거 - reserve에 해당하지 않는 lost만 _lost로 생성 - lost에 해당하지 않는 reserve만 _reserve 생성 _reserve를 순회하여 옷가져온 학생(r)의 앞 학생(r-1)이 _lost에 해당하는지 확인 - 해당하면 _lost.remove(앞 학생(r-1)) _reserve를 순회하여 옷가져온 학생(r)의 뒤 학생(r+1)이 _lost에 해당하는지 확인 - 해당하면 _lost.remove(뒤 학생(r+1)) 총학생수(n) - 체육복을 못빌린 학생 (len(_lost) )   def solution(n, lost, reserve):\r# 자신이 예비를 가져왔지만, 도둑 맞은경우 제거\r_lost = list(filter(lambda x : x not in reserve, lost))\r_reserve = list(filter(lambda x : x not in lost, reserve))\rfor r in _reserve :\rif r-1 in _lost : # 앞 학생(r-1)이 _lost에 해당하는지\r_lost.remove(r-1)\t# 빌려줌으로 _lost에서 제거\relif r+1 in _lost : # 뒤 학생(r+1)이 _lost에 해당하는지\r_lost.remove(r+1)\t# 빌려줌으로 _lost에서 제거\rreturn n - len(_lost)\r Others Solution def solution(n, lost, reserve):\r_reserve = [r for r in reserve if r not in lost]\r_lost = [l for l in lost if l not in reserve]\rfor r in _reserve:\rf = r - 1\rb = r + 1\rif f in _lost:\r_lost.remove(f)\relif b in _lost:\r_lost.remove(b)\rreturn n - len(_lost)\r TestCase #solution(10, [8,10], [6,7,9])\r#solution(5,\t[2, 4],\t[1, 3, 5])\r#solution(5, [2,3,4] ,[1,2,3])\r#solution(5,\t[2, 4],\t[3])\r#solution(3,\t[3],\t[1])\r ","description":"Programmers 체육복","id":41,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42862 체육복","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42862-gym-suit/"},{"content":"Programmers - 81301 숫자 문자열과 영단어 Task description 원문 : Programmers 81301 링크\n 네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.\n  다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\n 1478 → \u0026quot;one4seveneight\u0026quot;\r234567 → \u0026quot;23four5six7\u0026quot;\r10203 → \u0026quot;1zerotwozero3\u0026quot;\r  이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.\n  참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.\n    숫자 영단어     0 zero   1 one   2 two   3 three   4 four   5 five   6 six   7 seven   8 eight   9 nine    Condition   1 ≤ s의 길이 ≤ 50 s가 \u0026ldquo;zero\u0026rdquo; 또는 \u0026ldquo;0\u0026quot;으로 시작하는 경우는 주어지지 않습니다. return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.   input output    s result     \u0026ldquo;one4seveneight\u0026rdquo; 1478   \u0026ldquo;23four5six7\u0026rdquo; 234567   \u0026ldquo;2three45sixseven\u0026rdquo; 234567   \u0026ldquo;123\u0026rdquo; 123     입출력 예 #1\n문제 예시와 같습니다.\n  입출력 예 #2\n문제 예시와 같습니다.\n  입출력 예 #3\n\u0026ldquo;three\u0026quot;는 3, \u0026ldquo;six\u0026quot;는 6, \u0026ldquo;seven\u0026quot;은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다.\n입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\n  입출력 예 #4 s에는 영단어로 바뀐 부분이 없습니다.\n Solution 배열과 반복문을 이용한 해결   배열에 담는다. (배열인덱스가 0부터 시작이므로 zero 부터 nine 까지 인덱스와 숫자 영단어와 매핑이 된다. 문자열 s를 numbers를 순회하며, 숫자 영단어(numbers[i])의 값을 숫자(str(i)) 값으로 리플레이스   def solution(s):\rnumbers = [\u0026quot;zero\u0026quot;,\u0026quot;one\u0026quot;,\u0026quot;two\u0026quot;,\u0026quot;three\u0026quot;,\u0026quot;four\u0026quot;,\u0026quot;five\u0026quot;,\u0026quot;six\u0026quot;,\u0026quot;seven\u0026quot;,\u0026quot;eight\u0026quot;,\u0026quot;nine\u0026quot;]\rfor i in range(0, len(numbers)) :\rs = s.replace(numbers[i],str(i))\rreturn int(s)\r 배열과 reduce()를 이용한 해결  reduce를 누적 집계 목적으로 사용하는게 일반적이지만, 반복 처리에도 사용가능하다는 것을 배웠다.\n from functools import reduce\rdef solution(s):\rnumbers = [\u0026quot;zero\u0026quot;,\u0026quot;one\u0026quot;,\u0026quot;two\u0026quot;,\u0026quot;three\u0026quot;,\u0026quot;four\u0026quot;,\u0026quot;five\u0026quot;,\u0026quot;six\u0026quot;,\u0026quot;seven\u0026quot;,\u0026quot;eight\u0026quot;,\u0026quot;nine\u0026quot;]\rreturn int(reduce(lambda value, idx : value.replace(numbers[idx], str(idx)), range(len(numbers)) ,s))\r reduce()  reduce(function, iterable(순회 가능한 데이터) [, initializer=None(초기값)])\n 누적 집계를 위해서 사용한다. 파라미터의 function에는2가지 인자가 존재한다. (value(누적대상), element(iterable의 현재 값))    reduce()를 통해 풀수 있다는 것을 다른 사람의 코드로 확인후 풀어보면서, 이해가 안가는 것이 생겨 reduce() 함수를 찾아보게 되었다.\n  reduce(lambda value, idx : formula , [0,1,2\u0026hellip;9], \u0026lsquo;one4seveneight\u0026rsquo;) 여기에서 value와 idx의 값 매핑이 생각했던 것과 달랐다. reduce(lambda a, b : formula , x, y) a는 x, b는 y로 매핑될것 같았지만, a는 y가 b는 x가 매핑되었다. 왜 이런 결과가 나오나 이해가 되지 않아 검색하던 도중 reduce의 코드를 보고 이해가 되었다.\n reduce code link def reduce(function, iterable, initializer=None):\rit = iter(iterable)\rif initializer is None:\t# initializer가 입력이 되지않은 경우\rvalue = next(it) # 첫값을 뽑고 인덱스++\telse:\t# initializer가 입력이된 경우\rvalue = initializer for element in it:\rvalue = function(value, element)\rreturn value\r  reduce의 파라미터중 initializer가 입력이 되지않는 일반적인 경우 function의 첫번째 파라미터는 최초 iterable의 첫번째 값이며, 이후 function의 결과값(누적된 값)이 들어간다.\n  reduce의 파라미터중 initializer가 입력이 되어 있는 경우 function의 첫번째 파라미터는 최초 initializer 값이며, 이후 function의 결과값(누적된 값)이 들어간다.\n  생각했던 lambda a,b: a+b (10,20) 같은 function(10,20)의 파라미터 세팅이 아닌, reduce(lambda a,b: a+b, [0,1,2,\u0026hellip;9],100)의 function(100,0) 파라미터 세팅이였다.\n Others Solution from functools import reduce\rdigit={'zero':'0','one':'1','two':'2','three':'3','four':'4','five':'5','six':'6','seven':'7','eight':'8','nine':'9'}\rdef solution(s):\rreturn int(reduce(lambda ans,d:ans.replace(d,digit[d]),digit.keys(),s))\r TestCase a = [\u0026quot;one4seveneight\u0026quot;, \u0026quot;23four5six7\u0026quot;, \u0026quot;2three45sixseven\u0026quot;, \u0026quot;123\u0026quot;]\rfor i in a :\rsolution(i)\r ","description":"Programmers 숫자 문자열과 영단어","id":42,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 81301 숫자 문자열과 영단어","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-81301-numeric-strings-and-english-words/"},{"content":"Programmers - 64061 크레인 인형 뽑기 Task description 원문 : Programmers 64061 링크\n 게임개발자인 \u0026ldquo;죠르디\u0026quot;는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. \u0026ldquo;죠르디\u0026quot;는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.\n  게임 화면은 \u0026ldquo;1 x 1\u0026rdquo; 크기의 칸들로 이루어진 \u0026ldquo;N x N\u0026rdquo; 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 \u0026ldquo;5 x 5\u0026rdquo; 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 \u0026ldquo;1 x 1\u0026rdquo; 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.\n  만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.\n  크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)\n  게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.\n Condition   board 배열은 2차원 배열로 크기는 \u0026ldquo;5 x 5\u0026rdquo; 이상 \u0026ldquo;30 x 30\u0026rdquo; 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.   input output    board moves result     [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4     입출력 예에 대한 설명 입출력 예 #1\n  인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.\n Solution   크레인의 이동만큼 반복 board의 길이 만큼 반복 move위치의 board를 순서대로 순회해서, 0이 아닌경우 basket이 비어있지 않으면 마지막 값과 board[i][move-1] 값을 비교해서 같다면 - 마지막 값 팝 - 터진 인형의 개수 +2 basket이 비어있지 않으면 마지막 값과 board[i][move-1] 값이 다르면 - basket에 담는다. board[i][move-1] 위치의 값을 0으로 세팅하고, 루프를 나간다.   def solution(board, moves):\ranswer = 0\rbasket = [] # 뽑은 인형을 담을 stack\rfor move in moves :\t# 크레인의 이동만큼 반복\rfor i in range(0, len(board[0])): # board의 길이 만큼 반복\rif board[i][move-1] != 0 : # move위치의 board를 순서대로 순회\rif len(basket) != 0 and basket[-1] == board[i][move-1] : # basket이 비어있지 않으면 마지막 값과 ``board[i][move-1]`` 값이 같다면\rbasket.pop()\t# 마지막 값 팝 answer += 2\t# 터진 인형의 개수 +2\relse :\rbasket.append(board[i][move-1])\t#basket에 담는다.\rboard[i][move-1] = 0\t#``board[i][move-1]`` 위치의 값을 0으로 세팅하고,\rbreak\t# 루프를 나간다.\rreturn answer\r Others Solution def solution(board, moves):\rcols = list(map(lambda x: list(filter(lambda y: y \u0026gt; 0, x)), zip(*board)))\ra, s = 0, [0]\rfor m in moves:\rif len(cols[m - 1]) \u0026gt; 0:\rif (d := cols[m - 1].pop(0)) == (l := s.pop()):\ra += 2\relse:\rs.extend([l, d])\rreturn a\r TestCase solution([[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]], [1,5,3,5,1,2,1,4])\t#4\r ","description":"Programmers 크레인 인형 뽑기","id":43,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 64061 크레인 인형 뽑기","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-64061-crane-puppet-game/"},{"content":"Programmers - 70128 내적 Task description 원문 : Programmers 70128 링크\n 길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.\n  이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + \u0026hellip; + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)\n Condition   a, b의 길이는 1 이상 1,000 이하입니다. a, b의 모든 수는 -1,000 이상 1,000 이하입니다.   input output    a b result     [1,2,3,4] [-3,-1,0,2] 3   [-1,0,1] [1,0,-1] -2     입출력 예 설명\n 입출력 예 #1 a와 b의 내적은 1*(-3) + 2*(-1) + 3*0 + 4*2 = 3 입니다. 입출력 예 #2 a와 b의 내적은 (-1)1 + 00 + 1*(-1) = -2 입니다.   Point  n-1이 나와서 재귀함수로 접근해야하나 싶었지만, 배열 문제에 자주 나오던 람다식으로 시도해보았다.\n 람다  람다는 익명 함수를 한줄의 코드로 선언하여 변수 또는 반환값, 파라미터로 사용하는 코드이다.\n  람다식 - lambda parameter : formula 단독 수행 - lambda parameter : formula (input-value)\n def hap(x,y): return x+y\r  일반 함수로 합을 구하는 공식을 람다식으로 변환하면 아래와같고,\n lambda x,y : x+y (10,20)\r map 함수  map()은 리스트를 받아서 요소(배열의 값)들을 람다식을 적용하여, 새로운 배열로 만들어 반환.\n  리스트 1개 일때 - map(function, list) 리스트 1개 이상 - map(function, list1, list2..)\n   map 함수는 함수와 리스트를 인자로 받음. 리스트의 요소(원소;배열의 값)를 하나씩 꺼내서 함수를 적용. 그 결과를 새로운 리스트에 담아 반환.   a = [1,2,3]\rb = [4,5,6]\rresult = []\rfor i in range(0,len(a)) :\rresult.append(a[i]+b[i])\r  map을 이용하면 위의 복잡한 식을 한줄로 줄일 수 있다.\n list(map(lambda x,y : x+y, [1,2,3],[4,5,6]))\r  여담으로 zip 함수를 이용할 수도 있다.\n result = []\rfor t in list(zip([1, 2, 3], [4, 5, 6])) : result.append(sum(t))\r Solution   배열 a와 b를 map함수로, 배열의 요소 x,y를 서로 곱해서 배열로 반환 배열의 합을 구함   def solution(a, b):\rreturn sum(list(map(lambda x,y : x*y , a,b))) #sum( 생성된 map 배열을 더함\r#\tlist(map(\t# a,b 배열을 받아 각 요소 x,y를 람다식을 수행\r#\tlambda x,y : x*y\t# x,y 를 곱하는 람다식\r# , a,b))\r#)  Others Solution  zip을 이용하여 한줄로 표현할 수 도 있다.\n def solution(a, b):\rreturn sum([x*y for x, y in zip(a,b)])\r  람다를 for 문처럼 사용\n def solution(a, b):\rreturn sum(map(lambda i: a[i]*b[i], range(len(a))))\r TestCase solution([1,2,3,4], [-3,-1,0,2])\rsolution([-1,0,1],\t[1,0,-1])\r ","description":"Programmers 내적","id":44,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 70128 내적","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-70128-inner-product/"},{"content":"Programmers - 42748 K번째 수 Task description 원문 : Programmers 42748 링크\n 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.\n  예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\n  array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.\n Condition   array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다.   input output    array commands return     [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3]    Solution   commands를 순회 command를 얻어 array를 자른다 잘라낸 배열을 정렬한다. 그중 N 번째 수를 결과 배열에 담는다.   def solution(array, commands):\ranswer = []\rfor command in commands : tmp = array[command[0]-1:command[1]]\rtmp.sort()\ranswer.append(tmp[command[2]-1])\rreturn answer\r Others Solution  람다식으로 한줄로 표현 할 수도 있다.\n def solution(array, commands):\rreturn list(map(lambda x:sorted(array[x[0]-1:x[1]])[x[2]-1], commands))\r TestCase solution([1, 5, 2, 6, 3, 7, 4],\t[[2, 5, 3], [4, 4, 1], [1, 7, 3]])\r ","description":"Programmers K번째 수","id":45,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42748 K번째 수","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42748-kth-number/"},{"content":"Programmers - 72410 신규 아이디 추천 Task description 원문 : Programmers 72410 링크\n 카카오에 입사한 신입 개발자 네오는 \u0026ldquo;카카오계정개발팀\u0026quot;에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \u0026ldquo;네오\u0026quot;에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다. 다음은 카카오 아이디의 규칙입니다.\n  아이디의 길이는 3자 이상 15자 이하여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.\n단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\n\u0026ldquo;네오\u0026quot;는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\n신규 유저가 입력한 아이디가 new_id 라고 한다면,\n 1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.\r2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\r3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\r4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\r5단계 new_id가 빈 문자열이라면, new_id에 \u0026quot;a\u0026quot;를 대입합니다.\r6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.\r만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\r7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\r  예를 들어, new_id 값이 \u0026ldquo;\u0026hellip;!@BaT#*..y.abcdefghijklm\u0026rdquo; 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다.\n  1단계 대문자 \u0026lsquo;B\u0026rsquo;와 \u0026lsquo;T\u0026rsquo;가 소문자 \u0026lsquo;b\u0026rsquo;와 \u0026rsquo;t\u0026rsquo;로 바뀌었습니다.\n\u0026quot;...!@BaT#*..y.abcdefghijklm\u0026quot; → \u0026quot;...!@bat#*..y.abcdefghijklm\u0026quot;\n  2단계 \u0026lsquo;!\u0026rsquo;, \u0026lsquo;@\u0026rsquo;, \u0026lsquo;#\u0026rsquo;, \u0026lsquo;*\u0026rsquo; 문자가 제거되었습니다.\n\u0026quot;...!@bat#*..y.abcdefghijklm\u0026quot; → \u0026quot;...bat..y.abcdefghijklm\u0026quot;\n  3단계 \u0026lsquo;\u0026hellip;\u0026lsquo;와 \u0026lsquo;..\u0026rsquo; 가 \u0026lsquo;.\u0026lsquo;로 바뀌었습니다.\n\u0026quot;...bat..y.abcdefghijklm\u0026quot; → \u0026quot;.bat.y.abcdefghijklm\u0026quot;\n  4단계 아이디의 처음에 위치한 \u0026lsquo;.\u0026lsquo;가 제거되었습니다.\n\u0026quot;.bat.y.abcdefghijklm\u0026quot; → \u0026quot;bat.y.abcdefghijklm\u0026quot;\n  5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.\n\u0026quot;bat.y.abcdefghijklm\u0026quot; → \u0026quot;bat.y.abcdefghijklm\u0026quot;\n  6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.\n\u0026quot;bat.y.abcdefghijklm\u0026quot; → \u0026quot;bat.y.abcdefghi\u0026quot;\n  7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.\n\u0026quot;bat.y.abcdefghi\u0026quot; → \u0026quot;bat.y.abcdefghi\u0026quot;\n  따라서 신규 유저가 입력한 new_id가 \u0026ldquo;\u0026hellip;!@BaT#*..y.abcdefghijklm\u0026quot;일 때, 네오의 프로그램이 추천하는 새로운 아이디는 \u0026quot;bat.y.abcdefghi\u0026quot; 입니다.\n  신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, \u0026ldquo;네오\u0026quot;가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.\n Condition   new_id는 길이 1 이상 1,000 이하인 문자열입니다. new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다. new_id에 나타날 수 있는 특수문자는 -_.~!@#$%^\u0026amp;*()=+[{]}:?,\u0026lt;\u0026gt;/ 로 한정됩니다.   input output    no new_id result     예1 \u0026ldquo;\u0026hellip;!@BaT#*..y.abcdefghijklm\u0026rdquo; \u0026ldquo;bat.y.abcdefghi\u0026rdquo;   예2 \u0026ldquo;z-+.^.\u0026rdquo; \u0026ldquo;z\u0026ndash;\u0026rdquo;   예3 \u0026ldquo;=.=\u0026rdquo; \u0026ldquo;aaa\u0026rdquo;   예4 \u0026ldquo;123_.def\u0026rdquo; \u0026ldquo;123_.def\u0026rdquo;   예5 \u0026ldquo;abcdefghijklmn.p\u0026rdquo; \u0026ldquo;abcdefghijklmn\u0026rdquo;    Solution   lower()를 이용한 lowercase 정규식을 이용해 허용되지 않는 특수문자 제거 문자열을 순회하며 이전이 . 인경우 스킵 아닌경우, temp 변수에 추가 문자열 처음과 마지막이 . 이면 삭제 new_id가 빈문자열이면 a로 세팅 new_id 16보다 길면 15자리로 잘라내고, 마지막이 .이면 삭제 new_id 3자리 보다 작으면 마지막 단어로 반복 3까지   import re def solution(new_id):\r#step1 new_id = new_id.lower()\r#step2\rregex = re.compile('(\\~|\\!|\\@|\\#|\\$|\\%|\\^|\\\u0026amp;|\\*|\\(|\\)|\\=|\\+|\\[|\\{|\\]|\\}|\\:|\\?|\\,|\\\u0026lt;|\\\u0026gt;|\\/|)')\rnew_id = regex.sub('', new_id)\r#step3\rstep3 = ''\rfor i in range(0,len(new_id)) :\rif i != 0 and new_id[i] == '.' :\rif(new_id[i-1] != '.') :\rstep3 += new_id[i]\relse : step3 += new_id[i]\rnew_id = step3\r#step4\rif new_id[0] == '.' :\rnew_id = new_id[1:]\rif len(new_id) != 0 and new_id[-1] == '.' :\rnew_id = new_id[:len(new_id)-1]\rnew_id = new_id\r#step5 if new_id == '' :\rnew_id = 'a'\r#step6 if len(new_id) \u0026gt; 15 :\rnew_id = new_id[:15]\rif new_id[-1] == '.' :\rnew_id = new_id[:len(new_id)-1]\r#step7 if len(new_id) \u0026lt; 3 :\rfor i in range(0, 3-len(new_id)) :\rnew_id += new_id[-1]\rreturn new_id\r Other Solution  다른 사람의 풀이를 보고 정규식의 중요성을 배웠다.\n import re\rdef solution(new_id):\rst = new_id\rst = st.lower()\rst = re.sub('[^a-z0-9\\-_.]', '', st)\rst = re.sub('\\.+', '.', st)\rst = re.sub('^[.]|[.]$', '', st)\rst = 'a' if len(st) == 0 else st[:15]\rst = re.sub('^[.]|[.]$', '', st)\rst = st if len(st) \u0026gt; 2 else st + \u0026quot;\u0026quot;.join([st[-1] for i in range(3-len(st))])\rreturn st\r TestCase tests = [\u0026quot;...!@BaT#*..y.abcdefghijklm\u0026quot;, \u0026quot;z-+.^.\u0026quot;,\u0026quot;=.=\u0026quot;, \u0026quot;123_.def\u0026quot;, \u0026quot;abcdefghijklmn.p\u0026quot;]\rfor test in tests :\rsolution(test)\r ","description":"Programmers 신규 아이디 추천","id":46,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 72410 신규 아이디 추천","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-72410-new-id-recommendation/"},{"content":"Programmers - 42576 완주하지 못한 선수 Task description 원문 : Programmers 42576 링크\n 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.\n Condition   마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다.   input output    participant completion return     [\u0026ldquo;leo\u0026rdquo;, \u0026ldquo;kiki\u0026rdquo;, \u0026ldquo;eden\u0026rdquo;] [\u0026ldquo;eden\u0026rdquo;, \u0026ldquo;kiki\u0026rdquo;] \u0026ldquo;leo\u0026rdquo;   [\u0026ldquo;marina\u0026rdquo;, \u0026ldquo;josipa\u0026rdquo;, \u0026ldquo;nikola\u0026rdquo;, \u0026ldquo;vinko\u0026rdquo;, \u0026ldquo;filipa\u0026rdquo;] [\u0026ldquo;josipa\u0026rdquo;, \u0026ldquo;filipa\u0026rdquo;, \u0026ldquo;marina\u0026rdquo;, \u0026ldquo;nikola\u0026rdquo;] \u0026ldquo;vinko\u0026rdquo;   [\u0026ldquo;mislav\u0026rdquo;, \u0026ldquo;stanko\u0026rdquo;, \u0026ldquo;mislav\u0026rdquo;, \u0026ldquo;ana\u0026rdquo;] [\u0026ldquo;stanko\u0026rdquo;, \u0026ldquo;ana\u0026rdquo;, \u0026ldquo;mislav\u0026rdquo;] \u0026ldquo;mislav\u0026rdquo;    Solution   participant 배열을 DICT로 변경 - 키는 선수명, 값은 카운트 - 키가 없으면 1, 키가 있다면 +1 completion를 순회 하며 DICT을 조회 - 선수를 조회하여 카운트 값이 1이면 삭제 - 선수를 조회하여 카운트 값이 1보다 크면 -1 남아있는 선수의 이름을 반환   \rdef solution(participant,completion):\ranswer = ''\rdic = {}\rfor player in participant :\t# participant 배열을 DICT로 변경\rif dic.get(player) is None :\t# 키는 선수명, 값은 카운트\rdic[player] = 1\telse :\rdic[player] += 1\t# 키가 없으면 1, 키가 있다면 +1\rfor player in completion :\t# completion를 순회 하며 DICT을 조회\rif dic[player] == 1 :\t# 선수를 조회하여 카운트 값이 1이면 삭제\rdel(dic[player])\relse :\rdic[player] -= 1\t# 선수를 조회하여 카운트 값이 1보다 크면 -1\rfor k in dic.keys() :\t# 남아있는 선수의 이름을 반환\ranswer = k\rreturn answer\r Other Solution  다른 사람의 풀이를 보고 Counter라는 콜렉션의 함수를 처음 보았다. ~메모~\n from collections import Counter\rdef solution(participant, completion):\ranswer = Counter(participant) - Counter(completion) # Counter로 생성하여 서로 -연산을 통해 남는 카운트를 반환\rreturn list(answer.keys())[0]\r TestCase solution([\u0026quot;leo\u0026quot;, \u0026quot;kiki\u0026quot;, \u0026quot;eden\u0026quot;],\t[\u0026quot;eden\u0026quot;, \u0026quot;kiki\u0026quot;]) # \u0026quot;leo\u0026quot;\rsolution([\u0026quot;marina\u0026quot;, \u0026quot;josipa\u0026quot;, \u0026quot;nikola\u0026quot;, \u0026quot;vinko\u0026quot;, \u0026quot;filipa\u0026quot;], [\u0026quot;josipa\u0026quot;, \u0026quot;filipa\u0026quot;, \u0026quot;marina\u0026quot;, \u0026quot;nikola\u0026quot;]) # \u0026quot;vinko\u0026quot;\rsolution([\u0026quot;mislav\u0026quot;, \u0026quot;stanko\u0026quot;, \u0026quot;mislav\u0026quot;, \u0026quot;ana\u0026quot;], [\u0026quot;stanko\u0026quot;, \u0026quot;ana\u0026quot;, \u0026quot;mislav\u0026quot;]) #\u0026quot;mislav\u0026quot;\r ","description":"Programmers 완주하지 못한 선수","id":47,"section":"blog","tags":["Algorithm","CodingTest","Programmers"],"title":"Programmers 42576 완주하지 못한 선수","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/programmers/202107/programmers-42576-players-who-did-not-finish/"},{"content":"BAEKJOON - 4949 균형잡힌 세상 Task description 원문 : 백준 4949 링크\n메시지를 입력받아 괄호를 열고 닫아야 한다.\n 열고 닫는 괄호가 균형 맞게 되어있으면 yes 아니면 no 출력\n ex) asd(b)dd(d[ddd]) yes ex) (asdasd] no 메시지의 끝은 .으로 끝나고 메시지가 \u0026ldquo;.\u0026rdquo; 이면 종료   Condition   모든 왼쪽 소괄호(\u0026quot;(\u0026quot;)는 오른쪽 소괄호(\u0026quot;)\u0026quot;)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(\u0026quot;[\u0026quot;)는 오른쪽 대괄호(\u0026quot;]\u0026quot;)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 하나 또는 여러줄에 걸쳐서 문자열이 주어진다. 각 문자열은 영문 알파벳, 공백, 소괄호(\u0026quot;( )\u0026quot;) 대괄호(\u0026quot;\u0026quot;)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다. 7번째의 \u0026quot; .\u0026ldquo;와 같이 괄호가 하나도 없는 경우도 균형잡힌 문자열로 간주할 수 있다. 입력의 종료조건으로 맨 마지막에 점 하나(\u0026rdquo;.\u0026quot;)가 들어온다.   input output 예제 입력 1 So when I die (the [first] I will see in (heaven) is a score list).\r[ first in ] ( first out ).\rHalf Moon tonight (At least it is better than no Moon at all].\rA rope may form )( a trail in a maze.\rHelp( I[m being held prisoner in a fortune cookie factory)].\r([ (([( [ ] ) ( ) (( ))] )) ]).\r.\r.\r예제 출력 1 yes\ryes\rno\rno\rno\ryes\ryes\r Solution   메시지가 \u0026ldquo;.\u0026rdquo; 이면 종료 메시지가 \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;[\u0026rsquo; 이면 스택에 추가   \rwhile True : msg = input()\rif msg == '.' :\t# \u0026quot;.\u0026quot; 이면 종료\rbreak\rfront = []\t# 스택 생성\rflag = True # .이나오기 전에 조건에 만족(균형) X 면 False\rfor i in range(0, len(msg)) :\tif msg[i] == '.' : if len(front) == 0 and flag: # 스택이 모두 pop되고, 조건에 만족(균형) 하면 yes\rprint('yes')\relse : print('no')\relif msg[i] == '(' or msg[i] == '[' : # 메시지가 '(' 또는 '[' 이면 스택에 추가\rfront.append(msg[i])\relif (msg[i] == ')' or msg[i] == ']') and len(front) == 0 : # 괄호를 안열고, 닫으려 할때 flag = False\relif msg[i] == ')' : # )가 나왔을때 if front[-1] == '(' :\t# 스택 마지막이 ( 였다면 팝\rfront.pop()\relse :\rflag = False\t# 스택 마지막이 [ 으로 조건에 만족(균형) no\relif msg[i] == ']' :\t# ]가 나왔을때 if front[-1] == '[' : # 스택 마지막이 [ 였다면 팝\rfront.pop()\relse : flag = False\t# 스택 마지막이 ( 으로 조건에 만족(균형) no\r TestCase \r ","description":"백준 균형잡힌 세상","id":48,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 4949 균형잡힌 세상","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-4949-a-balanced-world/"},{"content":"BAEKJOON - 1541 잃어버린 괄호 Task description 원문 : 백준 1541 링크\n +와 -그리고 괄호를 가진 식에서 괄호를 모두 지웠다. 그리고 나서 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n Condition   첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다. 첫째 줄에 정답을 출력한다.   input output 예제 입력 1 55-50+40\r예제 출력 1 -35\r Solution   +와 -그리고 숫자들을 배열에 넣는다. 첫번째 - 이후 +는 괄호로 묶는다 (- (A + B) 랑 -A-B 와 같으므로 +여도 -로 계산한다.)   message = input() # 입력받은 메시지\rformula = [] # 공식 배열 (숫자,+,-)\rvalue = \u0026quot;\u0026quot;\t# 쪼개진 숫자 문자열로 조합\rflag = False # +를 -로 계산할지 여부 (첫 -가 나왔는지 여부)\rresult = 0\t# 결과값\rfor i in range(0,len(message)) :\t# +와 -그리고 숫자들을 배열에 넣는다.\rif message[i] == \u0026quot;+\u0026quot; or message[i] == \u0026quot;-\u0026quot; :\tformula.append(int(value))\t# +, -가 나오면 그전까지의 value를 숫자로 바꿔 formula 배열에 넣는다\rvalue=\u0026quot;\u0026quot;\rformula.append(message[i])\t# + or - 를 formula 배열에 추가\relif i ==len(message)-1 :\rvalue += message[i]\t# 마지막 인덱스인경우 value를 숫자로 바꿔 formula 배열에 넣는다\rformula.append(int(value))\telse :\t# 숫자는 value에 추가\rvalue += message[i]\rfor i in range(0,len(formula)) :\rif formula[i] == \u0026quot;+\u0026quot; or formula[i] == \u0026quot;-\u0026quot; :\rif(formula[i] == \u0026quot;-\u0026quot;) :\rflag = True\relse :\rif flag == False :\rresult += formula[i] else :\rresult -= formula[i] print(result)\r TestCase  ","description":"백준 잃어버린 괄호 ","id":49,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 1541 잃어버린 괄호 ","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-1541-lost-parenthesis/"},{"content":"BAEKJOON - 10828 스택 Task description 원문 : 백준 10828 링크\n 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\n  명령은 총 다섯 가지이다.\n  push X: 정수 X를 스택에 넣는 연산이다. pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 스택에 들어있는 정수의 개수를 출력한다. empty: 스택이 비어있으면 1, 아니면 0을 출력한다. top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\n Condition   첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.   input output 14\rpush 1\rpush 2\rtop\rsize\rempty\rpop\rpop\rpop\rsize\rempty\rpop\rpush 3\rempty\rtop\r예제 출력 1 복사\r2\r2\r0\r2\r1\r-1\r0\r1\r-1\r0\r3\r예제 입력 2 복사\r7\rpop\rtop\rpush 123\rtop\rpop\rtop\rpop\r예제 출력 2 복사\r-1\r-1\r123\r123\r-1\r-1\r Solution import sys\rclass Stack :\t# 클래스 생성\rdef __init__(self) :\rself.elements = []\t# 스택의 엘리먼츠 추가\rdef push(self, x) :\tself.elements.append(x)\t# x를 스택에 추가\rdef empty(self) :\t# 엘리먼츠의 길이(사이즈)가 0 이면 1 if len(self.elements) == 0 : print(1)\rreturn 1\relse :\rprint(0)\rreturn 0\rdef pop(self) :\tif len(self.elements) == 0 : #비어있는 경우 -1\rprint(-1)\relse :\rself.top()\rself.elements.pop()\rdef size(self) :\rprint(len(self.elements))\rreturn len(self.elements)\rdef top(self) :\rif len(self.elements) == 0 :\rprint(-1)\relse :\rprint(self.elements[-1])\r#n = int(input())\rn = int(sys.stdin.readline().rstrip())\rs = Stack()\rfor i in range(0,n) :\rinput_split = sys.stdin.readline().rstrip().split()\rcommand = input_split[0]\r#command = str(input())\rif 'pop' == command.lower() :\rs.pop()\relif 'size' == command.lower() :\rs.size()\relif 'top' == command.lower() :\rs.top()\relif 'empty' == command.lower() :\rs.empty()\relif 'push' == command.lower() :\rs.push(input_split[1])\r TestCase  ","description":"백준 스택","id":50,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 10828 스택","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-10872-stack/"},{"content":"BAEKJOON - 10872 팩토리얼(Factorial) Task description 원문 : 백준 10872 링크\n 0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.\n Condition   첫째 줄에 정수 N(0 ≤ N ≤ 12)가 주어진다.   input output 예제 입력 1 복사\r10\r예제 출력 1 복사\r3628800\r예제 입력 2 복사\r0\r예제 출력 2 복사\r1\r Solution  0이면 1리턴 0이 아니면 N * factorial(N-1) 리턴 # N * (N-1)!\n def factorial(N): if ( N != 0) :\rreturn N * factorial(N-1) #N * (N-1)!\relse :\rreturn 1\rN = int(input())\rfn = factorial(N)\rprint(fn)\r TestCase  ","description":"백준 팩토리얼","id":51,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 10872 팩토리얼","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-10872-factorial/"},{"content":"dimsom / dumplings (\u0026lsquo;딤섬 / 만두\u0026rsquo;) ingredient (\u0026lsquo;재료, 성분\u0026rsquo;)  a. What ingredients do you need to make a 김치찌개?\n grocery (\u0026lsquo;식료품, 식자재 / 식료품점\u0026rsquo;)  I need to go to the grocery (store). / I need to buy some groceries.\n ingredient 와 grocery   ingredient는 요리 뿐만 아니라 만드는 모든 것의 재료 grocery는 음식을 만들때의 재료   I had A on B . (\u0026lsquo;B에 A가 있었습니다.')  I had a P.T. on Wednesday. (수요일에 PT가 있었습니다.) I had a haircut on Tuesday. (화요일에 머리를 잘랐었습니다.)\n I had/ate A at the B. (\u0026lsquo;B에서 A를 먹었습니다.')  I had fried chicken at the company. (나는 회사에서 후라이드 치킨을 먹었습니다.) I ate dinner at the company. (나는 회사에서 저녁을 먹었습니다.)\n I enjoy trying out A (\u0026lsquo;나는 A를 즐긴다\u0026rsquo;)  I enjoy trying out new exercise (나는 새로운 운동을 즐깁니다.) I enjoy trying out new foods. (나는 새로운 음식을 즐깁니다.) I enjoy trying out new menus / dishes. (나는 새로운 메뉴/요리를 시도하는 것을 즐깁니다.)\n leek (\u0026lsquo;부추\u0026rsquo;) sesame oil (\u0026lsquo;참기름\u0026rsquo;) I prefer A (\u0026lsquo;나는 A를 선호한다.')  I prefer shopping (groceries) online (나는 온라인 쇼핑(식료품)을 선호한다)\n when I need it at the moment. (\u0026lsquo;지금 내가 필요할 때\u0026rsquo;) I bought A and it was really good. (\u0026lsquo;A 샀었는데 정말 좋았습니다.')  I bought grocery beef for steak and it was really good.\n Grammar Error: I was Tuesday. → I had a haircut on Tuesday. I was eat chicken at company. → I had/ate fried chicken at the company.\rI try delivery new restaurants. → I enjoy trying out new delivery restaurants/foods. / I enjoy trying out new restaurants on the delivery app.\rI enjoy trying out new menus / dishes.\rI like online stores, like Market Kurly, but I sometimes use supermarkets or local stores when I’m busy. → I prefer shopping (groceries) online ~ when I need it at the moment.\rI bought grocery beef for steak and it was really good. → I bought a beef steak at Market Kurly and ~.  New expressions learned today: ingredient 재료 / grocery 식료품, 식자재 / 식료품점\rI need to go to the grocery (store). / I need to buy some groceries.\ra. What _ingredients_ do you need to make a 김치찌개?\rb. I went out to buy some _groceries_ because we didn’t have anything to eat.\rfrozen ready-made food → ready meal\rdimsom / dumplings\rI like (__) the best. = (___) is my favorite frozen/instant food. = My favorite ready meal is (___). leek (green onion, spring onion), garlic\r열려라 참깨! Open Sesame! → sesame oil 참기름\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":52,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.07.08","uri":"https://offetuoso.github.io/blog/english/202107/20210708-english-speak/"},{"content":"BAEKJOON - 11729 하노이 탑 이동 순서(Hanoi Tower Travel Order) Task description 원문 : 백준 11729 링크\n 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 아래서 부터 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라.\n  아래 그림은 원판이 5개인 경우의 예시이다.\n Condition   한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. 이동 횟수는 최소가 되어야 한다.   input output 예제 입력 1 복사\r3\r예제 출력 1 복사\r7\r1 3\r1 2\r3 2\r1 3\r2 1\r2 3\r1 3\r Solution   첫번째 봉에 있는 1~n-1 까지의 원반을 두번째 봉에 옮김 첫번째 봉에 있는 n 원반을 세번째 봉에 옮김 세번째 봉에 있는 1~n-1 까지의 원반을 세번째 봉에 옮김   def hanoi(n, first, second ,third) :\rif n == 1 :\rresult.appthird(str(first)+' '+str(third)) # n이 1까지 재귀로 호출되면 결과 배열에 담음\relse : hanoi(n-1, first, third, second) # first에서 n-1의 모든 원반을 second로 모두 옮김, 임시 경유는 third\rhanoi(1, first, second, third)\t# first에서 third로 마지막(N번째) 원반을 third로 옮김, 임시 경유는 second\rhanoi(n-1, second, first, third) # second에 있는 n-1의 모든 원반을 third로 옮김, 임시 경유는 first\rresult = []\rn = int(input())\rhanoi(n, 1, 2, 3) # hanoi(옮길 원반수, 1번 봉, 2번 봉, 3번 봉)\rprint(len(result))\rfor item in result :\rprint(item)\r TestCase  ","description":"백준 하노이 탑 이동 순서","id":53,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 11729 하노이 탑 이동 순서","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-11729-hanoi-tower-travel-order/"},{"content":"BAEKJOON - 2941 크로아티아 알파벳(Croatian Alphabet) Task description 원문 : 백준 2941 링크\n 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n    크로아티아 알파벳 변경     č c=   ć c-   dž dz=   đ d-   lj lj   nj nj   š s=   ž z=      예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.   Condition   dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.   input output 예제 입력 1 ljes=njak\r예제 출력 1\r6\r예제 입력 2\rddz=z=\r예제 출력 2\r3\r예제 입력 3\rnljj\r예제 출력 3\r3\r예제 입력 4\rc=c=\r예제 출력 4\r2\r예제 입력 5\rdz=ak\r예제 출력 5\r3\r Solution    입력 변경     dz= 0\t(dž)   z= 1 (ž)   d- 2 (đ)   c= 3 (č)   c- 4 (ć)   nj 5 (nj)   s= 6 (š)   lj 7 (lj)     알파벳과 -, = 만 입력이 이루어 지기 때문에 1자리의 다른 문자열로 치환(숫자) , 순서는 dz=가 z= 보다 먼저 배열에 들어가 있어야 한다. 자리수를 센다.\n msg = input() # 케이스 입력받음\rcroatian = ['dz=','z=','d-','c=','c-','nj','s=','lj'] #크로아티아 문자열 배열, 치환할 우선순위에 맞게 배열 생성\rfor i in range(0,len(croatian)) :\rmsg = msg.replace(croatian[i], str(i)) #크로아티아 문자열을 배열 인덱스로 변환\rprint(len(msg)) #길이 출력\r TestCase ljes=njak #6\rddz=z= #3\rnljj #3\rc=c= #2\rdz=ak #3\r ","description":"백준 크로아티아 알파벳","id":54,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2941 크로아티아 알파벳","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2941-croatian-alphabet/"},{"content":"Lombok @Data 어노테이션 \u0026ldquo;getter\u0026rdquo; \u0026ldquo;setter\u0026rdquo; 인식 안될때 문제  Spring Boot에서 프로젝트 생성시 아래와 같이 lombok을 추가하고 데이터 오브젝트 클래스에서 lombok 선언을 하였음에도, 컨트롤러에서 @RequestBody를 통해 Company company 객체를 전달받았을때, 데이터가 세팅이 안되고 Null로 데이터가 있는 경우가 있었다.\n  찾아보니, 사용하는 lombok-xxx.jar를 실행하여 IDE(eclipse, sts)에 설치 해줘야 한다는 것이다.\n 해결책   Jar가 설치된 위치로 가서 Terminal을 연다.    Jar를 실행시킨다.   \tjava -jar [jar 파일.jar]\r  lombok 설치화면이 뜬다.    specify location(위치 지정) 클릭    설치할 IDE 선택    설치완료    ini 파일 확인   해당 체크한 부분이 있는지 확인한다. lombok이 설치되고 경로를 추가해준다. ini가 수정이 안된경우 해당 내용을 넣어 수정해준다.   -javaagent: [lombok.jar 경로] (C:\\develop\\Files\\IDE\\sts-4.8.1.RELEASE\\lombok.jar)\r  IDE 재시작 Project \u0026gt; clean   참조 Lombok is not generating getter and setter \n","description":"Lombok @Data 어노테이션 문제","id":55,"section":"blog","tags":["Troubleshooting"],"title":"Lombok @Data 어노테이션 getter setter 인식 안될때","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/spring/lombok-error/"},{"content":"BAEKJOON - 2798 블랙잭(black jack) Task description 원문 : 백준 2798 링크\n  첫번째 줄은 카드의 (장)수 N과 블랙잭 넘버(목표 값) M을 입력받는다. 두번째 줄은 공백으로 구분된 N장의 카드 입력받는다. M이 넘지 않는 3장의 합중 가장 큰 경우 출력.   Condition   첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.   input output 예제 입력 1 5 21\r5 6 7 8 9\r예제 출력 1 21\r예제 입력 2 10 500\r93 181 245 214 315 36 185 138 216 295\r예제 출력 2 497\r Solution  완전탐색 (Brute-Force) 문제로 경우의 수를 모두 찾아본다.\n 같은 배열을 자리수 만큼 반복 이전에 나온것은 사용하지 않는다.   n, m = map(int, input().split())\rnumbers = list(map(int, input().split()))\rresult = 0\rfor i in numbers :\rfor j in numbers :\rif i != j :\t# 첫번째에서 선택한 값이 아닌것 for k in numbers :\rsum = i+j+k\rif i != k and j != k and sum \u0026lt;= m: #첫번째 두번째에서 선택한 값이 아닌것이며, i,j,k의 값이 sum을 넘지 않는것\rresult = max(sum,result) # 그 중에 가장 큰 값\rprint(result)\r TestCase #n, m = 5, 21\r#numbers = [5, 6, 7, 8, 9]\r#n, m = 10, 500\r#numbers = [93, 181, 245, 214, 315, 36, 185, 138, 216, 295]\r ","description":"백준 블랙잭","id":56,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2798 블랙잭","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2798-black-jack/"},{"content":"BAEKJOON - 1712 손익분기점(break even point) Task description 원문 : 백준 1712 링크\n 노트북 제조하는데 노트북 판매 대수에 상관없이 A만원의 고정 비용이 든다.\n한 대의 노트북을 생산하는 데에는 B만원의 가변 비용이 든다\nA=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며,\n열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다.\n생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다. 첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.   input output 예제 입력 1 1000 70 170\r예제 출력 1 11\r예제 입력 2 3 2 1\r예제 출력 2 -1\r예제 입력 3 2100000000 9 10\r예제 출력 3 2100000001\r Solution  일단 하나씩 계산해서 손익분기점을 찾아보았으나.. 시간초과에 걸린다.\n a, b, c = map(int, input().split())\rqty = 0\rif(c \u0026lt; 2):\rprint(-1)\rexit()\relse :\rwhile True :\rqty += 1\rformula1 = a + (b*qty)\rformula2 = (c*qty)\rif(formula1 \u0026lt; formula2):\rprint(formula2)\rbreak\r  루프 없이 어떻게 계산을 해야할까 고민하다 가변, 판매단가만 곱했을때 변하는것을 보고 판매단가 - 가변비용를 생각하였다.\n a, b, c = map(int, input().split())\rif(b \u0026gt;= c):\t# 가변비용이 판매단가와 같거나 크면, 아무리 수량을 늘려도 손익분기점에 도달하지 못한다\rprint(-1)\relse :\rprint((a//(c-b))+1) # (고정비/(단가-가변비용)) +1 (+1를 추가되어 손익분기점이 됨)\r   TestCase \r ","description":"백준 손익분기점","id":57,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 1712 손익분기점","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-1712-break-even-point/"},{"content":"BAEKJOON - 7576 토마토(tomato) Task description  철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.\n  창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.\n  토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.\n  입력 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 토마토가 하나 이상 있는 경우만 입력으로 주어진다.\n  출력 여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.\n Condition   토마토가 하나 이상 있는 경우만 입력으로 주어진다. 2 ≤ M,N ≤ 1,000   input output 예제 입력 1 6 4\r0 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 1\r예제 출력 1 8\r예제 입력 2 6 4\r0 -1 0 0 0 0\r-1 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 1\r예제 출력 2 -1\r예제 입력 3 6 4\r1 -1 0 0 0 0\r0 -1 0 0 0 0\r0 0 0 0 -1 0\r0 0 0 0 -1 1\r예제 출력 3 6\r예제 입력 4 5 5\r-1 1 0 0 0\r0 -1 -1 -1 0\r0 -1 -1 -1 0\r0 -1 -1 -1 0\r0 0 0 0 0\r예제 출력 4 14\r예제 입력 5 2 2\r1 -1\r-1 1\r예제 출력 5 0\r Solution \rfrom collections import deque\rdx = [-1, 1, 0, 0]\rdy = [0, 0, -1, 1]\rdef bfs() :\rresult = 0\rwhile queue :\ra, b = queue.popleft()\rfor i in range(4) :\rx = a + dx[i]\ry = b + dy[i]\rif 0 \u0026lt;= x \u0026lt; N and 0 \u0026lt;= y \u0026lt; M and graph[x][y] == 0 :\rqueue.append([x,y])\rgraph[x][y] = graph[a][b] + 1\rresult = max(graph[a][b], result)\rreturn result\rM, N = map(int, input().split())\rqueue = deque([])\rgraph = []\rfor i in range(N) :\rgraph.append(list(map(int, input().split())))\rfor j in range(M) :\rif graph[i][j] == 1 :\rqueue.append([i,j])\rr = bfs() for i, j in enumerate(graph) :\rif 0 in j :\rr = -1\rbreak\rprint(r)\r TestCase \r ","description":"백준 토마토","id":58,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 7578 토마토","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-7578-tomato/"},{"content":"BAEKJOON - 2606 미로(maze) Task description  N×M크기의 배열로 표현되는 미로가 있다.\n1\t0\t1\t1\t1\t1\n1\t0\t1\t0\t1\t0\n1\t0\t1\t0\t1\t1\n1\t1\t1\t0\t1\t1\n  미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.\n  위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.\n Condition input 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.\n4 6\r101111\r101010\r101011\r111011\r output 15\r Solution n, m = map(int, input().split())\rqueue = []\rmatrix = []\rfor i in range(n):\rmatrix.append(list(input()))\rqueue = [[0, 0]]\rmatrix[0][0] = 1\rdx = [+1, -1, 0, 0]\rdy = [ 0, 0, -1, +1] #상하좌우\rwhile queue :\ra,b = queue[0][0],queue[0][1]\rdel queue[0]\rfor i in range(4):\rx = a + dx[i]\ry = b + dy[i]\rif 0 \u0026lt;= x \u0026lt; n and 0 \u0026lt;= y \u0026lt; m and matrix[x][y] == \u0026quot;1\u0026quot; : queue.append([x,y])\rmatrix[x][y] = matrix[a][b] + 1\rprint(matrix[n - 1][m - 1])\r TestCase \r ","description":"백준 미로","id":59,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2178 미로","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2178-maze/"},{"content":"BAEKJOON - 2606 바이러스(virus) Task description  신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.\n  예를 들어 7대의 컴퓨터가 \u0026lt;그림 1\u0026gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.\n  어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.\n  입력\n첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.\n  출력\n1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.\n Condition   1 번 컴퓨터가 탐색 시작 노드이다. 1 \u0026lt;= N \u0026gt;= 100 (컴퓨터의 수) M (네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수)   input 7\r6\r1 2\r2 3\r1 5\r5 2\r5 6\r4 7\r output 4\r Solution   1부터 10001까지 모든 숫자 조회 숫자를 문자로 바꿔 저장 no는 자기자신의 값 i로 세팅 숫자의 자리수 만큼 반복 자리수의 숫자를 no에 더해줌 생성된 d(n) 값을 self dict에 추가 1 ~ 10001 까지의 숫자중 dict에 없는 숫자만 출력   from collections import deque\rN = int(input()) # 컴퓨터의 갯수\rM = int(input()) # 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수\r# 그래프 생성\rgraph = [[] for i in range(N+1)] # 0부터 N까지의 배열 (0은 사용안함)\rfor i in range(0,M) : # 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수만큼 반복\rK = list(map(int, input().split()))\t# 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍\rgraph[K[0]].append(K[1])\t# 그래프에 연결 추가\rgraph[K[1]].append(K[0]) # 반대의 경우도 연결 추가\r# 방문을 체크할 배열 생성\rvisited = [False for i in range(N+1)] # 방문 안한것으로 0~N까지의 배열 생성 (0은 사용 안함)\rqueue = deque() # 큐 생성\rcount = 0 # 결과 (1번 컴퓨터로 인해 바이러스 감염된 컴퓨터의 수)\rstart = 1 # 탐색 시작 컴퓨터 1\rqueue.append(start)\t# 큐에 추가\rvisited[start] = True\t# 1번 컴퓨터 방문처리\rwhile queue : # 큐의 데이터가 있는 동안\ridx = queue.popleft() # 검사할 컴퓨터의 번호를 팝\r#print(idx) # BFS 출력 하지만 문제\rif idx != start : # 탐색 시작 노드 1이 아닌것\rcount += 1\t# 1번 컴퓨터로 인해 감염된 컴퓨터 카운트\rfor node in graph[idx]: # 검사할 컴퓨터의 인접노드(graph[idx])의 연결된 인접 컴퓨터(노드) 만큼\rif not visited[node] : # 방문한 컴퓨터가 아닌 경우\rqueue.append(node)\t# 큐에 추가\rvisited[node] = True # 방문처리\rprint(count) # 결과 출력 (1번 컴퓨터로 인해 바이러스 감염된 컴퓨터의 수)\r  최초 함수로 코딩했으나, 백준에서는 함수를 사용하면 오답처리가 되었다.\n \rfrom collections import deque\rdef bfs(graph, start ,visited) :\rcount = 0\rqueue = deque()\rqueue.append(start)\rvisited[start] = True\rwhile queue :\ridx = queue.popleft()\r#print('pop',idx)\rif idx != start :\rcount += 1\rfor node in graph[idx]:\rif not visited[node] :\rqueue.append(node)\rvisited[node] = True\rreturn count\rN = int(input())\rM = int(input())\rgraph = [[] for i in range(N+1)]\rfor i in range(0,M) :\rK = list(map(int, input().split()))\rgraph[K[0]].append(K[1])\rgraph[K[1]].append(K[0])\rvisited = [False for i in range(N+1)]\r#print (graph,'\\n', visited)\rbfs(graph,1,visited)\r TestCase 예제 입력 7\r6\r1 2\r2 3\r1 5\r5 2\r5 6\r4 7\r예제 출력 4\r ","description":"백준 셀프 넘버","id":60,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2606 바이러스","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2606-virus/"},{"content":"너비 우선 탐색 알고리즘 BFS (Breadth-First Search)  BFS는 너비 우선 탐색이라고 부르며, 시작 위치에서 가까운 노드부터 우선적으로 탐색하는 알고리즘이다.\n  BFS는 큐 자료구조를 이용하며, 구체적인 동작 과정은 아래와 같다.\n   탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복함.     그래프를 준비하고, 시작 노드는 1로 BFS를 시작한다. (번호가 낮은 인접 노드부터 방문)    시작 노드인 \u0026lsquo;1\u0026rsquo;을 큐에 삽입하고 방문 처리를 한다.    큐에서 노드 \u0026lsquo;1\u0026rsquo;을 꺼내 방문하지 않은 인접 노드 \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;8\u0026rsquo;을 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;2\u0026rsquo;를 꺼내 방문하지 않은 인접 노드 \u0026lsquo;7\u0026rsquo;을 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;3\u0026rsquo;을 꺼내 방문하지 않은 인접 노드 \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;를 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;8\u0026rsquo;을 꺼내고 방문하지 않은 인접 노드가 없으므로 무시한다.    큐에 남아있는 \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;을 꺼낸다.    이러한 과정을 반복하여 전체 노드의 탐색 순서는 다음과 같다.\n 1 2 3 8 7 4 5 6  BFS 소스코드 예제 (Python)  아래 소스는 노드를 2차원 배열로 생성하여 [0]은 비워두고, 인덱스 별로 배열로 인접 노드를 정의함. 예를들어, graph[1] = [2, 3, 8] 로 1번 노드에 인접한 2, 3 8로 구성된다.\n from collections import deque\r# BFS 함수 정의\rdef bfs(graph, start, visited):\r# 큐(Queue) 구현을 위해 deque 라이브러리 사용\rqueue = deque()\r# 시작 노드(1)를 큐에 넣고, 방문 처리\rqueue.append(start)\rvisited[start] = True\r# 큐가 빌 때까지 반복\rwhile queue :\r# 큐에서 하나의 원소를 뽑아 출력\rv = queue.popleft()\rprint(v, end=' ') # print()의 기본 옵션중 end=' '를 통해 개행하지 않고 옆으로 출력을 붙인다.\r# 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입\rfor i in graph[v]:\rif not visited[i] :\rqueue.append(i)\rvisited[i] = True\rpass\r# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)\rgraph = [\r[],\r[2, 3, 8],\r[1, 7],\r[1, 4, 5],\r[3, 5],\r[3, 4],\r[7],\r[2, 6, 8],\r[1, 7]\r]\r# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)\rvisited = [False] * 9\r# 정의된 BFS 함수 호출\rbfs(graph, 1, visited)\r 참고   파이썬(Python) 기초 print ( )문의 옵션 (sep , end , format , Escape )          ","description":"bfs 탐색 알고리즘.","id":61,"section":"blog","tags":["Algorithm"],"title":"너비 우선 탐색 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/search/bfs/bfs-algorithm/"},{"content":"I have worked A (\u0026lsquo;나는 A에서 일했었습니다\u0026rsquo;)  Eight years ago, I have worked in a buffet. I served foods and cleaned the rooms. (나는 8년전에 뷔페에서 일했습니다. 나는 음식을 제공하고 방을 청소했습니다.)\n really/quite tough (\u0026lsquo;정말/꽤 힘들다\u0026rsquo;)  it was really/quite tough but fun at the same time. (매우/꽤 힘들었지만, 동시에 재미있었습니다.)\n I worked with A (\u0026lsquo;나는 A와 함께 일했다\u0026rsquo;)  because I worked with my friends. (왜냐하면, 나의 친구들과 같이 일했기 때문이다)\n be 동사 + V-ing (\u0026lsquo;V 하는중이다\u0026rsquo;)  I am working right now. (나는 일하는 중이다.)\n  I was hanging out with my friends. (나는 친구들과 어울리고 있었다.)\n I met A (\u0026lsquo;나는 A를 만났다\u0026rsquo;)  I met good friends there. (\u0026lsquo;나는 그곳에서 좋은 친구들을 만났다\u0026rsquo;)\n I was A and [sub-topic] (나는 A 였고, [sub-topic] 이였습니다.)  I was a student and got a part-time job for weekends. (저는 학생이었고 주말에 아르바이트를했습니다.)\n  I was a child and liked to joke (저는 어렸었고, 장난을 좋아했습니다.)\n I worked there on weekends while I was a student and even after I graduated/after I got a full-time job.   저는 학생 시절 주말에 일했고 졸업 후에도 정규직을 얻은 후에도 그곳에서 일했습니다.)\n I first started working there when I was a student, but kept working on weekends even after I got a full-time job  학생 시절부터 일을 시작했는데 정규직을 잡은 후에도 주말에도 계속 일했습니다.)\n don’t enjoy going to buffets because of their low-quality food, but I like the lunch buffets of the family restaurants, like Outback or VIPs.   음식의 질이 낮기 때문에 뷔페에가는 것을 좋아하지 않지만 아웃백이나 VIP 같은 패밀리 레스토랑의 점심 뷔페는 좋아합니다.')\n Just because (\u0026lsquo;그냥\u0026rsquo;) because + 문장  because you are beautiful. (당신은 아름다우니까요.)\n because of + 단어/절  because of your money. (당신의 돈 때문에요.)\n Grammar Error: Eight years ago, I was worked 뷔페, serve and cleaned rooms. → Eight years ago, I have worked in a 돌잔치 buffet. I served steaks (foods) and cleaned the rooms.\rIt was so tough and fun → It was really/quite tough but fun (at the same time).\rIt was so tough, (that) I quit.\rbecause working with friends → because I worked with my friends.\rbe 동사 + V-ing (I am working right now. / I was hanging out with my friends.)\rI was + meet good friends → I met good friends there.\rI was a student and got a job to work on weekends. → I was a student and got a part-time job for weekends.\r→ I worked there on weekends while I was a student and even after I graduated/after I got a full-time job.\r→ I first started working there when I was a student, but kept working on weekends even after I got a full-time job (I became ~).\rI don’t enjoy buffet because of their food, but I like franchise restaurants’ lunch buffet, like Outback. → I don’t enjoy going to buffets because of their low-quality food, but I like the lunch buffets of the family restaurants, like Outback or VIPs.\r New expressions learned today: because + 문장 because you are beautiful. because of + 단어/절 because of your money.\rJust because. 그냥\rA: Why do you like skateboarding?\rB: Just because. It’s fun.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":62,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.07.01","uri":"https://offetuoso.github.io/blog/english/202107/20210701-english-speak/"},{"content":"백준 4673 Self Number Task description  문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n  양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n  예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.\n  33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...\r  n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.\n  생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다.\n 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97\r  10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.\n Condition   10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.   input  없음\n output 1\r3\r5\r7\r9\r20\r31\r42\r53\r64\r|\r| \u0026lt;-- a lot more numbers\r|\r9903\r9914\r9925\r9927\r9938\r9949\r9960\r9971\r9982\r9993\r Solution   1부터 10001까지 모든 숫자 조회 숫자를 문자로 바꿔 저장 no는 자기자신의 값 i로 세팅 숫자의 자리수 만큼 반복 자리수의 숫자를 no에 더해줌 생성된 d(n) 값을 self dict에 추가 1 ~ 10001 까지의 숫자중 dict에 없는 숫자만 출력   \rself = {} #dist 생성\rfor i in range(1, 10001) : # 1 ~ 10000 까지\rsNo = str(i)\t# 숫자를 문자열로 변경\rno = i # 자기 자신을 세팅하여, \u0026lt;mark\u0026gt;33\u0026lt;/mark\u0026gt; + 3 + 3 = 39 부분을 처리\rfor j in range(0,len(sNo)) :\t# 반복문으로 자리수 마다 no에 더해주며, 33 \u0026lt;mark\u0026gt;+ 3 + 3\u0026lt;/mark\u0026gt; = 39 부분을 처리\rno += int(sNo[j])\rself[no] = no # 생성된 값을 dist에 추가\rfor i in range(1, 10001) :\t# 1 ~ 10000까지 숫자중 if self.get(i) is None :\t# d(n)를 통하여 생성되지 않은 숫자를 찾음\rprint(i)\t# self number 출력\r TestCase  ","description":"백준 셀프 넘버","id":63,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 4673 셀프 넘버","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/self-number/"},{"content":"백준 8958 ox quiz Task description  \u0026ldquo;OOXXOXXOOO\u0026quot;와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.\n  \u0026ldquo;OOXXOXXOOO\u0026quot;의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.\n  OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.   input 5\rOOXXOXXOOO\rOOXXOOXXOO\rOXOXOXOXOXOXOX\rOOOOOOOOOO\rOOOOXOOOOXOOOOX\r output 10\r9\r7\r55\r30\r Solution   입력 받은 N 만큼 케이스를 입력받아 반복한다. 케이스를 입력받고 길이만큼 반복한다. 점수(score)와 더해줄 값(addition)을 0으로 초기화 한다. 케이스를 문자열로 변경하고 문자열 하나씩 슬라이스하여 str에 저장. str의 값을 비교하여 1. O인경우, addition을 1 증가시키고 score에 addition을 더해준다. 2. X인경우, addition을 0 으로 초기화 시킨다. 케이스의 마지막 str일때 score를 출력한다.   n = int(input()) # 입력받을 케이스 갯수\rfor i in range(n): # 입력받은 수 만큼 반복\rcase = input()\t# 케이스 입력받음 ex) OOXXOXXOOO\rscore = 0\t# 케이스의 점수\raddition = 0\t# 점수에 더해지는 값\rfor j in range(0,len(case)):\t# 케이스의 길이 만큼 len(OOXXOXXOOO)\rstr = case[j] # 케이스를 인덱스로 1개씩 순회\rif str == 'O' :\t# O인경우 addtion 1증가 score에 addtion 더함\raddition +=1\rscore += addition else : # X인경우 addtion 0으로 초기화\raddition = 0\rif j == len(case) -1 :\t# 케이스의 마지막 str인 경우 score 출력\rprint(score)\r TestCase 5\rOOXXOXXOOO\rOOXXOOXXOO\rOXOXOXOXOXOXOX\rOOOOOOOOOO\rOOOOXOOOOXOOOOX\r ","description":"백준 OX 퀴즈","id":64,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 8958 OX 퀴즈","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/ox-quiz/"},{"content":"PermCheck  Codility - Lesson4 - Counting Elements - PermCheck\n Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다.\n순열은 1부터 N까지의 각 요소를 한 번만 포함하는 시퀀스입니다. 예를 들어 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\rA [3] = 2\r  순열이지만 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\r  값 2가 없기 때문에 순열이 아닙니다.\n  목표는 배열 A가 순열인지 확인하는 것입니다.\n  배열 A가 주어지면 배열 A가 순열이면 1을 반환하고 그렇지 않으면 0을 반환합니다.\n예를 들어 다음과 같은 배열 A가 있습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\rA [3] = 2\r  함수는 1을 반환해야합니다. 주어진 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\r  함수는 0을 반환해야합니다.\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . def solution(A) N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수 입니다.   Solution   조건1 배열 A는 순열 [1 \u0026hellip; N] 배열 A를 오름 정렬한다 1. A.sort() 2. N = A[-1] ( A.sort()후 A[-1]은 배열의 최대값)    SUM(A)는 는 순열 A 배열의 합 B(비교대상) = N*(N+1)//2 (수열의 합 공식; 1 ~ N 까지의 합)    SUM(A) == B 는 배열의 합과 수열의 합 공식이 맞는지 비교 1. solution[9, 5, 7, 3, 2, 7, 3, 1, 10, 8] 의 경우 합이 55가 되며, B와 같다. 이를 해결하기 위해서 중복된 숫자를 제거\nA = list(set(A)) 2. set을 통해 중복제거 시 [1,1] 의 경우 문제가 생긴다. 중복제거후 [1],과 1*(1+1)//2 는 1로 통과가 되는 논리적 오류가 발생한다. 이를 해결하기 위해 중복 제거하기 전 A배열의 길이와 N값과 비교한다. 예를 들어, [1,2,3,4] 1부터 4까지의 수열이 있다면 길이와 마지막 숫자는 같을 수 밖에 없으므로 length = N   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\rlength = len(A) # 중복 제거하기 전 A배열의 길이\rA = list(set(A))\t# 중복제거\rA.sort()\t# 정렬\rN = A[-1]\t# A의 제일 큰 수\rB = N*(N+1)//2\t# 수열의 합의 공식\rif sum(A) == B and length == N : # 배열 A와 수열의 합이 공식이 같고, 중복 제거하기 전 A배열의 길이와 N의 값이 같은지 체크\rreturn 1\relse :\rreturn 0\rpass\r#solution([4,1,3,2])\r#solution([2,2,8])\r#solution([9, 5, 7, 3, 2, 7, 3, 1, 10, 8])\r#solution([1,1])\r  시간 복잡성 O(N) or O(N * log(N))\n TestCase #solution([4,1,3,2])\r#solution([2,2,8])\r#solution([9, 5, 7, 3, 2, 7, 3, 1, 10, 8]) \u0026lt;\u0026lt; 순열이 아닌경우\r#solution([1,1]) \u0026lt;\u0026lt; 순열이 아닌경우2 (중복제거 해도 문제)\r ","description":"PermCheck","id":65,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - PermCheck","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-check/"},{"content":"백준 2839 설탕배달 Task description  상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n  상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\n  상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)   input output    case input ouput     1 18 4   2 4 -1   3 6 2   4 9 3   5 11 3    Solution   5로 최대한 나눈다. 5로 나누어 몫이 0인경우, 0이 아닌경우로 나누어진다. 1. 5로 나누어 몫이 0인경우 5의 배수이므로 5로 나눈 값(division) 이 결과 5로 나누어 몫이 아닌경우 1. 5로 나눌수 없고(값이 0) 3으로 나누어 떨어지지 않는경우 -1 이 결과 2. 5로 나눈 몫을 3으로 나누어 몫이 0인 경우 5로 나눈 값(division)와 5로 나눈 몫을 3으로 나눈 값(quotient//3)을 더한 값이 결과 ; 3. 5로 나눈 몫을 3으로 나누어 몫이 0이 아닌경우 1~ 5로 나눈 값 까지 루프를 생성 1. 5로 나눈것을 1단계씩 되돌려, 3으로 나누어 몫이 0으로 나누어 떨어지는 값 찾으면, (division-i)+(quotient+(5*i)) 이 값 2. 끝까지 못찾았을때 -1이 결과   N = int(input())\rdivision = N//5 # 5로 나눈 값\rquotient = N%5 # 5로 나눈 몫\rresult = 0\rif quotient == 0 : # 5로 나누어 떨어지면 result = division # 5로 나눈 값이 결과\relse : # 5로 나누어 몫이 남는 경우\rif division == 0 and not N % 3 == 0 :\t# 5로 나눌수 없고(값이 0) 3으로 나누어 떨어지지 않는경우 -1 이 결과\rresult = -1\relif quotient%3 == 0 : # 5로 나눈 몫을 3으로 나누어 몫이 0인 경우 \u0026lt;mark\u0026gt;5로 나눈 값(division)와 5로 나눈 몫을 3으로 나눈 값(quotient//3)을 더한 값이 결과\rresult = division\rresult += quotient // 3\relse :\t# 5로 나눈 몫을 3으로 나누어 몫이 0이 아닌경우\rfor i in range(1, division+1) : # 1~ 5로 나눈 값 까지 루프\rif (quotient+(5*i)) %3 == 0 :\t# 5로 나눈것을 1단계씩 되돌려, 3으로 나누어 몫이 0으로 나누어 떨어지는 값 찾으면, (division-i)+(quotient+(5*i)) 이 값\rresult = (division-i) result += (quotient+(5*i)) // 3\rbreak\relse :\rif i == division :\t# 끝까지 못찾았을때 -1이 결과\rresult = -1\rbreak\rprint(result)\r TestCase 18 #4\r4 #-1\r6 #2\r9 #3\r11 #3\r ","description":"백준 설탕배달","id":66,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2839 설탕배달","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/sugar-delivery/"},{"content":"MaxCounter  Codility - Lesson4 - Counting Elements - MaxCounter\n Task description  처음에는 0으로 설정된 N 개의 카운터가 제공되며 두 가지 가능한 작업이 있습니다.\n  증가 (X) -카운터 X가 1 증가합니다. 최대 카운터 -모든 카운터는 모든 카운터의 최대 값으로 설정됩니다. M 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 이 배열은 연속 작업을 나타냅니다.\n  A [K] = X, 즉 1 ≤ X ≤ N이면 연산 K는 증가 (X), A [K] = N + 1이면 작업 K는 최대 카운터입니다. 예를 들어, 정수 N = 5이고 배열 A가 다음과 같은 경우 :\n  A [0] = 3 A [1] = 4 A [2] = 4 A [3] = 6 A [4] = 1 A [5] = 4 A [6] = 4\r  각 연속 작업 후 카운터 값은 다음과 같습니다.\n  (0, 0, 1, 0, 0) (0, 0, 1, 1, 0) (0, 0, 1, 2, 0) (2, 2, 2, 2, 2) (3, 2, 2 , 2, 2) (3, 2, 2, 3, 2) (3, 2, 2, 4, 2)\r  목표는 모든 작업 후 모든 카운터의 값을 계산하는 것입니다.\n  정수 N과 M 개의 정수로 구성된 비어 있지 않은 배열 A가 주어지면 카운터 값을 나타내는 정수 시퀀스를 반환합니다. 결과 배열은 정수 배열로 반환되어야합니다. 예를 들면 다음과 같습니다.\n  A [0] = 3 A [1] = 4 A [2] = 4 A [3] = 6 A [4] = 1 A [5] = 4 A [6] = 4\r  함수는 위에서 설명한대로 [3, 2, 2, 4, 2]를 반환해야합니다.\n Condition   def solution(N, A) 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. N + 1 ] 범위 내의 정수 입니다.   Solution  이번 문제 풀이의 핵심은 increase(X) 보다, max counter를 루프를 돌지 않고 해결하는가 였습니다. 카운트는 0부터 값을 세지만, max counter 이후에는 max counter 시점의 최대 카운트 값부터 다시 카운트를 세고, max counter 시점의 최대 카운트 값을 모든 배열에 적용 후 각각의 카운트 값(다시 카운트를 센 카운트 값)을 더해주면 루프 없이 해결할 수 있습니다.\n   count라는 딕셔너리를 생성 배열 A를 루프로 선회하며, 값은 X (A[K])    increase(X) 기능 (1 \u0026lt;= X \u0026lt;= N 일때) \u0026gt; - count에 키가 X인 딕셔너리가 없으면 0으로 생성 \u0026gt; - count1증가 \u0026gt; - max_count(현재 최대 카운트) 값 구함    1 \u0026lt;= X \u0026lt;= N 아닌 ( N+1 == X) 경우 \u0026gt; - max counter 실행시 최대 카운트 세팅 \u0026gt; - 모든 count 값 삭제 \u0026gt; - 현재 최대 카운트 값 0으로 초기화    N개의 요소를 가지는 결과 배열을 max_value(max counter 실행시 최대 카운트) 값으로 생성 count 딕셔너리로 루프 \u0026gt; - max_value 부터 추가된 count의 값 결과 배열 result[X-1]에 세팅 # -1 은 인덱스 번호로 변경 0~ X-1   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(N, A):\rcount = {}\rmax_count = 0 # 현재 최대 카운트 값\rmax_value = 0 # max counter 이후에는 max counter 시점의 최대 카운트 값\rfor X in A :\rif 1 \u0026lt;= X \u0026lt;= N : # increase(X) 기능 (1 \u0026lt;= X \u0026lt;= N 일때)\rif count.get(X) is None :\t# count에 키가 X인 딕셔너리가 없으면 0으로 생성\rcount[X] = 0\rcount[X] += 1\t# count[X] 1증가\rmax_count = max(count[X], max_count) # 현재 최대 카운트 값 구함 else : # max counter 기능 (N+1 == X인 경우)\rmax_value += max_count\t# max counter 실행시 최대 카운트 세팅 count.clear()\t# 모든 count 값 삭제\rmax_count = 0\t# 현재 최대 카운트 값 0으로 초기화\rresult = [max_value] * N # N개의 요소를 가지는 결과 배열을 max_value(max counter 실행시 최대 카운트) 값으로 생성\rfor X, value in count.items() :\rresult[X-1] += value\t# max_value 부터 추가된 count[X]의 값 결과 배열 result[X-1]에 세팅 # -1 은 인덱스 번호로 변경 0~ X-1\rreturn result\r  시간 복잡성 O(N + M)\n TestCase solution(5,[3,4,4,6,1,4,4])\r ","description":"MaxCounter","id":67,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - MaxCounter","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/max-counter/"},{"content":"샤딩(Sharding) Database의 샤딩(Sharding)이란?  같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미.\n 샤딩은 수평 분할(Horizontal Partitioning)과 동일. 테이블의 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위함. application level에서도 가능하지만 database level에서도 가능.   수평 분할 (horizotal partitioning, Range Based Partitioning)  샤딩과 동일한 의미를 가지며 스키마를 다수의 복제본을 구성하고 각각의 샤드에 샤드키를 기준으로 데이터를 분리하는 것을 말한다. DBA가 데이터의 패턴과 저장공간을 잘 알고 샤드키를 선정하여 분할한다.\n    id Name Age     1 Bob 27   3 Alice 23   5 Dennis 20   7 Miller 24       id Name Age     2 Sago 29   4 Riley 30   6 Wilson 18   8 Brown 25    샤딩의 장점과 단점 장점   수평적 확장 horizontal scaling (=scaling out)이 가능하다: 서버의 하드웨어(RAM, CPU 등)를 업그레이드하는 수직적 확장과 다르게, 존재하는 stack에 machine을 추가하는 방식으로 능력을 향상시킬 수 있다. 쿼리 반응 속도를 빠르게 한다: 스캔 범위를 줄이기 때문!\n application을 신뢰할 수 있게 만든다: 서버 다운 등 생겼을 때, un-sharded 데이터베이스와 다르게 단일 shard에만 영향을 줄 확률이 높다. application이 일부라도 작동할 수 있도록 위험을 완화시켜준다.   단점   잘못 사용했을 때 risk(데이터 손상, 유실 등)가 크다. 데이터가 한 쪽 shards에 쏠려 sharding이 무의미 해질 수 있다. 한 번 쪼개게 되면, 다시 un-sharded 구조로 돌리기 어렵다. 모든 데이터베이스 엔진에서 natively support 되지 않는다.   샤딩시 고려사항   데이터 재분배   샤딩을 진행 한 DB의 물리적인 용량한계와 성능한계가 왔을 경우 적절하게 shard수를 scale-up 작업을 늘릴 수 있도록 설계해야한다. (확장고려)    샤딩으로부터 데이터 조인   샤딩된 데이터베이스간에 조인이 불가능하기 때문에 어느정도의 데이터 중복은 감안해야 한다.    파티셔닝 잘 구현하기   샤딩의 기준이되는 샤드키를 잘 정하거나 hash의 경우 함수를 잘 선택해야 한다.    샤드된 DBMS들의 트랜잭션 문제   XA와 같은 Global Transaction을 사용하면 샤딩된 데이터베이스간에 트랜잭션이 가능하나 성능저하의 문제가 있다.    Global Unique Key   샤딩에 경우 DBMS에서 제공하는 auto-increment를 사용하면 key가 중복될 가능성이 있기 때문에 application 레벨에서 key 생성을 담당해야 한다.    데이터 축소   Table 단위를 가능한 작게 만들자.   샤딩(Sharding) 구성시 고려할 문제   샤딩 알고리즘 : 정수값 등으로 샤딩을 처리할 때 데이터의 비율 고려 샤딩 데이터 조회 : 분산된 Database에서 Data를 어떻게 읽을 것인가 데이터 재분배 : 서비스 정지 없이 데이터베이스 스키마 및 서버 설계 필요 샤딩 조인 : 역정규화를 어느정도 감수해야 함   샤딩(Sharding) 방법  Shard Key를 어떻게 정의하느냐에 따라 데이터를 분산시키는 방법이 결정됩니다.\n range-based sharding  주어진 value의 범위를 기반으로 데이터를 나누는 샤딩 방법입니다. 예를 들어 연도 컬럼을 이용하여 데이터를 나눌수 있습니다. 이 방식을 이용하면 몇몇 개의 shard를 만들고 범위에 연도에 따라 데이터를 저장할 수 있습니다.\n    hiredate Name Age     1981 Bob 27   1982 Alice 23   1983 Dennis 20   1985 Miller 24       hiredate Name Age     2001 Sago 29   2005 Riley 30   2007 Wilson 18   2009 Brown 25       hiredate Name Age     2011 Oh 32   2012 Kim 33   2017 Park 24   2021 Lee 42    장점  가장 큰 장점은 실행이 비교적 간단하다는 것이다. 모든 shard들은 다른 데이터를 가지고 있고, original 데이터베이스 뿐 아니라 서로가 똑같은 스키마를 가지게 된다. application code는 그저 데이터가 어떤 범위인지 읽고 그에 상응하는 shard에 쓰면 된다.\n 단점  반면, 데이터베이스를 골고루 분배하지는 못하기 때문에 앞서 말한 데이터베이스 hotspots가 생길 수 있다. 위 그림 상으로는 모든 shard들이 같은 양의 데이터를 가지고 있지만, 특정 데이터가 다른 데이터에 비해 더 많이 찾아질 수 있기 때문에 읽는 횟수가 불균형할 수 있다.\n hash based sharding  다른 말로 Key Based Sharding, modulus-based sharding이라고도 불린다. 키와 같은 값을 해쉬함수(Hash)에 넣어 나오는 값으로 서버를 지정하는 방식\n  hash 함수는 고객 이메일과 같은 데이터 조각을 Input으로 받아, hash value라는 완전히 다른 형태의 value를 Ouput으로 내보낸다. sharding의 관점에서 봤을 때 hash value는 들어오는 데이터가 저장될 shard를 결정하는 shard ID가 될 것이다.\n shard key  올바른 shard에 일관성 있는 방식으로 들어갈 수 있도록 entry를 위치시키기 위해, hash 함수에 들어가는 value들은 같은 column에서 나와야 한다. 이 colum을 shard key라고 부른다.\n   각 행을 위한 고유 식별자를 생성한다는 측면에서 shard keys는 primary keys(pk)와 비슷하다. 넓게 본다면, shard key는 정적이어야 하고 시간에 따라 바뀌어서는 안 된다. 그렇지 않으면 업데이트에 필요한 작업이 증가하고 퍼포먼스를 느리게할 수 있다.   단점  key based sharding이 많이 쓰이긴 하지만, 데이터베이스에 서버를 동적으로 추가하거나 제거할 때 어려울 수 있다. 서버를 추가할 때 각각의 서버는 그에 상응하는 hash value가 있어야 하고, 존재하는 많은 entry들은 맞는 hash value에 다시 매핑되고, 적합한 서버에 migrate 되어야 한다. 데이터를 rebalancing하는 것을 시작한다면 새로운 hash 함수 뿐 아니라 예전 hsah 함수도 유효하지 않게 된다. 결과적으로 migration을 하는 동안 애플리케이션은 새로운 데이터를 쓰지 못하고, 쉴 수밖에 없다.\n 장점  이 전략의 가장 큰 장점은 hotspots를 방지하기 위해 데이터를 골고루 분배할 수 있고, 알고리즘적으로 분배하기 때문에 range나 directory와 다르게 모든 데이터가 어디에 위치하는지 말해주는 map을 가질 필요가 없다.\n Directory Based Sharding  파티셔닝 매커니즘을 제공하는 추상화된 서비스 생성. 이 sharding을 실행하기 위해서는 반드시 어떤 shard가 어떤 데이터를 갖고 있는지를 추적할 수 있는 shard key를 사용하는 lookup table을 만들고 유지해야 한다.\n lookup table  간단히 말하면 특정 데이터를 찾을 수 있는(where specific data can be found) 정적인 정보를 갖고 있는 테이블이다.\n  Delivery Zone 열은 shard key로 정의된다. shard key로부터 온 데이터는 각각의 행이 어떤 shard에 쓰여져야 하는지를 lookup 테이블과 함께 쓰여진다. range based sharding과 비슷해 보이지만, 범위를 기준으로 shard key의 데이터를 내려주는 것과 다르게 각 키들은 각자 자신만의 특별한 shard에 들어가게 된다.\n 어떤 상황에서 쓸지  해당 방법은 shard key가 낮은 cardinality를 가질 때 좋은 선택이다. hash 함수를 거치지 않기 때문에 key based sharding과도 다르다. 그저 lookup table에서 key를 보고 어디에 데이터를 쓸지 결정하는 것 뿐이다.\n 장점  유연성(flexibility)이다. range based sharding은 범위에 국한되고, key based sharding은 만들고 난 뒤 바꾸기 매우 어려운 hash 함수에 국한된다. 반면 directory based sharding은 데이터를 쪼개기 위한 entry들은 어떤 시스템이나 알고리즘에 상관 없이 entry를 할당할 수 있도록 해준다. 동적으로 shard를 추가하는 것도 비교적 쉽다.\n 단점  반면 쿼리하거나 write하기 전에 lookup table에 연결이 필요하기 때문에, application 퍼포먼스에 안 좋은 영향(detrimental impact)을 줄 수 있다. 게다가 lookup table은 실패 지점이 될 수 있다. lookup table이 손상되면 데이터를 새로 쓰거나 존재하는 데이터에 접근하는 것에 영향을 줄 수 있기 때문이다.\n 참조   MySQL Shard 데이터 재분배 Database sharding이란? Database의 샤딩(Sharding)이란? 파티셔닝의 정의와 종류 그리고 샤딩   ","description":"샤딩 ","id":68,"section":"blog","tags":["Database","Sharding","manage"],"title":"샤딩(Sharding)","uri":"https://offetuoso.github.io/blog/develop/database/tech/sharding/"},{"content":"AWS RDS RDS 서비스 생성  AWS Management Console에서 RDS 접속\n RDS 데이터베이스 인스턴스 생성  RDS에 MySQL 인스턴스를 생성한다.\n  데이터베이스 생성 클릭\n  데이터베이스 생성\n 표준 생성 원하는 데이터베이스 선택    Mysql 버전 선택과 템플릿 설정\n Mysql Community Mysql 버전 선택 - MySQL 5.7.22 템플릿 선택 -    DB 인스턴스 설정\n 인스턴스명 추가 DB에 접근할 계정 정보 입력    DB 인스턴스 크기\n  DB 인스턴스 크기\n 스토리지 자동조정 해제 - 체크 해두면 자동 스토리지 증설로 인한 요금부과가 될 수 있습니다.    연결 설정\n 추가 연결 구성 클릭후 펼치기    외부 연결을 위한 퍼블릭 액세스 수정 - 예    데이터베이스 생성\n  생성된 데이터베이스 인스턴스 확인  파라미터 그룹 추가  데이터베이스의 문자 인코딩 관련 파라미터를 UTF-8로 설정을 한다.\n  왼쪽 메뉴 파라미터 그룹 - 파라미터 그룹 생성\n  파라미터 그룹 생성\n 생성한 MySQL 버전을 선택 - 잘못 선택되면 파라미터 그룹 선택 창에서 보이지 않음 파라미터 정보 추가    생성된 파라미터 그룹명 클릭\n  파라미터 인코딩 수정\n cha 검색    1.1. utf8 선택 가능한 것들 모두 수정\n  col 검색    2.1. utf8 선택 가능한 것들 모두 수정\n  생성된 데이터베이스 인스턴스 수정\n  생성한 파라미터 그룹 선택\n  데이터베이스 인스턴스 수정\n 수정 예약 - 즉시 적용    수정중\n 보안 설정 (인바운스)  외부에서 접속이 안되는 경우 확인 해봐야 할것\n 연결 - 퍼블릭액세스 (예) 보안 - 인바운스 규칙    데이터베이스 - 인스턴스 - 수정\n  인바운스 default 클릭\n  보안그룹 클릭\n  인바운스 규칙 편집\n  인바운스 규칙 저장\n DBeaver 연결  연결 생성\n  Server 정보 추가\n   Server Host는 생성한 RDS의 엔드포인트 입력   RDS 왼쪽 메뉴 데이터베이스 - 인스턴스 - 연결및 보안    연결 완료\n End ","description":"AWS RDS를 이용한 Mysql","id":69,"section":"blog","tags":["AWS","RDS","MySQL"],"title":"AWS RDS에 MySQL 인스턴스 생성 후 연결","uri":"https://offetuoso.github.io/blog/develop/database/mysql/aws-rds-mysql/"},{"content":"FrogRiverOne  Codility - Lesson4 - Counting Elements - FrogRiverOne\n Task description  은 개구리가 강 건너편으로 가고 싶어합니다. 개구리는 처음에 강의 한 둑 (위치 0)에 있으며 반대쪽 둑 (위치 X + 1)에 도달하려고합니다. 잎은 나무에서 강 표면으로 떨어집니다.\n  엽을 나타내는 N 개의 정수로 구성된 배열 A가 제공됩니다. A[K]는 초 단위로 측정 된 시간 K에서 한 잎이 떨어지는 위치를 나타냅니다.\n  는 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 찾는 것입니다. 개구리는 잎이 1에서 X까지 강 건너 모든 위치에 나타날 때만 건널 수 있습니다 (즉, 1에서 X까지의 모든 위치가 잎으로 덮여있는 가장 빠른 순간을 찾고 싶습니다). 강의 흐름 속도가 무시할 정도로 작다고 가정 할 수 있습니다. 즉, 잎이 강에 떨어지면 위치가 바뀌지 않습니다.\n  예를 들어, 다음과 같은 정수 X = 5 및 배열 A가 제공됩니다.\n  A [0] = 1\rA [1] = 3\rA [2] = 1\rA [3] = 4\rA [4] = 2\rA [5] = 3\rA [6] = 5\rA [7] = 4\r  번째 6에서는 잎이 위치 5로 떨어집니다. 이것은 잎이 강 건너 모든 위치에 나타나는 가장 빠른 시간입니다.\n  N 개의 정수와 X로 구성된 비어 있지 않은 배열 A가 주어지면 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 반환합니다. 개구리가 강 반대편으로 점프 할 수없는 경우 함수는 −1을 반환해야합니다.\n  예를 들어, 주어진 X = 5이고 배열 A는 다음과 같습니다.\n  A [0] = 1\rA [1] = 3\rA [2] = 1\rA [3] = 4\rA [4] = 2\rA [5] = 3\rA [6] = 5\rA [7] = 4\r  함수는 위에서 설명한대로 6을 반환해야합니다.\n Condition   def solution(X, A) 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . N 및 X는 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. X ] 범위 내의 정수 입니다.   Solution   total = sum(range(X+1)) chked = [None for i in range(X)] # 체크 배열을 None으로 초기화 하여 생성 루프로 A를 순회 if( chked[A[i]-1] == None) : #체크 배열에 값이 없는지 체크 4-1. chked[A[i]-1]에 A[i] 세팅 4-2. chk_sum에 A[i]을 합함 if total == chk_sum : #   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, A):\rtotal = sum(range(X+1))\t# 1~X 까지의 합을 생성\rchked = [None for i in range(X)] # 체크 배열을 None으로 초기화 하여 생성\rchk_sum = 0\rfor i in range(len(A)) :\rif( chked[A[i]-1] == None) : # 체크 배열에 값이 없는지 체크\rchked[A[i]-1] = A[i]\rchk_sum += A[i]\rif total == chk_sum : # total과 chk_sum같다면 모든 1~X까지 찾은 상태이므로 현재의 i를 반환\rreturn i\rif total != chk_sum :\t# total과 chk_sum 다르다면 1~X까지의 찾은 숫자중에 나오지 않은 수가 있는것 return -1\r  시간 복잡성 O(N)\n TestCase solution(5, [1,3,1,4,2,3,5,4])\r ","description":"FrogRiverOne","id":70,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - FrogRiverOne","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/frog-river-one/"},{"content":"Tape Equilibrium  Codility - Lesson3 - Time Complexity - TapeEquilibrium\n Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 0 \u0026lt;P \u0026lt;N 인 정수 P는이 배열 A를 두 부분으로 분할합니다 (A [0], A [1], \u0026hellip;, A [P − 1] 및 A [P], A [ P + 1], \u0026hellip;, A [N-1]) 분할 된 두 부분의 차이는 다음의 값입니다. | (A [0] + A [1] + \u0026hellip; + A [P − 1]) − (A [P] + A [P + 1] + .. . + A [N − 1]) | 즉, 첫 번째 부분의 합과 두 번째 부분의 합 사이의 절대 차이입니다. 달성 할 수있는 최소 차이를 반환합니다.\n  예를 들어, 다음과 같은 배열 A가 제공됩니다.\n  A [0] = 3\rA [1] = 1\rA [2] = 2\rA [3] = 4\rA [4] = 3\r  이 테이프들을 4곳으로 나눌 수 있습니다.\n   P = 1, 차이 = | 3 − 10 | = 7 # A[0] ///// A[1] A[2] A[3] A[4] P = 2, 차이 = | 4 − 9 | = 5 # A[0] A[1] ///// A[2] A[3] A[4] P = 3, 차이 = | 6 − 7 | = 1 # A[0] A[1] A[2] ///// A[3] A[4] P = 4, 차이 = | 10 − 3 | = 7 # A[0] A[1] A[2] A[3] ///// A[4]    N 정수의 비어 있지 않은 배열 A가 주어지면 달성 할 수있는 최소 차이를 반환합니다.\n  A [0] = 3\rA [1] = 1\rA [2] = 2\rA [3] = 4\rA [4] = 3\r  함수는 위에서 설명한대로 1을 반환해야합니다.\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오. N은 [ 2 .. 100,000 ] 범위 내의 정수 이고; 배열 A의 각 요소는 [ -1,000 .. 1,000 ] 범위 내의 정수 입니다.   Solution 시도 1  루프를 1번만 사용했지만, sum() 함수를 루프 안에서 처리 했더니 O(N * N)의 시간 복잡도가 나오게 되었다.\n def solution(A):\rminimum = 99999\rfirst = 0;\rfor i in range(0,len(A)-1) :\rfirst += A[i]\rminimum = min(minimum, abs(first-(sum(A)-first)))\rreturn minimum\r  시간 복잡성 O(N * N)\n 시도 2 # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\rminimum = 99999 # 가작작은 차이 값\rfirst = 0; # 첫번째 테이프 그룹\rtotal = sum(A) # A배열 전체의 합\rfor i in range(0,len(A)-1) :\rfirst += A[i] # A[0]~A[i]까지의 합\rsecond = total - first #first를 제외한 나머지 테이프의 합\rminimum = min(minimum, abs(first - second)) #첫번째 그룹의 합과 두번째 그룹의 합의 차이중 가장작은것\rreturn minimum\r  시간 복잡성 O(N)\n TestCase solution([3,1,2,4,3])\r ","description":"Tape Equilibrium","id":71,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - TapeEquilibrium","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/tape-equilibrium/"},{"content":"Perm Missing Elem  Codility - Lesson3 - Time Complexity - PermMissingElem\n Task description  배열 A는 1 ~ N+1의 범위의 정수를 담고 있는 배열이며 1 ~ N+1의 정수중 1개의 숫자(요소)가 빠져있다.\n  예를 들면 다음과 같습니다.\n  A[0] = 2\rA[1] = 3\rA[2] = 1\rA[3] = 5\r  1~5까지의 숫자중 4가 빠져 있기 때문에 4를 반환\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오. N은 [ 0 .. 100,000 ] 범위 내의 정수입니다. A의 요소는 모두 구별됩니다. 배열 A의 각 요소는 [1 .. (N + 1)] 범위 내의 정수입니다.   Solution   N은 배열의 길이+1 (인덱스가 0부터 시작하기 때문에 +1) Sum(range(N+1)) - Sum(A) (1 ~ N+1 까지의 합) - (배열의 요소의 합) = 1 부터 N+1 까지의 숫자중 빠진 수   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, Y, D):\rN = len(A)+1\rreturn sum (range(N+1)) - sum(A)\rpass\r  시간 복잡성 O(N) or O(N * log(N))\n TestCase  ","description":"PermMissingElem","id":72,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - PermMissingElem","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-missing-elem/"},{"content":"Frog Jmp  Codility - Lesson3 - Time Complexity - Frog Jmp\n Task description  세 개의 정수 X, Y, D를 입력받는 함수를 작성합니다.\n X는 개구리의 위치 Y는 개구리의 목표 위치 Y는 개구리의 이동거리 위치 X에서 D씩 최소의 이동을 하여 목표를 Y에 도달하거나 넘어가기 위하여 이동하는 최소 횟수 반환    예를 들면 다음과 같습니다.\n  X = 10\rY = 85\rD = 30\r  개구리는 다음과 같이 위치하므로 함수는 3을 반환해야합니다.\n  첫 번째 점프 후 위치 10 + 30 = 40\r두 번째 점프 후 위치 10 + 30 + 30 = 70\r세 번째 점프 후 위치 10 + 30 + 30 + 30 = 100\r Condition   def solution(X, Y, D) X, Y 및 D는 [ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 . X ≤ Y. 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 .   Solution   Y == X 이 경우 개구리가 뛸 필요가 없기 때문에 0을 반환 (이 테스트 케이스를 생각하지 못해서 틀렸었다.)    Y-X = (목표위치 - 시작위치 =남은 거리) (Y-X) % D == 0 (\u0026ldquo;남은 거리 // D가 0으로 떨어지는지 나머지가 있는지 조건\u0026rdquo;) True(나머지 0) : (Y-X) // D False(나머지 0아님) : ((Y-X) // D) + 1   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, Y, D):\rif (Y == X) :\rreturn 0\rreturn (Y-X) % D == 0 and (Y-X) // D or ((Y-X) // D) + 1 pass\r  시간 복잡성 O(1)\n TestCase solution(10, 75, 30)\rsolution(2, 2, 1)\rsolution(1, 101, 10)\r ","description":"Frog Jmp","id":73,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Frog Jmp","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-frog-jmp/"},{"content":"RESTful API - Docker의 Mysql과 Mybatis 연동 Docker  Docker에 Mysql을 올리는 것은 저번 포스팅에서 진행하였기 때문에 도커에 Mysql 올리기 링크를 남기고 다음부터 진행합니다.\n  지난 포스트에서 생성한 Docker의 Mysql 컨테이너를 실행\n   docker ps -a (\u0026ldquo;컨테이너 조회\u0026rdquo;)    docker start (\u0026ldquo;컨테이너 시작\u0026rdquo;)  docker restart (\u0026ldquo;컨테이너에 재시작하기\u0026rdquo;) docker stop (\u0026ldquo;컨테이너에 종료하기\u0026rdquo;) docker attach (\u0026ldquo;현재 실행중인 컨테이너에 접속하기\u0026rdquo;)      sudo docker exec -it /bin/bash (\u0026ldquo;컨테이너의 CLI 접속\u0026rdquo;)   PS C:\\WINDOWS\\system32\u0026gt; docker ps -a\rCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\r4b6fb99160bf mysql:5.6 \u0026quot;docker-entrypoint.s…\u0026quot; 9 days ago Exited (255) 2 days ago 0.0.0.0:9876-\u0026gt;3306/tcp, :::9876-\u0026gt;3306/tcp test_mysql\rPS C:\\WINDOWS\\system32\u0026gt; docker start test_mysql\rtest_mysql\rPS C:\\WINDOWS\\system32\u0026gt; sudo docker exec -it test_mysql /bin/bash\r DBeaver 연결 및 테이블 생성  지난 포스트 Mysql DBeaver 설치 참조\n  UserProfile table 생성\n -- test.UserProfile definition\rCREATE TABLE `UserProfile` (\r`id` varchar(64) NOT NULL DEFAULT '',\r`name` varchar(64) DEFAULT NULL,\r`phone` varchar(64) DEFAULT NULL,\r`address` varchar(256) DEFAULT NULL,\rPRIMARY KEY (`id`)\r) ENGINE=InnoDB DEFAULT CHARSET=latin1;\r Dependency 추가 Dependency란 ?  자바 프로젝트 관리 도구인 아파치 메이븐의 XML형태의 라이브러리(의존성) 정의이며, Spring에서 Pom.xml에 추가하는 것을 의존성 주입이라 하며, Pom.xml에 xml 형식으로 추가하면 Maven Repositoy에서 라이브러리 파일을 자동으로 받아준다.\n pom.xml에 MysqlJ Dependency 추가  pom.xml은 /demo/pom.xml 프로젝트 최상단에서 찾아볼수 있습니다. SpringBoot에 Mysql과 Mybatis를 추가하기 위하여 pom.xml에 해당 dependency를 추가할 것입니다.\n  pom.xml은 아래와 같은 구조로 되어있으며, dependencies 밑의 dependency들 처럼 mysqlj와 mybatis를 추가하면 됩니다.\n Maven Repositiry  dependency를 추가하기 위하여 Maven Repositiry를 접속합니다.  MysqlJ (Mysql Connector for Java)  mysql connector를 받기 위하여 mysql j 를 검색합니다. mysqlj는 Mysql을 위한 JDBC 입니다.\n  Maven dependency xml 소스를 복사합니다.\n  pom.xml에 붙여넣고\n  Mysql Connector의 버전을 제거합니다. Spring Boot에서는 자주 사용하는 라이브러리에 한해서 SpringBoot 버전과 가장 호환이 잘되는 버전으로 빌드를 해주는 기능이 있기 때문에 버전은 제거해둡니다. 버전을 남겨두면 버전에 따라 waring이 뜰 수 있습니다.\n pom.xml에 Mybatis Dependency 추가 Mybatis  mybatis를 검색하고 Mybatis Spring Boot Starter를 선택합니다. 마이바티스(MyBatis)는 자바 퍼시스턴스 프레임워크의 하나로 XML 서술자나 애너테이션(annotation)을 사용하여 저장 프로시저나 SQL 문으로 객체들을 연결시키는데 도움을 줍니다.\n  마찬가지로 Mybatis Maven dependency xml pom.xml에 붙여넣습니다.\n application.properties 설정  /demo/src/main/resources/application.properties 파일을 수정합니다.\n  application.properties 파일에 Mysql 접속 정보를 추가합니다.\n spring.datasource.url = jdbc:mysql://localhost:[port]/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;serverTimezone=Asia/Seoul\u0026amp;useSSL=false\rspring.datasource.username = [userId]\rspring.datasource.password = [password]\r  프로젝트 우클릭 \u0026gt; Maven \u0026gt; Update Poject를 통하여 추가한 라이브러리들을 받습니다.\n UserProfile 테이블 생성  기존에 만들었던 com.example.demo.model.UserProfile의 필드들을 토대로 UserProfile 테이블을 생성합니다.\n UserProfile.java package com.example.demo.model;\rpublic class UserProfile {\rprivate String id;\rprivate String name;\rprivate String phone;\rprivate String address;\rpublic UserProfile(String id, String name, String phone, String address) {\rsuper();\rthis.id = id;\rthis.name = name;\rthis.phone = phone;\rthis.address = address;\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getPhone() {\rreturn phone;\r}\rpublic void setPhone(String phone) {\rthis.phone = phone;\r}\rpublic String getAddress() {\rreturn address;\r}\rpublic void setAddress(String address) {\rthis.address = address;\r}\r}\r UserProfile 테이블 엔티티  Id를 키로 잡고 나머지  UserProfile 테이블 생성쿼리 CREATE TABLE `UserProfile` (\r`id` varchar(64) NOT NULL DEFAULT '',\r`name` varchar(64) DEFAULT NULL,\r`phone` varchar(64) DEFAULT NULL,\r`address` varchar(256) DEFAULT NULL,\rPRIMARY KEY (`id`)\r) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r Mapper 생성 Mapper  Mybatis 매핑XML에 기재된 SQL을 호출하기 위한 인터페이스입니다. 스프링부트, mybatis 3.0이상에서는 Mapper를 통하여 SqlSession을 등록을 생략하고, DAO 인터페이스와 인터페이스 구현을 하지 않고 바로 SQL을 호출 할 수 있습니다. @mapper 어노테이션을 이용해 메서드명과 xml 파일의 id를 매핑시켜 편리하게 사용 할 수 있습니다.\n UserProfileMapper.java 파일 생성  /demo/src/main/java/com/example/demo/mapper 패키지를 생성합니다.\n UserProfileMapper  interface로 UserProfileMapper를 생성하고 @Mapper를 붙여서 스프링에서 Mapper로 인식하게 합니다.\n UserProfileMapper 작성 package com.example.demo.mapper;\rimport java.util.List;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.apache.ibatis.annotations.Param;\rimport com.example.demo.model.UserProfile;\r@Mapper\rpublic interface UserProfileMapper {\r}\r getUserProfile 작성   @select를 사용하여 select 쿼리를 정의합니다 Mybatis를 통하여 파라미터인 id와 ${id}를 매핑합니다.   \t@Select(\u0026quot;SELECT * FROM UserProfile WHERE id = ${id}\u0026quot;)\rUserProfile getUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r getUserProfileList 작성   @select를 사용하여 select 쿼리를 정의합니다.   \t@Select(\u0026quot;SELECT * FROM UserProfile\u0026quot;)\rList\u0026lt;UserProfile\u0026gt; getUserProfileList();\r putUserProfile 작성   @Insert를 사용하여 insert 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Insert(\u0026quot;INSERT INTO UserProfile VALUES(${id},${name},${phone},${address})\u0026quot;) int putUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r postUserProfile 작성   @Update를 사용하여 update 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Update(\u0026quot;UPDATE UserProfile SET name = ${name}, phone = ${phone}, address = ${address} WHERE id = ${id})\u0026quot;) int postUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r deleteUserProfile 작성   @Delete를 사용하여 delete 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Delete(\u0026quot;DELETE UserProfile WHERE id = ${id}\u0026quot;)\rint deleteUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r UserProfileMapper.java package com.example.demo.mapper;\rimport java.util.List;\rimport org.apache.ibatis.annotations.Insert;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.apache.ibatis.annotations.Param;\rimport org.apache.ibatis.annotations.Select;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport com.example.demo.model.UserProfile;\r@Mapper\rpublic interface UserProfileMapper {\r@Select(\u0026quot;SELECT * FROM UserProfile WHERE id = #{id}\u0026quot;)\rUserProfile getUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r@Select(\u0026quot;SELECT * FROM UserProfile\u0026quot;)\rList\u0026lt;UserProfile\u0026gt; getUserProfileList();\r@Insert(\u0026quot;INSERT INTO UserProfile VALUES(#{id},#{name},#{phone},#{address})\u0026quot;) int putUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r@Update(\u0026quot;UPDATE UserProfile SET name = #{name}, phone = #{phone}, address = #{address} WHERE id = #{id}\u0026quot;) int postUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r@Delete(\u0026quot;DELETE FROM UserProfile WHERE id = #{id}\u0026quot;)\rint deleteUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r}\r UserProfileController 수정  UserMap을 만들어 메모리상에서 사용자 정보를 GET, POST, PUT, DELETE 하던것을 새롭게 추가한 UserProfileMapper를 사용하여 GET, POST, PUT, DELETE 하게 수정합니다.\n  UserProfileMapper를 파라미터로 전달받아 내부 참조변수에 저장하는 생성자를 만들면, SpringBoot가 알아서 Mapper 클래스를 만들어 객체를 UserProfileController를 생성하면서 생성자로 전달합니다.\n  이후 전달된 UserProfileMapper 클래스 객체를 통해 메서드를 사용할 수 있습니다.\n UserProfileController.java package com.example.demo.controller;\rimport org.apache.catalina.User;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.web.bind.annotation.DeleteMapping;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport org.springframework.web.bind.annotation.PostMapping;\rimport org.springframework.web.bind.annotation.PutMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RequestParam;\rimport org.springframework.web.bind.annotation.RestController;\rimport com.example.demo.mapper.UserProfileMapper;\rimport com.example.demo.model.UserProfile;\rimport java.util.ArrayList;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport javax.annotation.PostConstruct;\r@RestController\rpublic class UserProfileController {\rprivate UserProfileMapper mapper;\rpublic UserProfileController(UserProfileMapper mapper) {\rthis.mapper = mapper;\r}\r@GetMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic UserProfile getUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\r//return userMap.get(id);\t//변경전\rreturn mapper.getUserProfile(id);\r}\r@GetMapping(\u0026quot;/users/all\u0026quot;)\rpublic List\u0026lt;UserProfile\u0026gt; getUserProfileList() {\r//return new ArrayList\u0026lt;UserProfile\u0026gt;(userMap.values()); //변경전\rreturn mapper.getUserProfileList();\r}\r@PutMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void putUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rint resultCnt = mapper.putUserProfile(id, name, phone, address);\r}\r@PostMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void postUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rint resultCnt = mapper.postUserProfile(id, name, phone, address);\r}\r@DeleteMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void deleteUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\rint resultCnt = mapper.deleteUserProfile(id);\r}\r}\r 테스트  제일 먼저 PUT 을 통해서 사용자 1건을 추가합니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  GET의 getUserProfile를 통해 사용자가 입력이 잘 되었는지 확인해 봅니다.\n  Mysql에 잘 저장되었는지 확인해 봅니다.\n  제일 먼저 POST를 통해서 입력한 사용자의 정보를 수정해 봅니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  Mysql에서 잘 수정되었는지 확인해 봅니다.\n  GET의 getUserProfileList를 통해 수정이된 내용을 확인해 봅니다.\n  DELETE를 통하여 추가한 사용자를 삭제합니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  GET의 getUserProfileList를 통해 삭제된 내용을 확인해 봅니다.\n  Mysql에서 잘 삭제되었는지 확인해 봅니다.\n End ","description":"레스트풀 API","id":74,"section":"blog","tags":["Restful","Api","Docker","Mysql","Mybatis"],"title":"RESTful API에 Docker Mysql 컨테이너와 Mybatis 연동","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-2/"},{"content":"Odd Occurrences In Array  Codility - Lesson2 - Array - Odd Occurrences In Array\n Task description  N개의 정수가 담긴 배열 A를 입력받습니다 배열에는 홀수 개의 요소가 포함됩니다. 배열의 각 요소는 짝을 이루지 않는 한 요소를 제외하고 동일한 값을 가진 다른 요소와 짝을 가지고 있습니다. 짝이 없는 요소를 찾으면 해결됩니다\n  예를 들어, 주어진 A 배열은 이렇습니다.\n  A [0] = 9 A [1] = 3 A [2] = 9\rA [3] = 3 A [4] = 9 A [5] = 7\rA [6] = 9\r   인덱스 0과 2에있는 요소의 값은 9입니다. 인덱스 1과 3에있는 요소의 값은 3이고, 인덱스 4와 6에있는 요소의 값은 9이고 인덱스 5의 요소는 값 7을 가지며 짝을 이루지 않습니다.\nCondition   N은 [1..1,000,000] 범위 내의 홀수 정수이고; 배열 A의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 . A의 값 중 하나를 제외하고 모두 짝수 번 발생합니다. 다음 가정에 대한 효율적인 알고리즘을 작성하십시오   Solution 1회차   A의 배열을 0부터 N까지 리스트를 조회하며 현재값 curr = A[i]를 기억해 두고 첫번째 요소 pop(0) 남은 A배열와 체크된 숫자 배열 B에 curr가 있는지 확인해서 없으면 짝이 없기 때문에 curr 값 리턴 아니라면 B배열에 curr 추가   def solution(A):\r# write your code in Python 3.6\rB = []\rfor i in range (0, len(A)) :\rcurr = A[0]\rA.pop(0)\rif curr not in A and curr not in B :\rreturn curr\rB.append(curr)\rpass\r  시간 복잡성 O (N ** 2)으로 n = 100,003, n = 999,999 시간 초과\n  for 안에서 in을 통해 다시 조회하는 것이 시간 복잡성을 늘린거 같다\n 2회차   A배열을 A.sort()를 사용해 asc 정렬 정렬을 하고 0 ~ len(A)까지의 반복문중 인덱스가 홀수면 값저장, 짝수면 홀수와 비교 마지막 인덱스가 홀수고 마지막 까지 짝이 없는 값이 없다면 마지막 값이 짝이 없는 값이므로 반환   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\r# write your code in Python 3.6\rA.sort()\rodd = 0\rfor i in range (0, len(A)) :\rif i % 2 == 0 :\rif i+1 != len(A) :\rodd = A[i]\relse :\rreturn A[i] else :\rif odd != A[i] : return odd pass\r  시간 복잡성 O(N) or O(N*log(N)) 하나의 for에서 처리를 해서 timeout에 걸리지 않았다.\n 다른 사람 풀이  풀이 방식이 비슷하나 A.sort()와 sorted(A)의 차이가 있다.\n sort와 sorted의 차이  따로 정리하며 포스팅 해야겠지만,\n list.sort()   list.sort()는 list 클래스의 메서드입니다. 실행 시 기본적으로 오름차순으로 리스트 객체 자체를 정렬하며 반환하는 값은 None입니다. 추가로 key와 reverse 파라미터를 조정하여 정렬기준을 변경할 수 있습니다.   \tlist.sort()\r sorted(list)   sorted 메서드는 list, tuple, string, dict, set 등 iterable 객체를 파라미터로 받아 정렬된 iterable를 반환합니다. sort 메서드처럼 key와 reverse파라미터를 조정해서 정렬 기준을 변경 할 수 있다.   \tlist1 = sorted(list)\r sort vs sorted?  데이터가 많으면 많을 수록 sorted는 새로운 객체를 생성해야하는 내부 처리가 있어서 sort보다 시간이 더 걸린다. 도긴 개긴이지만 sort 메서드가 미세하게 더 빠르다.\n  하지만 list가 아닌 iterable인 경우에서는 어쩔 수 없이 sorted를 사용해야 합니다.\n def test3(A):\rif len(A) == 1:\rreturn A[0]\rA = sorted(A)\rprint(A)\rfor i in range(0, len(A), 2):\rif i+1 == len(A):\rreturn A[i]\rif A[i] != A[i+1]:\rreturn A[i]\r 다른 사람 풀이2  시간 복잡성 O(N) or O(N*log(N)) lambda와 reduce() 메서드를 공부해 봐야겠다.\n 다른사람 코드 2\rdef solution(A):\rreturn reduce(lambda x,y: x^y, A)\r TestCase solution([9, 3, 9, 3, 9, 7, 9])\rsolution([9, 3, 9, 3, 9])\r ","description":"Odd Occurrences In Array","id":75,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Odd Occurrences In Array","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-odd-occurrences-in-array/"},{"content":"CyclicRotation  Codility - Lesson2 - Array - CyclicRotation\n Task description  N 개의 정수로 구성된 배열 A와 오른쪽으로 회전할 횟수 K가 제공됩니다. A의 각 요소가 오른쪽으로 K 번 이동합니다. N 개의 정수와 K로 구성된 배열 A가 주어지면 배열 A가 K 번 회전 된 배열을 반환합니다.\n  예를 들어, 주어진\n   A = [3, 8, 9, 7, 6] K = 3    함수는 [9, 7, 6, 3, 8]을 반환해야합니다. 세 가지 회전이 이루어졌습니다.\n  [3, 8, 9, 7, 6]-\u0026gt; [6, 3, 8, 9, 7]\r[6, 3, 8, 9, 7]-\u0026gt; [7, 6, 3, 8, 9]\r[7, 6, 3, 8, 9]-\u0026gt; [9, 7, 6, 3, 8]\r Condition   함수 작성 : class Solution {public int [] solution (int [] A, int K); } N 및 K는 [ 0 .. 100 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ -1,000 .. 1,000 ] 범위 내의 정수 입니다.   Solution # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A, K):\rN = len(A)\rfor value in A :\rif not (-1000 \u0026lt;= value \u0026lt;= 1000) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\rif not (0 \u0026lt;= N \u0026lt;= 100) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\relif not (0 \u0026lt;= K \u0026lt;= 100) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\relse :\rB = []\rfor i in range(0,N) :\rB.append(0) for i in range(0,N) :\rrotate = (i+K) % N\rB[rotate] = (A[i])\rA = B\rreturn A\rpass\r TestCase \r ","description":"Cyclic Rotation","id":76,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Cyclic Rotation","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-cyclic-rotation/"},{"content":"Mysql DBeaver 설치 DBeaver 다운로드  DBeaverinstall file 다운로드 운영체제에 맞는 DBeavr 인스톨파일을 다운받아 실행시킨다.   Mysql을 선택한다.   자신의 서버정보에 맞게 입력하면 Mysql을 사용할 수 있다.  ","description":"Mysql DBeaver 설치","id":77,"section":"blog","tags":["Mysql","Developer","DBeaver","Tools"],"title":"Mysql DBeaver 설치","uri":"https://offetuoso.github.io/blog/develop/database/mysql/mysql-dbeaver-install/"},{"content":"Mysql Developer 설치 SQL Developer 다운로드  SQL Developer 다운로드 운영체제에 맞는 SQL Developer를 다운받아 압축을 풀어 실행시킨다.  mysql-connector-java 설치  mysql connector j 다운로드 링크\n  Archives   Platform Independent를 선택하고 zip으로 받습니다.  Oracle Developer 설정  도구 \u0026gt; 환경설정 데이터베이스 \u0026gt; 타사JDBC드라이버 \u0026gt; 항목추가  신규 접속 생성  Mysql이 추가된것을 확인할 수 있다.   자신의 서버정보에 맞게 입력하면 Mysql Developer를 사용할 수 있다.  ","description":"Mysql Developer 설치","id":78,"section":"blog","tags":["Mysql","Developer","MysqlDeveloper","OracleDevelop","Tools"],"title":"Mysql Developer 설치","uri":"https://offetuoso.github.io/blog/develop/database/mysql/mysql-developer-install/"},{"content":"Maven error “Failure to transfer…” 문제 Failure to transfer com.google.guava:guava:jar:10.0.1 from https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempte from/to central (https://repo.maven.apache.org/maven2): The operation was cancelled.\r  https://repo.maven.apache.org/maven2에서 디펜던시를 전송하지 못하는 오류가 발생하였고, 로컬 저장소에 캐시되었습니다.\n 해결책 1   프로젝트 우클릭 -\u0026gt; Run as -\u0026gt; Maven Install 프로젝트 우클릭 -\u0026gt; Refresh 프로젝트 우클릭 -\u0026gt; Update Project (옵션 클릭 force update of snapshots/releases)   해결책 2   실행중인 IDE(이클립스, Sts) 종료 로컬 레퍼지토리 삭제\nC:\\Users{userNm}.m2\\repository   참조 https://stackoverflow.com/questions/5074063/maven-error-failure-to-transfer\n","description":"메이븐 에러","id":79,"section":"blog","tags":["Troubleshooting"],"title":"Maven Error - Failure to transfer..","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/spring/maven-error-repository/"},{"content":"SpringBoot를 이용한 RESTful API SpringBoot  스프링 프레임워크 기반 프로젝트를 복잡한 설정없이 쉽고 빠르게 만들어주는 라이브러리입니다. 사용자가 일일이 모든 설정을 하지 않아도 자주 사용되는 기본설정을 알아서 해줍니다.\n  Spring Boot 장점\n   라이브러리 관리의 자동화 라이브러리 버전 자동 관리 설정의 자동화 내장 Tomcat 독립적으로 실행 가능한 JAR   간단한 RESTful API 생성 Spring Starter Project로 프로젝트 생성  스프링STS4를 실행 하고, file \u0026gt; new \u0026gt; Spring Starter Project를 선택\n  서비스에 대한 설정을 할 수 있는 화면이 나오며 Demo라는 프로젝트명 그대로 \u0026lsquo;next\u0026rsquo; 진행   Spring Starter 구성 시 추가할 web \u0026gt; Spring Web Dependency를 추가   next를 눌러 진행하면, 스프링스타터의 서비스를 이용해서 방금전 입력한 항목들을 이용해 템플릿을 만들어 달라고 요청할 URL이며 URL을 호출하여, ZIP파일 형태로도 제공 받을수 있습니다. finish를 눌러 마무리합니다.   프로젝트 우클릭 \u0026gt; Run as \u0026gt; Spring Boot App을 눌러 실행   콘솔창으로 정상적으로 서비스가 올라가는 것을 볼 수 있습니다.   서비스될 Port가 :8080으로 설정된 것도 확인 가능합니다.   http://localhost:8080/ 로 접속해 보면 매핑되는 URI가 없기 때문에 오류 페이지대신 Whitelabel Error Page 페이지가 보이게 됩니다.  RESTful API 작성 Model - UserProfile.java 생성  com.example.demo 밑에 com.example.demo.model 패키지를 생성하고 그 안에 UserProfile이라는 VO 객체(Value Obeject)를 생성   String 형의 id, name, phone, address를 Private로 추가   생성자는 에디터 우클릭 \u0026gt; source \u0026gt; generate constructor using fields 를 사용하여 자동 생성   소스에 생성자가 추가된 것을 확인   private로 생성된 field들에 접근하기 위하여, getter와 setter 또한 generator를 이용하여 생성   소스에 getter, setter가 추가된 것을 확인  package com.example.demo.model;\rpublic class UserProfile {\rprivate String id;\rprivate String name;\rprivate String phone;\rprivate String address;\rpublic UserProfile(String id, String name, String phone, String address) {\rsuper();\rthis.id = id;\rthis.name = name;\rthis.phone = phone;\rthis.address = address;\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getPhone() {\rreturn phone;\r}\rpublic void setPhone(String phone) {\rthis.phone = phone;\r}\rpublic String getAddress() {\rreturn address;\r}\rpublic void setAddress(String address) {\rthis.address = address;\r}\r}\r Controller - UserProfileController.java 생성  Spring에서 컨트롤러를 지정해주기 위한 어노테이션은 @Controller와 @RestController가 있습니다. 하지만 여기서는 @RestController를 추가합니다.\n  UserMap을 만들어 메모리상에서 사용자 정보를 GET, POST, PUT, DELETE 할 수 있게 세팅합니다.  package com.example.demo.controller;\rimport org.apache.catalina.User;\rimport org.springframework.web.bind.annotation.RequestParam;\rimport org.springframework.web.bind.annotation.RestController;\rimport com.example.demo.model.UserProfile;\rimport java.util.ArrayList;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport javax.annotation.PostConstruct;\r@RestController\rpublic class UserProfileController {\rprivate Map\u0026lt;String, UserProfile\u0026gt; userMap;\r@PostConstruct\rpublic void init() {\ruserMap = new HashMap\u0026lt;String, UserProfile\u0026gt;();\ruserMap.put(\u0026quot;1\u0026quot;, new UserProfile(\u0026quot;1\u0026quot;, \u0026quot;홍길동\u0026quot;, \u0026quot;111-1111\u0026quot;, \u0026quot;서울시 영등포구 신길1동\u0026quot;));\ruserMap.put(\u0026quot;2\u0026quot;, new UserProfile(\u0026quot;2\u0026quot;, \u0026quot;김근로\u0026quot;, \u0026quot;111-1112\u0026quot;, \u0026quot;서울시 영등포구 신길2동\u0026quot;));\ruserMap.put(\u0026quot;3\u0026quot;, new UserProfile(\u0026quot;3\u0026quot;, \u0026quot;박영업\u0026quot;, \u0026quot;111-1113\u0026quot;, \u0026quot;서울시 영등포구 신길3동\u0026quot;));\r}\r}\r  아래 표와 같은 기능을 Controller에서 간단히 작성해 보려합니다.\n    Resource GET(read) PUT(create) POST(update) DELETE(delete)     /users 사용자 전체 조회 - - -   /users/{id} {id}사용자 조회 {id} 신규 사용자 추가 {id} 사용자 수정 {id} 사용자 삭제    GET  GET : /users/1 과 GET : /users/all 을 구현\n   @PathVariable은 String3에서 추가된 기능으로 URL에서 {특정값}을 변수로 받아 올 수 있다.    @GetMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic UserProfile getUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\rreturn userMap.get(id);\r}\r@GetMapping(\u0026quot;/users/all\u0026quot;)\rpublic List\u0026lt;UserProfile\u0026gt; getUserProfile() {\rreturn new ArrayList\u0026lt;UserProfile\u0026gt;(userMap.values());\r}\r  REST API Client Postman을 이용한 테스트 GET : http://localhost:8080/users/1 GET : http://localhost:8080/users/all  PUT  PUT : /users/1?name=\u0026amp;phone=\u0026amp;address=\n   @PathVariable은 String3에서 추가된 기능으로 URL에서 {특정값}을 변수로 받아 올 수 있다. @RequestParam 또한 @PathVariable과 비슷하지만, request의 parameter에서 가져오는 것이다. ?name=홍길동 과 같은 쿼리스트링을 파라미터로 파싱해준다.    @PutMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void putUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rUserProfile userProfile = new UserProfile(id,name,phone,address);\ruserMap.put(id,userProfile);\r}\r  PUT : http://localhost:8080/users/4?name=정운영\u0026amp;phone=111-4444\u0026amp;address=서울시 영등포구 신길4동   GET : http://localhost:8080/users/4  POST  POST : /users/1?name=\u0026amp;phone=\u0026amp;address=\n  @PostMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void postUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rUserProfile userProfile = userMap.get(id);\ruserProfile.setName(name);\ruserProfile.setPhone(phone);\ruserProfile.setAddress(address);\r}\r  POST : http://localhost:8080/users/1?name=첫번째\u0026amp;phone=010-1111\u0026amp;address=서울시 영등포구 영등포1동   GET : http://localhost:8080/users/1  DELETE  DELETE : /users/1\n  @DeleteMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void deleteUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\ruserMap.remove(id);\r}\r  DELETE : http://localhost:8080/users/1   GET : http://localhost:8080/users/all  참고   SpringBoot spring.io Dependency Annotation @Controller vs @RestController   ","description":"레스트풀 API","id":80,"section":"blog","tags":["Restful","Api"],"title":"SpringBoot를 이용한 RESTful API","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-1/"},{"content":"레스트풀 API(Restful Api) REST (Representational state transfer)  REST(Representational State Transfer)는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다. REST는 로이 필딩(Roy Fielding)의 2000년 박사학위 논문에서 소개 엄격한 의미로 REST는 네트워크 아키텍처 원리의 모음이다. 여기서 \u0026lsquo;네트워크 아키텍처 원리\u0026rsquo;란 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반을 일컫는다. 간단한 의미로는, 웹 상의 자료를 HTTP위에서 SOAP이나 쿠키를 통한 세션 트랙킹 같은 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스를 말한다.\n REST 구성  1.자원(RESOURCE) - URI 2.행위(Verb) - HTTP METHOD 3.표현(Representations)\n REST의 목표  REST의 목표는 성능, 확장 성, 단순성, 수정 가능성, 가시성, 이식성 및 안정성을 높이는 것. 이는 REST 아키텍처에 적용되는 제약 조건을 통해 달성됩니다.\n REST 아키텍처 원칙(아키텍처 스타일, 아키텍처의 제약 조건)  해당 6가지 원칙을 모두 만족한다면, REST하다 이야기 할 수 있습니다.\n   인터페이스 일관성 (using a uniform interface): URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.    무상태성(Stateless): 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.    캐시 가능(Cacheability): REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다.    클라이언트/서버 구조 (client–server architecture): REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.    계층화(Layered System): REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.    Code on demand (optional) - 클라이언트는 리소스에 대한 표현을 응답으로 받고 처리해야 하는데, 어떻게 처리해야 하는지에 대한 Code를 서버가 제공하는 것을 의미한다. Html에서의 javascript가 가장 대표적인 예이다. 하지만 서버에서 제공되는 코드를 실행해야 하기 때문에 보안 문제를 야기할 수 있습니다. (이 제약조건은 필수는 아님.)   REST가 필요한 이유   애플리케이션 분리 및 통합 다양한 클라이언트의 등장 최근의 서버 프로그램은 다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다. 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.   RESTful API ?  RESTful은 위의 REST 아키텍처의 원칙을 모두 만족하는 것을 의미한다. RESTful API란 REST라는 아키텍처 스타일과 원칙을 모두 만족하는 모두 만족하는 API라는 뜻이다.\n REST API 디자인   URL을 심플하고 직관적으로 만들자   REST API를 URL만 보고도, 직관적으로 이해할 수 있어야 한다 URL을 길게 만드는것 보다, 최대 2 depth 정도로 간단하게 만드는 것이 이해하기 편하다.     BAD   http://restapi.example.com/customerUsers\rhttp://restapi.example.com/sellerUsers\r   Good   http://restapi.example.com/users/customer\rhttp://restapi.example.com/users/seller\r  소문자를 사용한다.   도메인 주소명은 대소문자를 구분하지 않는다. 디렉터리 명 이하의 주소는 서버의 운영체제에 따라 다르다. 대소문자를 혼용하여 사용하는 주소는 권장되지 않는다.     BAD   http://restapi.example.com/users/customer/\r   Good   http://restapi.example.com/users/customer/get-adress\r  언더바를 대신 하이픈을 사용한다. 가급적 하이픈의 사용도 최소화하며, 정확한 의미나 표현을 위해 단어의 결합이 불가피한 경우에 사용한다.     Bad   http://restapi.example.com/users/customer/get_adress\r   Good   http://restapi.example.com/users/customer/get-adress\r  마지막에 슬래시를 포함하지 않는다.   슬래시는 계층을 구분하는 것으로, 마지막에는 사용하지 않는다.     Bad   http://restapi.example.com/users/customer/\r   Good   http://restapi.example.com/users/customer\r  행위는 포함하지 않는다.   행위(동사)는 URL대신 Method를 사용하여 전달한다.(GET, POST, PUT, DELETE 등)      Resource GET(read) PUT(create) POST(update) DELETE(delete)     /goods 상품목록 상품추가 - -   /goods/{id} {id}값 상품상세 - {id}값 상품 수정 {id}값 상품 삭제      Bad   POST : http://restapi.example.com/users/customer/delete-post/1\r   Good   DELETE : http://restapi.example.com/users/customer/post/1\r  가급적 명사를 사용하되, 제어 자원을 의미하는 경우 예외적으로 동사를 허용한다.     Bad   POST : http://restapi.example.com/users/customer/duplication\r   Good   POST : http://restapi.example.com/users/customer/duplicate\r  7.파일 확장자는 URI에 포함시키지 않는다.\n REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않습니다. Accept header를 사용하도록 한다.     Bad   GET : http://restapi.example.com/users/customer/profile.png\r   Good   GET http://restapi.example.com/users/customer/profile\rHTTP/1.1 Host: restapi.example.com Accept: image/jpg\r   오류 처리를 명확하게 해라.\r    HTTP 상태코드를 정하고(많아도 안좋음), 다른 개발자들을 위한 오류 메시지 정의, 상세 정보 링크 등을 넣어주면 도움이 된다.   참고   REST wiki   ","description":"레스트풀 API","id":81,"section":"blog","tags":["REST","RESTful","Api"],"title":"RESTFULL API (RESTful API)","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api/"},{"content":"도커에 Mysql 올리기 도커 버전 체크  cmd창 또는 Windows PowerShell을 싱행한다.  도커 초기화  일단 도커의 이미지/컨테이너들을 모두 지워주는 것 부터 시작하겠습니다.\n PS C:\\\u0026gt; sudo docker rm -f `sudo docker ps -a -q`\rPS C:\\\u0026gt; sudo docker rmi -f `sudo docker images`\r 도커 이미지 가져오기 (get Mysql Image for Docker)  Mysql의 경우 DockerHub에 있기 때문에, 쉽게 이미지를 받아 올 수 있습니다.\n DockerHub에서 mysql 이미지 받아오기   PS C:\\\u0026gt; docker pull mysql\rUsing default tag: latest\rlatest: Pulling from library/mysql\rDigest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969\rStatus: Image is up to date for mysql:latest\rdocker.io/library/mysql:latest\r   다운받은 도커 이미지 확인   PS C:\\\u0026gt; docker images\rREPOSITORY TAG IMAGE ID CREATED SIZE\rmysql latest c0cdc95609f1 13 days ago 556MB\rdocker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB\r Mysql 컨테이너 설정  sudo docker run -d -p 9876:3306 -e MYSQL_ROOT_PASSWORD= \u0026ndash;name test_mysql mysql:5.6\n PS C:\\\u0026gt; sudo docker run -d -p 9876:3306 -e MYSQL_ROOT_PASSWORD=passw0rd --name test_mysql mysql:5.6\r  docker run \u0026ndash;name mysql-test -e MYSQL_ROOT_PASSWORD= -d -p 3306:3306 mysql:5.7\n PS C:\\\u0026gt; docker run --name mysql-test -e MYSQL_ROOT_PASSWORD=passw0rd -d -p 3306:3306 mysql:5.7\rfb4e8d8a5dd23d2c2b8068b311105f28bd8bd97067e78a7f4779d7da5bb3a483\r docker 옵션   -d 는 컨테이너를 백그라운드에서 동작하는 어플리케이션으로 실행    -p 9876:3306 는 -p 옵션은 호스트와 컨테이너 간의 포트(port) 배포(publish)/바인드(bind)를 위해서 사용되는데요. 호스트(host) 컴퓨터에서 컨테이너에서 리스닝하고 있는 포트로 접속할 수 있도록 설정해줍니다. 위 커맨드는 컨테이너 내부에서 3306 포트로 리스닝하고 있는 HTTP 서버를 호스트 컴퓨터에서 9876 포트로 접속할 수 있도록 해줍니다.    -e 는 Docker 컨테이너의 환경변수를 설정하기 위해서는 -e 옵션을 사용합니다. 또한, -e 옵션을 사용하면 Dockerfile의 ENV 설정도 덮어써지게 됩니다. 아래 커맨드는 FOO 환경 변수를 bar로 세팅을 하고, 환경 변수를 출력하고 있습니다.    MYSQL_ROOT_PASSWORD=passw0rd는 mysql의 기본 비밀번호를 설정합니다.    \u0026ndash;name test_mysql은 Docker 컨테이너를 제어할 때 컨테이너 ID를 사용하면 읽거나 기억하기가 어려워서 불편하게 느껴집니다. 이럴 경우, \u0026ndash;name 옵션을 사용해서 컨테이너에 이름을 부여해주면 해당 test_mysql 이름으로 컨테이너를 식별할 수 있습니다.   생성된 Mysql 컨테이너 확인  docker ps -a 명령어 실행\n PS C:\\\u0026gt; docker ps -a\rCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\raf3dd622e753 mysql \u0026quot;docker-entrypoint.s…\u0026quot; 28 hours ago Up 32 minutes 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp test_mysql\r Mysql 컨테이너 test_mysql의 CLI 접속  sudo docker exec -it test_mysql /bin/bash 명령어 실행\n PS C:\\\u0026gt; sudo docker exec -it test_mysql /bin/bash\r Mysql 테스트 설치시 등록한 암호 입력  mysql -u root -p\n root@4b6fb99160bf:/# mysql -u root -p\rEnter password:\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 1\rServer version: 5.6.51 MySQL Community Server (GPL)\rCopyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\rmysql\u0026gt;\r Mysql user 생성 및 권한 부여  개발에 사용할 developer라는 유저 생성\n mysql\u0026gt; CREATE USER 'developer'@'%' IDENTIFIED BY 'passw0rd';\rQuery OK, 0 rows affected (0.00 sec)\r  developer에게 모든 권한 부여\n mysql\u0026gt; GRANT ALL PRIVILEGES ON *.* TO 'developer'@'%';\rQuery OK, 0 rows affected (0.00 sec)\rmysql\u0026gt;\r 유저 변경 mysql\u0026gt; quit\rBye\rroot@4b6fb99160bf:/# mysql -u developer -p\rEnter password:\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 2\rServer version: 5.6.51 MySQL Community Server (GPL)\rCopyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\rmysql\u0026gt;\r 데이터베이스 생성 mysql\u0026gt; create database test;\rQuery OK, 1 row affected (0.00 sec)\rmysql\u0026gt; show databases;\r+--------------------+\r| Database |\r+--------------------+\r| information_schema |\r| mysql |\r| performance_schema |\r| test |\r+--------------------+\r4 rows in set (0.00 sec)\rmysql\u0026gt;\r  참고 :\n 도커 웹 페이지   ","description":"도커에 Mysql 올리기","id":82,"section":"blog","tags":["Docker","Mysql"],"title":"도커에 Mysql 올리기-1 (Docker Mysql)","uri":"https://offetuoso.github.io/blog/develop/backend/docker/docker-mysql/"},{"content":"도커 (Docker) 도커란 ?  도커란 리눅스의 응용 프로그램들을 프로세스 격리 기술을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트. 도커 웹 페이지의 기능을 인용하면 다음과 같다:\n 도커 컨테이너는 일종의 소프트웨어를 소프트웨어의 실행에 필요한 모든 것을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는\r무엇이든 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.\r 도커의 특징   도커의 컨테이너는 각각 독립적이다. 독립적으로 존재하기 때문에 원하는 어떤 환경이든 모듈적으로 관리 가능하다. 하나의 서버에 각각의 여러개의 컨테이너를 갖을 수 있다. 컨테이너는 줄이거나 늘릴 수 있다. 예를 들면 자바 서버의 트래픽이 늘어 난다면, 장고 서버를 줄이고 자바를 더 싣을 수 있다. 도커를 사용하면 서버를 늘릴 때마다 서버를 구매하고 다시 설치할 필요가 없어진다 원하는 개발 환경 파일에 저장을 하면, docker는 이를 원하는 어떤 머신이든 해당 환경을 시뮬레이션 해준다.   도커의 장/단점 ####장점\n  빠른 실행 환경 구축 가볍고 빠른 실행 속도 하드웨어 자원 절감 공유 환경 제공, DockerHub를 통해 검증된 많은 이미지들 사용가능 쉬운 배포(Deploy) 제공   ####단점\n  초기 진입장벽에 의한 업무효율 감소 리눅스 기반   도커 설치 (Window 10) 1. 도커 설치를 위한 준비  Windows 10에서 도커를 설치 하기 위해서는 Hyper-V를 설치해야 합니다. Hyper-V를 사용하면 Windows에서 가상 머신으로 여러 운영 체제를 실행할 수 있습니다.\n 2. 도커 다운로드 및 설치   도커 웹 페이지에서 Get Docker 클릭 하여 다운로드      Ok를 눌러 넘어갑니다. WSL2(Windows Subsystem for Linux 2)란?     설치가 완료 되면 \u0026ldquo;Close and log out\u0026rdquo; 를 클릭하여 재접속 합니다.      재접속 후에는 Host에 docker의 Localhost가 추가 되어 Window에서 악성코드에 의하여 Host파일이 변경되었다고 알람이 뜰 수도 있습니다. Host 내용 한번 확인하시고 아래와 같은 내용이라면 무시해도 됩니다.      도커가 실행되며,  윈도우 트레이 아이콘에서도 확인 할 수 있습니다.    윈도우에서 sudo 사용하기  Docker를 공부하는 도중 명령어 중에 sudo가 포함된 명령어를 실행시 cmd 기준 아래와 같은 화면이 나타났다.   윈도우에서는 기본적으러 sudo를 지원하지 않기 때문인거같아 choco라는 패키지 관리자를 이용하여 설치를 하여 해결하였다.\n  choco라는 패키지 관리자를 통하여 sudo 패키지를 설치하면 된다.\n choco install sudo\rchoco upgrade sudo\r  참고 :\n 도커 웹 페이지   ","description":"도커 설치","id":83,"section":"blog","tags":["Docker","Install"],"title":"도커 설치 (Docker Install) ","uri":"https://offetuoso.github.io/blog/develop/backend/docker/docker-install/"},{"content":"   The A is about the B (\u0026lsquo;A는 B에 관한것\u0026rsquo;)  The video is about the effect of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향)\n the effect of A on B (\u0026lsquo;A가 B에 미치는 영향\u0026rsquo;) = the influence of A on B  the effect of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향.)\n the influence of A on B (\u0026lsquo;A가 B에 미치는 영향\u0026rsquo;)  the influence of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향.)\n I want more A, so I can B (\u0026lsquo;더 많은 A를 원해, 그래서 B 할 수 있도록\u0026rsquo;)  I want more time, so I can exercise/work out (더 운동할 수 있는 더 많은 시간을 원한다.)\n give numbers to ~ → to rank ('-에 순위를 매기다')  give numbers to hobby (취미에 순위를 매기다.)\n choose priority (\u0026lsquo;우선 순위 선택\u0026rsquo;) I went to the ~ ('-에 갔다')  I went to 횡성 웰리힐리파크 for skiing. (횡성 웰리힐리파크에 스키타러 갔었다.) I went to 웰리힐리파크 for night snow boarding at 10pm. (10시에 심야 스노우 보드를 타기 위해 웰리 힐리 파크에갔습니다.) I went to the library to study. (공부하러 도서관을 갔었다.)\n ~ days a week. (\u0026lsquo;일주일에 -일\u0026rsquo;)  A year ago, I worked out three days a week. (1년 전에는, 1주일에 3일 운동하러 나갔다.) I went skate boarding three days(times) a week. (1주일에 3일씩 스케이트 보드를 탔다.)\n It was bright from the strong lights (\u0026lsquo;강한 불빛에 비추어 밝았다.')  The light was very strong. → It was bright from the strong lights.\n Q. How does effect of exercising regularly on our body? (\u0026lsquo;규칙적인 운동이 우리 몸에 미치는 영향을 미치는가?')  when I regularly exercise, I had more energy and less stress at that time. (규칙적으로 운동 할 때 그 당시에는 더 많은 에너지와 스트레스를 덜 받았습니다.)\n ##Grammar Error:\nstarting exercising regularly effect on body. → The video is about the effect of exercising regularly on our body. the effect of A on B the influence of A on B I want more exercise → I want more time so exercise. → I want more time, so I can exercise/work out. so hard → so difficult Working out is too hard. I’d like to go swimming. I went to 횡성 웰리힐리파크 for skiing. / I went to the library to study. I went to 횡성 웰리힐리파크 at 10pm for night snowboarding. The light was very strong. → It was bright from the strong lights. One years ago, I was three days on week. → (About) A year ago, I worked out three days a week. / I went skateboarding three days(times) a week. I think decreased stress → I have more stress now. / I had less stress at that time. /I think the amount of stress has increased. I was more energetic at that time.\u0026ndash;\u0026gt; I had more energy ~. I was more energetic and had less stress at that time. / I had more energy and less stress at that time.\n##New expressions learned today: give numbers to sth → to rank choose priority\n본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":84,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.05.14","uri":"https://offetuoso.github.io/blog/english/202105/20210514-english-speak/"},{"content":"탐색 알고리즘 탐색(search)  탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는과정. 그래프 또는 트리의 자료구조에서 데이터를 찾는 문제가 주로 나온다. 대표적으로 DPS, BPS가 있으며, 원리를 제대로 이해해야 코딩테스트 문제를 풀 수 있다. 그런데 DPS와 BPS를 이해하기 위해서 기본 자료구조인 스택, 큐, 재귀 함수 등을 이해가 전제로 되어야한다.\n 자료구조  자료구조란 데이터를 표현하고 관리하고 처리하기 위한 구조 스택과 큐는 삽입(Push)과 출력(Pop)이라는 두 핵심적인 함수로 구성 실제 구현할땐 오버플로우와 언더플로우를 고민해야한다.\n 스택  스택의 구조는 선입후출 또는 후입선출구조. 스택은 박스 쌓기로 비유할 수 있다.\n 스택의 요소    기능  명칭  설명      push(x) 삽입 스택의 마지막에 엘리먼트를 추가(append)하며, 마지막에 삽입된 인덱스(top)가 증가한다.   pop() 추출(삭제) 스택의 마지막 엘리먼트를 반환하고 삭제(del)하며, 마지막에 삽입된 인덱스(top)가 감소한다.   peak() 스택의 마지막 엘리먼트 반환 스택의 마지막 엘리먼트를 반환한다, 마지막에 삽입된 인덱스(top)는 변화가 없다.   top() 스택의 top 반환 마지막에 삽입된 인덱스(top)를 반환한다. 엘리먼츠(리스트)의 사이즈 -1   isEmpty() 스택이 비어있는지 체크 엘리먼츠(리스트)가 비어있으면 True/ 비어있지 않으면 False 반환   clear() 스택 초기화 엘리먼츠(리스트)를 초기화, 마지막에 삽입된 인덱스(top)도 -1   size() 스택의 사이즈 반환 엘리먼츠(리스트) 사이즈 반환   contains() 엘리먼츠(리스트) 초기화 엘리먼츠를 초기화, 마지막에 삽입된 인덱스(top)도 -1   search() 엘리먼츠(리스트) 초기화 엘리먼츠를 초기화, 마지막에 삽입된 인덱스(top)도 -1    \rstack.py class Stack :\r#초기화\rdef __init__(self) :\rself.elements = [] #stack 엘리먼츠 생성\r#데이터 추가\rdef push(self, x) :\rself.elements.append(x) #stack 엘리먼트 추가\r#최근에 추가된(Top) 데이터 삭제\rdef pop(self) :\rif self.isEmpty() :\rreturn \u0026quot;stack underflow!\u0026quot;\relse : del self.elements[self.top()]\rreturn self.elements[self.top()]\r#최근에 추가된(Top) 데이터 삭제\rdef peek(self) : return(self.elements[self.top()])\r#최근에 추가된 인덱스 반환 def top(self) :\rreturn self.size()-1 #인덱스 = (사이즈-1) #stack의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif (self.top() == -1) :\rreturn True\relse :\rreturn False\r#stack 초기화\rdef clear(self) : self.elements = [] #엘리먼츠 초기화\r#stack의 길이 반환\rdef size(self) :\rreturn (len(self.elements))\r#stack의 값이 포함되어있는지 확인, 비었으면 true, 아니면 false\rdef contains(self, x) :\rif(x in self.elements) : #x가 엘리먼츠에 포함되어있는지\rreturn True else :\rreturn False\r#엘리먼트를 보관한 인덱스 반환(리스트 인덱스의 역방향, 1부터 시작)\rdef search(self, x) :\rresult = -1\rfor i in range(1,self.size()+1) :\rif x == self.elements[(self.size()-i)] : result = i\rreturn result\rstack = Stack() print(stack.elements)\rstack.push(1)\rprint(stack.elements)\rstack.push(2)\rprint(stack.elements)\rstack.push('banana')\rprint(stack.elements)\rstack.push(4)\rprint(stack.elements)\rstack.push(5)\rprint(stack.elements)\rprint(\u0026quot;size() \u0026quot;, stack.size())\rprint(\u0026quot;contains(1) \u0026quot;, stack.contains(1))\rprint(\u0026quot;search(1) \u0026quot;, stack.search(1))\rprint(\u0026quot;search(2) \u0026quot;, stack.search(2))\rprint(\u0026quot;peek() \u0026quot;, stack.peek())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;stack.clear() \u0026quot;)\rstack.clear() print(\u0026quot;size() \u0026quot;, stack.size())\rprint(\u0026quot;top() \u0026quot;, stack.top())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\r 큐  큐는 대기줄에 비유할 수 있는 공정한 자료구조, 단 새치기는 없다고 가정. 이러한 스택의 구조를 선입선출구조.\n    기능  명칭  설명      enQueue(x) 삽입 큐의 마지막에 엘리먼트를 추가하며, 마지막에 삽입된 인덱스(rear)가 증가한다.   deQueue() 추출(삭제) 큐의 첫번째 엘리먼트를 반환하고 삭제(빈값으로 세팅 None)하며 , 마지막에 삽입된 인덱스(front-1)가 감소한다. 큐가 마지막의 인덱스에 도달했다면 초기화 (or 삭제 시 한칸씩 땡긴다.)   peak() 큐의 첫번째 엘리먼트 반환 큐의 첫번째 엘리먼트를 반환한다, front 변화 없음   isEmpty() 큐가 비어있는지 체크 프론트와 리어가 같으면 True/ 프론트와 리어가 같지 않으면 False 반환   size() 큐의 사이즈 반환 사용된 엘리먼츠 리스트의 숫자 반환 (rear - front)    \r선형 큐  선형 큐는 데이터를 입력하면 rear가 증가하고 삭제를 통해 front도 증가, 하지만 여러번의 삽입과 삭제를 하면, 삭제된 이후 배열의 앞 공간은 사용할 수 없게 된다.\n linearQueue.py 리스트로 만든 선형큐 MAX = 5\rclass LinearQueue :\r#초기화 def __init__(self, max = MAX) :\rself.maxSize = max\rself.elements = [None] * self.maxSize #비어있는 배열은 None으로 초기화\rself.front = -1 #queue의 앞쪽 인덱스, 삭제 시 증가 self.rear = -1 #queue의 뒤쪽 인덱스 , 삽입 시 증가\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif self.front == self.rear : #front와 rear가 같으면 비어있음\rresult = True\relse : result = False return result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rif(self.rear+1 == self.maxSize) : #rear+1이 maxSize면 오버플로우\rprint(\u0026quot;queue Overflow!\u0026quot;)\relse :\rself.rear += 1 self.elements[self.rear] = x #rear+1에 새로운 데이터 추가\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse :\rself.front += 1\rresult = self.elements[self.front]\rself.elements[self.front] = 'None' #front+1의 데이터 None으로 삭제\rreturn result\r#queue가 비어있으면서 front가 마지막 인덱스(maxSize-1) 까지 도달\rif(self.isEmpty() and self.front == self.maxSize-1) :\rself.front = -1 #front를 초기화\rself.rear = -1 #rear를 초기화\r\u0026quot;\u0026quot;\u0026quot;\r# 삭제 후 한 칸씩 옮기는 로직\rfor i in range(0,self.maxSize) :\rif(i+1 != self.maxSize) :\rself.elements[i] = self.elements[i+1]\relse : self.elements[i] = None\rself.front -= 1\rself.rear -= 1\r\u0026quot;\u0026quot;\u0026quot;\r#queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[self.front+1]\r#queue의 사이즈 반환\rdef size(self) :\rreturn self.rear - self.front queue = LinearQueue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r linearDequeue.py  파이썬의 deque를 이용한 선형큐\n MAX = 5\rfrom collections import deque\rclass LinearDequeue :\r#초기화 def __init__(self, max = MAX) :\rself.elements = deque()\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif len(self.elements) == 0 : result = True\relse : result = False return result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rself.elements.append(x)\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse : return self.elements.popleft() #queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[0]\r#queue의 사이즈 반환\rdef size(self) :\rreturn len(self.elements)\rqueue = LinearDequeue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r 환형큐  선형큐의 공간 낭비의 문제점을 해결하기 위해 고안된 환형큐지만 역시나 문제점이 있다. front 와 rear가 같으면 비어(isEmpty) 있는 상태이지만, 환형 큐가 꽉찬(isFull) 상태 또한 front와 rear가 같아 문제점이 발생한다.\n  front와 rear의 위치만으로 큐의 비어있는 상태와 꽉찬 상태를 구분할 수 없기 때문에 이를 위해 큐의 한칸을 비어둔다. 한칸을 비움으로써 큐의 비어있는 상태와 꽉찬 상태의 front와 rear 위치를 다르게 하여 해결한다.\n circularQueue.py MAX = 5\rclass CircularQueue :\r#초기화 def __init__(self, max = MAX) :\rself.maxSize = max\rself.elements = [None] * self.maxSize #비어있는 배열은 None으로 초기화\rself.front = 0 #queue의 앞쪽 인덱스, 삭제 시 증가 self.rear = 0 #queue의 뒤쪽 인덱스 , 삽입 시 증가\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif self.front == self.rear : #front와 rear가 같으면 비어있음\rresult = True\relse : result = False return result\rdef isFull(self) :\rif self.front == (self.rear+1) % self.maxSize :\rresult = True\relse :\rresult = False\rreturn result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rif(self.isFull()) : #rear+1이 maxSize면 오버플로우\rprint(\u0026quot;queue Overflow!\u0026quot;)\relse :\rself.rear = (self.rear+1) % self.maxSize\rself.elements[self.rear] = x #rear+1에 새로운 데이터 추가\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse :\rself.front = (self.front+1) % self.maxSize\rresult = self.elements[self.front]\rself.elements[self.front] = 'None' #front+1의 데이터 None으로 삭제\rreturn result\r#queue가 비어있으면서 front가 마지막 인덱스(maxSize-1) 까지 도달\rif(self.isEmpty() and self.front == self.maxSize-1) :\rself.front = -1 #front를 초기화\rself.rear = -1 #rear를 초기화\r\u0026quot;\u0026quot;\u0026quot;\r# 삭제 후 한 칸씩 옮기는 로직\rfor i in range(0,self.maxSize) :\rif(i+1 != self.maxSize) :\rself.elements[i] = self.elements[i+1]\relse : self.elements[i] = None\rself.front -= 1\rself.rear -= 1\r\u0026quot;\u0026quot;\u0026quot;\r#queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[self.front+1]\r#queue의 사이즈 반환\rdef size(self) :\rreturn self.rear - self.front queue = CircularQueue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rqueue.enQueue(6)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rqueue.enQueue(6)\rprint(queue.elements)\rqueue.enQueue(7)\rprint(queue.elements)\rqueue.enQueue(8)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r 재귀 함수  자기 자신을 다시 호출하는 함수. 재귀 함수의 종료조건을 반드시 명시해야 한다. 컴퓨터 내부적인 스택 자료구조를 이용한다. 마지막 함수까지 끝나고 나서야 다시 역순으로 돌아가 종료된다.\n  아래 예제는 입력받은 숫자만큼 부터 카운트다운을 하는 소스이다.\n countdown.py (재귀함수 사용) m = int(input())\rdef coountdwon(n) :\rif(n ==0 ) :\rreturn 'Happy new year!'\relse : print(n)\rreturn coountdwon(n-1)\rcoountdwon(m)\r countdown2.py (반복문사용) for i in range(0, m) :\rprint(m-i)\rif (m-i) == 1 :\rprint('Happy new year!')\r 유클리드 호제법 이 자료는 나동빈님의 이코테 서적과 유튜브 영상을 보고 정리한 자료입니다.\n참고 : http://www.yes24.com/Product/Goods/91433923\n  ","description":"탐색 알고리즘.","id":85,"section":"blog","tags":["Algorithm"],"title":"탐색 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/search/search-algorithm/"},{"content":"[문제1] 왕실의 기사 [문제] 왕실의 기사 : 문제 설명  행복 왕국의 왕실 정원은 체스판과 같은 8 × 8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다 나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다 나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있다\n   수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기   수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기   이처럼 8 × 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라. 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a 부터 h로 표현한다\n  c2에 있을 때 이동할 수 있는 경우의 수는 6가지이다 a1에 있을 때 이동할 수 있는 경우의 수는 2가지이다 d4에 있을 때 이동할 수 있는 경우의 수는 8가지이다.\n [문제] 조건  조건 풀이시간 20분 시간제한 1초, 메모리 128mb\n  입력 첫째 줄에 8x8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1 처럼 열과 행으로 이뤄진다.\n  출력 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오.\n  입력 예시 a1\n  출력 예시 2\n 아이디어   모든 경우를 탐색하는 완전탐색 유형의 문제이다 문자 -\u0026gt; 아스키 코드를 반환 하는 ord(\u0026lsquo;a\u0026rsquo;) 를 알아야 한다.\n참고 \u0026lt;-\u0026gt; chr(97)   royal_knight.py n = str(input())\rx = ord(n[0:1])\ry = n[1:2]\r#print(n[0:1])\r#print(n[1:2])\r#print(chr(104))\r#print(ord('a'))\rmv = [0 , 1, 2, 3, 4, 5, 6, 7]\rdx = [-1, +1, +2, +2, +1, -1, -2, +2]\rdy = [-2, -2, -1, +1, +2, +2, +1, -1]\rcount = 0\rfor move in mv :\rif( ord('a') \u0026lt;= int(x)+dx[move] \u0026lt;= ord('h')\rand 1 \u0026lt;= int(y)+dy[move] \u0026lt;= 8) :\rcount += 1\rprint(count)  royal_knight2.py input_data = input()\rrow = input_data[1]\rcolumn = int(ord(input_data[0]))- int(ord('a')) +1\rsteps = [(-2, -1), (-2, +1), (-1, +2), (+1,+2), (+2, +1), (+2, -1), (+1, -2), (-1, +2)]\rcount = 0\rfor step in steps :\rif( 1 \u0026lt;= step[0]+int(row) \u0026lt;= 8 and 1 \u0026lt;= step[1]+int(column) \u0026lt;= 8 ) :\rcount += 1\rprint(count)  파이썬 모범답안 input_data = input()\rrow = int(input_data[1])\rcolumn = int(ord(input_data[0]))- int(ord('a')) +1\rsteps = [(-2, -1), (-2, +1), (-1, +2), (+1,+2), (+2, +1), (+2, -1), (+1, -2), (-1, +2)]\rresult = 0\rfor step in steps :\rnext_row = step[0]+row\rnext_column = step[0]+column\rif( 1 \u0026lt;= next_row \u0026lt;= 8 and 1 \u0026lt;= next_column \u0026lt;= 8 ) :\rresult += 1\rprint(result)  놓친 아이디어   input_data = input(), input_data[0],input_data[1] 로 접근 할 수 있는것을 더 복잡하게 잘라냈다. int(ord(input_data[0])) - int(ord(input_data[a])) + 1 을 사용하여 1 ~ 8로 더 간편히 조회가능. 이동 관련해서 dx,dy 각각 배열을 만들었지만, row, column을 하나의 데이터로 묶어서 사용할 수도 있다.   RoyalKnight.java package ex.algorithm.implement;\rimport java.util.ArrayList;\rimport java.util.Scanner;\rpublic class RoyalKnight{\rpublic static void main(String[] args) {\rint result = 0;\rScanner sc = new Scanner(System.in);\rString input_data = sc.nextLine();\rint row = Integer.parseInt(input_data.substring(1,2));\rint column = (int)input_data.substring(0,1).charAt(0) - (int) 'a' + 1;\rArrayList steps = new ArrayList\u0026lt;ArrayList\u0026lt;Integer[]\u0026gt;\u0026gt;();\rsteps.add(new Integer[]{-2,-1});\rsteps.add(new Integer[]{-2,+1});\rsteps.add(new Integer[]{-1,+2});\rsteps.add(new Integer[]{+1,+2});\rsteps.add(new Integer[]{+2,+1});\rsteps.add(new Integer[]{+2,-1});\rsteps.add(new Integer[]{+1,-2});\rsteps.add(new Integer[]{-1,-2});\rfor (Object obj : steps) {\rInteger[] step = (Integer[])obj;\rint next_row = row + step[0];\rint next_column = column + step[1];\rif((1 \u0026lt;= next_row \u0026amp;\u0026amp; next_row \u0026lt;= 8) \u0026amp;\u0026amp; (1 \u0026lt;= next_column \u0026amp;\u0026amp; next_column \u0026lt;= 8)) {\rresult++;\r}\r}\rSystem.out.println(result);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 왕실의 기사","id":86,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"왕실의 기사 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/royal_knight/"},{"content":"Education Interest Fields Project KTDS 2019.10 ~ Present  Actual Expense Calculation System [Development, Operation]\n Introduction :  Develop and operate a system that calculates the actual construction expenses of subcontractors such as expenses for employee insurance, safety management, waste disposal, and private inventory storage based on submitted data and evidence for KT.\n Technical  Web backend (Java, ExtJs Framework, OracleDB) Web frontend (html, css, JS, jQuery, Jsp) Versioning : Subversion (feature branch, code review) DevOps : Provide a reliable integrated automation system by building, testing, distributing, etc. using Jenkins Dependency Management : Increase maintenance and decrease dependency using Maven  Task (Skills)  Employee Attendance and Approval System  Develop a system that calculates actual expenses for National Health Insurance, National Pension Service, and Long-Term Care Insurance Develop a statement of accounts exporting function Decrease expenses through payment of calculated insurance expenses with the exact number of working days Deliver standardized and intuitive reports, decreased time consumption, and supported decision making with provision of the statement of accounts Optimize management of attendance through digitization and digitalization   Diagnose and Improve Source Vulnerability and Security  Diagnose source vulnerability regularly Prepare for hacking attacks through analysis and application of the latest hacking trends   Integrate Subcontracts of Guarantee and of Guarantor  Collaborate with other agencies through interfaces Ensure reliable real-time safe trading using the guarantee system   Achievement :  Since the opening of the actual cost settlement system on January, 2021, 5,603 cases of actual cost settlement have been paid, and 6,493 cases are under process.    TSK [2019.06 ~ 2019.10] Electronic Purchase System [Development]\no\tIntroduction : Developed an electronic purchasing system that provides electronic bidding, contracts, and orders for water treatment, waste disposal construction, and material delivery between TSK affiliates and partners. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask (Skills) •\tDeveloped systems for business registration, certification, and approval of partner companies\n Assisted in optimization •\tDeveloped electronic contract and contract report system Provide reliability to counterparties •\tIssued KTNET electronic tax invoice and installed certificate signing toolkit (tradesign) Integrated interface with other institutions Ensured reliability of the contract through issuance of electronic tax invoice  SK Home\u0026amp;service [2018.11 ~ 2019.05] Inventory Management System [Development, Operation]\no\tIntroduction : Developed a system for product management process and approval system, such as product application, order, and distribution, used by internal agents and equipment engineers\no\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of inventory application system\n Developed inventory management and application systems Ensure accurate measurement of inventory volume by systemizing inventory management Accelerated inventory management support for applying, ordering, transferring, etc. •\tDevelopment of (integrated) approval system Improved maintenance of collaborative usage of inventory and credit card by modularizing POS system Stabilized system Detected issues and updated system through periodic monitoring Distributed and created backup using shell scripts on Linux  SK Broadband [2018.08 ~ 2018.11] Advancement of HR System [Development]\no\tIntroduction : Developed an internal open recruiting system that recruits experts within the company in case of manpower issues at a particular department and a 52-hour flextime policy application process.\no\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of an internal open recruiting system process\n Partook in enabling reusage of repeated windows through modularization Reduced development time, increased reusage and improved maintenance •\tDevelopment of flextime policy application process Provided intuitive management of schedule by developing calendar-based window Maximized employee autonomy and work efficiency  KYOBO Life [2018.06 ~ 2018.07] Integrated Monitoring System [Development]\no\tIntroduction : Developed an interface, which receives data from other systems and equipment, for an integrated monitoring system, which provides figures such as status and traffic of infrastructure equipment, in the form of dashboards. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tIntegration with other systems\n Increased scalability by developing a variety of interfaces, including TUI, DB2DB, and File2DB •\tDevelopment of batch management system Enabled convenient and easy setting of batches by developing batch management system •\tDevelopment of Dashboard Assisted fast decision making by enabling intuitive log analysis through visualization of logs •\tSSO integration Provided convenient accessibility though shared sessions  Heungkuk Fire \u0026amp; Marine Insurance [2018.02 ~ 2018.05] Audit Information System [Development]\no\tIntroduction : Responsible for continuous monitoring to alert any anomaly in audit information system, Implements of audit process, and development of follow-up and approval process o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of continuous monitoring\n Detected and notified abnormal transactions through scenario-based data analysis Reduced the cost of time and maintaining reliability by preventing accidents in advance •\tImplements of audit Provided efficient management of the person in charge through history management and organization of an audit team Enabled convenient management of outputs, such as audit plans, audit checklist, review points, reports, etc. •\tDevelopment of follow-up process Assisted decision making by providing examples of outputs and decisions of prior audit cases as reference •\tDevelopment of approval process Increased efficiency through development of approval system Enabled collection and management of approval data  Korea Safety \u0026amp; Health Agency [2017.11 ~ 2018.01] Industrial Accident Prevention Information System ERP [Development]\no\tIntroduction : Developed protective equipment certification review process for the Industrial Accident Prevention Information System o\tTechnical •\tWeb Backend (Java, Spring Framework, Tibero, ibatis) •\tWeb Front (Nexacro Platform, Jsp, HTML5, CSS3, Ajax, JS Es6, jQuery) •\tVersioning : Subversion (feature branch, code review) o\tTask •\tProtective equipment certification application and approval\n Increased efficiency in management of certified equipment through registration Provided convenient registration and application process based on the approval status and processing order of certification tasks such as written examination, technical capability and production system examination, product examination by type, verification examination, autonomous safety verification report, etc.  Namsung Shipping [2017.08 ~ 2017.10] Cargo Trace Mobile [Development]\no\tIntroduction : Developed a contract management process that manages customer fares on site and contact management process that enables convenient searching and contacting of responsible department and personnel of Namsung Shipping. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tContract Management\n Increased speed and improved convenience for immediate response through customer fare management •\tDevelopment of Contact Us Developed a system that visualizes contact information of responsible department and personnel and that provides quick access to responsible personnel through phone calls and SNS  Samsung Asset Management [2017.04 ~ 2017.07] Development of Fund Solution [Development]\no\tIntroduction : Partook in development of fund products, home screens, research \u0026amp; insight, topic search, products of interest, and integrated search for fund solutions\no\tTechnical •\tWeb backend (Java, Struts Framewrk, racleDB) •\tWeb frntend (html, css, JS, jQuery, Jsp) •\tVersining : Subversin (feature branch, cde review) •\tDevps : Prepared for large volume of traffic using Lad Balancing •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tConfiguration of home screen in dashboard form to provides required information at a quick glance\n Developed themed-specific home screens such as main screen, solution, ETF focus, and research \u0026amp; insight Improved efficiency of response time through asynchronous processing method using AJAX •\tFund Products Developed detailed advanced search function that enables custom searches Provided intuitive interfaces by visualizing important indicators of the fund, including its type, operator, risk indicator, and yield Developed fund product lists with dynamic sorting capabilities using jqGrid Developed a user-friendly look-up by including a function to align funds by short-term and long-term returns •\tFund Comparison Developed fund comparison function that allows comparisons up to three products on one screen Improved efficiency of response time through asynchronous processing method using AJAX Provided the rate of return graphs for each fund using HighChart and the annual rate of return graphs for all funds being compared on one screen Optimized the range, legend, and form of reactive information of the graph\u0026rsquo;s x-axis y-axis through close collaboration with fund planners •\tResearch \u0026amp; Insight Improved maintenance and reduced development time through joint development of an integrated function that enables multiple dashboards to operate under the same module Provided user convenience by adding topics(tags) to each post to search for filtered results •\tIntegrated search Developed an integrated search engine with keyword searching function which provides all contents, that include the keyword, from Fund, ETF Focus, Research \u0026amp; Insight, and Knowledge PLUS Provided more detailed search capabilities by enabling searching within the search results Optimized SQL through query tuning o\tAchievement : •\tReceived Web Awards Korea 2017 Best Asset Management Award in the Financial Sector Link  JEJUair [2017.02 ~ 2017.04] Development of Pre-in-flight Meal Reservation System [Development]\no\tIntroduction : Developed a statistical system for in-flight meals sold by JEJUair. Statistics consisted of data by country/airport and the number of meal orders by meal supplier on pivot table, and detailed search conditions, such as period, flight number, supplier, in-flight meal, etc., provided desired statistical data at a glance.\no\tTechnical •\tWeb backend (Java, Spring Framework, Aws Aurora DB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of Statistical System\n Developed a statistical table using pivot queries that aggregate columns into rows Minimized response time through optimization and tuning of queries and increased efficiency through reduction of resource usage Developed jointly with SAP a system that collects data such as air schedules, countries, airports, in-flight meals, etc. through the Saf Jco Library •\tDiagnosed security vulnerabilities and developed security solutions using Coderay  Audien [2016.08 ~ 2017.01] Development of Web Streaming System [Development]\no\tIntroduction : Developed a back-end and front-end domain for all customer services, including product development, streaming, and escrow payment, at Audien (an audio book streaming content hybrid app company).\no\tTechnical\t\tWeb backend (Java, Spring Framework, OracleDB) \tWeb frontend (html, css, JS, jQuery, Jsp) \tVersioning : Subversion (feature branch, code review) \tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask \tDeveloped services for all products, such as home screen, list, detailed screen, shopping basket, purchase of voucher, and coupon registration, using audiobook as a product \tDeveloped with efficient response time through asynchronous processing using AJAX \tProvided the same functionality on WEB, Android, and IOS by developing a hybrid app \tCreated new customer value by launch audiobook web services that are not in the marketplace in collaboration with project managers \tDeveloped audio book categories, product lists, and detailed screens similar to e-libraries or online bookstores for convenient access by consumers. \tDevelopment of streaming player using opensource product \tDeveloped audio player using Video.js, an opensource product \tImplemented streaming tool using HLS(Http Live Streaming) protocol \tIntegration of payment service with escrow \tImplemented a secure payment system that asks the purchase intention once more to eliminate inefficient aspects such as simple change of mind, etc. before payment \tDeveloped, validated, and secured consumer-friendly and efficient systems by conducting integrated testing and unit testing \tAssisted transaction management through success processing and rollback processing by coherently combining the success and failure of payment services and business logic into one process\nFiNMART [2016.04 ~ 2016.07] Development of Loan Comparative Quote Hybrid App Service [Development]\no\tIntroduction : Developed a hybrid platform that provides loan quotes and developed a credit and real estate loan application system using used car dealer certification and dealer management in B2B format and customer credit information in B2C format.\no\tTechnical \tWeb backend (Java, Spring Framework, Maria DB) \tWeb frontend (html, css, JS, jQuery, Jsp) \tVersioning : Subversion (feature branch, code review) \tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask \tDevelopment of B2B used car dealer certification and dealer member management \tIncreased service credibility by developing used car dealer registration system that only registers vetted dealers \tDeveloped sale management system to enable dealers to register their vehicles for sale \tDevelopment of credit and real estate loan application functions \tDeveloped an intuitive user interface that divides loan applications into steps for convenient registration process on mobile screen \tImproved convenience by providing temporary saving in filling out loan applications \tDeveloped identity verification and credit score verification through KCB identity verification \tProvided optimal loan products from various financial institutions based on customer verification information \tDeveloped back-office processes after customer loan applications to facilitate bank and customer connectivity o\tAchievement : \tReceived Internet Biz Eco Award Grand Prize in Business Sector \tReceived Smart App Award Special Grand Prize \tReceived JB Financial Holding FinTech Competition Excellence Award\nSaerom Information Systems [2013.04 ~ 2015.07] Development of Groupware [Development]\no\tIntroduction : While working at Saerom Information Systems, a groupware company, partook in 9 groupware development projects for Yujin Machinery, the Supreme Court, Woongjin Holdings, Chunhajeil Feed, Leehan, Gamevil, Kelim Ceramics, Nasung Shipping, and Danal. In-house, developed, tested, and maintained solutions, worked on groupware porting and groupware customization, and assisted further development upon additional requests. o\tTechnical •\tWeb backend (Java, Spring Framework, IBM Lotus, IBM Notes, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) o\tTask •\tPortal\n Provided default menus and portlet based on user’s responsibility Improved convenience to users by developing portlet individualization function Provided intuitive services by visualizing payment progress •\tMail Provided collaboration and work efficiency through mail service Provided mail backup service using archive Prevented spams and strengthened security through mail monitoring •\tElectronic Approval Improved convenience by providing various basic templates to create additional required forms Enable detailed settings through options for each approval form •\tProject/Task Management Provided intuitive data on progression through visualization of data in Gantt Chart forms Provided systematic task management and inquiry functions •\tCommunity Developed survey function Developed popular post function Provided list function for responses to posts (comments, replies, interests) •\tIntegrated search Developed system menus and contact search functions •\tHR management Configured organizational chart using LDAP Developed tree-type organizational chart Developed restructuring and departmental management system •\tMultilingual Support Provided Korean/English as default languages Enabled infinite multilingual expansion capability through language packs Improved multilingual management convenience  ","description":"about me","id":87,"section":"","tags":[],"title":"About Me","uri":"https://offetuoso.github.io/about/"},{"content":"Git 캐시(cache) 삭제 // 원격 저장소와 로컬 저장소 파일을 삭제\r$ git rm 파일명\r// 원격 저장소에 있는 파일만 삭제하고, //로컬 저장소에 있는 파일은 삭제하지 않음\r$ git rm --cached 파일명\r rm -r 옵션\r// 파일 삭제\r$ git rm --cached 파일명\r// 폴더 하위의 모든 파일을 삭제\r$ git rm -r --cached 폴더명\r ","description":"깃 캐시 삭제","id":88,"section":"blog","tags":["Git"],"title":"Git 캐시 삭제","uri":"https://offetuoso.github.io/blog/develop/git/202105/time/"},{"content":"[문제1] 시각 [문제] 시각 : 문제 설명  정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하라. 예를 들어 1을 입력했을 때\n  다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다 00시 00분 03초 00시 13분 30초\n  반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다 00시 02분 55초 01시 27분 45초\n [문제] 조건  조건 풀이시간 15분 시간제한 2초, 메모리 128mb\n  입력 첫째 줄에 정수 N이 입력된다.(0\u0026lt;=N\u0026lt;=23)\n  출력 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.\n  입력예시 5\n  출력예시 11475\n 아이디어  복잡하게 생각할 필요없이 하루는 86,400초로 00시00분00초 -\u0026gt; 23시59분59초 까지 모든 경우는 86,400로 경우의 수가 100,000 개도 되지 않기 때문에 모든 초를 센다 하여도 2초가 넘지 않는다.\n  모든 초를 조회하는 완전탐색 유형으로 생각하면된다.\n  모든 시간 분 초를 순회하며, 합쳐서 문자로 합쳐서 포함 여부를 조회한다.\n  파이썬 if(\u0026lsquo;3\u0026rsquo; in str(hour)+str(minute)+str(second)) : #활용\n  자바 if((\u0026quot;\u0026quot;+hour+minute+second).contains(\u0026ldquo;3\u0026rdquo;)){} //활용\n time1.py n = int(input())\rcount, hour, minute, second = 0, 0, 0, 0\rwhile True :\rif('3' in str(hour)+str(minute)+str(second)):\rcount += 1\rsecond += 1\rif second == 60 :\rminute += 1\rsecond = 0\rif minute == 60 :\rhour += 1\rminute = 0\rif hour == n+1 :\rbreak\rprint(count)  파이썬 모범답안 n = int(input())\rresult = 0;\rfor h in range(n+1) :\rfor m in range(60) :\rfor s in range(60) :\rif('3' in str(h)+str(m)+str(s)) :\rresult += 1\rprint(result)\r Time.java package ex.Algorithm.implement;\rimport java.util.Scanner;\rpublic class Time{\rpublic static void main(String args[]) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint hour = 0;\rint minute = 0;\rint second = 0;\rint count = 0;\rwhile (true) {\rif((\u0026quot;\u0026quot;+hour+minute+second).contains(\u0026quot;3\u0026quot;)) {\rcount++;\r}\rsecond++;\rif(second == 60){\rminute ++;\rsecond = 0;\r}\rif(minute == 60){\rhour ++;\rminute = 0;\r}\rif(hour == n+1){\rbreak;\r}\r}\rSystem.out.println(count);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 시각","id":89,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"시각 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/time/"},{"content":"[문제1] 상하좌우 [문제] 상하좌우 : 문제 설명  여행가 A는 N × N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다\n  계획서에는 하나의 줄에 띄어쓰기를 기준으로 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다. 각 문자의 의미는 다음과 같다\n  L: 왼쪽으로 한 칸 이동 R: 오른쪽으로 한 칸 이동 U: 위로 한 칸 이동 D: 아래로 한 칸 이동\n  이때 여행가 A가 N × N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다 예를 들어 (1, 1)의 위치에서 L 혹은 U를 만나면 무시된다 다음은 N = 5인 지도와 계획이다\n [문제] 조건  조건 풀이시간 15분 시간제한 1초, 메모리 128mb\n  입력 첫째 줄에 공간의 크기를 나타내는 N이 주어집니다. (1\u0026lt;=N\u0026lt;=100) 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어집니다. (1\u0026lt;=이동 횟수\u0026lt;=100)\n  출력 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X,Y)를 공백으로 구분하여 출력한다.\n  입력예시 5 R R R U D D 출력예시 3 4\n up-down-left-right1.py n = int(input()) # map의 최대 크기\rm = list(map(str, input().split())) #공백으로 구분된 이동플랜\rx, y = 1, 1\t# 시작위치\rfor move in m: # 입력받은 이동 커맨드\rif (move == \u0026quot;U\u0026quot;) and (x - 1) \u0026gt; 0: # U (x-1, y)를 x-1이 1보다 작아지지 않는 선에서 수행 x -= 1\relif (move == \u0026quot;D\u0026quot;) and (x + 1) \u0026lt;= n : # D (x+1, y)를 x+1이 n보다 커지지 않는 선에서 수행 x += 1\relif (move == \u0026quot;L\u0026quot;) and (y - 1) \u0026gt; 0: # L (x, y-1)를 y-1이 1보다 작아지지 않는 선에서 수행 y -= 1\relif (move) == \u0026quot;R\u0026quot;) and (y + 1) \u0026lt;= n : # R (x, y+1)를 y+1이 n보다 커지지 않는 선에서 수행 y += 1\rprint(x,' ',y)  up-down-left-right1.py n = int(input())\rm = input().split()\rx, y = 1, 1\rmove_type = ['U','D','L','R']\rdx = [-1, +1, 0, 0]\rdy = [0, 0, -1, +1]\rfor move in m:\rfor i in range(0, len(move_type)) :\rif move == move_type[i] :\rif( 1 \u0026lt;= x+dx[i] \u0026lt;= n and 1 \u0026lt;= y+dy[i] \u0026lt;= n ) :\rx += dx[i]\ry += dy[i]\rprint(x,' ',y)\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 상하좌우","id":90,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"상하좌우 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202104/up-down-left-right/"},{"content":"[문제1] 숫자 카드 게임 [문제] 숫자 카드 게임 : 문제 설명  숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.\n  숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.   모든 행을 순회 하여, 행의 가장 작은 수중에 가장큰 수를 찾기\n  카드들이 N X M 형태로 놓여 있을 때, 게임의 룰에 맞게 카드를 뽑는 프로그램을 만드시오.\n [문제] 조건  조건 시간 1초, 메모리 120mb\n  입력조건 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다. (1 \u0026lt;= N,M \u0026lt;= 100) 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수이다.\n  출력조건 첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다\n  입력예시 3 3 3 1 2 4 1 4 2 2 2\n  출력예시 2\n  입력예시 2 4 7 3 1 8 3 3 3 4\n  출력예시 3\n 아이디어  각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수 찾기 list에서 가장 작은 원소를 찾아주는 min() 함수 이용 입력 파라메터 중에서 가장 큰 원소를 찾아주는 max(a, b) 함수 이용\n game_of_number_card.py n, m = map(int, input().split())\rresult = 0\rfor i in range(n):\rdata = list(map(int, input().split()))\rminumum = min(data)\rresult = max(result, minumum)\rprint(result)  GameOfCard.java package ex.Algorithm.greedy;\rimport java.util.Arrays;\rimport java.util.Scanner;\rpublic class GameOfCard {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint result = 0;\rString n = sc.nextLine();\rString m = null;\rString arr[] = n.split(\u0026quot; \u0026quot;);\rint maximum = 0;\rfor (int i = 0; i \u0026lt; Integer.parseInt(arr[0]); i++) {\rm = sc.nextLine();\rString row[] = m.split(\u0026quot; \u0026quot;);\r//자바 String배열 -\u0026gt; int배열로 변경 Java8 기준\rint[] nums = Arrays.asList(row).stream().mapToInt(Integer::parseInt).toArray();\r/*\rint[] nums = new int[row.length];\rfor(int j=0; j\u0026lt;row.length; j++) {\rnums[j] = Integer.parseInt(row[j]);\r}\r*/\rArrays.sort(nums);\rif(maximum \u0026lt; nums[0]) {\rmaximum = nums[0];\r}\r}\rSystem.out.println(maximum);\r}\r}\r 파이썬 모범답안 1 #n, m을 공백으로 구분하여 입력받기\rn, m = map(int, input().split())\rresult = 0\r#한 줄씩 입력받아 확인\rfor i in range(n):\rdata = list(map(int, input().split(\u0026quot; \u0026quot;)))\r# 현재 줄에서 '가장 작은 수' 찾기\rmin_value = min(data)\r# '가장 작은 수'들 중에서 가장 큰 수 찾기\rresult = max(result, min_value)\rprint(result)\r 파이썬 모범답안 2 #n, m을 공백으로 구분하여 입력받기\rn, m = map(int, input().split())\rresult = 0\r#한 줄씩 입력받아 확인\rfor i in range(n):\rdata = list(map(int, input().split()))\rmin_value = 10001\r#현재 줄에서 '가장 작은 수' 찾기\rfor a in data :\rmin_value = min(min_value, a)\r#'가장 작은 수 중'에서 가장 큰 수 찾기 result = max(result, min_value)\rprint(result)\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 숫자 카드 게임","id":91,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"숫자 카드 게임 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/games-of-number-card/"},{"content":"[문제1] 큰 수의 법칙 [문제] 큰 수의 법칙 : 문제 설명  출제자는 큰 수의 법칙을 본인만의 방식으로 다르게 사용하고 있다. 이 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙이다. 단 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.\n  예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.\n  배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 출제자의 큰 수의 법칙에 따른 결과를 출력하시오\n [문제] 조건  조건 시간 1초, 메모리 120mb\n  입력조건 첫째 줄에 N(2 \u0026lt;= N \u0026lt;= 1,000), M(1 \u0026lt;= M \u0026lt;= 10,000), K(1 \u0026lt;= K \u0026lt;= 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다. 입력으로 주어지는 K는 항상 M보다 작거나 같다\n  출력조건 첫째 줄에 큰 수 의 법칙에 따라 더해진 답을 출력한다\n  입력예시 5 8 3 2 4 5 4 6\n  출력예시 46\n 아이디어  최초 while 안에 k번의 반복문을 두어 큰수를 반복시키려고 했다만 문제 조건의 시간과 메모리의 조건이 있어 최대 입력값인 1000, 10000, 10000 이라면 열심히 풀고도 오답이 나올것이다.\n  n m k 5 7 2 2 1 5 4 3\n  {5, 5, 4, 5, 5, 4, 5}\n  코딩문제인줄 알았으나 수열문제 였다. 일단 5의 갯수를 세어 count * 5로 반복문 없이 계산을 하려한다.\n  첫번째로 반복되는 수열중 5의 갯수를 구하는 법이다. 반복되는 5, 5, 4는 (k+1) 3이며 전체의 총 개수에서 몇번 사용할 수 있는지 생각해 보면 m // (k+1) 몫은 2가 나온다. 여기에 k를 다시 곱해준다 (m // (+1) 2)*k 여기까지 계산하면 반복되는 수열중의 제일 큰 수를 계산한다.\n  하지만 수열에 포함되지 않은 5의 갯수를 더해줘야한다. 딱 나눠떨어지면 0, 나머지가 있다면 나머지 만큼의 5를 더해 줘야한다. 여기에 자주 쓰이는 % 연산자가 있다\n  m % (k+1) 으로 1이나온다. 나머지의 갯수를 계산하는 식 m % (k+1)\n  count = (m // (+1) 2)*k count += m % (k+1)\n  이렇게 하면 {(5), (5), 4, (5), (5), 4, (5)} 5의 개수를 얻었고 이제 4의 개수를 얻어보자 아까 구했던 수열이 반복되는 (m // (k+1)) 만큼 4를 곱해준다\n  count2 = (m // (k+1)) 나머지는 2번째 수가 나오지 못하여, 몫으로 안떨어지고 나머지가 된것이기 때문에 2번째 큰수는 나머지 추가로 더해줄게 없다\n  result = (count첫번째큰수)+(count2두번째큰수)\n law_of_large_number.py n, m, k = map(int, input().split()) l = list(map(int, input().split()));\rl.sort();\rfirst = l[n-1] second = l[n-2]\rcount = (m // (k+1))*k count += m % (k+1)\rcount2 = (m // (k+1)) #m-count\rresult = (count*first) + (count2*second)\rprint(result)\r LawOfLargeNumber.java package ex.Algorithm.greedy;\rimport java.util.Arrays;\rimport java.util.Collections;\rimport java.util.Scanner;\rpublic class LawofLargeNumber {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint result = 0;\rString str1 = sc.nextLine();\rString str2 = sc.nextLine();\rint n = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[0]);\rint m = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[1]);\rint k = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[2]);\rString list[] = str2.split(\u0026quot; \u0026quot;);\rArrays.sort(list);\rint first = Integer.parseInt(list[n-1]);\rint second = Integer.parseInt(list[n-2]);\r//System.out.println(\u0026quot;n\u0026quot;+n);\r//System.out.println(\u0026quot;m\u0026quot;+m);\r//System.out.println(\u0026quot;k\u0026quot;+k);\r//System.out.println(\u0026quot;first\u0026quot;+first);\r//System.out.println(\u0026quot;second\u0026quot;+second);\r//5 5 4 5 5 4 5\rint count = (m/(k+1))*k;\rcount += m%(k+1);\rint count2 = m-count; //System.out.println(count);\rresult = (count*first) + (count2*second);\rSystem.out.println(result);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 큰수의 법칙","id":92,"section":"blog","tags":["Algorithm","Greedy","이코테","수열"],"title":"큰수의 법칙 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/law-of-large-number/"},{"content":"   a. touching (\u0026lsquo;감동시키는\u0026rsquo;) a. entertaining (\u0026lsquo;재미있는\u0026rsquo;)  It was really entertaining and the storyline was also a bit touching(sad). (정말 재미 있었고 스토리 라인도 약간 감동적이었습니다.)\n These days (\u0026lsquo;요즘\u0026rsquo;) = Nowadays  These day , I go to bed in 1 am and (get up) 7 am (요즘은 새벽 1시에 자고 아침 7시에 일어나)\n On weekends (\u0026lsquo;주말에\u0026rsquo;) get up at (~ time) ('-시에 일어나') still (\u0026lsquo;여전히\u0026rsquo;)  On weekends, I get up at 1 pm and still go to bed the same (주말에는 오후 1시에 일어나도 똑같이 잠자리에 든다)\n ~ hours ('-시간')  I sleep for 9 hours (난 9시간 동안 잔다.)\n When A, then B. (\u0026lsquo;A 하면 B합니다.')  When I very tired, then has insomnia. (내가 매우 피곤하면 불면증이 생깁니다.) → I have a hard time falling asleep quickly, especially when I’m very tired. (나는 특히 내가 매우 피곤할 때 빨리 잠들기가 힘듭니다.)\n especially (\u0026lsquo;특히\u0026rsquo;) I am always (\u0026lsquo;난 항상\u0026rsquo;) ~I always a little tired and I drinking a lot of coffee.~\n I am always a little tired and I drink a lot of coffee. (나는 항상 조금 피곤하고 커피를 많이 마신다.)\n a lot (\u0026lsquo;많이\u0026rsquo;)  I watch Netflix a lot. (나는 넷플릭스를 많이 봅니다.) I had drinking a lot of coffee. (나는 커피를 많이 마셨다.)\n Have p.p ('-했다.\u0026rsquo; 현재완료 시점)  I have be growth (나는 성장했다.)\n Have been p.p ('-되어졌다.' 현재완료 시점)  I Have been healthed (나는 건강해졌다.) I Have been fired (나는 해고당했다.)\n Have been ~ing ('-해 오고 있다.' 현재완료 진행형으로)  I have been learning English for three weeks. (저는 3 주 동안 영어를 배우고 있습니다.)\n be ~ing ('-하고 있어')  I am drinking a coffee (나는 커피를 마시고 있다) I am trying to get some sleep (잠을 좀 자려고 해요) I am learning English (나 영어 배우고 있어) I am having a talk with A (나 A와 이야기 하고 있어요)\n how I can get to A / how to get to A (\u0026lsquo;A에가는 방법\u0026rsquo;)  how I can get to 안양천 how to get to 안양천\n remain (\u0026lsquo;남다\u0026rsquo;)  the question remains (문제가 남아있다.)\n remaining (\u0026lsquo;남아있는\u0026rsquo;)  The remaining amount (남은 금액)\n recommend (\u0026lsquo;추천하다/권장하다\u0026rsquo;) recommended (\u0026lsquo;추천하는/권장되는\u0026rsquo;)  recommended posts, groups that are relative to you\n strongly recommend (\u0026lsquo;강력추천\u0026rsquo;) The recommended amount of ~ ('-권장량')  The recommended amount of sleep (권장 수면량)\n I had a hard time (\u0026lsquo;나는 힘들었다.') fluently (\u0026lsquo;유창한\u0026rsquo;)  I have a hard time speaking English fluently (영어를 유창하게 말하는 것이 힘들다)\n frustrating (\u0026lsquo;좌절/실망\u0026rsquo;)  This solution is so frustrating. (이 솔루션은 너무 실망 스럽습니다)\n 문법오류 It was so funny and also sad. → It was really entertaining and the storyline was also a bit sad/touching.\rThese days (Nowadays) , I go to bed in 1 am and (get up) 7 am → at + time\rWhen I weekend, then I get up at 1pm but I still go to bed at 1 am. → On weekends, I get up at 1 pm and still go to bed the same.\r9 o’clock → 9 hours\rweak insomnia. When I very tired, then has insomnia.\r→ I have a hard time falling asleep quickly, especially when I’m very tired.\rI always a little tired and I drinking a lot of coffee. → I am always a little tired and I drink a lot of coffee. I watch Netflix a lot.\rI had drinking a lot of coffee.\rhave V-ing. → have been V-ing\rI have been learning English for three weeks.\rI have tried watching Mr. Sunshine, but it’s not my style.\rHave you tried bungee jumping? No, I haven’t.\rbe V-ing. ; I am drinking a coffee, I am trying to get some sleep, I am learning English (I’m learning how to speak in English), I am having a talk with Kihun.\rc.f. how I can get to 안양천, how to get to 안양천\rShe is having a rest → She is taking a rest.\rWhat are you doing? → I am doing ~.  새로배운 표현 remain 남다, remaining 남아있는\rthe question remains = there lies the question, the question is “-”\rThe remaining amount\rrecommend (v) → recommended (a) 1. 추천하다 (추천하는), 2. 권장하다 (권장되는)\rrecommended posts, groups that are relative to you\rI really/strongly recommend ~. (I strongly recommend (watching) Mr. Sunshine)\rThe recommended amount of _____.\rinfluence (v) → have an influence on sth\rhave a hard time V-ing\rI have a hard time speaking English fluently.\rWhen I was in middle school, I had a hard time getting up early.\rWhen I was a high school student, I had a hard time studying at school.\rfrustrating (a)\rThis problem set is so frustrating.\rCoding is so frustrating. / Coding really frustrates me.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":93,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.08","uri":"https://offetuoso.github.io/blog/english/202104/20210408-english-speak/"},{"content":"go to ~ ('-에 간다')  I go to company. (나는 회사에 간다.)\n be going to ~ ('-에 갈꺼다')  I\u0026rsquo;m going to market. (나는 마트에 간다. 갈예정이 있음 )\n be going to go to ~ ('-에 갈꺼야')  I\u0026rsquo;m going to go to korea. (나는 한국에 갈꺼야. 아직 계획은 세우지 않았음 )\n went to ~ ('- 갔었다 \u0026lsquo;)  I went to starfield. (나는 스타필드에 갔었다.)\n how can I get to the ~ ? ('- 까지 어떻게 가나요?')  Excuse me, how can I get to the \u0026lsquo;동대문 market\u0026rsquo;? (동대문 시장까지 어떻게 가나요?)\n Can you tell me where the ~ is ? ('-가 어디에 있는지 말해 줄 수 있습니까?')  Can you tell me where the bus station is? (버스 정류장이 어디인지 말해 줄 수 있나요?)\n Can you tell me how I can ~ ? (\u0026lsquo;어떻게 - 할 수 있는지 말씀해 주시겠습니까?')  Can you tell me how I can use this machine? (이 기계를 어떻게 사용할 수 있는지 말해 줄 수 있습니까?)\n I’d like to know how to get to the ~. ('-에가는 방법을 알고 싶습니다.')  I’d like to know how to get to the 안양천 (안양천에가는 방법을 알고 싶습니다.)\n purpose (\u0026lsquo;목적\u0026rsquo;) Grammar Error: I go to the workspace and → I went to the company and there were flowers (cherry blossoms) on the side of the roads nearby the company building.\rNew expressions learned today: strategy (n) 요령 → 전략\rskills vs. strategies\rpurpose 목적\rWhich subway station should I go to / to get to 안양천?\rCould you tell me how to spell it?\rExcuse me, how can I get to the _(location)_?\rCan I ask you a question?\rDo you know where _(location)_ is?\rCan you tell me where the bus station is? / how I can get to (location)?\rCan you tell me how I can use this machine?\rCan you tell me how to use this machine?\rI’d like to know how to get to the _(location)_.\rPardon me for asking, but ...\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":94,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.07","uri":"https://offetuoso.github.io/blog/english/202104/20210407-english-speak/"},{"content":"[문제1] 1이 될때까지 [문제] 1이 될때까지 : 문제 설명  어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n [문제] 조건  입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n make_one.py n, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  MakeOne.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"모험가 파티를 만드는 알고리즘","id":95,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"모험가 길드 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/adventurer-guild/"},{"content":"prepare (\u0026lsquo;준비하다\u0026rsquo;)  Pick/Choose two questions and prepare your answers. (두 가지 질문을 고르고 답을 준비하십시오.)\n the meaning of the ~ ('-의 의미')  the meaning of the name. (이름의 의미) The meaning of one’s name may have an influence on their life. (이름의 의미가 그들의 삶에 영향을 미칠 수 있습니다.)\n to have influence on ~ ('-에 영향을 미치다')  to have influence on life (삶에 영향을 미치다)\n v. affect ~ ('-에 영향을 미치다')  affect life (삶에 영향을 미치다)\n to affect positively/negatively = to bring a positive/negative effect on sth n. effect (\u0026lsquo;효과\u0026rsquo;)  effect of sleep (수면의 효과)\n strategy (\u0026lsquo;전략\u0026rsquo;)  skills and strategies (기술과 전략)\n Naming center (\u0026lsquo;작명소\u0026rsquo;)  It would be difficult to name my child based on astrology. (점성술에 근거하여 내 아이의 이름을 짓는 것은 어려울 것입니다.)\n make sure (\u0026lsquo;확실한\u0026rsquo;)  Make sure you do the dishes right after you eat. (식사 후 바로 설거지를하세요.) Make sure you give me the file by tomorrow. (내일까지 파일을 주셔야합니다.) = You must give me the file ~\n sure  Are you sure? (\u0026lsquo;확실합니까?') Are you sure you sent me the file via email? (이메일로 파일을 보냈습니까?)\n can you tell me again? (\u0026lsquo;다시 말해줄래?') = Can you repeat it once more? 문법오류 My name has an influence on positive effects on my life. (내 이름은 내 삶에 긍정적 인 영향을 미칩니다.)\r→ My name has an influence on my life. (내 이름은 내 삶에 영향을 미칩니다.)\r/ My name has a positive effect on my life. (내 이름은 내 삶에 긍정적 인 영향을 미칩니다.)\r→ My name gave/brought a positive effect on my life. (내 이름은 내 삶에 긍정적 인 영향을 미쳤습니다.)\r 새로배운 표현 to affect positively/negatively = to bring a positive/negative effect on sth\rmean (v) → meaning (n)\rS(n) + V (+ O(n) / + Adj.) (+ Adv.)\rone (n) 대명사로 쓰일 경우 → 그것, 한 사람\r조동사 - must, may/might, should/shall, would/will, have, celebrity (n) stars, famous people - Celebrity (IU) 셀럽\rCardi B - Culture, / North~West\rmake sure\rMake sure you do the dishes right after you eat.\rMake sure you give me the file by tomorrow. = You must give me the file ~\rsure → Are you sure? / Are you sure you sent me the file via email?\rI’m sure.\rSure. (Of course. No problem.)\rstrategy - skills and strategies\rCan you tell me again? = Can you repeat it once more?\rI’d like to know when the due date is.\rPardon me for asking, but where can I sign up for the membership?\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":96,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.02","uri":"https://offetuoso.github.io/blog/english/202104/20210402-english-speak/"},{"content":"##have influence on ~ ('-에 영향을 미치다')\n 동학개미 had some influence on the national stock market. (\u0026lsquo;동학 개미는 전국 주식 시장에 영향을 미쳤습니다.') I think, he has achievement that influence on some developer (\u0026lsquo;그는 일부 개발자에게 영향을 미치는 업적을 가지고 있다고 생각합니다.') I think, his achievement has some influence on [software developers/engineers.] (\u0026lsquo;그는 일부 개발자에게 영향을 미치는 업적을 가지고 있다고 생각합니다.') Netflix now has a huge influence on the media industry. (\u0026lsquo;Netflix는 이제 미디어 산업에 큰 영향력을 미치고 있습니다. \u0026lsquo;)\n say/ speak/ talk/ tell \u0026gt;\tsay (말하는 내용에 집중) 말하다\r- \u0026quot;i'm so tired \u0026quot; he said. (그가 \u0026quot;나는 피곤해\u0026quot; '라고 말했다')\r\u0026gt;\tspeak (1.말하는 행위, 2.언어를 사용할 수 있는 능력)말하다\r1. The teacher will speak about the test tomorrow (1. 선생님은 내일 시험에 대해 말할 것입니다)\r2. I can speak English (2. 나는 영어를 사용할 수 있습니다)\r\u0026gt; talk (말을 주고 받는 행위) 이야기하다, 말하다\r-\the talks too much (그는 말이 너무 많다)\r- We talked about the our future (우리는 우리의 미래에 대하여 이야기 했습니다)\r\u0026gt; tell (말하는 대상과 내용에 초점) 말하다 -\tI'll tell you what happened. (무슨 일이 있었는지 말씀 드리겠습니다.)\r 각 동사마다 표현하는 방법이 다르다 \u0026gt;\tsay\r1. 말하는 내용은 that\r- I say \u0026lt;mark\u0026gt;(that)\u0026lt;/mark\u0026gt; ~ (that 생략가능)\r2. 말하는 대상은 전치사 to 사용 - I say that ~ \u0026lt;mark\u0026gt;to\u0026lt;/mark\u0026gt; you (to를 붙여서 말하는 대상 추가)\r\u0026gt;\tspeak /talk\r1. 말하는 내용은 about\r- We speak \u0026lt;mark\u0026gt;about\u0026lt;/mark\u0026gt; the money\r- We talk \u0026lt;mark\u0026gt;about\u0026lt;/mark\u0026gt; the money\r2. 말하는 대상은 to 사용\r- They speak to me about the money\r- please talk to me about the money\r\u0026gt;\ttell *tell은 말하는 대상과 내용이 다 나와야 합니다\r1. 대상 tell [내용/명사] / 대상 tell about [내용/명사] 3형식 - she tells me the our future\r- they told him their product\r- she tells me about the our future\r- they told him about their product\r2. tell (대상) that (내용, 문장 형태(Phrase, 구))\r*내용이 ‘누가 뭘 했다’ 등 긴 내용을 말할 때 사용. (주어와 동사 필요)\r– Paul tells me that he likes to visit the new house.\r– They told him that they didn’t buy it.\r3. tell (대상) to do (something)\r*이 경우에는 주로 ‘(누구)에게 (무엇을 하라고)명령하다’라는 뜻으로 사용됩니다.\r– Paul tells me to clean my room.\r– They told him to show them his ID card.\r 전치사를 사용한 표현 \u0026gt;\t1. talk over: ~에 대해 (깊이) 이야기 하다\r– We talked over the new project.\r– Jason talked over his plan to Paris. \u0026gt;\t2. talk (대상) into (동명사): ~하도록 설득하다\r– He talked me into buying his new painting.\r– She talked him into sending a letter.\t say-speak-talk-tell은 아래 홈페이지에서 참조\r참고 : http://cafeclass.kr/say-speak-talk-tell-%EC%B0%A8%EC%9D%B4/\rAmerica(US)\u0026rsquo;s third gender \u0026gt; 1. He\r2. She\r3. Them\r plural (\u0026lsquo;복수형 more than one\u0026rsquo;) - a. the first person plural\r- n. the first person plural\r singular (\u0026lsquo;단수형 one\u0026rsquo;) - a. the third person singular form of the verb\r- n. the first person singular\r pass down (\u0026lsquo;전달받다, 물려받다\u0026rsquo;) (casual)  One of the parents’ family names is passed down to the child in Korea. (\u0026lsquo;한국에서는 부모의 성이 아이에게 전해집니다.')\n inherit (\u0026lsquo;상속하다\u0026rsquo;) (formal)  Instead of inheriting all the financial assets to his children, he donated 70% to the society. (\u0026lsquo;모든 금융 자산을 자녀들에게 물려주는 대신 사회에 70 %를 기부했습니다.')\n refer to (\u0026lsquo;인용하다\u0026rsquo;)  he was refer to sentence of poem (\u0026lsquo;그는시의 문장을 언급했다\u0026rsquo;)\n n. ancestor (\u0026lsquo;선조\u0026rsquo;) n. descendent (\u0026lsquo;후손\u0026rsquo;) \u0026gt; (de/di- : minus, later → decline, diminish)\r n. occupation (\u0026lsquo;직업\u0026rsquo;) prince and princess → princes and princesses (plural -es: is) 발음주의 연도읽기   1908 - nineteen-o-eight \u0026gt; nineteen-hundred and eight - The Olympics was held in Pyeongchang in 2018. - 2582 B.C. 2080, 2090   본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":97,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.01","uri":"https://offetuoso.github.io/blog/english/202104/20210401-english-speak/"},{"content":"[문제1] 곱하기 혹은 더하기 [문제] 곱하기 혹은 더하기 : 문제 설명  각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 \u0026lsquo;x\u0026rsquo; 혹은 \u0026lsquo;+\u0026rsquo; 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성. 단, + 보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정.\n   예를 들어, 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2)x 9)x 8)x 4) = 576이다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어짐.   [문제] 조건  입력조건 첫째 줄에 여러개의 숫자로 구성된 하나의 문자열 S가 주어집니다.(1\u0026lt;=S의 길이 \u0026lt;=20)\n  출력조건 첫째 줄에 만들어 질 수 있는 가장 큰 수를 출력합니다.\n  입력예시\n02984\n  출력예시\n576\n  문자열 내 연산자 계산 가능 메소드  eval()\rresult = eval('(3+5)*7')\rprint(result) # 56\r- 리스트 내 item들을 하나의 문자열로 만들어주는 메소드 list = ['a', 'b', 'c'] print(''.join(list)) # print: abc\r- 리스트에 item 추가 시, 위치 선정이 가능토록하는 메소드\r# list = ['a', 'b', 'c'] list.insert(0, \u0026quot;new\u0026quot;)\rprint(list) # ['new', 'a', 'b', 'c']  sum_or_multiply.py s = input()\rresult=0\rfor n in list(s) :\rif result == 0 or n == 0 or result == 1 or n == 1 : result += int(n)\relse :\rresult *= int(n)\rprint(result)\r 모범답안 파이썬 data = input()\rresult = int(data[0])\rfor i in range(1,len(data)) :\rnum = int(data[i])\rif num \u0026lt;= 1 or result \u0026lt;= 1:\rresult += num\relse:\rresult *= num\rprint(result)\r SumOrMultiply.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class SumOrMultiply {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rString s = sc.nextLine();\rint result = 0;\rfor (int i = 0; i \u0026lt; s.length(); i++) {\rint n = Integer.parseInt(s.substring(i, i+1));\rif(result == 0 || n == 0 || result == 1 || n == 1) {\rresult += n;\r}else {\rresult *= n;\r}\r}\rSystem.out.println(result);\r}\r}\r 모범답안 자바 package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class SumOrMultiply {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rString str = sc.nextLine();\rlong result = str.charAt(0) - '0';\rfor(int i=1; i \u0026lt; str.length();i++) {\rint num = str.charAt(i) - '0';\rif (num \u0026lt;= 1 ||result \u0026lt;= 1) {\rresult += num;\r}else {\rresult *= num;\r}\r}\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  곱하는 것보다 더하는 것이 더 큰 값을 얻을 수 있다. 곱해서 0또는 1이되는 상황보다, 곱하는게 큰 값을 얻는다\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"최고의 숫자가 되기 위하여 더하기 혹은 곱하기를 진행","id":98,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"더하기 혹은 곱하기 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/sum-and-multiply/"},{"content":"prefers a to b (\u0026lsquo;b 보다 a를 더 선호\u0026rsquo;)  we are prefers apple to banana (\u0026lsquo;우리는 바나나보다 사과를 선호합니다.')\n giving birth (\u0026lsquo;출산\u0026rsquo;) = when the baby was born  when the mother was giving birth (\u0026lsquo;어머니가 출산 할때\u0026rsquo;)\n n. name (\u0026lsquo;이름을 지어주다\u0026rsquo;)  How do American Indian women name their babies? (\u0026lsquo;아메리칸 인디언 여성들은 아기의 이름을 어떻게 지어주나요?')\n compound words (\u0026lsquo;합성어\u0026rsquo;)  handphone is compound word that Consists of two word? (\u0026lsquo;handphone은 두 단어로 구성된 합성어입니다.')\n consists of ~ ('-로 구성된\u0026rsquo;)  notebook consists of many material (\u0026lsquo;노트북은 많은 재료로 구성됩니다.')\n v. believe (\u0026lsquo;믿다\u0026rsquo;) n. belief (\u0026lsquo;신뢰\u0026rsquo;)  belief is very important (\u0026lsquo;믿음은 매우 중요합니다.')\n tend to do (\u0026lsquo;경향이 있다.')  Believer is tend to pray before have a eating (\u0026lsquo;신자는 먹기 전에기도하는 경향이 있습니다 \u0026lsquo;)\n 새로운 단어  belief 신뢰\rgiving birth 신뢰\rprefers 선호하다\rtend to do 경향이 있다.\r 문법오류 Yes, each culture has using same names. → I think there are some common names used in many cultures. For example, Yujin , Suzan, and Susie.\rbackground → American Indian women (tend to) choose their babies’ names from what they saw while giving birth. = American Indian women tend to name their babies from what they saw while giving birth.\rthere are believe the stars and planets influence → because there are beliefs that the stars and plants have important influence (on their lives).\rthey believe astrology and Zodiac.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":99,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.26","uri":"https://offetuoso.github.io/blog/english/202103/20210326-english-speak/"},{"content":"Introduction (\u0026lsquo;소개, 서론\u0026rsquo;) Introduction → Body → Conclusion  This pagraph is book of Introduction (\u0026lsquo;이 단락은 서론입니다.')\n topic sentence (\u0026lsquo;주제 문장\u0026rsquo;)  this is topic sentence in paragraph (\u0026lsquo;이것은 단락의 주제 문장입니다\u0026rsquo;)\n Q. What is a must-included item when you summarize a text? (\u0026lsquo;글을 요약할때 꼭 포함되어야 하는것?')  main points, paraphrase the topic sentence\n plagiarism (\u0026lsquo;표절\u0026rsquo;)  this book has relate to rumor of plagiarism (\u0026lsquo;이 책은 표절 소문과 연루되어 있습니다\u0026rsquo;)\n customize  (1) to personalize to make sth fit for a certain purpose/situation/…\n  (2) 관습 each culture has its favorite names and naming-customs, so here are some from around the world.\n traditions vs. custom (\u0026lsquo;전통과 관습\u0026rsquo;) occupation (n) (\u0026lsquo;직업, Job보다 캐쥬얼 하지 않은 뜻\u0026rsquo;)  job categories → occupation categories main occupation My main occupation is a programmer, but I also work as a part-time teacher.\n elder (\u0026lsquo;무리의 가장큰 어른\u0026rsquo;) all in all - in general, most of the time (\u0026lsquo;전체적으로 \u0026lsquo;) 새로운 단어 custom 관습\roccupation 직업\rplagiarism 표절\r 문법오류 name’s meaning → meaning of names\rWhat did we do yesterday? / We learned about the meaning of names from many cultures (around the world)\rThird paragraph is the topic’s examples. Topic is culture’s names\r→ This text is introducing different naming cultures around the world. It gives/includes examples of Mongolian, North American Indian, Eskimo, and Russian cultures.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":100,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.25","uri":"https://offetuoso.github.io/blog/english/202103/20210325-english-speak/"},{"content":"Read the sentences (\u0026lsquo;문장 읽기\u0026rsquo;)  you must to read the sentences in book (\u0026lsquo;책에있는 문장을 읽어야합니다\u0026rsquo;)\n Read the sentences (\u0026lsquo;문장 읽기\u0026rsquo;)  you must to read the sentences in book (\u0026lsquo;책에있는 문장을 읽어야합니다\u0026rsquo;)\n some (\u0026lsquo;약간, 전체는 아니고, 아예 아닌것도 아님\u0026rsquo;)  some people who attempt to change (\u0026lsquo;변화를 시도하는 사람들\u0026rsquo;)\n 새로운 단어 passage 문구 / 통로\rsilently 잠자코, 조용히\rrepeat 반복\rintonation 말의 높낮이\rsome not all but not none\r 문법오류 I was weekends also studying English and.. --\u0026gt; I spudied during the weekends.\r--\u0026gt; I had to study during the weekends.\r(Subject Noun+ Action Verb + etc)\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":101,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.24","uri":"https://offetuoso.github.io/blog/english/202103/20210324-english-speak/"},{"content":"[문제1] 1이 될때까지 [문제] 1이 될때까지 : 문제 설명  어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n [문제] 조건  입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n make_one.py n, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  MakeOne.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"1이 될때까지 알고리즘.","id":102,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"1이 될때까지 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/make-one/"},{"content":"[문제1] 거스름돈 [문제] 거스름돈 : 문제 설명  당신은 음식점의 계산을 도와주는 점원입니다. 카운트에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈은 N은 항상 10의 배수입니다.\n [문제] 거스름돈 : 문제 해결 아이디어   최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐의 단위부터 돈을 거슬러 주면 됩니다. N원을 거슬러 줘야 할 때, 가장먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러줍니다. 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러주면 됩니다. N = 1,260일 때의 예시를 확인해 봅시다.    1,260 원을 500원부터 거슬러 준다면 아래와 같이\n    화페단위 500 100 50 10     손님이 받은 개수 2 2 1 1    [문제] 거스름돈 : 정당성 분석   가장큰 화폐단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요? 가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다. 만약 800원을 거슬러 주어야 하는데 화폐 단위가 500원 400원 100원이라면 어떻게 될까요 ? -\u0026gt; 400원 짜리 2개가 정답이됨 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 합니다.   reverse_change.py n =1260\rcount = 0 array = [500,100,50,10]\rfor coin in array:\rcount += n / coin\rn %= coin print(count)\r ReverseCharge.java package ex.Algorithm.greedy;\rpublic class ReverseCharge {\rpublic static void main(String[] args) {\rint n = 1260;\rint[] coins = {500,100,50,10};\rint count = 0;\rfor (int coin : coins) {\rcount += n/coin;\rn %= coin;\r}\rSystem.out.println(count);\r}\r}\r [문제] 거스름돈 : 시간 복잡도 분석   화폐의 종류가 K라고 할때, 소스코드의 시간복잡도는 O(K)이다. 이 알고리즘의 시간복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":103,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"거스름돈 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/reverse-charge/"},{"content":"그리디 알고리즘(탐욕법) 그리디 알고리즘이란 ?  그리디 알고리즘이란\n 그리디 알고리즘(탐욕법)은 현재상황에서 가장 좋은 것만 고르는 방법을 의미. 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 있는 능력을 요구. 그리디 해법은 그 정당성 분석이 중요. 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토 필요.   [문제 상황] 루트 노드로 부터 시작하여 가는 노드의 합을 최대로 만들고 싶습니다.  Q. 최적의 해는 무엇인가요 ?\n  Q. 단순히 매 상황에서 가장큰 값을 고른다면 어떻게 될까요?\n   일반적인 상황에서 그리디알고리즘은 최적의 해를 보장할 수 없을때가 많다. 하지만 코딩 테스트에서의 대부분의 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됨.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":104,"section":"blog","tags":["Algorithm","Greedy"],"title":"그리디 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/greedy-algorithm/"},{"content":"do you mind?  (1) Are you okay/fine with it? (\u0026lsquo;괜찮나요?') Do you mind if I change the schedule? 괜찮다면, 스케쥴을 변경해도 될까요? (2) Mind your own business. (\u0026lsquo;니 일이나 신경써.') Do you mind? 니 일이나 신경써.\n attempt to ~ ('-를 시도하다.')  they are attempt to find something 그들은 무언갈 찾으려 한다. i attempt to speaking english 나는 영어로 말하길 시도한다.\n I had a meeting ~ ('-를 만났다.')  I had a meeting with english teacher 나는 영어 선생님과 Meeting을 가졌다.(만났다.) I had a meeting with my friends 나는 친구를 만났다\n - means ~ ('-의 뜻은 -입니다\u0026rsquo;)  **my name\u0026rsquo;s means a victory ** 내 이름은 승리를 의미합니다. **\u0026lsquo;팽-하\u0026rsquo; means \u0026lsquo;펭수 하이\u0026rsquo; ** \u0026lsquo;펭-하\u0026rsquo;는 \u0026lsquo;펭수-하이\u0026rsquo;를 뜻합니다.\n a. accurate (\u0026lsquo;정확한\u0026rsquo;)  **Do you think the information on the table is accurate? ** 테이블의 정보가 정확하다고 생각하나요?\n familiar with (\u0026lsquo;익숙한\u0026rsquo;)  **familiar with the technical terms ** 기술 용어에 익숙 함\n n. accuracy (\u0026lsquo;정확\u0026rsquo;) v. intend (\u0026lsquo;의도하다\u0026rsquo;)  **I didn’t intend to offend you(her) when I laughed at your(her) new haircut. ** 당신의 새 머리를 보고 웃은 것은 마음을 상하게 할 의도는 없었어요.\n 새로운 단어 honorable contribution 명예로운 공헌\rachievement 업적\rmaterial 재료\rconversation 대화\rjudgement 판단\rnervous 긴장한\r 문법오류 one time ago → an hour ago\rI has → had a meeting with Sophia an hour ago\rI have a class with June today.\rWe call him an old-fashioned man. Olivia is meaning → Olivia means Olive and peace.\rI have heard of ~\rI’ve heard of Jack from the book, I’m also familiar with the name Charlie.\rI think the Korea column is not that accurate.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":105,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.19","uri":"https://offetuoso.github.io/blog/english/202103/20210319-english-speak/"},{"content":"Did you take a look at ~? ('-보셨나요?')  Did you take a look at the Book 책 보셨나요? Did you take a look at sky? 하늘을 보셨나요?\n I took a look at ~ (\u0026lsquo;나는 -를 보았다.')  I took a look at the book, 1 hour ago 1 시간 전에 책을 봤어요. I was took a look at sky last day 나는 어제 하늘을 봤어요\n a. impressed (\u0026lsquo;깊은 인상\u0026rsquo;) n. impression (\u0026lsquo;인상\u0026rsquo;) I’m impressed by ~ (\u0026lsquo;나는 당신의 -에 감동받았습니다.')  I’m impressed by your letter 나는 당신의 편지에 감동받았습니다. I’m impressed by your passion 나는 당신의 열정에 감동받았습니다.\n related to ~ ('-와 연관되다.')  I think, he is related to crime 그는 범죄와 관련된 것 같아요. my homework relate to math 나의 숙제는 수학과 관련있다.\n v. skim  He always skimmed the book 그는 항상 책을 훑어보았다.\n v. scan a. intermediate (중급의) beginners → intermediate → high/advanced level\r  He was in intermediate class, 3 month ago 그는 3개월 전에 중급반이였다.\n 영어 8품사 사전 표기법 \rn. 명사 (noun [naun] )\r-모든 사람, 사물, 동물의 이름을 나타내는 단어\r-문장에서 주어, 보어, 목적어가 된다.\r*C : 가산명사\r*U : 불가산명사\r*CU : 주로 가산명사\r*UC : 주로 불가산명사\r*sing. : 단수형\r*pl. : 복수형\r*n.pl. : 복수명사\r*fem. : 여성형\r*neg. : 부정형\rpron. 대명사 (pronoun [próunàun] )\r-인칭대명사: I, my, me, mine, myself, she, her, he, his, him 등\r-지시대명사: it, this, these, that, those 등\r*obj : 목적격\r*poss : 소유격\rv. 동사 (verb [vəːrb] )\rvtr. 타동사 (Transitive Verb)\rvi. 자동사 (Intransitive Verb)\r-동작이나 상태를 나타내는 단어\r-be동사 : am, are, is, was, were 등\r-일반동사 : be동사와 조동사를 제외한 나머지 동사\r*auxil. v. : 조동사 - can, may, will, should, must 등\r*p. : 과거형\r*p.p. : 과거분사형\r*pres.p. : 현재분사\r※목적어로 구분하는 자동사와 타동사\r자동사 : 목적어를 취하지 않는 동사\r타동사 : 목적어를 취하는 동사\r동사뒤에 목적어(영향을 받는 사람이나 사물)(이)가 필요한지 여부에 따라서\r자동사(Intransitive Verb)와 타동사(Transitive Verb)로 구분할 수 있습니다. adj. (or a.) 형용사 (adjective [ǽdʒiktiv] )\r-명사나 대명사를 수식하거나 보충 설명하는 단어\r-우리말에서 보통 \u0026lt; ~ㄴ, ~한\u0026gt; 으로 해석되는 단어\radv. (or ad.) 부사 (adverb [ǽdvəːrb] )\r-형용사, 다른 부사, 동사, 문장전체를 수식하는 단어\r-① 형용사 / 다른 부사 수식 : This is a very very delicious cake.\r-② 동사 수식 : She can run fast.\r-③ 문장 전체 수식 : Luckily, I passed the exam.\rprep. 전치사 (preposition [prèpəzíʃən] ) -명사나 대명사 앞에 쓰여서 장소, 시간 등을 나타내는 단어\r-in, at\r*pref. : 접두사\r*suf. : 접미사\rconj. 접속사 (conjunction [kəndʒΛŋkʃən] )\r-단어와 단어, 문장과 문장 등을 연결하는 단어\r-when, or, and\rinterj. (or int.) 감탄사 (interjection [ìntərdʒékʃən] )\r-놀람, 기쁨 등 감정을 나타내는 단어\r-Oh, Wow\r출처: https://fireball.tistory.com/409 [What's up]\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":106,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.17","uri":"https://offetuoso.github.io/blog/english/202103/20210317-english-speak/"},{"content":"I use ~ (\u0026lsquo;난 -를 사용한다.')  I use Java 난 자바를 사용한다. I use Korean 난 한국어를 사용한다.\n I’m preparing ~ ('-를 준비중입니다\u0026rsquo;)  ** I’m preparing to change job ** 나는 이직을 준비중입니다. ** I’m preparing to party in my house ** 우리 집에서 파티를 준비하고 있어요.\n ~ is intense ('-이 ~빡세다~힘들다.')\n Work is not intense 일은 힘들지 않다. Always Study is intense 공부는 힘들다.\n I learned ~ (\u0026lsquo;나는 -배웠다\u0026rsquo;)  I learned computer science in my University 나는 대학에서 컴퓨터를 전공했다. I learned baking bread 나는 빵굽기를 배웠다.\n I want to ~ ('-하고 싶습니다.')  I want to hold your hand 당신의 손을 잡고 싶습니다. I want to change job! 이직하고 싶어요!\n I\u0026rsquo;m good at ~ (\u0026lsquo;나는 -잘해\u0026rsquo;)  I\u0026rsquo;m good at make smile 나는 미소를 잘 짓습니다. I\u0026rsquo;m good at cleaning my room 나는 내방 청소를 잘해요\n I\u0026rsquo;m about to ~ (\u0026lsquo;나는 -할 예정이다\u0026rsquo;)  I\u0026rsquo;m about to go to bed 나는 자러갈 예정이다. I\u0026rsquo;m about to study english 나는 영어공부를 할 예정이다.\n Benefits \u0026amp; Drawbacks (장점 \u0026amp; 단점)\rTake your time (천천히) Achievement (성취감)\rWorking late (야근) Intense (빡센) Regular job = 정규직\rStable job = 안정감 있는 직업 Objective / Goal = 목표\rRegret = 후회\rAge Limit = 나이 제한\rVaccine = 백신\rPandemic = 전국적인 유행병\rGovernance = 통치  본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":107,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.16","uri":"https://offetuoso.github.io/blog/english/202103/20210316-english-speak/"},{"content":"I’m used to ~ (\u0026lsquo;난 -에 익숙해\u0026rsquo;)  I\u0026rsquo;m used to you 난 너에게 익숙해 I\u0026rsquo;m used to working overtime 난 야근에 익숙해\n I\u0026rsquo;m afraid ~ (\u0026lsquo;유감스럽지만,')  I\u0026rsquo;m afraid Rainy outside 유감이지만, 밖에 비가 오는 것 같아 **I\u0026rsquo;m afraid ** 유감이지만, 밖에 비가 오는 것 같아\n I’m working on ~ (\u0026lsquo;지금 -를 하고있어\u0026rsquo;)  I’m working on my English speaking 난 영어 말하기를 공부하고 있어 i\u0026rsquo;m working on study Algorithm 난 알고리즘을 공부하고 있어\n I’m ~ is bad (\u0026lsquo;난 -가 안좋다\u0026rsquo;)  I’m health is bad 난 건강이 안좋다 I\u0026rsquo;m english is bad 난 영어를 잘 못한다.\n My girlfriend is another event. → My girlfriend had a personal schedule (She went out to hang out with her friends.)\rI’m English is tiny → My English is bad. / I’m not that good at English. → I’m still learning English. / I’m working on my English speaking.\r(Q. What is the charm of skateboarding?) A. other skateboarders communication → (full sentence) I think the charm of skateboarding is that I can ride skateboards with other skateboarders. / I enjoy riding skateboards with other people → (shorter) Communicating with other skateboarders is the best. / the greatest charm. skateboarding stage → spot\rshortboard and longboard and skateboard → I started with the shortboard and then the longboard and then the skateboard. / I started with the shortboard and then the longboard. Now I can ride the standard skateboard as well.\rIsn’t/Wasn’t living in other countries tough?\rhave an access to\rhang out (Google HangOut / Meet) - to meet someone or to play with someone, usually friends.\rMy hobby is skateboarding. → I enjoy(love) skateboarding in my free time.\rI started in-door climbing recently. / I’m into sth. = having a great interest in sth\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":108,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.15","uri":"https://offetuoso.github.io/blog/english/202103/20210315-english-speak/"},{"content":"Nothing on this page will be visible. This file exists solely to respond to /search URL.\nSetting a very low sitemap priority will tell search engines this is not important content.\n","description":"","id":109,"section":"","tags":null,"title":"Search Results","uri":"https://offetuoso.github.io/search/"}]