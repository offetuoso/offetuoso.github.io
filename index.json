[{"content":"[문제1] 곱하기 혹은 더하기 ###[문제] 곱하기 혹은 더하기 : 문제 설명\n 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 \u0026lsquo;x\u0026rsquo; 혹은 \u0026lsquo;+\u0026rsquo; 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성. 단, + 보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정.\n   예를 들어, 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2)x 9)x 8)x 4) = 576이다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어짐.   ###[문제] 조건\n 입력조건 첫째 줄에 여러개의 숫자로 구성된 하나의 문자열 S가 주어집니다.(1\u0026lt;=S의 길이 \u0026lt;=20)\n  출력조건 첫째 줄에 만들어 질 수 있는 가장 큰 수를 출력합니다.\n  입력예시\n02984\n  출력예시\n576\n  문자열 내 연산자 계산 가능 메소드  eval()\rresult = eval('(3+5)*7')\rprint(result) # 56\r- 리스트 내 item들을 하나의 문자열로 만들어주는 메소드 list = ['a', 'b', 'c'] print(''.join(list)) # print: abc\r- 리스트에 item 추가 시, 위치 선정이 가능토록하는 메소드\r# list = ['a', 'b', 'c'] list.insert(0, \u0026quot;new\u0026quot;)\rprint(list) # ['new', 'a', 'b', 'c']  ###make_one.py\nn, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  ###MakeOne.java\npackage ex.algorism.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r ###[문제] 정당성 분석\n 1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"최고의 숫자가 되기 위하여 더하기 혹은 곱하기를 진행","id":0,"section":"blog","tags":["java"],"title":"더하기 혹은 곱하기 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/sum-and-multiply/"},{"content":"[문제1] 1이 될때까지 ###[문제] 1이 될때까지 : 문제 설명\n 어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n ###[문제] 조건\n 입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n ###make_one.py\nn, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  ###MakeOne.java\npackage ex.algorism.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r ###[문제] 정당성 분석\n 1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"1이 될때까지 알고리즘.","id":1,"section":"blog","tags":["java"],"title":"1이 될때까지 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/make-one/"},{"content":"[문제1] 거스름돈 ###[문제] 거스름돈 : 문제 설명\n 당신은 음식점의 계산을 도와주는 점원입니다. 카운트에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈은 N은 항상 10의 배수입니다.\n ###[문제] 거스름돈 : 문제 해결 아이디어\n  최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐의 단위부터 돈을 거슬러 주면 됩니다. N원을 거슬러 줘야 할 때, 가장먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러줍니다. 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러주면 됩니다. N = 1,260일 때의 예시를 확인해 봅시다.    1,260 원을 500원부터 거슬러 준다면 아래와 같이\n    화페단위 500 100 50 10     손님이 받은 개수 2 2 1 1    ###[문제] 거스름돈 : 정당성 분석\n  가장큰 화폐단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요? 가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다. 만약 800원을 거슬러 주어야 하는데 화폐 단위가 500원 400원 100원이라면 어떻게 될까요 ? -\u0026gt; 400원 짜리 2개가 정답이됨 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 합니다.   ###reverse_change.py\nn =1260\rcount = 0 array = [500,100,50,10]\rfor coin in array:\rcount += n / coin\rn %= coin print(count)\r ###ReverseCharge.java\npackage ex.algorism.greedy;\rpublic class ReverseCharge {\rpublic static void main(String[] args) {\rint n = 1260;\rint[] coins = {500,100,50,10};\rint count = 0;\rfor (int coin : coins) {\rcount += n/coin;\rn %= coin;\r}\rSystem.out.println(count);\r}\r}\r ####[문제] 거스름돈 : 시간 복잡도 분석\n  화폐의 종류가 K라고 할때, 소스코드의 시간복잡도는 O(K)이다. 이 알고리즘의 시간복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":2,"section":"blog","tags":["java"],"title":"거스름돈 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/reverse-charge/"},{"content":"그리디 알고리즘(탐욕법) 그리디 알고리즘이란 ?  그리디 알고리즘이란\n 그리디 알고리즘(탐욕법)은 현재상황에서 가장 좋은 것만 고르는 방법을 의미. 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 있는 능력을 요구. 그리디 해법은 그 정당성 분석이 중요. 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토 필요.   [문제 상황] 루트 노드로 부터 시작하여 가는 노드의 합을 최대로 만들고 싶습니다.  Q. 최적의 해는 무엇인가요 ?\n  Q. 단순히 매 상황에서 가장큰 값을 고른다면 어떻게 될까요?\n   일반적인 상황에서 그리디알고리즘은 최적의 해를 보장할 수 없을때가 많다. 하지만 코딩 테스트에서의 대부분의 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됨.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":3,"section":"blog","tags":["java"],"title":"그리디 알고리즘","uri":"https://offetuoso.github.io/blog/greedy-algorithm/"},{"content":"do you mind?  (1) Are you okay/fine with it? (\u0026lsquo;괜찮나요?') Do you mind if I change the schedule? 괜찮다면, 스케쥴을 변경해도 될까요? (2) Mind your own business. (\u0026lsquo;니 일이나 신경써.') Do you mind? 니 일이나 신경써.\n attempt to ~ ('-를 시도하다.')  they are attempt to find something 그들은 무언갈 찾으려 한다. i attempt to speaking english 나는 영어로 말하길 시도한다.\n I had a meeting ~ ('-를 만났다.')  I had a meeting with english teacher 나는 영어 선생님과 Meeting을 가졌다.(만났다.) I had a meeting with my friends 나는 친구를 만났다\n - means ~ ('-의 뜻은 -입니다\u0026rsquo;)  **my name\u0026rsquo;s means a victory ** 내 이름은 승리를 의미합니다. **\u0026lsquo;팽-하\u0026rsquo; means \u0026lsquo;펭수 하이\u0026rsquo; ** \u0026lsquo;펭-하\u0026rsquo;는 \u0026lsquo;펭수-하이\u0026rsquo;를 뜻합니다.\n adv. accurate (\u0026lsquo;정확한\u0026rsquo;)  **Do you think the information on the table is accurate? ** 테이블의 정보가 정확하다고 생각하나요?\n familiar with (\u0026lsquo;익숙한\u0026rsquo;)  **familiar with the technical terms ** 기술 용어에 익숙 함\n n. accuracy (\u0026lsquo;정확\u0026rsquo;) v. intend (\u0026lsquo;의도하다\u0026rsquo;)  **I didn’t intend to offend you(her) when I laughed at your(her) new haircut. ** 당신의 새 머리를 보고 웃은 것은 마음을 상하게 할 의도는 없었어요.\n 새로운 단어 honorable contribution 명예로운 공헌\rachievement 업적\rmaterial 재료\rconversation 대화\rjudgement 판단\rnervous 긴장한\r 문법오류 one time ago → an hour ago\rI has → had a meeting with Sophia an hour ago\rI have a class with June today.\rWe call him an old-fashioned man. Olivia is meaning → Olivia means Olive and peace.\rI have heard of ~\rI’ve heard of Jack from the book, I’m also familiar with the name Charlie.\rI think the Korea column is not that accurate.\r end ","description":"영어 회화 문법정리","id":4,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.19","uri":"https://offetuoso.github.io/blog/20210319-english-speak/"},{"content":"Did you take a look at ~? ('-보셨나요?')  Did you take a look at the Book 책 보셨나요? Did you take a look at sky? 하늘을 보셨나요?\n I took a look at ~ (\u0026lsquo;나는 -를 보았다.')  I took a look at the book, 1 hour ago 1 시간 전에 책을 봤어요. I was took a look at sky last day 나는 어제 하늘을 봤어요\n adv. impressed (\u0026lsquo;깊은 인상\u0026rsquo;) n. impression (\u0026lsquo;인상\u0026rsquo;) I’m impressed by ~ (\u0026lsquo;나는 당신의 -에 감동받았습니다.')  I’m impressed by your letter 나는 당신의 편지에 감동받았습니다. I’m impressed by your passion 나는 당신의 열정에 감동받았습니다.\n related to ~ ('-와 연관되다.')  I think, he is related to crime 그는 범죄와 관련된 것 같아요. my homework relate to math 나의 숙제는 수학과 관련있다.\n v. skim  He always skimmed the book 그는 항상 책을 훑어보았다.\n v. scan adv. intermediate (중급의) beginners → intermediate → high/advanced level\r  He was in intermediate class, 3 month ago 그는 3개월 전에 중급반이였다.\n 영어 8품사 사전 표기법 \rn. 명사 (noun [naun] )\r-모든 사람, 사물, 동물의 이름을 나타내는 단어\r-문장에서 주어, 보어, 목적어가 된다.\r*C : 가산명사\r*U : 불가산명사\r*CU : 주로 가산명사\r*UC : 주로 불가산명사\r*sing. : 단수형\r*pl. : 복수형\r*n.pl. : 복수명사\r*fem. : 여성형\r*neg. : 부정형\rpron. 대명사 (pronoun [próunàun] )\r-인칭대명사: I, my, me, mine, myself, she, her, he, his, him 등\r-지시대명사: it, this, these, that, those 등\r*obj : 목적격\r*poss : 소유격\rv. 동사 (verb [vəːrb] )\rvtr. 타동사 (Transitive Verb)\rvi. 자동사 (Intransitive Verb)\r-동작이나 상태를 나타내는 단어\r-be동사 : am, are, is, was, were 등\r-일반동사 : be동사와 조동사를 제외한 나머지 동사\r*auxil. v. : 조동사 - can, may, will, should, must 등\r*p. : 과거형\r*p.p. : 과거분사형\r*pres.p. : 현재분사\r※목적어로 구분하는 자동사와 타동사\r자동사 : 목적어를 취하지 않는 동사\r타동사 : 목적어를 취하는 동사\r동사뒤에 목적어(영향을 받는 사람이나 사물)(이)가 필요한지 여부에 따라서\r자동사(Intransitive Verb)와 타동사(Transitive Verb)로 구분할 수 있습니다. adj. (or a.) 형용사 (adjective [ǽdʒiktiv] )\r-명사나 대명사를 수식하거나 보충 설명하는 단어\r-우리말에서 보통 \u0026lt; ~ㄴ, ~한\u0026gt; 으로 해석되는 단어\radv. (or ad.) 부사 (adverb [ǽdvəːrb] )\r-형용사, 다른 부사, 동사, 문장전체를 수식하는 단어\r-① 형용사 / 다른 부사 수식 : This is a very very delicious cake.\r-② 동사 수식 : She can run fast.\r-③ 문장 전체 수식 : Luckily, I passed the exam.\rprep. 전치사 (preposition [prèpəzíʃən] ) -명사나 대명사 앞에 쓰여서 장소, 시간 등을 나타내는 단어\r-in, at\r*pref. : 접두사\r*suf. : 접미사\rconj. 접속사 (conjunction [kəndʒΛŋkʃən] )\r-단어와 단어, 문장과 문장 등을 연결하는 단어\r-when, or, and\rinterj. (or int.) 감탄사 (interjection [ìntərdʒékʃən] )\r-놀람, 기쁨 등 감정을 나타내는 단어\r-Oh, Wow\r출처: https://fireball.tistory.com/409 [What's up]\r end ","description":"영어 회화 문법정리","id":5,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.17","uri":"https://offetuoso.github.io/blog/20210317-english-speak/"},{"content":"I use ~ (\u0026lsquo;난 -를 사용한다.')  I use Java 난 자바를 사용한다. I use Korean 난 한국어를 사용한다.\n I’m preparing ~ ('-를 준비중입니다\u0026rsquo;)  ** I’m preparing to change job ** 나는 이직을 준비중입니다. ** I’m preparing to party in my house ** 우리 집에서 파티를 준비하고 있어요.\n ~ is intense ('-이 ~빡세다~힘들다.')\n Work is not intense 일은 힘들지 않다. Always Study is intense 공부는 힘들다.\n I learned ~ (\u0026lsquo;나는 -배웠다\u0026rsquo;)  I learned computer science in my University 나는 대학에서 컴퓨터를 전공했다. I learned baking bread 나는 빵굽기를 배웠다.\n I want to ~ ('-하고 싶습니다.')  I want to hold your hand 당신의 손을 잡고 싶습니다. I want to change job! 이직하고 싶어요!\n I\u0026rsquo;m good at ~ (\u0026lsquo;나는 -잘해\u0026rsquo;)  I\u0026rsquo;m good at make smile 나는 미소를 잘 짓습니다. I\u0026rsquo;m good at cleaning my room 나는 내방 청소를 잘해요\n I\u0026rsquo;m about to ~ (\u0026lsquo;나는 -할 예정이다\u0026rsquo;)  I\u0026rsquo;m about to go to bed 나는 자러갈 예정이다. I\u0026rsquo;m about to study english 나는 영어공부를 할 예정이다.\n Benefits \u0026amp; Drawbacks (장점 \u0026amp; 단점)\rTake your time (천천히) Achievement (성취감)\rWorking late (야근) Intense (빡센) Regular job = 정규직\rStable job = 안정감 있는 직업 Objective / Goal = 목표\rRegret = 후회\rAge Limit = 나이 제한\rVaccine = 백신\rPandemic = 전국적인 유행병\rGovernance = 통치  end ","description":"영어 회화 문법정리","id":6,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.16","uri":"https://offetuoso.github.io/blog/20210316-english-speak/"},{"content":"I’m used to ~ (\u0026lsquo;난 -에 익숙해\u0026rsquo;)  I\u0026rsquo;m used to you 난 너에게 익숙해 I\u0026rsquo;m used to working overtime 난 야근에 익숙해\n I\u0026rsquo;m afraid ~ (\u0026lsquo;유감스럽지만,')  I\u0026rsquo;m afraid Rainy outside 유감이지만, 밖에 비가 오는 것 같아 **I\u0026rsquo;m afraid ** 유감이지만, 밖에 비가 오는 것 같아\n I’m working on ~ (\u0026lsquo;지금 -를 하고있어\u0026rsquo;)  I’m working on my English speaking 난 영어 말하기를 공부하고 있어 i\u0026rsquo;m working on study Algorithm 난 알고리즘을 공부하고 있어\n I’m ~ is bad (\u0026lsquo;난 -가 안좋다\u0026rsquo;)  I’m health is bad 난 건강이 안좋다 I\u0026rsquo;m english is bad 난 영어를 잘 못한다.\n My girlfriend is another event. → My girlfriend had a personal schedule (She went out to hang out with her friends.)\rI’m English is tiny → My English is bad. / I’m not that good at English. → I’m still learning English. / I’m working on my English speaking.\r(Q. What is the charm of skateboarding?) A. other skateboarders communication → (full sentence) I think the charm of skateboarding is that I can ride skateboards with other skateboarders. / I enjoy riding skateboards with other people → (shorter) Communicating with other skateboarders is the best. / the greatest charm. skateboarding stage → spot\rshortboard and longboard and skateboard → I started with the shortboard and then the longboard and then the skateboard. / I started with the shortboard and then the longboard. Now I can ride the standard skateboard as well.\rIsn’t/Wasn’t living in other countries tough?\rhave an access to\rhang out (Google HangOut / Meet) - to meet someone or to play with someone, usually friends.\rMy hobby is skateboarding. → I enjoy(love) skateboarding in my free time.\rI started in-door climbing recently. / I’m into sth. = having a great interest in sth\r end ","description":"영어 회화 문법정리","id":7,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.15","uri":"https://offetuoso.github.io/blog/20210315-english-speak/"},{"content":"자바 자바가상머신 (JVM) 자바의 장점 자바의 단점 자바의 기초 문법 객체지향과 자바 객체지향 프로그램 언어 객체 상속 오버라이딩 (Overriding)  오버라이딩이란?\n  사전적 의미로는 more important than any other considerations 번역해 보면 다른 고려 사항보다 더 중요하다이다.\n  부모 클래스로 부터 상속받은 메소드를 자식 클래스에서 재정의 하여, 덮어 쓰는 것이다. 상속받은 메소드를 그대로 사용할 수도 있지만, 자식 클래스에서 상황에 맞게 변경해야 하는 경우 오버라이딩을 사용한다.\n  오버라이딩을 사용하기 위한 조건에는 부모 클래스의 메소드를 재정의하는 것이므로 이름, 매개변수 리턴 값이 모두 같아야 한다.\n  오버라이딩의 조건\n 부모 클래스와 자식 클래스 사이에서만 성립한다. static 메소드는 오버라이딩 할 수 없다. static 메소드 끼리의 오버라이딩은 hiding이라 한다. private는 정의된 메소드는 상속 자체가 안된다. interface 메소드를 오버라이딩 할 경우엔 public으로 해야한다. 메소드의 파라미터가 완전히 일치해야 하며, 리턴타입도 같아야 한다. 파라미터의 이름은 상관없다. 부모 클래스의 접근제어자보다 좁아질 수 없다. 확장 될 수는 있다. 부모 클래스보다 더 많은 예외를 던질 수 있다. final 예약어로 정의된 메소드는 오버라이딩 할 수 없다.    아래 소스코드를 보면,\n main 클래스를 가지고 있는 Example 클래스 Talk라는 기능을 가진 부모 클래스, Person 클래스. Person을 부모로 가지고 있는 자식 클래스, Korean, American, Japanese로 구성되어있다. 모두 Talk 메소드를 가지고 있지만 각각 다른 기능을 수행한다.   Example.java package ex.java.overriding;\rpublic class Example {\rpublic static void main(String[] args) {\rPerson person = new Person();\rperson.Talk();\rKorean korean = new Korean();\rkorean.Talk();\rAmerican american = new American();\ramerican.Talk();\rJapanese japanese = new Japanese();\rjapanese.Talk();\r}\r}\rclass Person {\rvoid Talk() {\rString message = \u0026quot;Aaaa\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Korean extends Person{\r@Override\rvoid Talk() {\rString message = \u0026quot;안녕하세요!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass American extends Person{\r@Override\rpublic void Talk() {\rString message = \u0026quot;Hello!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Japanese extends Person{\r@Override\rprotected void Talk() {\rString message = \u0026quot;Konnichiwa!\u0026quot;;\rSystem.out.println(message);\r}\r}\r result Aaaa\r안녕하세요!\rHello!\rKonnichiwa!\r  소스를 보다보면 자식 클래스의 메소드 바로 위에 @override라는 것이 보일 것이다. 이것은 Annotation 이라는 주석 기능이다. 하지만 우리가 알고 있는 주석과는 다르며 컴퓨터는 그것을 이 메소드는 부모 클래스로 부터 오버라이드 받은 메소드이다. 명시해 주는것이다. 만일 메소드가 아래의 경우 오류로 알려준다.\n 1. 메소드 명칭이 잘못된경우\rThe method talks() of type Korean must override or implement a supertype method\r2. 리턴타입이 잘못된경우 The return type is incompatible with Person.Talk()\r3. 파라미터가 잘못된경우\rThe method Talk(String) of type Korean must override or implement a supertype method\r 오버로딩 (Overloading)  오버로딩이란?\n  사전적 의미로는 loading of a vehicle with too heavy a weight. 번역해 보면 너무 무거운 중량의 차량 적재.이다. 쉽게 말하면 과적해서 싣는 것이다.\n  보통 하나의 이름을 가진 메소드는 1개만 존재 하지만, 파라미터가 다르다면 컴퓨터는 오버로드된 메소드로 인식하여 다른 메소르도 인식함.\n  오버로딩이 되는 조건은\n 메소드 이름이 같아야 한다. 메소드의 파라미터의 형이 다르거나 갯수가 다르거나 순서가 다름. 반환타입은 영향을 미치지 않는다.    아래 소스코드를 보면,\n main 클래스를 가지고 있는 Example 클래스 Mountain이라는 클래스가 있고 echo라는 입력하면 답변을 해주는 메소드가 있다. 같은 이름의 다른 파라미터를 갖는 3개의 echo가 있다.   Example.java package ex.java.overloading;\rpublic class Example {\rpublic static void main(String[] args) {\rMountain mountain = new Mountain();\rmountain.echo(\u0026quot;Hello\u0026quot;); //문자열 입력\rmountain.echo(100);\t//숫자 입력\rmountain.echo(true);\t//참,거짓 입력\r}\r}\rclass Mountain {\rvoid echo(String say) {\rSystem.out.println(\u0026quot;you say \u0026quot;+say);\r}\rvoid echo(int money) {\rSystem.out.println(\u0026quot;you have \u0026quot;+money+\u0026quot; doller\u0026quot;);\r}\rvoid echo(Boolean bool) {\rif(bool) {\rSystem.out.println(\u0026quot;this is True\u0026quot;);\r}else {\rSystem.out.println(\u0026quot;this is False\u0026quot;);\r}\r}\r}\r result you say Hello\ryou have 100 doller\rthis is True\r  결과를 보면 어렵진 않다. 컴퓨터는 입력된 파라미터에 따라 어떤 함수를 호출할지 보여준다. 예를들면 우리가 많이 사용하는 System.out.println(); 출력 함수가 있다.\n  주의할점 파라메터의 순서를 다르게 오버라이드 하였지만, int와 long 모두 소숫점이 없는 정수를 입력 가능하기 때문에 컴퓨터의 입장에서는 어느 메소드를 사용할지 애매한경우가 생긴다.\n The method sum(int, long) is ambiguous for the type Calculator Calculator의 메소드 sum (int, long)은 형식에 대해 모호합니다.\n\tpublic class Example {\rpublic static void main(String[] args) {\rCalculator cal = new Calculator();\rcal.sum(1, 5);\r}\r}\rclass Calculator {\rvoid sum(int a, long b) {\rSystem.out.println(\u0026quot;sum is \u0026quot;+ (a+b));\r}\rvoid sum(long a, int b) {\rSystem.out.println(\u0026quot;sum is \u0026quot;+ (a+b));\r}\r}\r 다형성 오버라이딩을 이용한 다형성  위에서 오버라이딩을 설명했던 소스와 다른점 한가지가 있다. 그것은 main 클래스에서 자식 클래스를 선언하는 부분이다.\n Example.java package ex.java.overriding;\rpublic class Example {\rpublic static void main(String[] args) {\rPerson person = new Person();\rperson.Talk();\rperson = new Korean(); // Korea클래스의 인스턴스를 Person타입인 person으로 참조하여 사용.\rperson.Talk();\rperson = new American(); // American클래스의 인스턴스를 Person타입인 person으로 참조하여 사용.\rperson.Talk();\rperson = new Japanese();\t// Japanese클래스의 인스턴스를 Person타입인 person으로 참조하여 사용.\rperson.Talk();\r}\r}\rclass Person {\rvoid Talk() {\rString message = \u0026quot;Aaaa\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Korean extends Person{\r@Override\rvoid Talk() {\rString message = \u0026quot;안녕하세요!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass American extends Person{\r@Override\rpublic void Talk() {\rString message = \u0026quot;Hello!\u0026quot;;\rSystem.out.println(message);\r}\r}\rclass Japanese extends Person{\r@Override\rprotected void Talk() {\rString message = \u0026quot;Konnichiwa!\u0026quot;;\rSystem.out.println(message);\r}\r}\r result Aaaa\r안녕하세요!\rHello!\rKonnichiwa!\r 참조변수의 다형성  참조변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있다. 클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없기 때문에, 자식클래스에서 사용할 수 있는 멤버의 개수는 언제나 부모 클래스와 같거나 많게 된다.\n \rPerson person = new Person(); //정상\rKorean korean = new Korean(); //정상\r// 부모 클래스인 person은 Korean을 포함할 수 있다.\rPerson person = new Korean(); //정상\r// 부모 클래스는 자식으로 참조 할수 없다. Korean korean = new Person();\t//오류\r 참조변수의 형변환  자식클래스를 부모 클래스로 참조할때 자식 클래스로 형 변환 할 수 있다.\n \rPerson person = new Person();\rperson.Talk();\rKorean korean = new Korean();\rperson = (Korean) korean; //(Korean) 타입으로 형변환\rkorean.Talk();\rAmerican american = new American();\rperson = (American) american; //(American) 타입으로 형변환\ramerican.Talk();\rJapanese japanese = new Japanese(); //(Japanese) 타입으로 형변환\rperson = (Japanese) japanese;\rjapanese.Talk();\rperson = (American) japanese; //오류 !\rjapanese.Talk();\r 추상화 인터페이스 ","description":"자바의 기본 개념정리.","id":8,"section":"blog","tags":["java"],"title":"자바의 기본개념","uri":"https://offetuoso.github.io/blog/basic-java/"},{"content":"Nothing on this page will be visible. This file exists solely to respond to /search URL.\nSetting a very low sitemap priority will tell search engines this is not important content.\n","description":"","id":9,"section":"","tags":null,"title":"Search Results","uri":"https://offetuoso.github.io/search/"}]