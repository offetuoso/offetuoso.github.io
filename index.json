[{"content":"BAEKJOON - 4949 균형잡힌 세상 Task description 원문 : 백준 4949 링크\n메시지를 입력받아 괄호를 열고 닫아야 한다.\n 열고 닫는 괄호가 균형 맞게 되어있으면 yes 아니면 no 출력\n ex) asd(b)dd(d[ddd]) yes ex) (asdasd] no 메시지의 끝은 .으로 끝나고 메시지가 \u0026ldquo;.\u0026rdquo; 이면 종료   Condition   모든 왼쪽 소괄호(\u0026quot;(\u0026quot;)는 오른쪽 소괄호(\u0026quot;)\u0026quot;)와만 짝을 이뤄야 한다. 모든 왼쪽 대괄호(\u0026quot;[\u0026quot;)는 오른쪽 대괄호(\u0026quot;]\u0026quot;)와만 짝을 이뤄야 한다. 모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다. 모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다. 짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다. 하나 또는 여러줄에 걸쳐서 문자열이 주어진다. 각 문자열은 영문 알파벳, 공백, 소괄호(\u0026quot;( )\u0026quot;) 대괄호(\u0026quot;\u0026quot;)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다. 7번째의 \u0026quot; .\u0026ldquo;와 같이 괄호가 하나도 없는 경우도 균형잡힌 문자열로 간주할 수 있다. 입력의 종료조건으로 맨 마지막에 점 하나(\u0026rdquo;.\u0026quot;)가 들어온다.   input output 예제 입력 1 So when I die (the [first] I will see in (heaven) is a score list).\r[ first in ] ( first out ).\rHalf Moon tonight (At least it is better than no Moon at all].\rA rope may form )( a trail in a maze.\rHelp( I[m being held prisoner in a fortune cookie factory)].\r([ (([( [ ] ) ( ) (( ))] )) ]).\r.\r.\r예제 출력 1 yes\ryes\rno\rno\rno\ryes\ryes\r Solution   메시지가 \u0026ldquo;.\u0026rdquo; 이면 종료 메시지가 \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;[\u0026rsquo; 이면 스택에 추가   \rwhile True : msg = input()\rif msg == '.' :\t# \u0026quot;.\u0026quot; 이면 종료\rbreak\rfront = []\t# 스택 생성\rflag = True # .이나오기 전에 조건에 만족(균형) X 면 False\rfor i in range(0, len(msg)) :\tif msg[i] == '.' : if len(front) == 0 and flag: # 스택이 모두 pop되고, 조건에 만족(균형) 하면 yes\rprint('yes')\relse : print('no')\relif msg[i] == '(' or msg[i] == '[' : # 메시지가 '(' 또는 '[' 이면 스택에 추가\rfront.append(msg[i])\relif (msg[i] == ')' or msg[i] == ']') and len(front) == 0 : # 괄호를 안열고, 닫으려 할때 flag = False\relif msg[i] == ')' : # )가 나왔을때 if front[-1] == '(' :\t# 스택 마지막이 ( 였다면 팝\rfront.pop()\relse :\rflag = False\t# 스택 마지막이 [ 으로 조건에 만족(균형) no\relif msg[i] == ']' :\t# ]가 나왔을때 if front[-1] == '[' : # 스택 마지막이 [ 였다면 팝\rfront.pop()\relse : flag = False\t# 스택 마지막이 ( 으로 조건에 만족(균형) no\r TestCase \r ","description":"백준 균형잡힌 세상","id":0,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 4949 균형잡힌 세상","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-4949-a-balanced-world/"},{"content":"BAEKJOON - 1541 잃어버린 괄호 Task description 원문 : 백준 1541 링크\n +와 -그리고 괄호를 가진 식에서 괄호를 모두 지웠다. 그리고 나서 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n Condition   첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다. 첫째 줄에 정답을 출력한다.   input output 예제 입력 1 55-50+40\r예제 출력 1 -35\r Solution   +와 -그리고 숫자들을 배열에 넣는다. 첫번째 - 이후 +는 괄호로 묶는다 (- (A + B) 랑 -A-B 와 같으므로 +여도 -로 계산한다.)   message = input() # 입력받은 메시지\rformula = [] # 공식 배열 (숫자,+,-)\rvalue = \u0026quot;\u0026quot;\t# 쪼개진 숫자 문자열로 조합\rflag = False # +를 -로 계산할지 여부 (첫 -가 나왔는지 여부)\rresult = 0\t# 결과값\rfor i in range(0,len(message)) :\t# +와 -그리고 숫자들을 배열에 넣는다.\rif message[i] == \u0026quot;+\u0026quot; or message[i] == \u0026quot;-\u0026quot; :\tformula.append(int(value))\t# +, -가 나오면 그전까지의 value를 숫자로 바꿔 formula 배열에 넣는다\rvalue=\u0026quot;\u0026quot;\rformula.append(message[i])\t# + or - 를 formula 배열에 추가\relif i ==len(message)-1 :\rvalue += message[i]\t# 마지막 인덱스인경우 value를 숫자로 바꿔 formula 배열에 넣는다\rformula.append(int(value))\telse :\t# 숫자는 value에 추가\rvalue += message[i]\rfor i in range(0,len(formula)) :\rif formula[i] == \u0026quot;+\u0026quot; or formula[i] == \u0026quot;-\u0026quot; :\rif(formula[i] == \u0026quot;-\u0026quot;) :\rflag = True\relse :\rif flag == False :\rresult += formula[i] else :\rresult -= formula[i] print(result)\r TestCase  ","description":"백준 잃어버린 괄호 ","id":1,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 1541 잃어버린 괄호 ","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-1541-lost-parenthesis/"},{"content":"BAEKJOON - 10828 스택 Task description 원문 : 백준 10828 링크\n 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\n  명령은 총 다섯 가지이다.\n  push X: 정수 X를 스택에 넣는 연산이다. pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 스택에 들어있는 정수의 개수를 출력한다. empty: 스택이 비어있으면 1, 아니면 0을 출력한다. top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\n Condition   첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다. 출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.   input output 14\rpush 1\rpush 2\rtop\rsize\rempty\rpop\rpop\rpop\rsize\rempty\rpop\rpush 3\rempty\rtop\r예제 출력 1 복사\r2\r2\r0\r2\r1\r-1\r0\r1\r-1\r0\r3\r예제 입력 2 복사\r7\rpop\rtop\rpush 123\rtop\rpop\rtop\rpop\r예제 출력 2 복사\r-1\r-1\r123\r123\r-1\r-1\r Solution import sys\rclass Stack :\t# 클래스 생성\rdef __init__(self) :\rself.elements = []\t# 스택의 엘리먼츠 추가\rdef push(self, x) :\tself.elements.append(x)\t# x를 스택에 추가\rdef empty(self) :\t# 엘리먼츠의 길이(사이즈)가 0 이면 1 if len(self.elements) == 0 : print(1)\rreturn 1\relse :\rprint(0)\rreturn 0\rdef pop(self) :\tif len(self.elements) == 0 : #비어있는 경우 -1\rprint(-1)\relse :\rself.top()\rself.elements.pop()\rdef size(self) :\rprint(len(self.elements))\rreturn len(self.elements)\rdef top(self) :\rif len(self.elements) == 0 :\rprint(-1)\relse :\rprint(self.elements[-1])\r#n = int(input())\rn = int(sys.stdin.readline().rstrip())\rs = Stack()\rfor i in range(0,n) :\rinput_split = sys.stdin.readline().rstrip().split()\rcommand = input_split[0]\r#command = str(input())\rif 'pop' == command.lower() :\rs.pop()\relif 'size' == command.lower() :\rs.size()\relif 'top' == command.lower() :\rs.top()\relif 'empty' == command.lower() :\rs.empty()\relif 'push' == command.lower() :\rs.push(input_split[1])\r TestCase  ","description":"백준 스택","id":2,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 10828 스택","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-10872-stack/"},{"content":"BAEKJOON - 10872 팩토리얼(Factorial) Task description 원문 : 백준 10872 링크\n 0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.\n Condition   첫째 줄에 정수 N(0 ≤ N ≤ 12)가 주어진다.   input output 예제 입력 1 복사\r10\r예제 출력 1 복사\r3628800\r예제 입력 2 복사\r0\r예제 출력 2 복사\r1\r Solution  0이면 1리턴 0이 아니면 N * factorial(N-1) 리턴 # N * (N-1)!\n def factorial(N): if ( N != 0) :\rreturn N * factorial(N-1) #N * (N-1)!\relse :\rreturn 1\rN = int(input())\rfn = factorial(N)\rprint(fn)\r TestCase  ","description":"백준 팩토리얼","id":3,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 10872 팩토리얼","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-10872-factorial/"},{"content":"dimsom / dumplings (\u0026lsquo;딤섬 / 만두\u0026rsquo;) ingredient (\u0026lsquo;재료, 성분\u0026rsquo;)  a. What ingredients do you need to make a 김치찌개?\n grocery (\u0026lsquo;식료품, 식자재 / 식료품점\u0026rsquo;)  I need to go to the grocery (store). / I need to buy some groceries.\n ingredient 와 grocery   ingredient는 요리 뿐만 아니라 만드는 모든 것의 재료 grocery는 음식을 만들때의 재료   I had A on B . (\u0026lsquo;B에 A가 있었습니다.')  I had a P.T. on Wednesday. (수요일에 PT가 있었습니다.) I had a haircut on Tuesday. (화요일에 머리를 잘랐었습니다.)\n I had/ate A at the B. (\u0026lsquo;B에서 A를 먹었습니다.')  I had fried chicken at the company. (나는 회사에서 후라이드 치킨을 먹었습니다.) I ate dinner at the company. (나는 회사에서 저녁을 먹었습니다.)\n I enjoy trying out A (\u0026lsquo;나는 A를 즐긴다\u0026rsquo;)  I enjoy trying out new exercise (나는 새로운 운동을 즐깁니다.) I enjoy trying out new foods. (나는 새로운 음식을 즐깁니다.) I enjoy trying out new menus / dishes. (나는 새로운 메뉴/요리를 시도하는 것을 즐깁니다.)\n I prefer A (\u0026lsquo;나는 A를 선호한다.')  I prefer shopping (groceries) online (나는 온라인 쇼핑(식료품)을 선호한다)\n when I need it at the moment. (\u0026lsquo;지금 내가 필요할 때\u0026rsquo;) I bought A and it was really good. (\u0026lsquo;A 샀었는데 정말 좋았습니다.')  I bought grocery beef for steak and it was really good.\n Grammar Error: I was Tuesday. → I had a haircut on Tuesday. I was eat chicken at company. → I had/ate fried chicken at the company.\rI try delivery new restaurants. → I enjoy trying out new delivery restaurants/foods. / I enjoy trying out new restaurants on the delivery app.\rI enjoy trying out new menus / dishes.\rI like online stores, like Market Kurly, but I sometimes use supermarkets or local stores when I’m busy. → I prefer shopping (groceries) online ~ when I need it at the moment.\rI bought grocery beef for steak and it was really good. → I bought a beef steak at Market Kurly and ~.  New expressions learned today: ingredient 재료 / grocery 식료품, 식자재 / 식료품점\rI need to go to the grocery (store). / I need to buy some groceries.\ra. What _ingredients_ do you need to make a 김치찌개?\rb. I went out to buy some _groceries_ because we didn’t have anything to eat.\rfrozen ready-made food → ready meal\rdimsom / dumplings\rI like (__) the best. = (___) is my favorite frozen/instant food. = My favorite ready meal is (___). leek (green onion, spring onion), garlic\r열려라 참깨! Open Sesame! → sesame oil 참기름\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":4,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.07.08","uri":"https://offetuoso.github.io/blog/english/202107/20210708-english-speak/"},{"content":"BAEKJOON - 11729 하노이 탑 이동 순서(Hanoi Tower Travel Order) Task description 원문 : 백준 11729 링크\n 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 아래서 부터 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라.\n  아래 그림은 원판이 5개인 경우의 예시이다.\n Condition   한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. 이동 횟수는 최소가 되어야 한다.   input output 예제 입력 1 복사\r3\r예제 출력 1 복사\r7\r1 3\r1 2\r3 2\r1 3\r2 1\r2 3\r1 3\r Solution   첫번째 봉에 있는 1~n-1 까지의 원반을 두번째 봉에 옮김 첫번째 봉에 있는 n 원반을 세번째 봉에 옮김 세번째 봉에 있는 1~n-1 까지의 원반을 세번째 봉에 옮김   def hanoi(n, first, second ,third) :\rif n == 1 :\rresult.appthird(str(first)+' '+str(third)) # n이 1까지 재귀로 호출되면 결과 배열에 담음\relse : hanoi(n-1, first, third, second) # first에서 n-1의 모든 원반을 second로 모두 옮김, 임시 경유는 third\rhanoi(1, first, second, third)\t# first에서 third로 마지막(N번째) 원반을 third로 옮김, 임시 경유는 second\rhanoi(n-1, second, first, third) # second에 있는 n-1의 모든 원반을 third로 옮김, 임시 경유는 first\rresult = []\rn = int(input())\rhanoi(n, 1, 2, 3) # hanoi(옮길 원반수, 1번 봉, 2번 봉, 3번 봉)\rprint(len(result))\rfor item in result :\rprint(item)\r TestCase  ","description":"백준 하노이 탑 이동 순서","id":5,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 11729 하노이 탑 이동 순서","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-11729-hanoi-tower-travel-order/"},{"content":"BAEKJOON - 2941 크로아티아 알파벳(Croatian Alphabet) Task description 원문 : 백준 2941 링크\n 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n    크로아티아 알파벳 변경     č c=   ć c-   dž dz=   đ d-   lj lj   nj nj   š s=   ž z=      예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.   Condition   dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.   input output 예제 입력 1 ljes=njak\r예제 출력 1\r6\r예제 입력 2\rddz=z=\r예제 출력 2\r3\r예제 입력 3\rnljj\r예제 출력 3\r3\r예제 입력 4\rc=c=\r예제 출력 4\r2\r예제 입력 5\rdz=ak\r예제 출력 5\r3\r Solution    입력 변경     dz= 0\t(dž)   z= 1 (ž)   d- 2 (đ)   c= 3 (č)   c- 4 (ć)   nj 5 (nj)   s= 6 (š)   lj 7 (lj)     알파벳과 -, = 만 입력이 이루어 지기 때문에 1자리의 다른 문자열로 치환(숫자) , 순서는 dz=가 z= 보다 먼저 배열에 들어가 있어야 한다. 자리수를 센다.\n msg = input() # 케이스 입력받음\rcroatian = ['dz=','z=','d-','c=','c-','nj','s=','lj'] #크로아티아 문자열 배열, 치환할 우선순위에 맞게 배열 생성\rfor i in range(0,len(croatian)) :\rmsg = msg.replace(croatian[i], str(i)) #크로아티아 문자열을 배열 인덱스로 변환\rprint(len(msg)) #길이 출력\r TestCase ljes=njak #6\rddz=z= #3\rnljj #3\rc=c= #2\rdz=ak #3\r ","description":"백준 크로아티아 알파벳","id":6,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2941 크로아티아 알파벳","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2941-croatian-alphabet/"},{"content":"BAEKJOON - 2798 블랙잭(black jack) Task description 원문 : 백준 2798 링크\n  첫번째 줄은 카드의 (장)수 N과 블랙잭 넘버(목표 값) M을 입력받는다. 두번째 줄은 공백으로 구분된 N장의 카드 입력받는다. M이 넘지 않는 3장의 합중 가장 큰 경우 출력.   Condition   첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다. 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.   input output 예제 입력 1 5 21\r5 6 7 8 9\r예제 출력 1 21\r예제 입력 2 10 500\r93 181 245 214 315 36 185 138 216 295\r예제 출력 2 497\r Solution  완전탐색 (Brute-Force) 문제로 경우의 수를 모두 찾아본다.\n 같은 배열을 자리수 만큼 반복 이전에 나온것은 사용하지 않는다.   n, m = map(int, input().split())\rnumbers = list(map(int, input().split()))\rresult = 0\rfor i in numbers :\rfor j in numbers :\rif i != j :\t# 첫번째에서 선택한 값이 아닌것 for k in numbers :\rsum = i+j+k\rif i != k and j != k and sum \u0026lt;= m: #첫번째 두번째에서 선택한 값이 아닌것이며, i,j,k의 값이 sum을 넘지 않는것\rresult = max(sum,result) # 그 중에 가장 큰 값\rprint(result)\r TestCase #n, m = 5, 21\r#numbers = [5, 6, 7, 8, 9]\r#n, m = 10, 500\r#numbers = [93, 181, 245, 214, 315, 36, 185, 138, 216, 295]\r ","description":"백준 블랙잭","id":7,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2798 블랙잭","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2798-black-jack/"},{"content":"BAEKJOON - 1712 손익분기점(break even point) Task description 원문 : 백준 1712 링크\n 노트북 제조하는데 노트북 판매 대수에 상관없이 A만원의 고정 비용이 든다.\n한 대의 노트북을 생산하는 데에는 B만원의 가변 비용이 든다\nA=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며,\n열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다.\n생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다. 첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.   input output 예제 입력 1 1000 70 170\r예제 출력 1 11\r예제 입력 2 3 2 1\r예제 출력 2 -1\r예제 입력 3 2100000000 9 10\r예제 출력 3 2100000001\r Solution  일단 하나씩 계산해서 손익분기점을 찾아보았으나.. 시간초과에 걸린다.\n a, b, c = map(int, input().split())\rqty = 0\rif(c \u0026lt; 2):\rprint(-1)\rexit()\relse :\rwhile True :\rqty += 1\rformula1 = a + (b*qty)\rformula2 = (c*qty)\rif(formula1 \u0026lt; formula2):\rprint(formula2)\rbreak\r  루프 없이 어떻게 계산을 해야할까 고민하다 가변, 판매단가만 곱했을때 변하는것을 보고 판매단가 - 가변비용를 생각하였다.\n a, b, c = map(int, input().split())\rif(b \u0026gt;= c):\t# 가변비용이 판매단가와 같거나 크면, 아무리 수량을 늘려도 손익분기점에 도달하지 못한다\rprint(-1)\relse :\rprint((a//(c-b))+1) # (고정비/(단가-가변비용)) +1 (+1를 추가되어 손익분기점이 됨)\r   TestCase \r ","description":"백준 손익분기점","id":8,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 1712 손익분기점","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-1712-break-even-point/"},{"content":"BAEKJOON - 7576 토마토(tomato) Task description  철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.\n  창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.\n  토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.\n  입력 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 토마토가 하나 이상 있는 경우만 입력으로 주어진다.\n  출력 여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.\n Condition   토마토가 하나 이상 있는 경우만 입력으로 주어진다. 2 ≤ M,N ≤ 1,000   input output 예제 입력 1 6 4\r0 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 1\r예제 출력 1 8\r예제 입력 2 6 4\r0 -1 0 0 0 0\r-1 0 0 0 0 0\r0 0 0 0 0 0\r0 0 0 0 0 1\r예제 출력 2 -1\r예제 입력 3 6 4\r1 -1 0 0 0 0\r0 -1 0 0 0 0\r0 0 0 0 -1 0\r0 0 0 0 -1 1\r예제 출력 3 6\r예제 입력 4 5 5\r-1 1 0 0 0\r0 -1 -1 -1 0\r0 -1 -1 -1 0\r0 -1 -1 -1 0\r0 0 0 0 0\r예제 출력 4 14\r예제 입력 5 2 2\r1 -1\r-1 1\r예제 출력 5 0\r Solution \rfrom collections import deque\rdx = [-1, 1, 0, 0]\rdy = [0, 0, -1, 1]\rdef bfs() :\rresult = 0\rwhile queue :\ra, b = queue.popleft()\rfor i in range(4) :\rx = a + dx[i]\ry = b + dy[i]\rif 0 \u0026lt;= x \u0026lt; N and 0 \u0026lt;= y \u0026lt; M and graph[x][y] == 0 :\rqueue.append([x,y])\rgraph[x][y] = graph[a][b] + 1\rresult = max(graph[a][b], result)\rreturn result\rM, N = map(int, input().split())\rqueue = deque([])\rgraph = []\rfor i in range(N) :\rgraph.append(list(map(int, input().split())))\rfor j in range(M) :\rif graph[i][j] == 1 :\rqueue.append([i,j])\rr = bfs() for i, j in enumerate(graph) :\rif 0 in j :\rr = -1\rbreak\rprint(r)\r TestCase \r ","description":"백준 토마토","id":9,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 7578 토마토","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-7578-tomato/"},{"content":"BAEKJOON - 2606 미로(maze) Task description  N×M크기의 배열로 표현되는 미로가 있다.\n1\t0\t1\t1\t1\t1\n1\t0\t1\t0\t1\t0\n1\t0\t1\t0\t1\t1\n1\t1\t1\t0\t1\t1\n  미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.\n  위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.\n Condition input 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.\n4 6\r101111\r101010\r101011\r111011\r output 15\r Solution n, m = map(int, input().split())\rqueue = []\rmatrix = []\rfor i in range(n):\rmatrix.append(list(input()))\rqueue = [[0, 0]]\rmatrix[0][0] = 1\rdx = [+1, -1, 0, 0]\rdy = [ 0, 0, -1, +1] #상하좌우\rwhile queue :\ra,b = queue[0][0],queue[0][1]\rdel queue[0]\rfor i in range(4):\rx = a + dx[i]\ry = b + dy[i]\rif 0 \u0026lt;= x \u0026lt; n and 0 \u0026lt;= y \u0026lt; m and matrix[x][y] == \u0026quot;1\u0026quot; : queue.append([x,y])\rmatrix[x][y] = matrix[a][b] + 1\rprint(matrix[n - 1][m - 1])\r TestCase \r ","description":"백준 미로","id":10,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2178 미로","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2178-maze/"},{"content":"BAEKJOON - 2606 바이러스(virus) Task description  신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.\n  예를 들어 7대의 컴퓨터가 \u0026lt;그림 1\u0026gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.\n  어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.\n  입력\n첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.\n  출력\n1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.\n Condition   1 번 컴퓨터가 탐색 시작 노드이다. 1 \u0026lt;= N \u0026gt;= 100 (컴퓨터의 수) M (네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수)   input 7\r6\r1 2\r2 3\r1 5\r5 2\r5 6\r4 7\r output 4\r Solution   1부터 10001까지 모든 숫자 조회 숫자를 문자로 바꿔 저장 no는 자기자신의 값 i로 세팅 숫자의 자리수 만큼 반복 자리수의 숫자를 no에 더해줌 생성된 d(n) 값을 self dict에 추가 1 ~ 10001 까지의 숫자중 dict에 없는 숫자만 출력   from collections import deque\rN = int(input()) # 컴퓨터의 갯수\rM = int(input()) # 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수\r# 그래프 생성\rgraph = [[] for i in range(N+1)] # 0부터 N까지의 배열 (0은 사용안함)\rfor i in range(0,M) : # 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수만큼 반복\rK = list(map(int, input().split()))\t# 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍\rgraph[K[0]].append(K[1])\t# 그래프에 연결 추가\rgraph[K[1]].append(K[0]) # 반대의 경우도 연결 추가\r# 방문을 체크할 배열 생성\rvisited = [False for i in range(N+1)] # 방문 안한것으로 0~N까지의 배열 생성 (0은 사용 안함)\rqueue = deque() # 큐 생성\rcount = 0 # 결과 (1번 컴퓨터로 인해 바이러스 감염된 컴퓨터의 수)\rstart = 1 # 탐색 시작 컴퓨터 1\rqueue.append(start)\t# 큐에 추가\rvisited[start] = True\t# 1번 컴퓨터 방문처리\rwhile queue : # 큐의 데이터가 있는 동안\ridx = queue.popleft() # 검사할 컴퓨터의 번호를 팝\r#print(idx) # BFS 출력 하지만 문제\rif idx != start : # 탐색 시작 노드 1이 아닌것\rcount += 1\t# 1번 컴퓨터로 인해 감염된 컴퓨터 카운트\rfor node in graph[idx]: # 검사할 컴퓨터의 인접노드(graph[idx])의 연결된 인접 컴퓨터(노드) 만큼\rif not visited[node] : # 방문한 컴퓨터가 아닌 경우\rqueue.append(node)\t# 큐에 추가\rvisited[node] = True # 방문처리\rprint(count) # 결과 출력 (1번 컴퓨터로 인해 바이러스 감염된 컴퓨터의 수)\r  최초 함수로 코딩했으나, 백준에서는 함수를 사용하면 오답처리가 되었다.\n \rfrom collections import deque\rdef bfs(graph, start ,visited) :\rcount = 0\rqueue = deque()\rqueue.append(start)\rvisited[start] = True\rwhile queue :\ridx = queue.popleft()\r#print('pop',idx)\rif idx != start :\rcount += 1\rfor node in graph[idx]:\rif not visited[node] :\rqueue.append(node)\rvisited[node] = True\rreturn count\rN = int(input())\rM = int(input())\rgraph = [[] for i in range(N+1)]\rfor i in range(0,M) :\rK = list(map(int, input().split()))\rgraph[K[0]].append(K[1])\rgraph[K[1]].append(K[0])\rvisited = [False for i in range(N+1)]\r#print (graph,'\\n', visited)\rbfs(graph,1,visited)\r TestCase 예제 입력 7\r6\r1 2\r2 3\r1 5\r5 2\r5 6\r4 7\r예제 출력 4\r ","description":"백준 셀프 넘버","id":11,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2606 바이러스","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/baekjoon-2606-virus/"},{"content":"너비 우선 탐색 알고리즘 BFS (Breadth-First Search)  BFS는 너비 우선 탐색이라고 부르며, 시작 위치에서 가까운 노드부터 우선적으로 탐색하는 알고리즘이다.\n  BFS는 큐 자료구조를 이용하며, 구체적인 동작 과정은 아래와 같다.\n   탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복함.     그래프를 준비하고, 시작 노드는 1로 BFS를 시작한다. (번호가 낮은 인접 노드부터 방문)    시작 노드인 \u0026lsquo;1\u0026rsquo;을 큐에 삽입하고 방문 처리를 한다.    큐에서 노드 \u0026lsquo;1\u0026rsquo;을 꺼내 방문하지 않은 인접 노드 \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;8\u0026rsquo;을 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;2\u0026rsquo;를 꺼내 방문하지 않은 인접 노드 \u0026lsquo;7\u0026rsquo;을 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;3\u0026rsquo;을 꺼내 방문하지 않은 인접 노드 \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;를 큐에 삽입하고 방문 처리한다.    큐에서 노드 \u0026lsquo;8\u0026rsquo;을 꺼내고 방문하지 않은 인접 노드가 없으므로 무시한다.    큐에 남아있는 \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;을 꺼낸다.    이러한 과정을 반복하여 전체 노드의 탐색 순서는 다음과 같다.\n 1 2 3 8 7 4 5 6  BFS 소스코드 예제 (Python)  아래 소스는 노드를 2차원 배열로 생성하여 [0]은 비워두고, 인덱스 별로 배열로 인접 노드를 정의함. 예를들어, graph[1] = [2, 3, 8] 로 1번 노드에 인접한 2, 3 8로 구성된다.\n from collections import deque\r# BFS 함수 정의\rdef bfs(graph, start, visited):\r# 큐(Queue) 구현을 위해 deque 라이브러리 사용\rqueue = deque()\r# 시작 노드(1)를 큐에 넣고, 방문 처리\rqueue.append(start)\rvisited[start] = True\r# 큐가 빌 때까지 반복\rwhile queue :\r# 큐에서 하나의 원소를 뽑아 출력\rv = queue.popleft()\rprint(v, end=' ') # print()의 기본 옵션중 end=' '를 통해 개행하지 않고 옆으로 출력을 붙인다.\r# 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입\rfor i in graph[v]:\rif not visited[i] :\rqueue.append(i)\rvisited[i] = True\rpass\r# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)\rgraph = [\r[],\r[2, 3, 8],\r[1, 7],\r[1, 4, 5],\r[3, 5],\r[3, 4],\r[7],\r[2, 6, 8],\r[1, 7]\r]\r# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)\rvisited = [False] * 9\r# 정의된 BFS 함수 호출\rbfs(graph, 1, visited)\r 참고   파이썬(Python) 기초 print ( )문의 옵션 (sep , end , format , Escape )          ","description":"bfs 탐색 알고리즘.","id":12,"section":"blog","tags":["Algorithm"],"title":"너비 우선 탐색 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/search/bfs/bfs-algorithm/"},{"content":"I have worked A (\u0026lsquo;나는 A에서 일했었습니다\u0026rsquo;)  Eight years ago, I have worked in a buffet. I served foods and cleaned the rooms. (나는 8년전에 뷔페에서 일했습니다. 나는 음식을 제공하고 방을 청소했습니다.)\n really/quite tough (\u0026lsquo;정말/꽤 힘들다\u0026rsquo;)  it was really/quite tough but fun at the same time. (매우/꽤 힘들었지만, 동시에 재미있었습니다.)\n I worked with A (\u0026lsquo;나는 A와 함께 일했다\u0026rsquo;)  because I worked with my friends. (왜냐하면, 나의 친구들과 같이 일했기 때문이다)\n be 동사 + V-ing (\u0026lsquo;V 하는중이다\u0026rsquo;)  I am working right now. (나는 일하는 중이다.)\n  I was hanging out with my friends. (나는 친구들과 어울리고 있었다.)\n I met A (\u0026lsquo;나는 A를 만났다\u0026rsquo;)  I met good friends there. (\u0026lsquo;나는 그곳에서 좋은 친구들을 만났다\u0026rsquo;)\n I was A and [sub-topic] (나는 A 였고, [sub-topic] 이였습니다.)  I was a student and got a part-time job for weekends. (저는 학생이었고 주말에 아르바이트를했습니다.)\n  I was a child and liked to joke (저는 어렸었고, 장난을 좋아했습니다.)\n I worked there on weekends while I was a student and even after I graduated/after I got a full-time job.   저는 학생 시절 주말에 일했고 졸업 후에도 정규직을 얻은 후에도 그곳에서 일했습니다.)\n I first started working there when I was a student, but kept working on weekends even after I got a full-time job  학생 시절부터 일을 시작했는데 정규직을 잡은 후에도 주말에도 계속 일했습니다.)\n don’t enjoy going to buffets because of their low-quality food, but I like the lunch buffets of the family restaurants, like Outback or VIPs.   음식의 질이 낮기 때문에 뷔페에가는 것을 좋아하지 않지만 아웃백이나 VIP 같은 패밀리 레스토랑의 점심 뷔페는 좋아합니다.')\n Just because (\u0026lsquo;그냥\u0026rsquo;) because + 문장  because you are beautiful. (당신은 아름다우니까요.)\n because of + 단어/절  because of your money. (당신의 돈 때문에요.)\n Grammar Error: Eight years ago, I was worked 뷔페, serve and cleaned rooms. → Eight years ago, I have worked in a 돌잔치 buffet. I served steaks (foods) and cleaned the rooms.\rIt was so tough and fun → It was really/quite tough but fun (at the same time).\rIt was so tough, (that) I quit.\rbecause working with friends → because I worked with my friends.\rbe 동사 + V-ing (I am working right now. / I was hanging out with my friends.)\rI was + meet good friends → I met good friends there.\rI was a student and got a job to work on weekends. → I was a student and got a part-time job for weekends.\r→ I worked there on weekends while I was a student and even after I graduated/after I got a full-time job.\r→ I first started working there when I was a student, but kept working on weekends even after I got a full-time job (I became ~).\rI don’t enjoy buffet because of their food, but I like franchise restaurants’ lunch buffet, like Outback. → I don’t enjoy going to buffets because of their low-quality food, but I like the lunch buffets of the family restaurants, like Outback or VIPs.\r New expressions learned today: because + 문장 because you are beautiful. because of + 단어/절 because of your money.\rJust because. 그냥\rA: Why do you like skateboarding?\rB: Just because. It’s fun.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":13,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.07.01","uri":"https://offetuoso.github.io/blog/english/202107/20210701-english-speak/"},{"content":"백준 4673 Self Number Task description  문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n  양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n  예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.\n  33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...\r  n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.\n  생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다.\n 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97\r  10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.\n Condition   10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.   input  없음\n output 1\r3\r5\r7\r9\r20\r31\r42\r53\r64\r|\r| \u0026lt;-- a lot more numbers\r|\r9903\r9914\r9925\r9927\r9938\r9949\r9960\r9971\r9982\r9993\r Solution   1부터 10001까지 모든 숫자 조회 숫자를 문자로 바꿔 저장 no는 자기자신의 값 i로 세팅 숫자의 자리수 만큼 반복 자리수의 숫자를 no에 더해줌 생성된 d(n) 값을 self dict에 추가 1 ~ 10001 까지의 숫자중 dict에 없는 숫자만 출력   \rself = {} #dist 생성\rfor i in range(1, 10001) : # 1 ~ 10000 까지\rsNo = str(i)\t# 숫자를 문자열로 변경\rno = i # 자기 자신을 세팅하여, \u0026lt;mark\u0026gt;33\u0026lt;/mark\u0026gt; + 3 + 3 = 39 부분을 처리\rfor j in range(0,len(sNo)) :\t# 반복문으로 자리수 마다 no에 더해주며, 33 \u0026lt;mark\u0026gt;+ 3 + 3\u0026lt;/mark\u0026gt; = 39 부분을 처리\rno += int(sNo[j])\rself[no] = no # 생성된 값을 dist에 추가\rfor i in range(1, 10001) :\t# 1 ~ 10000까지 숫자중 if self.get(i) is None :\t# d(n)를 통하여 생성되지 않은 숫자를 찾음\rprint(i)\t# self number 출력\r TestCase  ","description":"백준 셀프 넘버","id":14,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 4673 셀프 넘버","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/self-number/"},{"content":"백준 8958 ox quiz Task description  \u0026ldquo;OOXXOXXOOO\u0026quot;와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.\n  \u0026ldquo;OOXXOXXOOO\u0026quot;의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.\n  OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.   input 5\rOOXXOXXOOO\rOOXXOOXXOO\rOXOXOXOXOXOXOX\rOOOOOOOOOO\rOOOOXOOOOXOOOOX\r output 10\r9\r7\r55\r30\r Solution   입력 받은 N 만큼 케이스를 입력받아 반복한다. 케이스를 입력받고 길이만큼 반복한다. 점수(score)와 더해줄 값(addition)을 0으로 초기화 한다. 케이스를 문자열로 변경하고 문자열 하나씩 슬라이스하여 str에 저장. str의 값을 비교하여 1. O인경우, addition을 1 증가시키고 score에 addition을 더해준다. 2. X인경우, addition을 0 으로 초기화 시킨다. 케이스의 마지막 str일때 score를 출력한다.   n = int(input()) # 입력받을 케이스 갯수\rfor i in range(n): # 입력받은 수 만큼 반복\rcase = input()\t# 케이스 입력받음 ex) OOXXOXXOOO\rscore = 0\t# 케이스의 점수\raddition = 0\t# 점수에 더해지는 값\rfor j in range(0,len(case)):\t# 케이스의 길이 만큼 len(OOXXOXXOOO)\rstr = case[j] # 케이스를 인덱스로 1개씩 순회\rif str == 'O' :\t# O인경우 addtion 1증가 score에 addtion 더함\raddition +=1\rscore += addition else : # X인경우 addtion 0으로 초기화\raddition = 0\rif j == len(case) -1 :\t# 케이스의 마지막 str인 경우 score 출력\rprint(score)\r TestCase 5\rOOXXOXXOOO\rOOXXOOXXOO\rOXOXOXOXOXOXOX\rOOOOOOOOOO\rOOOOXOOOOXOOOOX\r ","description":"백준 OX 퀴즈","id":15,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 8958 OX 퀴즈","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/ox-quiz/"},{"content":"PermCheck  Codility - Lesson4 - Counting Elements - PermCheck\n Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다.\n순열은 1부터 N까지의 각 요소를 한 번만 포함하는 시퀀스입니다. 예를 들어 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\rA [3] = 2\r  순열이지만 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\r  값 2가 없기 때문에 순열이 아닙니다.\n  목표는 배열 A가 순열인지 확인하는 것입니다.\n  배열 A가 주어지면 배열 A가 순열이면 1을 반환하고 그렇지 않으면 0을 반환합니다.\n예를 들어 다음과 같은 배열 A가 있습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\rA [3] = 2\r  함수는 1을 반환해야합니다. 주어진 배열 A는 다음과 같습니다.\n  A [0] = 4\rA [1] = 1\rA [2] = 3\r  함수는 0을 반환해야합니다.\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . def solution(A) N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수 입니다.   Solution   조건1 배열 A는 순열 [1 \u0026hellip; N] 배열 A를 오름 정렬한다 1. A.sort() 2. N = A[-1] ( A.sort()후 A[-1]은 배열의 최대값)    SUM(A)는 는 순열 A 배열의 합 B(비교대상) = N*(N+1)//2 (수열의 합 공식; 1 ~ N 까지의 합)    SUM(A) == B 는 배열의 합과 수열의 합 공식이 맞는지 비교 1. solution[9, 5, 7, 3, 2, 7, 3, 1, 10, 8] 의 경우 합이 55가 되며, B와 같다. 이를 해결하기 위해서 중복된 숫자를 제거\nA = list(set(A)) 2. set을 통해 중복제거 시 [1,1] 의 경우 문제가 생긴다. 중복제거후 [1],과 1*(1+1)//2 는 1로 통과가 되는 논리적 오류가 발생한다. 이를 해결하기 위해 중복 제거하기 전 A배열의 길이와 N값과 비교한다. 예를 들어, [1,2,3,4] 1부터 4까지의 수열이 있다면 길이와 마지막 숫자는 같을 수 밖에 없으므로 length = N   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\rlength = len(A) # 중복 제거하기 전 A배열의 길이\rA = list(set(A))\t# 중복제거\rA.sort()\t# 정렬\rN = A[-1]\t# A의 제일 큰 수\rB = N*(N+1)//2\t# 수열의 합의 공식\rif sum(A) == B and length == N : # 배열 A와 수열의 합이 공식이 같고, 중복 제거하기 전 A배열의 길이와 N의 값이 같은지 체크\rreturn 1\relse :\rreturn 0\rpass\r#solution([4,1,3,2])\r#solution([2,2,8])\r#solution([9, 5, 7, 3, 2, 7, 3, 1, 10, 8])\r#solution([1,1])\r  시간 복잡성 O(N) or O(N * log(N))\n TestCase #solution([4,1,3,2])\r#solution([2,2,8])\r#solution([9, 5, 7, 3, 2, 7, 3, 1, 10, 8]) \u0026lt;\u0026lt; 순열이 아닌경우\r#solution([1,1]) \u0026lt;\u0026lt; 순열이 아닌경우2 (중복제거 해도 문제)\r ","description":"PermCheck","id":16,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - PermCheck","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-check/"},{"content":"백준 2839 설탕배달 Task description  상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n  상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\n  상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\n Condition   첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)   input output    case input ouput     1 18 4   2 4 -1   3 6 2   4 9 3   5 11 3    Solution   5로 최대한 나눈다. 5로 나누어 몫이 0인경우, 0이 아닌경우로 나누어진다. 1. 5로 나누어 몫이 0인경우 5의 배수이므로 5로 나눈 값(division) 이 결과 5로 나누어 몫이 아닌경우 1. 5로 나눌수 없고(값이 0) 3으로 나누어 떨어지지 않는경우 -1 이 결과 2. 5로 나눈 몫을 3으로 나누어 몫이 0인 경우 5로 나눈 값(division)와 5로 나눈 몫을 3으로 나눈 값(quotient//3)을 더한 값이 결과 ; 3. 5로 나눈 몫을 3으로 나누어 몫이 0이 아닌경우 1~ 5로 나눈 값 까지 루프를 생성 1. 5로 나눈것을 1단계씩 되돌려, 3으로 나누어 몫이 0으로 나누어 떨어지는 값 찾으면, (division-i)+(quotient+(5*i)) 이 값 2. 끝까지 못찾았을때 -1이 결과   N = int(input())\rdivision = N//5 # 5로 나눈 값\rquotient = N%5 # 5로 나눈 몫\rresult = 0\rif quotient == 0 : # 5로 나누어 떨어지면 result = division # 5로 나눈 값이 결과\relse : # 5로 나누어 몫이 남는 경우\rif division == 0 and not N % 3 == 0 :\t# 5로 나눌수 없고(값이 0) 3으로 나누어 떨어지지 않는경우 -1 이 결과\rresult = -1\relif quotient%3 == 0 : # 5로 나눈 몫을 3으로 나누어 몫이 0인 경우 \u0026lt;mark\u0026gt;5로 나눈 값(division)와 5로 나눈 몫을 3으로 나눈 값(quotient//3)을 더한 값이 결과\rresult = division\rresult += quotient // 3\relse :\t# 5로 나눈 몫을 3으로 나누어 몫이 0이 아닌경우\rfor i in range(1, division+1) : # 1~ 5로 나눈 값 까지 루프\rif (quotient+(5*i)) %3 == 0 :\t# 5로 나눈것을 1단계씩 되돌려, 3으로 나누어 몫이 0으로 나누어 떨어지는 값 찾으면, (division-i)+(quotient+(5*i)) 이 값\rresult = (division-i) result += (quotient+(5*i)) // 3\rbreak\relse :\rif i == division :\t# 끝까지 못찾았을때 -1이 결과\rresult = -1\rbreak\rprint(result)\r TestCase 18 #4\r4 #-1\r6 #2\r9 #3\r11 #3\r ","description":"백준 설탕배달","id":17,"section":"blog","tags":["Algorithm","CodingTest","BAEKJOON"],"title":"BAEKJOON - 2839 설탕배달","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/sugar-delivery/"},{"content":"MaxCounter  Codility - Lesson4 - Counting Elements - MaxCounter\n Task description  처음에는 0으로 설정된 N 개의 카운터가 제공되며 두 가지 가능한 작업이 있습니다.\n  증가 (X) -카운터 X가 1 증가합니다. 최대 카운터 -모든 카운터는 모든 카운터의 최대 값으로 설정됩니다. M 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 이 배열은 연속 작업을 나타냅니다.\n  A [K] = X, 즉 1 ≤ X ≤ N이면 연산 K는 증가 (X), A [K] = N + 1이면 작업 K는 최대 카운터입니다. 예를 들어, 정수 N = 5이고 배열 A가 다음과 같은 경우 :\n  A [0] = 3 A [1] = 4 A [2] = 4 A [3] = 6 A [4] = 1 A [5] = 4 A [6] = 4\r  각 연속 작업 후 카운터 값은 다음과 같습니다.\n  (0, 0, 1, 0, 0) (0, 0, 1, 1, 0) (0, 0, 1, 2, 0) (2, 2, 2, 2, 2) (3, 2, 2 , 2, 2) (3, 2, 2, 3, 2) (3, 2, 2, 4, 2)\r  목표는 모든 작업 후 모든 카운터의 값을 계산하는 것입니다.\n  정수 N과 M 개의 정수로 구성된 비어 있지 않은 배열 A가 주어지면 카운터 값을 나타내는 정수 시퀀스를 반환합니다. 결과 배열은 정수 배열로 반환되어야합니다. 예를 들면 다음과 같습니다.\n  A [0] = 3 A [1] = 4 A [2] = 4 A [3] = 6 A [4] = 1 A [5] = 4 A [6] = 4\r  함수는 위에서 설명한대로 [3, 2, 2, 4, 2]를 반환해야합니다.\n Condition   def solution(N, A) 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . N은 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. N + 1 ] 범위 내의 정수 입니다.   Solution  이번 문제 풀이의 핵심은 increase(X) 보다, max counter를 루프를 돌지 않고 해결하는가 였습니다. 카운트는 0부터 값을 세지만, max counter 이후에는 max counter 시점의 최대 카운트 값부터 다시 카운트를 세고, max counter 시점의 최대 카운트 값을 모든 배열에 적용 후 각각의 카운트 값(다시 카운트를 센 카운트 값)을 더해주면 루프 없이 해결할 수 있습니다.\n   count라는 딕셔너리를 생성 배열 A를 루프로 선회하며, 값은 X (A[K])    increase(X) 기능 (1 \u0026lt;= X \u0026lt;= N 일때) \u0026gt; - count에 키가 X인 딕셔너리가 없으면 0으로 생성 \u0026gt; - count1증가 \u0026gt; - max_count(현재 최대 카운트) 값 구함    1 \u0026lt;= X \u0026lt;= N 아닌 ( N+1 == X) 경우 \u0026gt; - max counter 실행시 최대 카운트 세팅 \u0026gt; - 모든 count 값 삭제 \u0026gt; - 현재 최대 카운트 값 0으로 초기화    N개의 요소를 가지는 결과 배열을 max_value(max counter 실행시 최대 카운트) 값으로 생성 count 딕셔너리로 루프 \u0026gt; - max_value 부터 추가된 count의 값 결과 배열 result[X-1]에 세팅 # -1 은 인덱스 번호로 변경 0~ X-1   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(N, A):\rcount = {}\rmax_count = 0 # 현재 최대 카운트 값\rmax_value = 0 # max counter 이후에는 max counter 시점의 최대 카운트 값\rfor X in A :\rif 1 \u0026lt;= X \u0026lt;= N : # increase(X) 기능 (1 \u0026lt;= X \u0026lt;= N 일때)\rif count.get(X) is None :\t# count에 키가 X인 딕셔너리가 없으면 0으로 생성\rcount[X] = 0\rcount[X] += 1\t# count[X] 1증가\rmax_count = max(count[X], max_count) # 현재 최대 카운트 값 구함 else : # max counter 기능 (N+1 == X인 경우)\rmax_value += max_count\t# max counter 실행시 최대 카운트 세팅 count.clear()\t# 모든 count 값 삭제\rmax_count = 0\t# 현재 최대 카운트 값 0으로 초기화\rresult = [max_value] * N # N개의 요소를 가지는 결과 배열을 max_value(max counter 실행시 최대 카운트) 값으로 생성\rfor X, value in count.items() :\rresult[X-1] += value\t# max_value 부터 추가된 count[X]의 값 결과 배열 result[X-1]에 세팅 # -1 은 인덱스 번호로 변경 0~ X-1\rreturn result\r  시간 복잡성 O(N + M)\n TestCase solution(5,[3,4,4,6,1,4,4])\r ","description":"MaxCounter","id":18,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - MaxCounter","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/max-counter/"},{"content":"샤딩(Sharding) Database의 샤딩(Sharding)이란?  같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법을 의미.\n 샤딩은 수평 분할(Horizontal Partitioning)과 동일. 테이블의 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위함. application level에서도 가능하지만 database level에서도 가능.   수평 분할 (horizotal partitioning, Range Based Partitioning)  샤딩과 동일한 의미를 가지며 스키마를 다수의 복제본을 구성하고 각각의 샤드에 샤드키를 기준으로 데이터를 분리하는 것을 말한다. DBA가 데이터의 패턴과 저장공간을 잘 알고 샤드키를 선정하여 분할한다.\n    id Name Age     1 Bob 27   3 Alice 23   5 Dennis 20   7 Miller 24       id Name Age     2 Sago 29   4 Riley 30   6 Wilson 18   8 Brown 25    샤딩의 장점과 단점 장점   수평적 확장 horizontal scaling (=scaling out)이 가능하다: 서버의 하드웨어(RAM, CPU 등)를 업그레이드하는 수직적 확장과 다르게, 존재하는 stack에 machine을 추가하는 방식으로 능력을 향상시킬 수 있다. 쿼리 반응 속도를 빠르게 한다: 스캔 범위를 줄이기 때문!\n application을 신뢰할 수 있게 만든다: 서버 다운 등 생겼을 때, un-sharded 데이터베이스와 다르게 단일 shard에만 영향을 줄 확률이 높다. application이 일부라도 작동할 수 있도록 위험을 완화시켜준다.   단점   잘못 사용했을 때 risk(데이터 손상, 유실 등)가 크다. 데이터가 한 쪽 shards에 쏠려 sharding이 무의미 해질 수 있다. 한 번 쪼개게 되면, 다시 un-sharded 구조로 돌리기 어렵다. 모든 데이터베이스 엔진에서 natively support 되지 않는다.   샤딩시 고려사항   데이터 재분배   샤딩을 진행 한 DB의 물리적인 용량한계와 성능한계가 왔을 경우 적절하게 shard수를 scale-up 작업을 늘릴 수 있도록 설계해야한다. (확장고려)    샤딩으로부터 데이터 조인   샤딩된 데이터베이스간에 조인이 불가능하기 때문에 어느정도의 데이터 중복은 감안해야 한다.    파티셔닝 잘 구현하기   샤딩의 기준이되는 샤드키를 잘 정하거나 hash의 경우 함수를 잘 선택해야 한다.    샤드된 DBMS들의 트랜잭션 문제   XA와 같은 Global Transaction을 사용하면 샤딩된 데이터베이스간에 트랜잭션이 가능하나 성능저하의 문제가 있다.    Global Unique Key   샤딩에 경우 DBMS에서 제공하는 auto-increment를 사용하면 key가 중복될 가능성이 있기 때문에 application 레벨에서 key 생성을 담당해야 한다.    데이터 축소   Table 단위를 가능한 작게 만들자.   샤딩(Sharding) 구성시 고려할 문제   샤딩 알고리즘 : 정수값 등으로 샤딩을 처리할 때 데이터의 비율 고려 샤딩 데이터 조회 : 분산된 Database에서 Data를 어떻게 읽을 것인가 데이터 재분배 : 서비스 정지 없이 데이터베이스 스키마 및 서버 설계 필요 샤딩 조인 : 역정규화를 어느정도 감수해야 함   샤딩(Sharding) 방법  Shard Key를 어떻게 정의하느냐에 따라 데이터를 분산시키는 방법이 결정됩니다.\n range-based sharding  주어진 value의 범위를 기반으로 데이터를 나누는 샤딩 방법입니다. 예를 들어 연도 컬럼을 이용하여 데이터를 나눌수 있습니다. 이 방식을 이용하면 몇몇 개의 shard를 만들고 범위에 연도에 따라 데이터를 저장할 수 있습니다.\n    hiredate Name Age     1981 Bob 27   1982 Alice 23   1983 Dennis 20   1985 Miller 24       hiredate Name Age     2001 Sago 29   2005 Riley 30   2007 Wilson 18   2009 Brown 25       hiredate Name Age     2011 Oh 32   2012 Kim 33   2017 Park 24   2021 Lee 42    장점  가장 큰 장점은 실행이 비교적 간단하다는 것이다. 모든 shard들은 다른 데이터를 가지고 있고, original 데이터베이스 뿐 아니라 서로가 똑같은 스키마를 가지게 된다. application code는 그저 데이터가 어떤 범위인지 읽고 그에 상응하는 shard에 쓰면 된다.\n 단점  반면, 데이터베이스를 골고루 분배하지는 못하기 때문에 앞서 말한 데이터베이스 hotspots가 생길 수 있다. 위 그림 상으로는 모든 shard들이 같은 양의 데이터를 가지고 있지만, 특정 데이터가 다른 데이터에 비해 더 많이 찾아질 수 있기 때문에 읽는 횟수가 불균형할 수 있다.\n hash based sharding  다른 말로 Key Based Sharding, modulus-based sharding이라고도 불린다. 키와 같은 값을 해쉬함수(Hash)에 넣어 나오는 값으로 서버를 지정하는 방식\n  hash 함수는 고객 이메일과 같은 데이터 조각을 Input으로 받아, hash value라는 완전히 다른 형태의 value를 Ouput으로 내보낸다. sharding의 관점에서 봤을 때 hash value는 들어오는 데이터가 저장될 shard를 결정하는 shard ID가 될 것이다.\n shard key  올바른 shard에 일관성 있는 방식으로 들어갈 수 있도록 entry를 위치시키기 위해, hash 함수에 들어가는 value들은 같은 column에서 나와야 한다. 이 colum을 shard key라고 부른다.\n   각 행을 위한 고유 식별자를 생성한다는 측면에서 shard keys는 primary keys(pk)와 비슷하다. 넓게 본다면, shard key는 정적이어야 하고 시간에 따라 바뀌어서는 안 된다. 그렇지 않으면 업데이트에 필요한 작업이 증가하고 퍼포먼스를 느리게할 수 있다.   단점  key based sharding이 많이 쓰이긴 하지만, 데이터베이스에 서버를 동적으로 추가하거나 제거할 때 어려울 수 있다. 서버를 추가할 때 각각의 서버는 그에 상응하는 hash value가 있어야 하고, 존재하는 많은 entry들은 맞는 hash value에 다시 매핑되고, 적합한 서버에 migrate 되어야 한다. 데이터를 rebalancing하는 것을 시작한다면 새로운 hash 함수 뿐 아니라 예전 hsah 함수도 유효하지 않게 된다. 결과적으로 migration을 하는 동안 애플리케이션은 새로운 데이터를 쓰지 못하고, 쉴 수밖에 없다.\n 장점  이 전략의 가장 큰 장점은 hotspots를 방지하기 위해 데이터를 골고루 분배할 수 있고, 알고리즘적으로 분배하기 때문에 range나 directory와 다르게 모든 데이터가 어디에 위치하는지 말해주는 map을 가질 필요가 없다.\n Directory Based Sharding  파티셔닝 매커니즘을 제공하는 추상화된 서비스 생성. 이 sharding을 실행하기 위해서는 반드시 어떤 shard가 어떤 데이터를 갖고 있는지를 추적할 수 있는 shard key를 사용하는 lookup table을 만들고 유지해야 한다.\n lookup table  간단히 말하면 특정 데이터를 찾을 수 있는(where specific data can be found) 정적인 정보를 갖고 있는 테이블이다.\n  Delivery Zone 열은 shard key로 정의된다. shard key로부터 온 데이터는 각각의 행이 어떤 shard에 쓰여져야 하는지를 lookup 테이블과 함께 쓰여진다. range based sharding과 비슷해 보이지만, 범위를 기준으로 shard key의 데이터를 내려주는 것과 다르게 각 키들은 각자 자신만의 특별한 shard에 들어가게 된다.\n 어떤 상황에서 쓸지  해당 방법은 shard key가 낮은 cardinality를 가질 때 좋은 선택이다. hash 함수를 거치지 않기 때문에 key based sharding과도 다르다. 그저 lookup table에서 key를 보고 어디에 데이터를 쓸지 결정하는 것 뿐이다.\n 장점  유연성(flexibility)이다. range based sharding은 범위에 국한되고, key based sharding은 만들고 난 뒤 바꾸기 매우 어려운 hash 함수에 국한된다. 반면 directory based sharding은 데이터를 쪼개기 위한 entry들은 어떤 시스템이나 알고리즘에 상관 없이 entry를 할당할 수 있도록 해준다. 동적으로 shard를 추가하는 것도 비교적 쉽다.\n 단점  반면 쿼리하거나 write하기 전에 lookup table에 연결이 필요하기 때문에, application 퍼포먼스에 안 좋은 영향(detrimental impact)을 줄 수 있다. 게다가 lookup table은 실패 지점이 될 수 있다. lookup table이 손상되면 데이터를 새로 쓰거나 존재하는 데이터에 접근하는 것에 영향을 줄 수 있기 때문이다.\n 참조   MySQL Shard 데이터 재분배 Database sharding이란? Database의 샤딩(Sharding)이란? 파티셔닝의 정의와 종류 그리고 샤딩   ","description":"샤딩 ","id":19,"section":"blog","tags":["Database","Sharding","manage"],"title":"샤딩(Sharding)","uri":"https://offetuoso.github.io/blog/develop/database/tech/sharding/"},{"content":"AWS RDS RDS 서비스 생성  AWS Management Console에서 RDS 접속\n RDS 데이터베이스 인스턴스 생성  RDS에 MySQL 인스턴스를 생성한다.\n  데이터베이스 생성 클릭\n  데이터베이스 생성\n 표준 생성 원하는 데이터베이스 선택    Mysql 버전 선택과 템플릿 설정\n Mysql Community Mysql 버전 선택 - MySQL 5.7.22 템플릿 선택 -    DB 인스턴스 설정\n 인스턴스명 추가 DB에 접근할 계정 정보 입력    DB 인스턴스 크기\n  DB 인스턴스 크기\n 스토리지 자동조정 해제 - 체크 해두면 자동 스토리지 증설로 인한 요금부과가 될 수 있습니다.    연결 설정\n 추가 연결 구성 클릭후 펼치기    외부 연결을 위한 퍼블릭 액세스 수정 - 예    데이터베이스 생성\n  생성된 데이터베이스 인스턴스 확인  파라미터 그룹 추가  데이터베이스의 문자 인코딩 관련 파라미터를 UTF-8로 설정을 한다.\n  왼쪽 메뉴 파라미터 그룹 - 파라미터 그룹 생성\n  파라미터 그룹 생성\n 생성한 MySQL 버전을 선택 - 잘못 선택되면 파라미터 그룹 선택 창에서 보이지 않음 파라미터 정보 추가    생성된 파라미터 그룹명 클릭\n  파라미터 인코딩 수정\n cha 검색    1.1. utf8 선택 가능한 것들 모두 수정\n  col 검색    2.1. utf8 선택 가능한 것들 모두 수정\n  생성된 데이터베이스 인스턴스 수정\n  생성한 파라미터 그룹 선택\n  데이터베이스 인스턴스 수정\n 수정 예약 - 즉시 적용    수정중\n 보안 설정 (인바운스)  외부에서 접속이 안되는 경우 확인 해봐야 할것\n 연결 - 퍼블릭액세스 (예) 보안 - 인바운스 규칙    데이터베이스 - 인스턴스 - 수정\n  인바운스 default 클릭\n  보안그룹 클릭\n  인바운스 규칙 편집\n  인바운스 규칙 저장\n DBeaver 연결  연결 생성\n  Server 정보 추가\n   Server Host는 생성한 RDS의 엔드포인트 입력   RDS 왼쪽 메뉴 데이터베이스 - 인스턴스 - 연결및 보안    연결 완료\n End ","description":"AWS RDS를 이용한 Mysql","id":20,"section":"blog","tags":["AWS","RDS","MySQL"],"title":"AWS RDS에 MySQL 인스턴스 생성 후 연결","uri":"https://offetuoso.github.io/blog/develop/database/mysql/aws-rds-mysql/"},{"content":"FrogRiverOne  Codility - Lesson4 - Counting Elements - FrogRiverOne\n Task description  은 개구리가 강 건너편으로 가고 싶어합니다. 개구리는 처음에 강의 한 둑 (위치 0)에 있으며 반대쪽 둑 (위치 X + 1)에 도달하려고합니다. 잎은 나무에서 강 표면으로 떨어집니다.\n  엽을 나타내는 N 개의 정수로 구성된 배열 A가 제공됩니다. A[K]는 초 단위로 측정 된 시간 K에서 한 잎이 떨어지는 위치를 나타냅니다.\n  는 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 찾는 것입니다. 개구리는 잎이 1에서 X까지 강 건너 모든 위치에 나타날 때만 건널 수 있습니다 (즉, 1에서 X까지의 모든 위치가 잎으로 덮여있는 가장 빠른 순간을 찾고 싶습니다). 강의 흐름 속도가 무시할 정도로 작다고 가정 할 수 있습니다. 즉, 잎이 강에 떨어지면 위치가 바뀌지 않습니다.\n  예를 들어, 다음과 같은 정수 X = 5 및 배열 A가 제공됩니다.\n  A [0] = 1\rA [1] = 3\rA [2] = 1\rA [3] = 4\rA [4] = 2\rA [5] = 3\rA [6] = 5\rA [7] = 4\r  번째 6에서는 잎이 위치 5로 떨어집니다. 이것은 잎이 강 건너 모든 위치에 나타나는 가장 빠른 시간입니다.\n  N 개의 정수와 X로 구성된 비어 있지 않은 배열 A가 주어지면 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 반환합니다. 개구리가 강 반대편으로 점프 할 수없는 경우 함수는 −1을 반환해야합니다.\n  예를 들어, 주어진 X = 5이고 배열 A는 다음과 같습니다.\n  A [0] = 1\rA [1] = 3\rA [2] = 1\rA [3] = 4\rA [4] = 2\rA [5] = 3\rA [6] = 5\rA [7] = 4\r  함수는 위에서 설명한대로 6을 반환해야합니다.\n Condition   def solution(X, A) 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 . N 및 X는 [ 1 .. 100,000 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ 1 .. X ] 범위 내의 정수 입니다.   Solution   total = sum(range(X+1)) chked = [None for i in range(X)] # 체크 배열을 None으로 초기화 하여 생성 루프로 A를 순회 if( chked[A[i]-1] == None) : #체크 배열에 값이 없는지 체크 4-1. chked[A[i]-1]에 A[i] 세팅 4-2. chk_sum에 A[i]을 합함 if total == chk_sum : #   \r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, A):\rtotal = sum(range(X+1))\t# 1~X 까지의 합을 생성\rchked = [None for i in range(X)] # 체크 배열을 None으로 초기화 하여 생성\rchk_sum = 0\rfor i in range(len(A)) :\rif( chked[A[i]-1] == None) : # 체크 배열에 값이 없는지 체크\rchked[A[i]-1] = A[i]\rchk_sum += A[i]\rif total == chk_sum : # total과 chk_sum같다면 모든 1~X까지 찾은 상태이므로 현재의 i를 반환\rreturn i\rif total != chk_sum :\t# total과 chk_sum 다르다면 1~X까지의 찾은 숫자중에 나오지 않은 수가 있는것 return -1\r  시간 복잡성 O(N)\n TestCase solution(5, [1,3,1,4,2,3,5,4])\r ","description":"FrogRiverOne","id":21,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - FrogRiverOne","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/frog-river-one/"},{"content":"Tape Equilibrium  Codility - Lesson3 - Time Complexity - TapeEquilibrium\n Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 0 \u0026lt;P \u0026lt;N 인 정수 P는이 배열 A를 두 부분으로 분할합니다 (A [0], A [1], \u0026hellip;, A [P − 1] 및 A [P], A [ P + 1], \u0026hellip;, A [N-1]) 분할 된 두 부분의 차이는 다음의 값입니다. | (A [0] + A [1] + \u0026hellip; + A [P − 1]) − (A [P] + A [P + 1] + .. . + A [N − 1]) | 즉, 첫 번째 부분의 합과 두 번째 부분의 합 사이의 절대 차이입니다. 달성 할 수있는 최소 차이를 반환합니다.\n  예를 들어, 다음과 같은 배열 A가 제공됩니다.\n  A [0] = 3\rA [1] = 1\rA [2] = 2\rA [3] = 4\rA [4] = 3\r  이 테이프들을 4곳으로 나눌 수 있습니다.\n   P = 1, 차이 = | 3 − 10 | = 7 # A[0] ///// A[1] A[2] A[3] A[4] P = 2, 차이 = | 4 − 9 | = 5 # A[0] A[1] ///// A[2] A[3] A[4] P = 3, 차이 = | 6 − 7 | = 1 # A[0] A[1] A[2] ///// A[3] A[4] P = 4, 차이 = | 10 − 3 | = 7 # A[0] A[1] A[2] A[3] ///// A[4]    N 정수의 비어 있지 않은 배열 A가 주어지면 달성 할 수있는 최소 차이를 반환합니다.\n  A [0] = 3\rA [1] = 1\rA [2] = 2\rA [3] = 4\rA [4] = 3\r  함수는 위에서 설명한대로 1을 반환해야합니다.\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오. N은 [ 2 .. 100,000 ] 범위 내의 정수 이고; 배열 A의 각 요소는 [ -1,000 .. 1,000 ] 범위 내의 정수 입니다.   Solution 시도 1  루프를 1번만 사용했지만, sum() 함수를 루프 안에서 처리 했더니 O(N * N)의 시간 복잡도가 나오게 되었다.\n def solution(A):\rminimum = 99999\rfirst = 0;\rfor i in range(0,len(A)-1) :\rfirst += A[i]\rminimum = min(minimum, abs(first-(sum(A)-first)))\rreturn minimum\r  시간 복잡성 O(N * N)\n 시도 2 # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\rminimum = 99999 # 가작작은 차이 값\rfirst = 0; # 첫번째 테이프 그룹\rtotal = sum(A) # A배열 전체의 합\rfor i in range(0,len(A)-1) :\rfirst += A[i] # A[0]~A[i]까지의 합\rsecond = total - first #first를 제외한 나머지 테이프의 합\rminimum = min(minimum, abs(first - second)) #첫번째 그룹의 합과 두번째 그룹의 합의 차이중 가장작은것\rreturn minimum\r  시간 복잡성 O(N)\n TestCase solution([3,1,2,4,3])\r ","description":"Tape Equilibrium","id":22,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - TapeEquilibrium","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/tape-equilibrium/"},{"content":"Perm Missing Elem  Codility - Lesson3 - Time Complexity - PermMissingElem\n Task description  배열 A는 1 ~ N+1의 범위의 정수를 담고 있는 배열이며 1 ~ N+1의 정수중 1개의 숫자(요소)가 빠져있다.\n  예를 들면 다음과 같습니다.\n  A[0] = 2\rA[1] = 3\rA[2] = 1\rA[3] = 5\r  1~5까지의 숫자중 4가 빠져 있기 때문에 4를 반환\n Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오. N은 [ 0 .. 100,000 ] 범위 내의 정수입니다. A의 요소는 모두 구별됩니다. 배열 A의 각 요소는 [1 .. (N + 1)] 범위 내의 정수입니다.   Solution   N은 배열의 길이+1 (인덱스가 0부터 시작하기 때문에 +1) Sum(range(N+1)) - Sum(A) (1 ~ N+1 까지의 합) - (배열의 요소의 합) = 1 부터 N+1 까지의 숫자중 빠진 수   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, Y, D):\rN = len(A)+1\rreturn sum (range(N+1)) - sum(A)\rpass\r  시간 복잡성 O(N) or O(N * log(N))\n TestCase  ","description":"PermMissingElem","id":23,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - PermMissingElem","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-missing-elem/"},{"content":"Frog Jmp  Codility - Lesson3 - Time Complexity - Frog Jmp\n Task description  세 개의 정수 X, Y, D를 입력받는 함수를 작성합니다.\n X는 개구리의 위치 Y는 개구리의 목표 위치 Y는 개구리의 이동거리 위치 X에서 D씩 최소의 이동을 하여 목표를 Y에 도달하거나 넘어가기 위하여 이동하는 최소 횟수 반환    예를 들면 다음과 같습니다.\n  X = 10\rY = 85\rD = 30\r  개구리는 다음과 같이 위치하므로 함수는 3을 반환해야합니다.\n  첫 번째 점프 후 위치 10 + 30 = 40\r두 번째 점프 후 위치 10 + 30 + 30 = 70\r세 번째 점프 후 위치 10 + 30 + 30 + 30 = 100\r Condition   def solution(X, Y, D) X, Y 및 D는 [ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 . X ≤ Y. 다음 가정에 대한 효율적인 알고리즘을 작성하십시오 .   Solution   Y == X 이 경우 개구리가 뛸 필요가 없기 때문에 0을 반환 (이 테스트 케이스를 생각하지 못해서 틀렸었다.)    Y-X = (목표위치 - 시작위치 =남은 거리) (Y-X) % D == 0 (\u0026ldquo;남은 거리 // D가 0으로 떨어지는지 나머지가 있는지 조건\u0026rdquo;) True(나머지 0) : (Y-X) // D False(나머지 0아님) : ((Y-X) // D) + 1   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(X, Y, D):\rif (Y == X) :\rreturn 0\rreturn (Y-X) % D == 0 and (Y-X) // D or ((Y-X) // D) + 1 pass\r  시간 복잡성 O(1)\n TestCase solution(10, 75, 30)\rsolution(2, 2, 1)\rsolution(1, 101, 10)\r ","description":"Frog Jmp","id":24,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Frog Jmp","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-frog-jmp/"},{"content":"RESTful API - Docker의 Mysql과 Mybatis 연동 Docker  Docker에 Mysql을 올리는 것은 저번 포스팅에서 진행하였기 때문에 도커에 Mysql 올리기 링크를 남기고 다음부터 진행합니다.\n  지난 포스트에서 생성한 Docker의 Mysql 컨테이너를 실행\n   docker ps -a (\u0026ldquo;컨테이너 조회\u0026rdquo;)    docker start (\u0026ldquo;컨테이너 시작\u0026rdquo;)  docker restart (\u0026ldquo;컨테이너에 재시작하기\u0026rdquo;) docker stop (\u0026ldquo;컨테이너에 종료하기\u0026rdquo;) docker attach (\u0026ldquo;현재 실행중인 컨테이너에 접속하기\u0026rdquo;)      sudo docker exec -it /bin/bash (\u0026ldquo;컨테이너의 CLI 접속\u0026rdquo;)   PS C:\\WINDOWS\\system32\u0026gt; docker ps -a\rCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\r4b6fb99160bf mysql:5.6 \u0026quot;docker-entrypoint.s…\u0026quot; 9 days ago Exited (255) 2 days ago 0.0.0.0:9876-\u0026gt;3306/tcp, :::9876-\u0026gt;3306/tcp test_mysql\rPS C:\\WINDOWS\\system32\u0026gt; docker start test_mysql\rtest_mysql\rPS C:\\WINDOWS\\system32\u0026gt; sudo docker exec -it test_mysql /bin/bash\r DBeaver 연결 및 테이블 생성  지난 포스트 Mysql DBeaver 설치 참조\n  UserProfile table 생성\n -- test.UserProfile definition\rCREATE TABLE `UserProfile` (\r`id` varchar(64) NOT NULL DEFAULT '',\r`name` varchar(64) DEFAULT NULL,\r`phone` varchar(64) DEFAULT NULL,\r`address` varchar(256) DEFAULT NULL,\rPRIMARY KEY (`id`)\r) ENGINE=InnoDB DEFAULT CHARSET=latin1;\r Dependency 추가 Dependency란 ?  자바 프로젝트 관리 도구인 아파치 메이븐의 XML형태의 라이브러리(의존성) 정의이며, Spring에서 Pom.xml에 추가하는 것을 의존성 주입이라 하며, Pom.xml에 xml 형식으로 추가하면 Maven Repositoy에서 라이브러리 파일을 자동으로 받아준다.\n pom.xml에 MysqlJ Dependency 추가  pom.xml은 /demo/pom.xml 프로젝트 최상단에서 찾아볼수 있습니다. SpringBoot에 Mysql과 Mybatis를 추가하기 위하여 pom.xml에 해당 dependency를 추가할 것입니다.\n  pom.xml은 아래와 같은 구조로 되어있으며, dependencies 밑의 dependency들 처럼 mysqlj와 mybatis를 추가하면 됩니다.\n Maven Repositiry  dependency를 추가하기 위하여 Maven Repositiry를 접속합니다.  MysqlJ (Mysql Connector for Java)  mysql connector를 받기 위하여 mysql j 를 검색합니다. mysqlj는 Mysql을 위한 JDBC 입니다.\n  Maven dependency xml 소스를 복사합니다.\n  pom.xml에 붙여넣고\n  Mysql Connector의 버전을 제거합니다. Spring Boot에서는 자주 사용하는 라이브러리에 한해서 SpringBoot 버전과 가장 호환이 잘되는 버전으로 빌드를 해주는 기능이 있기 때문에 버전은 제거해둡니다. 버전을 남겨두면 버전에 따라 waring이 뜰 수 있습니다.\n pom.xml에 Mybatis Dependency 추가 Mybatis  mybatis를 검색하고 Mybatis Spring Boot Starter를 선택합니다. 마이바티스(MyBatis)는 자바 퍼시스턴스 프레임워크의 하나로 XML 서술자나 애너테이션(annotation)을 사용하여 저장 프로시저나 SQL 문으로 객체들을 연결시키는데 도움을 줍니다.\n  마찬가지로 Mybatis Maven dependency xml pom.xml에 붙여넣습니다.\n application.properties 설정  /demo/src/main/resources/application.properties 파일을 수정합니다.\n  application.properties 파일에 Mysql 접속 정보를 추가합니다.\n spring.datasource.url = jdbc:mysql://localhost:[port]/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;serverTimezone=Asia/Seoul\u0026amp;useSSL=false\rspring.datasource.username = [userId]\rspring.datasource.password = [password]\r  프로젝트 우클릭 \u0026gt; Maven \u0026gt; Update Poject를 통하여 추가한 라이브러리들을 받습니다.\n UserProfile 테이블 생성  기존에 만들었던 com.example.demo.model.UserProfile의 필드들을 토대로 UserProfile 테이블을 생성합니다.\n UserProfile.java package com.example.demo.model;\rpublic class UserProfile {\rprivate String id;\rprivate String name;\rprivate String phone;\rprivate String address;\rpublic UserProfile(String id, String name, String phone, String address) {\rsuper();\rthis.id = id;\rthis.name = name;\rthis.phone = phone;\rthis.address = address;\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getPhone() {\rreturn phone;\r}\rpublic void setPhone(String phone) {\rthis.phone = phone;\r}\rpublic String getAddress() {\rreturn address;\r}\rpublic void setAddress(String address) {\rthis.address = address;\r}\r}\r UserProfile 테이블 엔티티  Id를 키로 잡고 나머지  UserProfile 테이블 생성쿼리 CREATE TABLE `UserProfile` (\r`id` varchar(64) NOT NULL DEFAULT '',\r`name` varchar(64) DEFAULT NULL,\r`phone` varchar(64) DEFAULT NULL,\r`address` varchar(256) DEFAULT NULL,\rPRIMARY KEY (`id`)\r) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r Mapper 생성 Mapper  Mybatis 매핑XML에 기재된 SQL을 호출하기 위한 인터페이스입니다. 스프링부트, mybatis 3.0이상에서는 Mapper를 통하여 SqlSession을 등록을 생략하고, DAO 인터페이스와 인터페이스 구현을 하지 않고 바로 SQL을 호출 할 수 있습니다. @mapper 어노테이션을 이용해 메서드명과 xml 파일의 id를 매핑시켜 편리하게 사용 할 수 있습니다.\n UserProfileMapper.java 파일 생성  /demo/src/main/java/com/example/demo/mapper 패키지를 생성합니다.\n UserProfileMapper  interface로 UserProfileMapper를 생성하고 @Mapper를 붙여서 스프링에서 Mapper로 인식하게 합니다.\n UserProfileMapper 작성 package com.example.demo.mapper;\rimport java.util.List;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.apache.ibatis.annotations.Param;\rimport com.example.demo.model.UserProfile;\r@Mapper\rpublic interface UserProfileMapper {\r}\r getUserProfile 작성   @select를 사용하여 select 쿼리를 정의합니다 Mybatis를 통하여 파라미터인 id와 ${id}를 매핑합니다.   \t@Select(\u0026quot;SELECT * FROM UserProfile WHERE id = ${id}\u0026quot;)\rUserProfile getUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r getUserProfileList 작성   @select를 사용하여 select 쿼리를 정의합니다.   \t@Select(\u0026quot;SELECT * FROM UserProfile\u0026quot;)\rList\u0026lt;UserProfile\u0026gt; getUserProfileList();\r putUserProfile 작성   @Insert를 사용하여 insert 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Insert(\u0026quot;INSERT INTO UserProfile VALUES(${id},${name},${phone},${address})\u0026quot;) int putUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r postUserProfile 작성   @Update를 사용하여 update 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Update(\u0026quot;UPDATE UserProfile SET name = ${name}, phone = ${phone}, address = ${address} WHERE id = ${id})\u0026quot;) int postUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r deleteUserProfile 작성   @Delete를 사용하여 delete 쿼리를 정의합니다. Mybatis를 통하여 UserProfile 컬럼과 파라메터 ${param}를 매핑합니다.   \t@Delete(\u0026quot;DELETE UserProfile WHERE id = ${id}\u0026quot;)\rint deleteUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r UserProfileMapper.java package com.example.demo.mapper;\rimport java.util.List;\rimport org.apache.ibatis.annotations.Insert;\rimport org.apache.ibatis.annotations.Mapper;\rimport org.apache.ibatis.annotations.Param;\rimport org.apache.ibatis.annotations.Select;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport com.example.demo.model.UserProfile;\r@Mapper\rpublic interface UserProfileMapper {\r@Select(\u0026quot;SELECT * FROM UserProfile WHERE id = #{id}\u0026quot;)\rUserProfile getUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r@Select(\u0026quot;SELECT * FROM UserProfile\u0026quot;)\rList\u0026lt;UserProfile\u0026gt; getUserProfileList();\r@Insert(\u0026quot;INSERT INTO UserProfile VALUES(#{id},#{name},#{phone},#{address})\u0026quot;) int putUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r@Update(\u0026quot;UPDATE UserProfile SET name = #{name}, phone = #{phone}, address = #{address} WHERE id = #{id}\u0026quot;) int postUserProfile( @Param(\u0026quot;id\u0026quot;) String id\r, @Param(\u0026quot;name\u0026quot;) String name\r, @Param(\u0026quot;phone\u0026quot;) String phone\r, @Param(\u0026quot;address\u0026quot;) String address);\r@Delete(\u0026quot;DELETE FROM UserProfile WHERE id = #{id}\u0026quot;)\rint deleteUserProfile(@Param(\u0026quot;id\u0026quot;) String id);\r}\r UserProfileController 수정  UserMap을 만들어 메모리상에서 사용자 정보를 GET, POST, PUT, DELETE 하던것을 새롭게 추가한 UserProfileMapper를 사용하여 GET, POST, PUT, DELETE 하게 수정합니다.\n  UserProfileMapper를 파라미터로 전달받아 내부 참조변수에 저장하는 생성자를 만들면, SpringBoot가 알아서 Mapper 클래스를 만들어 객체를 UserProfileController를 생성하면서 생성자로 전달합니다.\n  이후 전달된 UserProfileMapper 클래스 객체를 통해 메서드를 사용할 수 있습니다.\n UserProfileController.java package com.example.demo.controller;\rimport org.apache.catalina.User;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.web.bind.annotation.DeleteMapping;\rimport org.springframework.web.bind.annotation.GetMapping;\rimport org.springframework.web.bind.annotation.PathVariable;\rimport org.springframework.web.bind.annotation.PostMapping;\rimport org.springframework.web.bind.annotation.PutMapping;\rimport org.springframework.web.bind.annotation.RequestMapping;\rimport org.springframework.web.bind.annotation.RequestParam;\rimport org.springframework.web.bind.annotation.RestController;\rimport com.example.demo.mapper.UserProfileMapper;\rimport com.example.demo.model.UserProfile;\rimport java.util.ArrayList;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport javax.annotation.PostConstruct;\r@RestController\rpublic class UserProfileController {\rprivate UserProfileMapper mapper;\rpublic UserProfileController(UserProfileMapper mapper) {\rthis.mapper = mapper;\r}\r@GetMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic UserProfile getUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\r//return userMap.get(id);\t//변경전\rreturn mapper.getUserProfile(id);\r}\r@GetMapping(\u0026quot;/users/all\u0026quot;)\rpublic List\u0026lt;UserProfile\u0026gt; getUserProfileList() {\r//return new ArrayList\u0026lt;UserProfile\u0026gt;(userMap.values()); //변경전\rreturn mapper.getUserProfileList();\r}\r@PutMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void putUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rint resultCnt = mapper.putUserProfile(id, name, phone, address);\r}\r@PostMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void postUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rint resultCnt = mapper.postUserProfile(id, name, phone, address);\r}\r@DeleteMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void deleteUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\rint resultCnt = mapper.deleteUserProfile(id);\r}\r}\r 테스트  제일 먼저 PUT 을 통해서 사용자 1건을 추가합니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  GET의 getUserProfile를 통해 사용자가 입력이 잘 되었는지 확인해 봅니다.\n  Mysql에 잘 저장되었는지 확인해 봅니다.\n  제일 먼저 POST를 통해서 입력한 사용자의 정보를 수정해 봅니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  Mysql에서 잘 수정되었는지 확인해 봅니다.\n  GET의 getUserProfileList를 통해 수정이된 내용을 확인해 봅니다.\n  DELETE를 통하여 추가한 사용자를 삭제합니다. HTTP Status 응답이 200인 것을 확인 할 수 있습니다.\n  GET의 getUserProfileList를 통해 삭제된 내용을 확인해 봅니다.\n  Mysql에서 잘 삭제되었는지 확인해 봅니다.\n End ","description":"레스트풀 API","id":25,"section":"blog","tags":["Restful","Api","Docker","Mysql","Mybatis"],"title":"RESTful API에 Docker Mysql 컨테이너와 Mybatis 연동","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-3/"},{"content":"Odd Occurrences In Array  Codility - Lesson2 - Array - Odd Occurrences In Array\n Task description  N개의 정수가 담긴 배열 A를 입력받습니다 배열에는 홀수 개의 요소가 포함됩니다. 배열의 각 요소는 짝을 이루지 않는 한 요소를 제외하고 동일한 값을 가진 다른 요소와 짝을 가지고 있습니다. 짝이 없는 요소를 찾으면 해결됩니다\n  예를 들어, 주어진 A 배열은 이렇습니다.\n  A [0] = 9 A [1] = 3 A [2] = 9\rA [3] = 3 A [4] = 9 A [5] = 7\rA [6] = 9\r   인덱스 0과 2에있는 요소의 값은 9입니다. 인덱스 1과 3에있는 요소의 값은 3이고, 인덱스 4와 6에있는 요소의 값은 9이고 인덱스 5의 요소는 값 7을 가지며 짝을 이루지 않습니다.\nCondition   N은 [1..1,000,000] 범위 내의 홀수 정수이고; 배열 A의 각 요소는 [ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 . A의 값 중 하나를 제외하고 모두 짝수 번 발생합니다. 다음 가정에 대한 효율적인 알고리즘을 작성하십시오   Solution 1회차   A의 배열을 0부터 N까지 리스트를 조회하며 현재값 curr = A[i]를 기억해 두고 첫번째 요소 pop(0) 남은 A배열와 체크된 숫자 배열 B에 curr가 있는지 확인해서 없으면 짝이 없기 때문에 curr 값 리턴 아니라면 B배열에 curr 추가   def solution(A):\r# write your code in Python 3.6\rB = []\rfor i in range (0, len(A)) :\rcurr = A[0]\rA.pop(0)\rif curr not in A and curr not in B :\rreturn curr\rB.append(curr)\rpass\r  시간 복잡성 O (N ** 2)으로 n = 100,003, n = 999,999 시간 초과\n  for 안에서 in을 통해 다시 조회하는 것이 시간 복잡성을 늘린거 같다\n 2회차   A배열을 A.sort()를 사용해 asc 정렬 정렬을 하고 0 ~ len(A)까지의 반복문중 인덱스가 홀수면 값저장, 짝수면 홀수와 비교 마지막 인덱스가 홀수고 마지막 까지 짝이 없는 값이 없다면 마지막 값이 짝이 없는 값이므로 반환   # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A):\r# write your code in Python 3.6\rA.sort()\rodd = 0\rfor i in range (0, len(A)) :\rif i % 2 == 0 :\rif i+1 != len(A) :\rodd = A[i]\relse :\rreturn A[i] else :\rif odd != A[i] : return odd pass\r  시간 복잡성 O(N) or O(N*log(N)) 하나의 for에서 처리를 해서 timeout에 걸리지 않았다.\n 다른 사람 풀이  풀이 방식이 비슷하나 A.sort()와 sorted(A)의 차이가 있다.\n sort와 sorted의 차이  따로 정리하며 포스팅 해야겠지만,\n list.sort()   list.sort()는 list 클래스의 메서드입니다. 실행 시 기본적으로 오름차순으로 리스트 객체 자체를 정렬하며 반환하는 값은 None입니다. 추가로 key와 reverse 파라미터를 조정하여 정렬기준을 변경할 수 있습니다.   \tlist.sort()\r sorted(list)   sorted 메서드는 list, tuple, string, dict, set 등 iterable 객체를 파라미터로 받아 정렬된 iterable를 반환합니다. sort 메서드처럼 key와 reverse파라미터를 조정해서 정렬 기준을 변경 할 수 있다.   \tlist1 = sorted(list)\r sort vs sorted?  데이터가 많으면 많을 수록 sorted는 새로운 객체를 생성해야하는 내부 처리가 있어서 sort보다 시간이 더 걸린다. 도긴 개긴이지만 sort 메서드가 미세하게 더 빠르다.\n  하지만 list가 아닌 iterable인 경우에서는 어쩔 수 없이 sorted를 사용해야 합니다.\n def test3(A):\rif len(A) == 1:\rreturn A[0]\rA = sorted(A)\rprint(A)\rfor i in range(0, len(A), 2):\rif i+1 == len(A):\rreturn A[i]\rif A[i] != A[i+1]:\rreturn A[i]\r 다른 사람 풀이2  시간 복잡성 O(N) or O(N*log(N)) lambda와 reduce() 메서드를 공부해 봐야겠다.\n 다른사람 코드 2\rdef solution(A):\rreturn reduce(lambda x,y: x^y, A)\r TestCase solution([9, 3, 9, 3, 9, 7, 9])\rsolution([9, 3, 9, 3, 9])\r ","description":"Odd Occurrences In Array","id":26,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Odd Occurrences In Array","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-odd-occurrences-in-array/"},{"content":"CyclicRotation  Codility - Lesson2 - Array - CyclicRotation\n Task description  N 개의 정수로 구성된 배열 A와 오른쪽으로 회전할 횟수 K가 제공됩니다. A의 각 요소가 오른쪽으로 K 번 이동합니다. N 개의 정수와 K로 구성된 배열 A가 주어지면 배열 A가 K 번 회전 된 배열을 반환합니다.\n  예를 들어, 주어진\n   A = [3, 8, 9, 7, 6] K = 3    함수는 [9, 7, 6, 3, 8]을 반환해야합니다. 세 가지 회전이 이루어졌습니다.\n  [3, 8, 9, 7, 6]-\u0026gt; [6, 3, 8, 9, 7]\r[6, 3, 8, 9, 7]-\u0026gt; [7, 6, 3, 8, 9]\r[7, 6, 3, 8, 9]-\u0026gt; [9, 7, 6, 3, 8]\r Condition   함수 작성 : class Solution {public int [] solution (int [] A, int K); } N 및 K는 [ 0 .. 100 ] 범위 내의 정수입니다 . 배열 A의 각 요소는 [ -1,000 .. 1,000 ] 범위 내의 정수 입니다.   Solution # you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\r# you can write to stdout for debugging purposes, e.g.\r# print(\u0026quot;this is a debug message\u0026quot;)\rdef solution(A, K):\rN = len(A)\rfor value in A :\rif not (-1000 \u0026lt;= value \u0026lt;= 1000) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\rif not (0 \u0026lt;= N \u0026lt;= 100) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\relif not (0 \u0026lt;= K \u0026lt;= 100) :\rprint(\u0026quot;this is a debug message\u0026quot;)\rreturn A\relse :\rB = []\rfor i in range(0,N) :\rB.append(0) for i in range(0,N) :\rrotate = (i+K) % N\rB[rotate] = (A[i])\rA = B\rreturn A\rpass\r TestCase \r ","description":"Cyclic Rotation","id":27,"section":"blog","tags":["Algorithm","CodingTest","Codility"],"title":"Codility - Cyclic Rotation","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-cyclic-rotation/"},{"content":"Mysql DBeaver 설치 DBeaver 다운로드  DBeaverinstall file 다운로드 운영체제에 맞는 DBeavr 인스톨파일을 다운받아 실행시킨다.   Mysql을 선택한다.   자신의 서버정보에 맞게 입력하면 Mysql을 사용할 수 있다.  ","description":"Mysql DBeaver 설치","id":28,"section":"blog","tags":["Mysql","Developer","DBeaver","Tools"],"title":"Mysql DBeaver 설치","uri":"https://offetuoso.github.io/blog/develop/database/mysql/mysql-dbeaver-install/"},{"content":"Mysql Developer 설치 SQL Developer 다운로드  SQL Developer 다운로드 운영체제에 맞는 SQL Developer를 다운받아 압축을 풀어 실행시킨다.  mysql-connector-java 설치  mysql connector j 다운로드 링크\n  Archives   Platform Independent를 선택하고 zip으로 받습니다.  Oracle Developer 설정  도구 \u0026gt; 환경설정 데이터베이스 \u0026gt; 타사JDBC드라이버 \u0026gt; 항목추가  신규 접속 생성  Mysql이 추가된것을 확인할 수 있다.   자신의 서버정보에 맞게 입력하면 Mysql Developer를 사용할 수 있다.  ","description":"Mysql Developer 설치","id":29,"section":"blog","tags":["Mysql","Developer","MysqlDeveloper","OracleDevelop","Tools"],"title":"Mysql Developer 설치","uri":"https://offetuoso.github.io/blog/develop/database/mysql/mysql-developer-install/"},{"content":"Maven error “Failure to transfer…” 문제 Failure to transfer com.google.guava:guava:jar:10.0.1 from https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempte from/to central (https://repo.maven.apache.org/maven2): The operation was cancelled.\r  https://repo.maven.apache.org/maven2에서 디펜던시를 전송하지 못하는 오류가 발생하였고, 로컬 저장소에 캐시되었습니다.\n 해결책 1   프로젝트 우클릭 -\u0026gt; Run as -\u0026gt; Maven Install 프로젝트 우클릭 -\u0026gt; Refresh 프로젝트 우클릭 -\u0026gt; Update Project (옵션 클릭 force update of snapshots/releases)   해결책 2   실행중인 IDE(이클립스, Sts) 종료 로컬 레퍼지토리 삭제\nC:\\Users{userNm}.m2\\repository   참조 https://stackoverflow.com/questions/5074063/maven-error-failure-to-transfer\n","description":"메이븐 에러","id":30,"section":"blog","tags":["Troubleshooting"],"title":"Maven Error - Failure to transfer..","uri":"https://offetuoso.github.io/blog/develop/troubleshooting/spring/maven-error-repository/"},{"content":"SpringBoot를 이용한 RESTful API SpringBoot  스프링 프레임워크 기반 프로젝트를 복잡한 설정없이 쉽고 빠르게 만들어주는 라이브러리입니다. 사용자가 일일이 모든 설정을 하지 않아도 자주 사용되는 기본설정을 알아서 해줍니다.\n  Spring Boot 장점\n   라이브러리 관리의 자동화 라이브러리 버전 자동 관리 설정의 자동화 내장 Tomcat 독립적으로 실행 가능한 JAR   간단한 RESTful API 생성 Spring Starter Project로 프로젝트 생성  스프링STS4를 실행 하고, file \u0026gt; new \u0026gt; Spring Starter Project를 선택\n  서비스에 대한 설정을 할 수 있는 화면이 나오며 Demo라는 프로젝트명 그대로 \u0026lsquo;next\u0026rsquo; 진행   Spring Starter 구성 시 추가할 web \u0026gt; Spring Web Dependency를 추가   next를 눌러 진행하면, 스프링스타터의 서비스를 이용해서 방금전 입력한 항목들을 이용해 템플릿을 만들어 달라고 요청할 URL이며 URL을 호출하여, ZIP파일 형태로도 제공 받을수 있습니다. finish를 눌러 마무리합니다.   프로젝트 우클릭 \u0026gt; Run as \u0026gt; Spring Boot App을 눌러 실행   콘솔창으로 정상적으로 서비스가 올라가는 것을 볼 수 있습니다.   서비스될 Port가 :8080으로 설정된 것도 확인 가능합니다.   http://localhost:8080/ 로 접속해 보면 매핑되는 URI가 없기 때문에 오류 페이지대신 Whitelabel Error Page 페이지가 보이게 됩니다.  RESTful API 작성 Model - UserProfile.java 생성  com.example.demo 밑에 com.example.demo.model 패키지를 생성하고 그 안에 UserProfile이라는 VO 객체(Value Obeject)를 생성   String 형의 id, name, phone, address를 Private로 추가   생성자는 에디터 우클릭 \u0026gt; source \u0026gt; generate constructor using fields 를 사용하여 자동 생성   소스에 생성자가 추가된 것을 확인   private로 생성된 field들에 접근하기 위하여, getter와 setter 또한 generator를 이용하여 생성   소스에 getter, setter가 추가된 것을 확인  package com.example.demo.model;\rpublic class UserProfile {\rprivate String id;\rprivate String name;\rprivate String phone;\rprivate String address;\rpublic UserProfile(String id, String name, String phone, String address) {\rsuper();\rthis.id = id;\rthis.name = name;\rthis.phone = phone;\rthis.address = address;\r}\rpublic String getId() {\rreturn id;\r}\rpublic void setId(String id) {\rthis.id = id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getPhone() {\rreturn phone;\r}\rpublic void setPhone(String phone) {\rthis.phone = phone;\r}\rpublic String getAddress() {\rreturn address;\r}\rpublic void setAddress(String address) {\rthis.address = address;\r}\r}\r Controller - UserProfileController.java 생성  Spring에서 컨트롤러를 지정해주기 위한 어노테이션은 @Controller와 @RestController가 있습니다. 하지만 여기서는 @RestController를 추가합니다.\n  UserMap을 만들어 메모리상에서 사용자 정보를 GET, POST, PUT, DELETE 할 수 있게 세팅합니다.  package com.example.demo.controller;\rimport org.apache.catalina.User;\rimport org.springframework.web.bind.annotation.RequestParam;\rimport org.springframework.web.bind.annotation.RestController;\rimport com.example.demo.model.UserProfile;\rimport java.util.ArrayList;\rimport java.util.HashMap;\rimport java.util.List;\rimport java.util.Map;\rimport javax.annotation.PostConstruct;\r@RestController\rpublic class UserProfileController {\rprivate Map\u0026lt;String, UserProfile\u0026gt; userMap;\r@PostConstruct\rpublic void init() {\ruserMap = new HashMap\u0026lt;String, UserProfile\u0026gt;();\ruserMap.put(\u0026quot;1\u0026quot;, new UserProfile(\u0026quot;1\u0026quot;, \u0026quot;홍길동\u0026quot;, \u0026quot;111-1111\u0026quot;, \u0026quot;서울시 영등포구 신길1동\u0026quot;));\ruserMap.put(\u0026quot;2\u0026quot;, new UserProfile(\u0026quot;2\u0026quot;, \u0026quot;김근로\u0026quot;, \u0026quot;111-1112\u0026quot;, \u0026quot;서울시 영등포구 신길2동\u0026quot;));\ruserMap.put(\u0026quot;3\u0026quot;, new UserProfile(\u0026quot;3\u0026quot;, \u0026quot;박영업\u0026quot;, \u0026quot;111-1113\u0026quot;, \u0026quot;서울시 영등포구 신길3동\u0026quot;));\r}\r}\r  아래 표와 같은 기능을 Controller에서 간단히 작성해 보려합니다.\n    Resource GET(read) PUT(create) POST(update) DELETE(delete)     /users 사용자 전체 조회 - - -   /users/{id} {id}사용자 조회 {id} 신규 사용자 추가 {id} 사용자 수정 {id} 사용자 삭제    GET  GET : /users/1 과 GET : /users/all 을 구현\n   @PathVariable은 String3에서 추가된 기능으로 URL에서 {특정값}을 변수로 받아 올 수 있다.    @GetMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic UserProfile getUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\rreturn userMap.get(id);\r}\r@GetMapping(\u0026quot;/users/all\u0026quot;)\rpublic List\u0026lt;UserProfile\u0026gt; getUserProfile() {\rreturn new ArrayList\u0026lt;UserProfile\u0026gt;(userMap.values());\r}\r  REST API Client Postman을 이용한 테스트 GET : http://localhost:8080/users/1 GET : http://localhost:8080/users/all  PUT  PUT : /users/1?name=\u0026amp;phone=\u0026amp;address=\n   @PathVariable은 String3에서 추가된 기능으로 URL에서 {특정값}을 변수로 받아 올 수 있다. @RequestParam 또한 @PathVariable과 비슷하지만, request의 parameter에서 가져오는 것이다. ?name=홍길동 과 같은 쿼리스트링을 파라미터로 파싱해준다.    @PutMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void putUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rUserProfile userProfile = new UserProfile(id,name,phone,address);\ruserMap.put(id,userProfile);\r}\r  PUT : http://localhost:8080/users/4?name=정운영\u0026amp;phone=111-4444\u0026amp;address=서울시 영등포구 신길4동   GET : http://localhost:8080/users/4  POST  POST : /users/1?name=\u0026amp;phone=\u0026amp;address=\n  @PostMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void postUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id\r, @RequestParam(\u0026quot;name\u0026quot;) String name\r, @RequestParam(\u0026quot;phone\u0026quot;) String phone\r, @RequestParam(\u0026quot;address\u0026quot;) String address) {\rUserProfile userProfile = userMap.get(id);\ruserProfile.setName(name);\ruserProfile.setPhone(phone);\ruserProfile.setAddress(address);\r}\r  POST : http://localhost:8080/users/1?name=첫번째\u0026amp;phone=010-1111\u0026amp;address=서울시 영등포구 영등포1동   GET : http://localhost:8080/users/1  DELETE  DELETE : /users/1\n  @DeleteMapping(\u0026quot;/users/{id}\u0026quot;)\rpublic void deleteUserProfile(@PathVariable(\u0026quot;id\u0026quot;) String id) {\ruserMap.remove(id);\r}\r  DELETE : http://localhost:8080/users/1   GET : http://localhost:8080/users/all  참고   SpringBoot spring.io Dependency Annotation @Controller vs @RestController   ","description":"레스트풀 API","id":31,"section":"blog","tags":["Restful","Api"],"title":"SpringBoot를 이용한 RESTful API","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-2/"},{"content":"레스트풀 API(Restful Api) REST (Representational state transfer)  REST(Representational State Transfer)는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다. REST는 로이 필딩(Roy Fielding)의 2000년 박사학위 논문에서 소개 엄격한 의미로 REST는 네트워크 아키텍처 원리의 모음이다. 여기서 \u0026lsquo;네트워크 아키텍처 원리\u0026rsquo;란 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반을 일컫는다. 간단한 의미로는, 웹 상의 자료를 HTTP위에서 SOAP이나 쿠키를 통한 세션 트랙킹 같은 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스를 말한다.\n REST 구성  1.자원(RESOURCE) - URI 2.행위(Verb) - HTTP METHOD 3.표현(Representations)\n REST의 목표  REST의 목표는 성능, 확장 성, 단순성, 수정 가능성, 가시성, 이식성 및 안정성을 높이는 것. 이는 REST 아키텍처에 적용되는 제약 조건을 통해 달성됩니다.\n REST 아키텍처 원칙(아키텍처 스타일, 아키텍처의 제약 조건)  해당 6가지 원칙을 모두 만족한다면, REST하다 이야기 할 수 있습니다.\n   인터페이스 일관성 (using a uniform interface): URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.    무상태성(Stateless): 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.    캐시 가능(Cacheability): REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다.    클라이언트/서버 구조 (client–server architecture): REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.    계층화(Layered System): REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.    Code on demand (optional) - 클라이언트는 리소스에 대한 표현을 응답으로 받고 처리해야 하는데, 어떻게 처리해야 하는지에 대한 Code를 서버가 제공하는 것을 의미한다. Html에서의 javascript가 가장 대표적인 예이다. 하지만 서버에서 제공되는 코드를 실행해야 하기 때문에 보안 문제를 야기할 수 있습니다. (이 제약조건은 필수는 아님.)   REST가 필요한 이유   애플리케이션 분리 및 통합 다양한 클라이언트의 등장 최근의 서버 프로그램은 다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다. 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.   RESTful API ?  RESTful은 위의 REST 아키텍처의 원칙을 모두 만족하는 것을 의미한다. RESTful API란 REST라는 아키텍처 스타일과 원칙을 모두 만족하는 모두 만족하는 API라는 뜻이다.\n REST API 디자인   URL을 심플하고 직관적으로 만들자   REST API를 URL만 보고도, 직관적으로 이해할 수 있어야 한다 URL을 길게 만드는것 보다, 최대 2 depth 정도로 간단하게 만드는 것이 이해하기 편하다.     BAD   http://restapi.example.com/customerUsers\rhttp://restapi.example.com/sellerUsers\r   Good   http://restapi.example.com/users/customer\rhttp://restapi.example.com/users/seller\r  소문자를 사용한다.   도메인 주소명은 대소문자를 구분하지 않는다. 디렉터리 명 이하의 주소는 서버의 운영체제에 따라 다르다. 대소문자를 혼용하여 사용하는 주소는 권장되지 않는다.     BAD   http://restapi.example.com/users/customer/\r   Good   http://restapi.example.com/users/customer/get-adress\r  언더바를 대신 하이픈을 사용한다. 가급적 하이픈의 사용도 최소화하며, 정확한 의미나 표현을 위해 단어의 결합이 불가피한 경우에 사용한다.     Bad   http://restapi.example.com/users/customer/get_adress\r   Good   http://restapi.example.com/users/customer/get-adress\r  마지막에 슬래시를 포함하지 않는다.   슬래시는 계층을 구분하는 것으로, 마지막에는 사용하지 않는다.     Bad   http://restapi.example.com/users/customer/\r   Good   http://restapi.example.com/users/customer\r  행위는 포함하지 않는다.   행위(동사)는 URL대신 Method를 사용하여 전달한다.(GET, POST, PUT, DELETE 등)      Resource GET(read) PUT(create) POST(update) DELETE(delete)     /goods 상품목록 상품추가 - -   /goods/{id} {id}값 상품상세 - {id}값 상품 수정 {id}값 상품 삭제      Bad   POST : http://restapi.example.com/users/customer/delete-post/1\r   Good   DELETE : http://restapi.example.com/users/customer/post/1\r  가급적 명사를 사용하되, 제어 자원을 의미하는 경우 예외적으로 동사를 허용한다.     Bad   POST : http://restapi.example.com/users/customer/duplication\r   Good   POST : http://restapi.example.com/users/customer/duplicate\r  7.파일 확장자는 URI에 포함시키지 않는다.\n REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않습니다. Accept header를 사용하도록 한다.     Bad   GET : http://restapi.example.com/users/customer/profile.png\r   Good   GET http://restapi.example.com/users/customer/profile\rHTTP/1.1 Host: restapi.example.com Accept: image/jpg\r   오류 처리를 명확하게 해라.\r    HTTP 상태코드를 정하고(많아도 안좋음), 다른 개발자들을 위한 오류 메시지 정의, 상세 정보 링크 등을 넣어주면 도움이 된다.   참고   REST wiki   ","description":"레스트풀 API","id":32,"section":"blog","tags":["REST","RESTful","Api"],"title":"RESTFULL API (RESTful API)","uri":"https://offetuoso.github.io/blog/develop/backend/restapi/restful-api-1/"},{"content":"도커에 Mysql 올리기 도커 버전 체크  cmd창 또는 Windows PowerShell을 싱행한다.  도커 초기화  일단 도커의 이미지/컨테이너들을 모두 지워주는 것 부터 시작하겠습니다.\n PS C:\\\u0026gt; sudo docker rm -f `sudo docker ps -a -q`\rPS C:\\\u0026gt; sudo docker rmi -f `sudo docker images`\r 도커 이미지 가져오기 (get Mysql Image for Docker)  Mysql의 경우 DockerHub에 있기 때문에, 쉽게 이미지를 받아 올 수 있습니다.\n DockerHub에서 mysql 이미지 받아오기   PS C:\\\u0026gt; docker pull mysql\rUsing default tag: latest\rlatest: Pulling from library/mysql\rDigest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969\rStatus: Image is up to date for mysql:latest\rdocker.io/library/mysql:latest\r   다운받은 도커 이미지 확인   PS C:\\\u0026gt; docker images\rREPOSITORY TAG IMAGE ID CREATED SIZE\rmysql latest c0cdc95609f1 13 days ago 556MB\rdocker/getting-started latest 3ba8f2ff0727 2 months ago 27.9MB\r Mysql 컨테이너 설정  sudo docker run -d -p 9876:3306 -e MYSQL_ROOT_PASSWORD=passw0rd \u0026ndash;name test_mysql mysql:5.6\n PS C:\\\u0026gt; sudo docker run -d -p 9876:3306 -e MYSQL_ROOT_PASSWORD=passw0rd --name test_mysql mysql:5.6\r docker 옵션   -d 는 컨테이너를 백그라운드에서 동작하는 어플리케이션으로 실행    -p 9876:3306 는 -p 옵션은 호스트와 컨테이너 간의 포트(port) 배포(publish)/바인드(bind)를 위해서 사용되는데요. 호스트(host) 컴퓨터에서 컨테이너에서 리스닝하고 있는 포트로 접속할 수 있도록 설정해줍니다. 위 커맨드는 컨테이너 내부에서 3306 포트로 리스닝하고 있는 HTTP 서버를 호스트 컴퓨터에서 9876 포트로 접속할 수 있도록 해줍니다.    -e 는 Docker 컨테이너의 환경변수를 설정하기 위해서는 -e 옵션을 사용합니다. 또한, -e 옵션을 사용하면 Dockerfile의 ENV 설정도 덮어써지게 됩니다. 아래 커맨드는 FOO 환경 변수를 bar로 세팅을 하고, 환경 변수를 출력하고 있습니다.    MYSQL_ROOT_PASSWORD=passw0rd는 mysql의 기본 비밀번호를 설정합니다.    \u0026ndash;name test_mysql은 Docker 컨테이너를 제어할 때 컨테이너 ID를 사용하면 읽거나 기억하기가 어려워서 불편하게 느껴집니다. 이럴 경우, \u0026ndash;name 옵션을 사용해서 컨테이너에 이름을 부여해주면 해당 test_mysql 이름으로 컨테이너를 식별할 수 있습니다.   생성된 Mysql 컨테이너 확인  docker ps -a 명령어 실행\n PS C:\\\u0026gt; docker ps -a\rCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\raf3dd622e753 mysql \u0026quot;docker-entrypoint.s…\u0026quot; 28 hours ago Up 32 minutes 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp test_mysql\r Mysql 컨테이너 test_mysql의 CLI 접속  sudo docker exec -it test_mysql /bin/bash 명령어 실행\n PS C:\\\u0026gt; sudo docker exec -it test_mysql /bin/bash\r Mysql 테스트 설치시 등록한 암호 입력  mysql -u root -p\n root@4b6fb99160bf:/# mysql -u root -p\rEnter password:\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 1\rServer version: 5.6.51 MySQL Community Server (GPL)\rCopyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\rmysql\u0026gt;\r Mysql user 생성 및 권한 부여  개발에 사용할 developer라는 유저 생성\n mysql\u0026gt; CREATE USER 'developer'@'%' IDENTIFIED BY 'passw0rd';\rQuery OK, 0 rows affected (0.00 sec)\r  developer에게 모든 권한 부여\n mysql\u0026gt; GRANT ALL PRIVILEGES ON *.* TO 'developer'@'%';\rQuery OK, 0 rows affected (0.00 sec)\rmysql\u0026gt;\r 유저 변경 mysql\u0026gt; quit\rBye\rroot@4b6fb99160bf:/# mysql -u developer -p\rEnter password:\rWelcome to the MySQL monitor. Commands end with ; or \\g.\rYour MySQL connection id is 2\rServer version: 5.6.51 MySQL Community Server (GPL)\rCopyright (c) 2000, 2021, Oracle and/or its affiliates. All rights reserved.\rOracle is a registered trademark of Oracle Corporation and/or its\raffiliates. Other names may be trademarks of their respective\rowners.\rType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\rmysql\u0026gt;\r 데이터베이스 생성 mysql\u0026gt; create database test;\rQuery OK, 1 row affected (0.00 sec)\rmysql\u0026gt; show databases;\r+--------------------+\r| Database |\r+--------------------+\r| information_schema |\r| mysql |\r| performance_schema |\r| test |\r+--------------------+\r4 rows in set (0.00 sec)\rmysql\u0026gt;\r  참고 :\n 도커 웹 페이지   ","description":"도커에 Mysql 올리기","id":33,"section":"blog","tags":["Docker","Mysql"],"title":"도커에 Mysql 올리기-1 (Docker Mysql)","uri":"https://offetuoso.github.io/blog/develop/backend/docker/docker-mysql/"},{"content":"도커 (Docker) 도커란 ?  도커란 리눅스의 응용 프로그램들을 프로세스 격리 기술을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트. 도커 웹 페이지의 기능을 인용하면 다음과 같다:\n 도커 컨테이너는 일종의 소프트웨어를 소프트웨어의 실행에 필요한 모든 것을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는\r무엇이든 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.\r 도커의 특징   도커의 컨테이너는 각각 독립적이다. 독립적으로 존재하기 때문에 원하는 어떤 환경이든 모듈적으로 관리 가능하다. 하나의 서버에 각각의 여러개의 컨테이너를 갖을 수 있다. 컨테이너는 줄이거나 늘릴 수 있다. 예를 들면 자바 서버의 트래픽이 늘어 난다면, 장고 서버를 줄이고 자바를 더 싣을 수 있다. 도커를 사용하면 서버를 늘릴 때마다 서버를 구매하고 다시 설치할 필요가 없어진다 원하는 개발 환경 파일에 저장을 하면, docker는 이를 원하는 어떤 머신이든 해당 환경을 시뮬레이션 해준다.   도커의 장/단점 ####장점\n  빠른 실행 환경 구축 가볍고 빠른 실행 속도 하드웨어 자원 절감 공유 환경 제공, DockerHub를 통해 검증된 많은 이미지들 사용가능 쉬운 배포(Deploy) 제공   ####단점\n  초기 진입장벽에 의한 업무효율 감소 리눅스 기반   도커 설치 (Window 10) 1. 도커 설치를 위한 준비  Windows 10에서 도커를 설치 하기 위해서는 Hyper-V를 설치해야 합니다. Hyper-V를 사용하면 Windows에서 가상 머신으로 여러 운영 체제를 실행할 수 있습니다.\n 2. 도커 다운로드 및 설치   도커 웹 페이지에서 Get Docker 클릭 하여 다운로드      Ok를 눌러 넘어갑니다. WSL2(Windows Subsystem for Linux 2)란?     설치가 완료 되면 \u0026ldquo;Close and log out\u0026rdquo; 를 클릭하여 재접속 합니다.      재접속 후에는 Host에 docker의 Localhost가 추가 되어 Window에서 악성코드에 의하여 Host파일이 변경되었다고 알람이 뜰 수도 있습니다. Host 내용 한번 확인하시고 아래와 같은 내용이라면 무시해도 됩니다.      도커가 실행되며,  윈도우 트레이 아이콘에서도 확인 할 수 있습니다.    윈도우에서 sudo 사용하기  Docker를 공부하는 도중 명령어 중에 sudo가 포함된 명령어를 실행시 cmd 기준 아래와 같은 화면이 나타났다.   윈도우에서는 기본적으러 sudo를 지원하지 않기 때문인거같아 choco라는 패키지 관리자를 이용하여 설치를 하여 해결하였다.\n  choco라는 패키지 관리자를 통하여 sudo 패키지를 설치하면 된다.\n choco install sudo\rchoco upgrade sudo\r  참고 :\n 도커 웹 페이지   ","description":"도커 설치","id":34,"section":"blog","tags":["Docker","Install"],"title":"도커 설치 (Docker Install) ","uri":"https://offetuoso.github.io/blog/develop/backend/docker/docker-install/"},{"content":"   The A is about the B (\u0026lsquo;A는 B에 관한것\u0026rsquo;)  The video is about the effect of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향)\n the effect of A on B (\u0026lsquo;A가 B에 미치는 영향\u0026rsquo;) = the influence of A on B  the effect of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향.)\n the influence of A on B (\u0026lsquo;A가 B에 미치는 영향\u0026rsquo;)  the influence of exercising regularly on our body. (규칙적인 운동이 우리의 몸에 미치는 영향.)\n I want more A, so I can B (\u0026lsquo;더 많은 A를 원해, 그래서 B 할 수 있도록\u0026rsquo;)  I want more time, so I can exercise/work out (더 운동할 수 있는 더 많은 시간을 원한다.)\n give numbers to ~ → to rank ('-에 순위를 매기다')  give numbers to hobby (취미에 순위를 매기다.)\n choose priority (\u0026lsquo;우선 순위 선택\u0026rsquo;) I went to the ~ ('-에 갔다')  I went to 횡성 웰리힐리파크 for skiing. (횡성 웰리힐리파크에 스키타러 갔었다.) I went to 웰리힐리파크 for night snow boarding at 10pm. (10시에 심야 스노우 보드를 타기 위해 웰리 힐리 파크에갔습니다.) I went to the library to study. (공부하러 도서관을 갔었다.)\n ~ days a week. (\u0026lsquo;일주일에 -일\u0026rsquo;)  A year ago, I worked out three days a week. (1년 전에는, 1주일에 3일 운동하러 나갔다.) I went skate boarding three days(times) a week. (1주일에 3일씩 스케이트 보드를 탔다.)\n It was bright from the strong lights (\u0026lsquo;강한 불빛에 비추어 밝았다.')  The light was very strong. → It was bright from the strong lights.\n Q. How does effect of exercising regularly on our body? (\u0026lsquo;규칙적인 운동이 우리 몸에 미치는 영향을 미치는가?')  when I regularly exercise, I had more energy and less stress at that time. (규칙적으로 운동 할 때 그 당시에는 더 많은 에너지와 스트레스를 덜 받았습니다.)\n ##Grammar Error:\nstarting exercising regularly effect on body. → The video is about the effect of exercising regularly on our body. the effect of A on B the influence of A on B I want more exercise → I want more time so exercise. → I want more time, so I can exercise/work out. so hard → so difficult Working out is too hard. I’d like to go swimming. I went to 횡성 웰리힐리파크 for skiing. / I went to the library to study. I went to 횡성 웰리힐리파크 at 10pm for night snowboarding. The light was very strong. → It was bright from the strong lights. One years ago, I was three days on week. → (About) A year ago, I worked out three days a week. / I went skateboarding three days(times) a week. I think decreased stress → I have more stress now. / I had less stress at that time. /I think the amount of stress has increased. I was more energetic at that time.\u0026ndash;\u0026gt; I had more energy ~. I was more energetic and had less stress at that time. / I had more energy and less stress at that time.\n##New expressions learned today: give numbers to sth → to rank choose priority\n본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":35,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.05.14","uri":"https://offetuoso.github.io/blog/english/202105/20210514-english-speak/"},{"content":"탐색 알고리즘 탐색(search)  탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는과정. 그래프 또는 트리의 자료구조에서 데이터를 찾는 문제가 주로 나온다. 대표적으로 DPS, BPS가 있으며, 원리를 제대로 이해해야 코딩테스트 문제를 풀 수 있다. 그런데 DPS와 BPS를 이해하기 위해서 기본 자료구조인 스택, 큐, 재귀 함수 등을 이해가 전제로 되어야한다.\n 자료구조  자료구조란 데이터를 표현하고 관리하고 처리하기 위한 구조 스택과 큐는 삽입(Push)과 출력(Pop)이라는 두 핵심적인 함수로 구성 실제 구현할땐 오버플로우와 언더플로우를 고민해야한다.\n 스택  스택의 구조는 선입후출 또는 후입선출구조. 스택은 박스 쌓기로 비유할 수 있다.\n 스택의 요소    기능  명칭  설명      push(x) 삽입 스택의 마지막에 엘리먼트를 추가(append)하며, 마지막에 삽입된 인덱스(top)가 증가한다.   pop() 추출(삭제) 스택의 마지막 엘리먼트를 반환하고 삭제(del)하며, 마지막에 삽입된 인덱스(top)가 감소한다.   peak() 스택의 마지막 엘리먼트 반환 스택의 마지막 엘리먼트를 반환한다, 마지막에 삽입된 인덱스(top)는 변화가 없다.   top() 스택의 top 반환 마지막에 삽입된 인덱스(top)를 반환한다. 엘리먼츠(리스트)의 사이즈 -1   isEmpty() 스택이 비어있는지 체크 엘리먼츠(리스트)가 비어있으면 True/ 비어있지 않으면 False 반환   clear() 스택 초기화 엘리먼츠(리스트)를 초기화, 마지막에 삽입된 인덱스(top)도 -1   size() 스택의 사이즈 반환 엘리먼츠(리스트) 사이즈 반환   contains() 엘리먼츠(리스트) 초기화 엘리먼츠를 초기화, 마지막에 삽입된 인덱스(top)도 -1   search() 엘리먼츠(리스트) 초기화 엘리먼츠를 초기화, 마지막에 삽입된 인덱스(top)도 -1    \rstack.py class Stack :\r#초기화\rdef __init__(self) :\rself.elements = [] #stack 엘리먼츠 생성\r#데이터 추가\rdef push(self, x) :\rself.elements.append(x) #stack 엘리먼트 추가\r#최근에 추가된(Top) 데이터 삭제\rdef pop(self) :\rif self.isEmpty() :\rreturn \u0026quot;stack underflow!\u0026quot;\relse : del self.elements[self.top()]\rreturn self.elements[self.top()]\r#최근에 추가된(Top) 데이터 삭제\rdef peek(self) : return(self.elements[self.top()])\r#최근에 추가된 인덱스 반환 def top(self) :\rreturn self.size()-1 #인덱스 = (사이즈-1) #stack의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif (self.top() == -1) :\rreturn True\relse :\rreturn False\r#stack 초기화\rdef clear(self) : self.elements = [] #엘리먼츠 초기화\r#stack의 길이 반환\rdef size(self) :\rreturn (len(self.elements))\r#stack의 값이 포함되어있는지 확인, 비었으면 true, 아니면 false\rdef contains(self, x) :\rif(x in self.elements) : #x가 엘리먼츠에 포함되어있는지\rreturn True else :\rreturn False\r#엘리먼트를 보관한 인덱스 반환(리스트 인덱스의 역방향, 1부터 시작)\rdef search(self, x) :\rresult = -1\rfor i in range(1,self.size()+1) :\rif x == self.elements[(self.size()-i)] : result = i\rreturn result\rstack = Stack() print(stack.elements)\rstack.push(1)\rprint(stack.elements)\rstack.push(2)\rprint(stack.elements)\rstack.push('banana')\rprint(stack.elements)\rstack.push(4)\rprint(stack.elements)\rstack.push(5)\rprint(stack.elements)\rprint(\u0026quot;size() \u0026quot;, stack.size())\rprint(\u0026quot;contains(1) \u0026quot;, stack.contains(1))\rprint(\u0026quot;search(1) \u0026quot;, stack.search(1))\rprint(\u0026quot;search(2) \u0026quot;, stack.search(2))\rprint(\u0026quot;peek() \u0026quot;, stack.peek())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\rprint(\u0026quot;stack.clear() \u0026quot;)\rstack.clear() print(\u0026quot;size() \u0026quot;, stack.size())\rprint(\u0026quot;top() \u0026quot;, stack.top())\rprint(\u0026quot;pop() \u0026quot;,stack.pop())\r 큐  큐는 대기줄에 비유할 수 있는 공정한 자료구조, 단 새치기는 없다고 가정. 이러한 스택의 구조를 선입선출구조.\n    기능  명칭  설명      enQueue(x) 삽입 큐의 마지막에 엘리먼트를 추가하며, 마지막에 삽입된 인덱스(rear)가 증가한다.   deQueue() 추출(삭제) 큐의 첫번째 엘리먼트를 반환하고 삭제(빈값으로 세팅 None)하며 , 마지막에 삽입된 인덱스(front-1)가 감소한다. 큐가 마지막의 인덱스에 도달했다면 초기화 (or 삭제 시 한칸씩 땡긴다.)   peak() 큐의 첫번째 엘리먼트 반환 큐의 첫번째 엘리먼트를 반환한다, front 변화 없음   isEmpty() 큐가 비어있는지 체크 프론트와 리어가 같으면 True/ 프론트와 리어가 같지 않으면 False 반환   size() 큐의 사이즈 반환 사용된 엘리먼츠 리스트의 숫자 반환 (rear - front)    \r선형 큐  선형 큐는 데이터를 입력하면 rear가 증가하고 삭제를 통해 front도 증가, 하지만 여러번의 삽입과 삭제를 하면, 삭제된 이후 배열의 앞 공간은 사용할 수 없게 된다.\n linearQueue.py 리스트로 만든 선형큐 MAX = 5\rclass LinearQueue :\r#초기화 def __init__(self, max = MAX) :\rself.maxSize = max\rself.elements = [None] * self.maxSize #비어있는 배열은 None으로 초기화\rself.front = -1 #queue의 앞쪽 인덱스, 삭제 시 증가 self.rear = -1 #queue의 뒤쪽 인덱스 , 삽입 시 증가\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif self.front == self.rear : #front와 rear가 같으면 비어있음\rresult = True\relse : result = False return result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rif(self.rear+1 == self.maxSize) : #rear+1이 maxSize면 오버플로우\rprint(\u0026quot;queue Overflow!\u0026quot;)\relse :\rself.rear += 1 self.elements[self.rear] = x #rear+1에 새로운 데이터 추가\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse :\rself.front += 1\rresult = self.elements[self.front]\rself.elements[self.front] = 'None' #front+1의 데이터 None으로 삭제\rreturn result\r#queue가 비어있으면서 front가 마지막 인덱스(maxSize-1) 까지 도달\rif(self.isEmpty() and self.front == self.maxSize-1) :\rself.front = -1 #front를 초기화\rself.rear = -1 #rear를 초기화\r\u0026quot;\u0026quot;\u0026quot;\r# 삭제 후 한 칸씩 옮기는 로직\rfor i in range(0,self.maxSize) :\rif(i+1 != self.maxSize) :\rself.elements[i] = self.elements[i+1]\relse : self.elements[i] = None\rself.front -= 1\rself.rear -= 1\r\u0026quot;\u0026quot;\u0026quot;\r#queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[self.front+1]\r#queue의 사이즈 반환\rdef size(self) :\rreturn self.rear - self.front queue = LinearQueue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r linearDequeue.py  파이썬의 deque를 이용한 선형큐\n MAX = 5\rfrom collections import deque\rclass LinearDequeue :\r#초기화 def __init__(self, max = MAX) :\rself.elements = deque()\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif len(self.elements) == 0 : result = True\relse : result = False return result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rself.elements.append(x)\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse : return self.elements.popleft() #queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[0]\r#queue의 사이즈 반환\rdef size(self) :\rreturn len(self.elements)\rqueue = LinearDequeue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r 환형큐  선형큐의 공간 낭비의 문제점을 해결하기 위해 고안된 환형큐지만 역시나 문제점이 있다. front 와 rear가 같으면 비어(isEmpty) 있는 상태이지만, 환형 큐가 꽉찬(isFull) 상태 또한 front와 rear가 같아 문제점이 발생한다.\n  front와 rear의 위치만으로 큐의 비어있는 상태와 꽉찬 상태를 구분할 수 없기 때문에 이를 위해 큐의 한칸을 비어둔다. 한칸을 비움으로써 큐의 비어있는 상태와 꽉찬 상태의 front와 rear 위치를 다르게 하여 해결한다.\n circularQueue.py MAX = 5\rclass CircularQueue :\r#초기화 def __init__(self, max = MAX) :\rself.maxSize = max\rself.elements = [None] * self.maxSize #비어있는 배열은 None으로 초기화\rself.front = 0 #queue의 앞쪽 인덱스, 삭제 시 증가 self.rear = 0 #queue의 뒤쪽 인덱스 , 삽입 시 증가\r#queue의 값이 비었는지 확인, 비었으면 true, 아니면 false\rdef isEmpty(self) :\rif self.front == self.rear : #front와 rear가 같으면 비어있음\rresult = True\relse : result = False return result\rdef isFull(self) :\rif self.front == (self.rear+1) % self.maxSize :\rresult = True\relse :\rresult = False\rreturn result\r#queue의 제일 뒷부분에 데이터 추가 def enQueue(self, x) :\rif(self.isFull()) : #rear+1이 maxSize면 오버플로우\rprint(\u0026quot;queue Overflow!\u0026quot;)\relse :\rself.rear = (self.rear+1) % self.maxSize\rself.elements[self.rear] = x #rear+1에 새로운 데이터 추가\r#queue의 제일 앞의 데이터 삭제 및 반환\rdef deQueue(self) :\rif self.isEmpty() : #queue가 비어있는지 확인\rreturn(\u0026quot;queue is Empty!\u0026quot;)\relse :\rself.front = (self.front+1) % self.maxSize\rresult = self.elements[self.front]\rself.elements[self.front] = 'None' #front+1의 데이터 None으로 삭제\rreturn result\r#queue가 비어있으면서 front가 마지막 인덱스(maxSize-1) 까지 도달\rif(self.isEmpty() and self.front == self.maxSize-1) :\rself.front = -1 #front를 초기화\rself.rear = -1 #rear를 초기화\r\u0026quot;\u0026quot;\u0026quot;\r# 삭제 후 한 칸씩 옮기는 로직\rfor i in range(0,self.maxSize) :\rif(i+1 != self.maxSize) :\rself.elements[i] = self.elements[i+1]\relse : self.elements[i] = None\rself.front -= 1\rself.rear -= 1\r\u0026quot;\u0026quot;\u0026quot;\r#queue의 제일 앞의 데이터 반환\rdef peek(self) :\rreturn self.elements[self.front+1]\r#queue의 사이즈 반환\rdef size(self) :\rreturn self.rear - self.front queue = CircularQueue(5);\rprint(queue.elements)\rqueue.enQueue(1)\rprint(queue.elements)\rqueue.enQueue(2)\rprint(queue.elements)\rqueue.enQueue('banana')\rprint(queue.elements)\rqueue.enQueue(4)\rprint(queue.elements)\rqueue.enQueue(5)\rprint(queue.elements)\rqueue.enQueue(6)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;peek() \u0026quot;, queue.peek())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\rprint(queue.elements)\rqueue.enQueue(6)\rprint(queue.elements)\rqueue.enQueue(7)\rprint(queue.elements)\rqueue.enQueue(8)\rprint(queue.elements)\rprint(\u0026quot;size() \u0026quot;, queue.size())\rprint(\u0026quot;deQueue() \u0026quot;,queue.deQueue())\r 재귀 함수  자기 자신을 다시 호출하는 함수. 재귀 함수의 종료조건을 반드시 명시해야 한다. 컴퓨터 내부적인 스택 자료구조를 이용한다. 마지막 함수까지 끝나고 나서야 다시 역순으로 돌아가 종료된다.\n  아래 예제는 입력받은 숫자만큼 부터 카운트다운을 하는 소스이다.\n countdown.py (재귀함수 사용) m = int(input())\rdef coountdwon(n) :\rif(n ==0 ) :\rreturn 'Happy new year!'\relse : print(n)\rreturn coountdwon(n-1)\rcoountdwon(m)\r countdown2.py (반복문사용) for i in range(0, m) :\rprint(m-i)\rif (m-i) == 1 :\rprint('Happy new year!')\r 유클리드 호제법 이 자료는 나동빈님의 이코테 서적과 유튜브 영상을 보고 정리한 자료입니다.\n참고 : http://www.yes24.com/Product/Goods/91433923\n  ","description":"탐색 알고리즘.","id":36,"section":"blog","tags":["Algorithm"],"title":"탐색 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/search/search-algorithm/"},{"content":"[문제1] 왕실의 기사 [문제] 왕실의 기사 : 문제 설명  행복 왕국의 왕실 정원은 체스판과 같은 8 × 8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다 나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다 나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있다\n   수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기   수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기   이처럼 8 × 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라. 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a 부터 h로 표현한다\n  c2에 있을 때 이동할 수 있는 경우의 수는 6가지이다 a1에 있을 때 이동할 수 있는 경우의 수는 2가지이다 d4에 있을 때 이동할 수 있는 경우의 수는 8가지이다.\n [문제] 조건  조건 풀이시간 20분 시간제한 1초, 메모리 128mb\n  입력 첫째 줄에 8x8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1 처럼 열과 행으로 이뤄진다.\n  출력 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오.\n  입력 예시 a1\n  출력 예시 2\n 아이디어   모든 경우를 탐색하는 완전탐색 유형의 문제이다 문자 -\u0026gt; 아스키 코드를 반환 하는 ord(\u0026lsquo;a\u0026rsquo;) 를 알아야 한다.\n참고 \u0026lt;-\u0026gt; chr(97)   royal_knight.py n = str(input())\rx = ord(n[0:1])\ry = n[1:2]\r#print(n[0:1])\r#print(n[1:2])\r#print(chr(104))\r#print(ord('a'))\rmv = [0 , 1, 2, 3, 4, 5, 6, 7]\rdx = [-1, +1, +2, +2, +1, -1, -2, +2]\rdy = [-2, -2, -1, +1, +2, +2, +1, -1]\rcount = 0\rfor move in mv :\rif( ord('a') \u0026lt;= int(x)+dx[move] \u0026lt;= ord('h')\rand 1 \u0026lt;= int(y)+dy[move] \u0026lt;= 8) :\rcount += 1\rprint(count)  royal_knight2.py input_data = input()\rrow = input_data[1]\rcolumn = int(ord(input_data[0]))- int(ord('a')) +1\rsteps = [(-2, -1), (-2, +1), (-1, +2), (+1,+2), (+2, +1), (+2, -1), (+1, -2), (-1, +2)]\rcount = 0\rfor step in steps :\rif( 1 \u0026lt;= step[0]+int(row) \u0026lt;= 8 and 1 \u0026lt;= step[1]+int(column) \u0026lt;= 8 ) :\rcount += 1\rprint(count)  파이썬 모범답안 input_data = input()\rrow = int(input_data[1])\rcolumn = int(ord(input_data[0]))- int(ord('a')) +1\rsteps = [(-2, -1), (-2, +1), (-1, +2), (+1,+2), (+2, +1), (+2, -1), (+1, -2), (-1, +2)]\rresult = 0\rfor step in steps :\rnext_row = step[0]+row\rnext_column = step[0]+column\rif( 1 \u0026lt;= next_row \u0026lt;= 8 and 1 \u0026lt;= next_column \u0026lt;= 8 ) :\rresult += 1\rprint(result)  놓친 아이디어   input_data = input(), input_data[0],input_data[1] 로 접근 할 수 있는것을 더 복잡하게 잘라냈다. int(ord(input_data[0])) - int(ord(input_data[a])) + 1 을 사용하여 1 ~ 8로 더 간편히 조회가능. 이동 관련해서 dx,dy 각각 배열을 만들었지만, row, column을 하나의 데이터로 묶어서 사용할 수도 있다.   RoyalKnight.java package ex.algorithm.implement;\rimport java.util.ArrayList;\rimport java.util.Scanner;\rpublic class RoyalKnight{\rpublic static void main(String[] args) {\rint result = 0;\rScanner sc = new Scanner(System.in);\rString input_data = sc.nextLine();\rint row = Integer.parseInt(input_data.substring(1,2));\rint column = (int)input_data.substring(0,1).charAt(0) - (int) 'a' + 1;\rArrayList steps = new ArrayList\u0026lt;ArrayList\u0026lt;Integer[]\u0026gt;\u0026gt;();\rsteps.add(new Integer[]{-2,-1});\rsteps.add(new Integer[]{-2,+1});\rsteps.add(new Integer[]{-1,+2});\rsteps.add(new Integer[]{+1,+2});\rsteps.add(new Integer[]{+2,+1});\rsteps.add(new Integer[]{+2,-1});\rsteps.add(new Integer[]{+1,-2});\rsteps.add(new Integer[]{-1,-2});\rfor (Object obj : steps) {\rInteger[] step = (Integer[])obj;\rint next_row = row + step[0];\rint next_column = column + step[1];\rif((1 \u0026lt;= next_row \u0026amp;\u0026amp; next_row \u0026lt;= 8) \u0026amp;\u0026amp; (1 \u0026lt;= next_column \u0026amp;\u0026amp; next_column \u0026lt;= 8)) {\rresult++;\r}\r}\rSystem.out.println(result);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 왕실의 기사","id":37,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"왕실의 기사 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/royal_knight/"},{"content":"Education Interest Fields Project KTDS 2019.10 ~ Present  Actual Expense Calculation System [Development, Operation]\n Introduction :  Develop and operate a system that calculates the actual construction expenses of subcontractors such as expenses for employee insurance, safety management, waste disposal, and private inventory storage based on submitted data and evidence for KT.\n Technical  Web backend (Java, ExtJs Framework, OracleDB) Web frontend (html, css, JS, jQuery, Jsp) Versioning : Subversion (feature branch, code review) DevOps : Provide a reliable integrated automation system by building, testing, distributing, etc. using Jenkins Dependency Management : Increase maintenance and decrease dependency using Maven  Task (Skills)  Employee Attendance and Approval System  Develop a system that calculates actual expenses for National Health Insurance, National Pension Service, and Long-Term Care Insurance Develop a statement of accounts exporting function Decrease expenses through payment of calculated insurance expenses with the exact number of working days Deliver standardized and intuitive reports, decreased time consumption, and supported decision making with provision of the statement of accounts Optimize management of attendance through digitization and digitalization   Diagnose and Improve Source Vulnerability and Security  Diagnose source vulnerability regularly Prepare for hacking attacks through analysis and application of the latest hacking trends   Integrate Subcontracts of Guarantee and of Guarantor  Collaborate with other agencies through interfaces Ensure reliable real-time safe trading using the guarantee system   Achievement :  Since the opening of the actual cost settlement system on January, 2021, 5,603 cases of actual cost settlement have been paid, and 6,493 cases are under process.    TSK [2019.06 ~ 2019.10] Electronic Purchase System [Development]\no\tIntroduction : Developed an electronic purchasing system that provides electronic bidding, contracts, and orders for water treatment, waste disposal construction, and material delivery between TSK affiliates and partners. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask (Skills) •\tDeveloped systems for business registration, certification, and approval of partner companies\n Assisted in optimization •\tDeveloped electronic contract and contract report system Provide reliability to counterparties •\tIssued KTNET electronic tax invoice and installed certificate signing toolkit (tradesign) Integrated interface with other institutions Ensured reliability of the contract through issuance of electronic tax invoice  SK Home\u0026amp;service [2018.11 ~ 2019.05] Inventory Management System [Development, Operation]\no\tIntroduction : Developed a system for product management process and approval system, such as product application, order, and distribution, used by internal agents and equipment engineers\no\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of inventory application system\n Developed inventory management and application systems Ensure accurate measurement of inventory volume by systemizing inventory management Accelerated inventory management support for applying, ordering, transferring, etc. •\tDevelopment of (integrated) approval system Improved maintenance of collaborative usage of inventory and credit card by modularizing POS system Stabilized system Detected issues and updated system through periodic monitoring Distributed and created backup using shell scripts on Linux  SK Broadband [2018.08 ~ 2018.11] Advancement of HR System [Development]\no\tIntroduction : Developed an internal open recruiting system that recruits experts within the company in case of manpower issues at a particular department and a 52-hour flextime policy application process.\no\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of an internal open recruiting system process\n Partook in enabling reusage of repeated windows through modularization Reduced development time, increased reusage and improved maintenance •\tDevelopment of flextime policy application process Provided intuitive management of schedule by developing calendar-based window Maximized employee autonomy and work efficiency  KYOBO Life [2018.06 ~ 2018.07] Integrated Monitoring System [Development]\no\tIntroduction : Developed an interface, which receives data from other systems and equipment, for an integrated monitoring system, which provides figures such as status and traffic of infrastructure equipment, in the form of dashboards. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tIntegration with other systems\n Increased scalability by developing a variety of interfaces, including TUI, DB2DB, and File2DB •\tDevelopment of batch management system Enabled convenient and easy setting of batches by developing batch management system •\tDevelopment of Dashboard Assisted fast decision making by enabling intuitive log analysis through visualization of logs •\tSSO integration Provided convenient accessibility though shared sessions  Heungkuk Fire \u0026amp; Marine Insurance [2018.02 ~ 2018.05] Audit Information System [Development]\no\tIntroduction : Responsible for continuous monitoring to alert any anomaly in audit information system, Implements of audit process, and development of follow-up and approval process o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of continuous monitoring\n Detected and notified abnormal transactions through scenario-based data analysis Reduced the cost of time and maintaining reliability by preventing accidents in advance •\tImplements of audit Provided efficient management of the person in charge through history management and organization of an audit team Enabled convenient management of outputs, such as audit plans, audit checklist, review points, reports, etc. •\tDevelopment of follow-up process Assisted decision making by providing examples of outputs and decisions of prior audit cases as reference •\tDevelopment of approval process Increased efficiency through development of approval system Enabled collection and management of approval data  Korea Safety \u0026amp; Health Agency [2017.11 ~ 2018.01] Industrial Accident Prevention Information System ERP [Development]\no\tIntroduction : Developed protective equipment certification review process for the Industrial Accident Prevention Information System o\tTechnical •\tWeb Backend (Java, Spring Framework, Tibero, ibatis) •\tWeb Front (Nexacro Platform, Jsp, HTML5, CSS3, Ajax, JS Es6, jQuery) •\tVersioning : Subversion (feature branch, code review) o\tTask •\tProtective equipment certification application and approval\n Increased efficiency in management of certified equipment through registration Provided convenient registration and application process based on the approval status and processing order of certification tasks such as written examination, technical capability and production system examination, product examination by type, verification examination, autonomous safety verification report, etc.  Namsung Shipping [2017.08 ~ 2017.10] Cargo Trace Mobile [Development]\no\tIntroduction : Developed a contract management process that manages customer fares on site and contact management process that enables convenient searching and contacting of responsible department and personnel of Namsung Shipping. o\tTechnical •\tWeb backend (Java, Spring Framework, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tContract Management\n Increased speed and improved convenience for immediate response through customer fare management •\tDevelopment of Contact Us Developed a system that visualizes contact information of responsible department and personnel and that provides quick access to responsible personnel through phone calls and SNS  Samsung Asset Management [2017.04 ~ 2017.07] Development of Fund Solution [Development]\no\tIntroduction : Partook in development of fund products, home screens, research \u0026amp; insight, topic search, products of interest, and integrated search for fund solutions\no\tTechnical •\tWeb backend (Java, Struts Framewrk, racleDB) •\tWeb frntend (html, css, JS, jQuery, Jsp) •\tVersining : Subversin (feature branch, cde review) •\tDevps : Prepared for large volume of traffic using Lad Balancing •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tConfiguration of home screen in dashboard form to provides required information at a quick glance\n Developed themed-specific home screens such as main screen, solution, ETF focus, and research \u0026amp; insight Improved efficiency of response time through asynchronous processing method using AJAX •\tFund Products Developed detailed advanced search function that enables custom searches Provided intuitive interfaces by visualizing important indicators of the fund, including its type, operator, risk indicator, and yield Developed fund product lists with dynamic sorting capabilities using jqGrid Developed a user-friendly look-up by including a function to align funds by short-term and long-term returns •\tFund Comparison Developed fund comparison function that allows comparisons up to three products on one screen Improved efficiency of response time through asynchronous processing method using AJAX Provided the rate of return graphs for each fund using HighChart and the annual rate of return graphs for all funds being compared on one screen Optimized the range, legend, and form of reactive information of the graph\u0026rsquo;s x-axis y-axis through close collaboration with fund planners •\tResearch \u0026amp; Insight Improved maintenance and reduced development time through joint development of an integrated function that enables multiple dashboards to operate under the same module Provided user convenience by adding topics(tags) to each post to search for filtered results •\tIntegrated search Developed an integrated search engine with keyword searching function which provides all contents, that include the keyword, from Fund, ETF Focus, Research \u0026amp; Insight, and Knowledge PLUS Provided more detailed search capabilities by enabling searching within the search results Optimized SQL through query tuning o\tAchievement : •\tReceived Web Awards Korea 2017 Best Asset Management Award in the Financial Sector Link  JEJUair [2017.02 ~ 2017.04] Development of Pre-in-flight Meal Reservation System [Development]\no\tIntroduction : Developed a statistical system for in-flight meals sold by JEJUair. Statistics consisted of data by country/airport and the number of meal orders by meal supplier on pivot table, and detailed search conditions, such as period, flight number, supplier, in-flight meal, etc., provided desired statistical data at a glance.\no\tTechnical •\tWeb backend (Java, Spring Framework, Aws Aurora DB) •\tWeb frontend (html, css, JS, jQuery, Jsp) •\tVersioning : Subversion (feature branch, code review) •\tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask •\tDevelopment of Statistical System\n Developed a statistical table using pivot queries that aggregate columns into rows Minimized response time through optimization and tuning of queries and increased efficiency through reduction of resource usage Developed jointly with SAP a system that collects data such as air schedules, countries, airports, in-flight meals, etc. through the Saf Jco Library •\tDiagnosed security vulnerabilities and developed security solutions using Coderay  Audien [2016.08 ~ 2017.01] Development of Web Streaming System [Development]\no\tIntroduction : Developed a back-end and front-end domain for all customer services, including product development, streaming, and escrow payment, at Audien (an audio book streaming content hybrid app company).\no\tTechnical\t\tWeb backend (Java, Spring Framework, OracleDB) \tWeb frontend (html, css, JS, jQuery, Jsp) \tVersioning : Subversion (feature branch, code review) \tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask \tDeveloped services for all products, such as home screen, list, detailed screen, shopping basket, purchase of voucher, and coupon registration, using audiobook as a product \tDeveloped with efficient response time through asynchronous processing using AJAX \tProvided the same functionality on WEB, Android, and IOS by developing a hybrid app \tCreated new customer value by launch audiobook web services that are not in the marketplace in collaboration with project managers \tDeveloped audio book categories, product lists, and detailed screens similar to e-libraries or online bookstores for convenient access by consumers. \tDevelopment of streaming player using opensource product \tDeveloped audio player using Video.js, an opensource product \tImplemented streaming tool using HLS(Http Live Streaming) protocol \tIntegration of payment service with escrow \tImplemented a secure payment system that asks the purchase intention once more to eliminate inefficient aspects such as simple change of mind, etc. before payment \tDeveloped, validated, and secured consumer-friendly and efficient systems by conducting integrated testing and unit testing \tAssisted transaction management through success processing and rollback processing by coherently combining the success and failure of payment services and business logic into one process\nFiNMART [2016.04 ~ 2016.07] Development of Loan Comparative Quote Hybrid App Service [Development]\no\tIntroduction : Developed a hybrid platform that provides loan quotes and developed a credit and real estate loan application system using used car dealer certification and dealer management in B2B format and customer credit information in B2C format.\no\tTechnical \tWeb backend (Java, Spring Framework, Maria DB) \tWeb frontend (html, css, JS, jQuery, Jsp) \tVersioning : Subversion (feature branch, code review) \tDependency Management : Improved maintenance and decreased dependency using Maven o\tTask \tDevelopment of B2B used car dealer certification and dealer member management \tIncreased service credibility by developing used car dealer registration system that only registers vetted dealers \tDeveloped sale management system to enable dealers to register their vehicles for sale \tDevelopment of credit and real estate loan application functions \tDeveloped an intuitive user interface that divides loan applications into steps for convenient registration process on mobile screen \tImproved convenience by providing temporary saving in filling out loan applications \tDeveloped identity verification and credit score verification through KCB identity verification \tProvided optimal loan products from various financial institutions based on customer verification information \tDeveloped back-office processes after customer loan applications to facilitate bank and customer connectivity o\tAchievement : \tReceived Internet Biz Eco Award Grand Prize in Business Sector \tReceived Smart App Award Special Grand Prize \tReceived JB Financial Holding FinTech Competition Excellence Award\nSaerom Information Systems [2013.04 ~ 2015.07] Development of Groupware [Development]\no\tIntroduction : While working at Saerom Information Systems, a groupware company, partook in 9 groupware development projects for Yujin Machinery, the Supreme Court, Woongjin Holdings, Chunhajeil Feed, Leehan, Gamevil, Kelim Ceramics, Nasung Shipping, and Danal. In-house, developed, tested, and maintained solutions, worked on groupware porting and groupware customization, and assisted further development upon additional requests. o\tTechnical •\tWeb backend (Java, Spring Framework, IBM Lotus, IBM Notes, OracleDB) •\tWeb frontend (html, css, JS, jQuery, Jsp) o\tTask •\tPortal\n Provided default menus and portlet based on user’s responsibility Improved convenience to users by developing portlet individualization function Provided intuitive services by visualizing payment progress •\tMail Provided collaboration and work efficiency through mail service Provided mail backup service using archive Prevented spams and strengthened security through mail monitoring •\tElectronic Approval Improved convenience by providing various basic templates to create additional required forms Enable detailed settings through options for each approval form •\tProject/Task Management Provided intuitive data on progression through visualization of data in Gantt Chart forms Provided systematic task management and inquiry functions •\tCommunity Developed survey function Developed popular post function Provided list function for responses to posts (comments, replies, interests) •\tIntegrated search Developed system menus and contact search functions •\tHR management Configured organizational chart using LDAP Developed tree-type organizational chart Developed restructuring and departmental management system •\tMultilingual Support Provided Korean/English as default languages Enabled infinite multilingual expansion capability through language packs Improved multilingual management convenience  ","description":"about me","id":38,"section":"","tags":[],"title":"About Me","uri":"https://offetuoso.github.io/about/"},{"content":"Git 캐시(cache) 삭제 // 원격 저장소와 로컬 저장소 파일을 삭제\r$ git rm 파일명\r// 원격 저장소에 있는 파일만 삭제하고, //로컬 저장소에 있는 파일은 삭제하지 않음\r$ git rm --cached 파일명\r rm -r 옵션\r// 파일 삭제\r$ git rm --cached 파일명\r// 폴더 하위의 모든 파일을 삭제\r$ git rm -r --cached 폴더명\r ","description":"깃 캐시 삭제","id":39,"section":"blog","tags":["Git"],"title":"Git 캐시 삭제","uri":"https://offetuoso.github.io/blog/develop/git/202105/time/"},{"content":"[문제1] 시각 [문제] 시각 : 문제 설명  정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하라. 예를 들어 1을 입력했을 때\n  다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다 00시 00분 03초 00시 13분 30초\n  반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다 00시 02분 55초 01시 27분 45초\n [문제] 조건  조건 풀이시간 15분 시간제한 2초, 메모리 128mb\n  입력 첫째 줄에 정수 N이 입력된다.(0\u0026lt;=N\u0026lt;=23)\n  출력 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.\n  입력예시 5\n  출력예시 11475\n 아이디어  복잡하게 생각할 필요없이 하루는 86,400초로 00시00분00초 -\u0026gt; 23시59분59초 까지 모든 경우는 86,400로 경우의 수가 100,000 개도 되지 않기 때문에 모든 초를 센다 하여도 2초가 넘지 않는다.\n  모든 초를 조회하는 완전탐색 유형으로 생각하면된다.\n  모든 시간 분 초를 순회하며, 합쳐서 문자로 합쳐서 포함 여부를 조회한다.\n  파이썬 if(\u0026lsquo;3\u0026rsquo; in str(hour)+str(minute)+str(second)) : #활용\n  자바 if((\u0026quot;\u0026quot;+hour+minute+second).contains(\u0026ldquo;3\u0026rdquo;)){} //활용\n time1.py n = int(input())\rcount, hour, minute, second = 0, 0, 0, 0\rwhile True :\rif('3' in str(hour)+str(minute)+str(second)):\rcount += 1\rsecond += 1\rif second == 60 :\rminute += 1\rsecond = 0\rif minute == 60 :\rhour += 1\rminute = 0\rif hour == n+1 :\rbreak\rprint(count)  파이썬 모범답안 n = int(input())\rresult = 0;\rfor h in range(n+1) :\rfor m in range(60) :\rfor s in range(60) :\rif('3' in str(h)+str(m)+str(s)) :\rresult += 1\rprint(result)\r Time.java package ex.Algorithm.implement;\rimport java.util.Scanner;\rpublic class Time{\rpublic static void main(String args[]) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint hour = 0;\rint minute = 0;\rint second = 0;\rint count = 0;\rwhile (true) {\rif((\u0026quot;\u0026quot;+hour+minute+second).contains(\u0026quot;3\u0026quot;)) {\rcount++;\r}\rsecond++;\rif(second == 60){\rminute ++;\rsecond = 0;\r}\rif(minute == 60){\rhour ++;\rminute = 0;\r}\rif(hour == n+1){\rbreak;\r}\r}\rSystem.out.println(count);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 시각","id":40,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"시각 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/time/"},{"content":"[문제1] 상하좌우 [문제] 상하좌우 : 문제 설명  여행가 A는 N × N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다\n  계획서에는 하나의 줄에 띄어쓰기를 기준으로 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다. 각 문자의 의미는 다음과 같다\n  L: 왼쪽으로 한 칸 이동 R: 오른쪽으로 한 칸 이동 U: 위로 한 칸 이동 D: 아래로 한 칸 이동\n  이때 여행가 A가 N × N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다 예를 들어 (1, 1)의 위치에서 L 혹은 U를 만나면 무시된다 다음은 N = 5인 지도와 계획이다\n [문제] 조건  조건 풀이시간 15분 시간제한 1초, 메모리 128mb\n  입력 첫째 줄에 공간의 크기를 나타내는 N이 주어집니다. (1\u0026lt;=N\u0026lt;=100) 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어집니다. (1\u0026lt;=이동 횟수\u0026lt;=100)\n  출력 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X,Y)를 공백으로 구분하여 출력한다.\n  입력예시 5 R R R U D D 출력예시 3 4\n up-down-left-right1.py n = int(input()) # map의 최대 크기\rm = list(map(str, input().split())) #공백으로 구분된 이동플랜\rx, y = 1, 1\t# 시작위치\rfor move in m: # 입력받은 이동 커맨드\rif (move == \u0026quot;U\u0026quot;) and (x - 1) \u0026gt; 0: # U (x-1, y)를 x-1이 1보다 작아지지 않는 선에서 수행 x -= 1\relif (move == \u0026quot;D\u0026quot;) and (x + 1) \u0026lt;= n : # D (x+1, y)를 x+1이 n보다 커지지 않는 선에서 수행 x += 1\relif (move == \u0026quot;L\u0026quot;) and (y - 1) \u0026gt; 0: # L (x, y-1)를 y-1이 1보다 작아지지 않는 선에서 수행 y -= 1\relif (move) == \u0026quot;R\u0026quot;) and (y + 1) \u0026lt;= n : # R (x, y+1)를 y+1이 n보다 커지지 않는 선에서 수행 y += 1\rprint(x,' ',y)  up-down-left-right1.py n = int(input())\rm = input().split()\rx, y = 1, 1\rmove_type = ['U','D','L','R']\rdx = [-1, +1, 0, 0]\rdy = [0, 0, -1, +1]\rfor move in m:\rfor i in range(0, len(move_type)) :\rif move == move_type[i] :\rif( 1 \u0026lt;= x+dx[i] \u0026lt;= n and 1 \u0026lt;= y+dy[i] \u0026lt;= n ) :\rx += dx[i]\ry += dy[i]\rprint(x,' ',y)\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 구현 알고리즘 상하좌우","id":41,"section":"blog","tags":["Algorithm","Implements","이코테"],"title":"상하좌우 (구현 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/implements/202104/up-down-left-right/"},{"content":"[문제1] 숫자 카드 게임 [문제] 숫자 카드 게임 : 문제 설명  숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.\n  숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.   모든 행을 순회 하여, 행의 가장 작은 수중에 가장큰 수를 찾기\n  카드들이 N X M 형태로 놓여 있을 때, 게임의 룰에 맞게 카드를 뽑는 프로그램을 만드시오.\n [문제] 조건  조건 시간 1초, 메모리 120mb\n  입력조건 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다. (1 \u0026lt;= N,M \u0026lt;= 100) 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수이다.\n  출력조건 첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다\n  입력예시 3 3 3 1 2 4 1 4 2 2 2\n  출력예시 2\n  입력예시 2 4 7 3 1 8 3 3 3 4\n  출력예시 3\n 아이디어  각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수 찾기 list에서 가장 작은 원소를 찾아주는 min() 함수 이용 입력 파라메터 중에서 가장 큰 원소를 찾아주는 max(a, b) 함수 이용\n game_of_number_card.py n, m = map(int, input().split())\rresult = 0\rfor i in range(n):\rdata = list(map(int, input().split()))\rminumum = min(data)\rresult = max(result, minumum)\rprint(result)  GameOfCard.java package ex.Algorithm.greedy;\rimport java.util.Arrays;\rimport java.util.Scanner;\rpublic class GameOfCard {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint result = 0;\rString n = sc.nextLine();\rString m = null;\rString arr[] = n.split(\u0026quot; \u0026quot;);\rint maximum = 0;\rfor (int i = 0; i \u0026lt; Integer.parseInt(arr[0]); i++) {\rm = sc.nextLine();\rString row[] = m.split(\u0026quot; \u0026quot;);\r//자바 String배열 -\u0026gt; int배열로 변경 Java8 기준\rint[] nums = Arrays.asList(row).stream().mapToInt(Integer::parseInt).toArray();\r/*\rint[] nums = new int[row.length];\rfor(int j=0; j\u0026lt;row.length; j++) {\rnums[j] = Integer.parseInt(row[j]);\r}\r*/\rArrays.sort(nums);\rif(maximum \u0026lt; nums[0]) {\rmaximum = nums[0];\r}\r}\rSystem.out.println(maximum);\r}\r}\r 파이썬 모범답안 1 #n, m을 공백으로 구분하여 입력받기\rn, m = map(int, input().split())\rresult = 0\r#한 줄씩 입력받아 확인\rfor i in range(n):\rdata = list(map(int, input().split(\u0026quot; \u0026quot;)))\r# 현재 줄에서 '가장 작은 수' 찾기\rmin_value = min(data)\r# '가장 작은 수'들 중에서 가장 큰 수 찾기\rresult = max(result, min_value)\rprint(result)\r 파이썬 모범답안 2 #n, m을 공백으로 구분하여 입력받기\rn, m = map(int, input().split())\rresult = 0\r#한 줄씩 입력받아 확인\rfor i in range(n):\rdata = list(map(int, input().split()))\rmin_value = 10001\r#현재 줄에서 '가장 작은 수' 찾기\rfor a in data :\rmin_value = min(min_value, a)\r#'가장 작은 수 중'에서 가장 큰 수 찾기 result = max(result, min_value)\rprint(result)\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 숫자 카드 게임","id":42,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"숫자 카드 게임 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/games-of-number-card/"},{"content":"[문제1] 큰 수의 법칙 [문제] 큰 수의 법칙 : 문제 설명  출제자는 큰 수의 법칙을 본인만의 방식으로 다르게 사용하고 있다. 이 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙이다. 단 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.\n  예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.\n  배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 출제자의 큰 수의 법칙에 따른 결과를 출력하시오\n [문제] 조건  조건 시간 1초, 메모리 120mb\n  입력조건 첫째 줄에 N(2 \u0026lt;= N \u0026lt;= 1,000), M(1 \u0026lt;= M \u0026lt;= 10,000), K(1 \u0026lt;= K \u0026lt;= 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다. 입력으로 주어지는 K는 항상 M보다 작거나 같다\n  출력조건 첫째 줄에 큰 수 의 법칙에 따라 더해진 답을 출력한다\n  입력예시 5 8 3 2 4 5 4 6\n  출력예시 46\n 아이디어  최초 while 안에 k번의 반복문을 두어 큰수를 반복시키려고 했다만 문제 조건의 시간과 메모리의 조건이 있어 최대 입력값인 1000, 10000, 10000 이라면 열심히 풀고도 오답이 나올것이다.\n  n m k 5 7 2 2 1 5 4 3\n  {5, 5, 4, 5, 5, 4, 5}\n  코딩문제인줄 알았으나 수열문제 였다. 일단 5의 갯수를 세어 count * 5로 반복문 없이 계산을 하려한다.\n  첫번째로 반복되는 수열중 5의 갯수를 구하는 법이다. 반복되는 5, 5, 4는 (k+1) 3이며 전체의 총 개수에서 몇번 사용할 수 있는지 생각해 보면 m // (k+1) 몫은 2가 나온다. 여기에 k를 다시 곱해준다 (m // (+1) 2)*k 여기까지 계산하면 반복되는 수열중의 제일 큰 수를 계산한다.\n  하지만 수열에 포함되지 않은 5의 갯수를 더해줘야한다. 딱 나눠떨어지면 0, 나머지가 있다면 나머지 만큼의 5를 더해 줘야한다. 여기에 자주 쓰이는 % 연산자가 있다\n  m % (k+1) 으로 1이나온다. 나머지의 갯수를 계산하는 식 m % (k+1)\n  count = (m // (+1) 2)*k count += m % (k+1)\n  이렇게 하면 {(5), (5), 4, (5), (5), 4, (5)} 5의 개수를 얻었고 이제 4의 개수를 얻어보자 아까 구했던 수열이 반복되는 (m // (k+1)) 만큼 4를 곱해준다\n  count2 = (m // (k+1)) 나머지는 2번째 수가 나오지 못하여, 몫으로 안떨어지고 나머지가 된것이기 때문에 2번째 큰수는 나머지 추가로 더해줄게 없다\n  result = (count첫번째큰수)+(count2두번째큰수)\n law_of_large_number.py n, m, k = map(int, input().split()) l = list(map(int, input().split()));\rl.sort();\rfirst = l[n-1] second = l[n-2]\rcount = (m // (k+1))*k count += m % (k+1)\rcount2 = (m // (k+1)) #m-count\rresult = (count*first) + (count2*second)\rprint(result)\r LawOfLargeNumber.java package ex.Algorithm.greedy;\rimport java.util.Arrays;\rimport java.util.Collections;\rimport java.util.Scanner;\rpublic class LawofLargeNumber {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint result = 0;\rString str1 = sc.nextLine();\rString str2 = sc.nextLine();\rint n = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[0]);\rint m = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[1]);\rint k = Integer.parseInt(str1.split(\u0026quot; \u0026quot;)[2]);\rString list[] = str2.split(\u0026quot; \u0026quot;);\rArrays.sort(list);\rint first = Integer.parseInt(list[n-1]);\rint second = Integer.parseInt(list[n-2]);\r//System.out.println(\u0026quot;n\u0026quot;+n);\r//System.out.println(\u0026quot;m\u0026quot;+m);\r//System.out.println(\u0026quot;k\u0026quot;+k);\r//System.out.println(\u0026quot;first\u0026quot;+first);\r//System.out.println(\u0026quot;second\u0026quot;+second);\r//5 5 4 5 5 4 5\rint count = (m/(k+1))*k;\rcount += m%(k+1);\rint count2 = m-count; //System.out.println(count);\rresult = (count*first) + (count2*second);\rSystem.out.println(result);\r}\r}\r 이 자료는 나동빈님의 이코테 저서를 보고 정리한 자료입니다.\n","description":"코딩테스트 큰수의 법칙","id":43,"section":"blog","tags":["Algorithm","Greedy","이코테","수열"],"title":"큰수의 법칙 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/law-of-large-number/"},{"content":"   a. touching (\u0026lsquo;감동시키는\u0026rsquo;) a. entertaining (\u0026lsquo;재미있는\u0026rsquo;)  It was really entertaining and the storyline was also a bit touching(sad). (정말 재미 있었고 스토리 라인도 약간 감동적이었습니다.)\n These days (\u0026lsquo;요즘\u0026rsquo;) = Nowadays  These day , I go to bed in 1 am and (get up) 7 am (요즘은 새벽 1시에 자고 아침 7시에 일어나)\n On weekends (\u0026lsquo;주말에\u0026rsquo;) get up at (~ time) ('-시에 일어나') still (\u0026lsquo;여전히\u0026rsquo;)  On weekends, I get up at 1 pm and still go to bed the same (주말에는 오후 1시에 일어나도 똑같이 잠자리에 든다)\n ~ hours ('-시간')  I sleep for 9 hours (난 9시간 동안 잔다.)\n When A, then B. (\u0026lsquo;A 하면 B합니다.')  When I very tired, then has insomnia. (내가 매우 피곤하면 불면증이 생깁니다.) → I have a hard time falling asleep quickly, especially when I’m very tired. (나는 특히 내가 매우 피곤할 때 빨리 잠들기가 힘듭니다.)\n especially (\u0026lsquo;특히\u0026rsquo;) I am always (\u0026lsquo;난 항상\u0026rsquo;) ~I always a little tired and I drinking a lot of coffee.~\n I am always a little tired and I drink a lot of coffee. (나는 항상 조금 피곤하고 커피를 많이 마신다.)\n a lot (\u0026lsquo;많이\u0026rsquo;)  I watch Netflix a lot. (나는 넷플릭스를 많이 봅니다.) I had drinking a lot of coffee. (나는 커피를 많이 마셨다.)\n Have p.p ('-했다.\u0026rsquo; 현재완료 시점)  I have be growth (나는 성장했다.)\n Have been p.p ('-되어졌다.' 현재완료 시점)  I Have been healthed (나는 건강해졌다.) I Have been fired (나는 해고당했다.)\n Have been ~ing ('-해 오고 있다.' 현재완료 진행형으로)  I have been learning English for three weeks. (저는 3 주 동안 영어를 배우고 있습니다.)\n be ~ing ('-하고 있어')  I am drinking a coffee (나는 커피를 마시고 있다) I am trying to get some sleep (잠을 좀 자려고 해요) I am learning English (나 영어 배우고 있어) I am having a talk with A (나 A와 이야기 하고 있어요)\n how I can get to A / how to get to A (\u0026lsquo;A에가는 방법\u0026rsquo;)  how I can get to 안양천 how to get to 안양천\n remain (\u0026lsquo;남다\u0026rsquo;)  the question remains (문제가 남아있다.)\n remaining (\u0026lsquo;남아있는\u0026rsquo;)  The remaining amount (남은 금액)\n recommend (\u0026lsquo;추천하다/권장하다\u0026rsquo;) recommended (\u0026lsquo;추천하는/권장되는\u0026rsquo;)  recommended posts, groups that are relative to you\n strongly recommend (\u0026lsquo;강력추천\u0026rsquo;) The recommended amount of ~ ('-권장량')  The recommended amount of sleep (권장 수면량)\n I had a hard time (\u0026lsquo;나는 힘들었다.') fluently (\u0026lsquo;유창한\u0026rsquo;)  I have a hard time speaking English fluently (영어를 유창하게 말하는 것이 힘들다)\n frustrating (\u0026lsquo;좌절/실망\u0026rsquo;)  This solution is so frustrating. (이 솔루션은 너무 실망 스럽습니다)\n 문법오류 It was so funny and also sad. → It was really entertaining and the storyline was also a bit sad/touching.\rThese days (Nowadays) , I go to bed in 1 am and (get up) 7 am → at + time\rWhen I weekend, then I get up at 1pm but I still go to bed at 1 am. → On weekends, I get up at 1 pm and still go to bed the same.\r9 o’clock → 9 hours\rweak insomnia. When I very tired, then has insomnia.\r→ I have a hard time falling asleep quickly, especially when I’m very tired.\rI always a little tired and I drinking a lot of coffee. → I am always a little tired and I drink a lot of coffee. I watch Netflix a lot.\rI had drinking a lot of coffee.\rhave V-ing. → have been V-ing\rI have been learning English for three weeks.\rI have tried watching Mr. Sunshine, but it’s not my style.\rHave you tried bungee jumping? No, I haven’t.\rbe V-ing. ; I am drinking a coffee, I am trying to get some sleep, I am learning English (I’m learning how to speak in English), I am having a talk with Kihun.\rc.f. how I can get to 안양천, how to get to 안양천\rShe is having a rest → She is taking a rest.\rWhat are you doing? → I am doing ~.  새로배운 표현 remain 남다, remaining 남아있는\rthe question remains = there lies the question, the question is “-”\rThe remaining amount\rrecommend (v) → recommended (a) 1. 추천하다 (추천하는), 2. 권장하다 (권장되는)\rrecommended posts, groups that are relative to you\rI really/strongly recommend ~. (I strongly recommend (watching) Mr. Sunshine)\rThe recommended amount of _____.\rinfluence (v) → have an influence on sth\rhave a hard time V-ing\rI have a hard time speaking English fluently.\rWhen I was in middle school, I had a hard time getting up early.\rWhen I was a high school student, I had a hard time studying at school.\rfrustrating (a)\rThis problem set is so frustrating.\rCoding is so frustrating. / Coding really frustrates me.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":44,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.08","uri":"https://offetuoso.github.io/blog/english/202104/20210408-english-speak/"},{"content":"go to ~ ('-에 간다')  I go to company. (나는 회사에 간다.)\n be going to ~ ('-에 갈꺼다')  I\u0026rsquo;m going to market. (나는 마트에 간다. 갈예정이 있음 )\n be going to go to ~ ('-에 갈꺼야')  I\u0026rsquo;m going to go to korea. (나는 한국에 갈꺼야. 아직 계획은 세우지 않았음 )\n went to ~ ('- 갔었다 \u0026lsquo;)  I went to starfield. (나는 스타필드에 갔었다.)\n how can I get to the ~ ? ('- 까지 어떻게 가나요?')  Excuse me, how can I get to the \u0026lsquo;동대문 market\u0026rsquo;? (동대문 시장까지 어떻게 가나요?)\n Can you tell me where the ~ is ? ('-가 어디에 있는지 말해 줄 수 있습니까?')  Can you tell me where the bus station is? (버스 정류장이 어디인지 말해 줄 수 있나요?)\n Can you tell me how I can ~ ? (\u0026lsquo;어떻게 - 할 수 있는지 말씀해 주시겠습니까?')  Can you tell me how I can use this machine? (이 기계를 어떻게 사용할 수 있는지 말해 줄 수 있습니까?)\n I’d like to know how to get to the ~. ('-에가는 방법을 알고 싶습니다.')  I’d like to know how to get to the 안양천 (안양천에가는 방법을 알고 싶습니다.)\n purpose (\u0026lsquo;목적\u0026rsquo;) Grammar Error: I go to the workspace and → I went to the company and there were flowers (cherry blossoms) on the side of the roads nearby the company building.\rNew expressions learned today: strategy (n) 요령 → 전략\rskills vs. strategies\rpurpose 목적\rWhich subway station should I go to / to get to 안양천?\rCould you tell me how to spell it?\rExcuse me, how can I get to the _(location)_?\rCan I ask you a question?\rDo you know where _(location)_ is?\rCan you tell me where the bus station is? / how I can get to (location)?\rCan you tell me how I can use this machine?\rCan you tell me how to use this machine?\rI’d like to know how to get to the _(location)_.\rPardon me for asking, but ...\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":45,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.07","uri":"https://offetuoso.github.io/blog/english/202104/20210407-english-speak/"},{"content":"[문제1] 1이 될때까지 [문제] 1이 될때까지 : 문제 설명  어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n [문제] 조건  입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n make_one.py n, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  MakeOne.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"모험가 파티를 만드는 알고리즘","id":46,"section":"blog","tags":["Algorithm"],"title":"모험가 길드 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/adventurer-guild/"},{"content":"prepare (\u0026lsquo;준비하다\u0026rsquo;)  Pick/Choose two questions and prepare your answers. (두 가지 질문을 고르고 답을 준비하십시오.)\n the meaning of the ~ ('-의 의미')  the meaning of the name. (이름의 의미) The meaning of one’s name may have an influence on their life. (이름의 의미가 그들의 삶에 영향을 미칠 수 있습니다.)\n to have influence on ~ ('-에 영향을 미치다')  to have influence on life (삶에 영향을 미치다)\n v. affect ~ ('-에 영향을 미치다')  affect life (삶에 영향을 미치다)\n to affect positively/negatively = to bring a positive/negative effect on sth n. effect (\u0026lsquo;효과\u0026rsquo;)  effect of sleep (수면의 효과)\n strategy (\u0026lsquo;전략\u0026rsquo;)  skills and strategies (기술과 전략)\n Naming center (\u0026lsquo;작명소\u0026rsquo;)  It would be difficult to name my child based on astrology. (점성술에 근거하여 내 아이의 이름을 짓는 것은 어려울 것입니다.)\n make sure (\u0026lsquo;확실한\u0026rsquo;)  Make sure you do the dishes right after you eat. (식사 후 바로 설거지를하세요.) Make sure you give me the file by tomorrow. (내일까지 파일을 주셔야합니다.) = You must give me the file ~\n sure  Are you sure? (\u0026lsquo;확실합니까?') Are you sure you sent me the file via email? (이메일로 파일을 보냈습니까?)\n can you tell me again? (\u0026lsquo;다시 말해줄래?') = Can you repeat it once more? 문법오류 My name has an influence on positive effects on my life. (내 이름은 내 삶에 긍정적 인 영향을 미칩니다.)\r→ My name has an influence on my life. (내 이름은 내 삶에 영향을 미칩니다.)\r/ My name has a positive effect on my life. (내 이름은 내 삶에 긍정적 인 영향을 미칩니다.)\r→ My name gave/brought a positive effect on my life. (내 이름은 내 삶에 긍정적 인 영향을 미쳤습니다.)\r 새로배운 표현 to affect positively/negatively = to bring a positive/negative effect on sth\rmean (v) → meaning (n)\rS(n) + V (+ O(n) / + Adj.) (+ Adv.)\rone (n) 대명사로 쓰일 경우 → 그것, 한 사람\r조동사 - must, may/might, should/shall, would/will, have, celebrity (n) stars, famous people - Celebrity (IU) 셀럽\rCardi B - Culture, / North~West\rmake sure\rMake sure you do the dishes right after you eat.\rMake sure you give me the file by tomorrow. = You must give me the file ~\rsure → Are you sure? / Are you sure you sent me the file via email?\rI’m sure.\rSure. (Of course. No problem.)\rstrategy - skills and strategies\rCan you tell me again? = Can you repeat it once more?\rI’d like to know when the due date is.\rPardon me for asking, but where can I sign up for the membership?\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":47,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.02","uri":"https://offetuoso.github.io/blog/english/202104/20210402-english-speak/"},{"content":"##have influence on ~ ('-에 영향을 미치다')\n 동학개미 had some influence on the national stock market. (\u0026lsquo;동학 개미는 전국 주식 시장에 영향을 미쳤습니다.') I think, he has achievement that influence on some developer (\u0026lsquo;그는 일부 개발자에게 영향을 미치는 업적을 가지고 있다고 생각합니다.') I think, his achievement has some influence on [software developers/engineers.] (\u0026lsquo;그는 일부 개발자에게 영향을 미치는 업적을 가지고 있다고 생각합니다.') Netflix now has a huge influence on the media industry. (\u0026lsquo;Netflix는 이제 미디어 산업에 큰 영향력을 미치고 있습니다. \u0026lsquo;)\n say/ speak/ talk/ tell \u0026gt;\tsay (말하는 내용에 집중) 말하다\r- \u0026quot;i'm so tired \u0026quot; he said. (그가 \u0026quot;나는 피곤해\u0026quot; '라고 말했다')\r\u0026gt;\tspeak (1.말하는 행위, 2.언어를 사용할 수 있는 능력)말하다\r1. The teacher will speak about the test tomorrow (1. 선생님은 내일 시험에 대해 말할 것입니다)\r2. I can speak English (2. 나는 영어를 사용할 수 있습니다)\r\u0026gt; talk (말을 주고 받는 행위) 이야기하다, 말하다\r-\the talks too much (그는 말이 너무 많다)\r- We talked about the our future (우리는 우리의 미래에 대하여 이야기 했습니다)\r\u0026gt; tell (말하는 대상과 내용에 초점) 말하다 -\tI'll tell you what happened. (무슨 일이 있었는지 말씀 드리겠습니다.)\r 각 동사마다 표현하는 방법이 다르다 \u0026gt;\tsay\r1. 말하는 내용은 that\r- I say \u0026lt;mark\u0026gt;(that)\u0026lt;/mark\u0026gt; ~ (that 생략가능)\r2. 말하는 대상은 전치사 to 사용 - I say that ~ \u0026lt;mark\u0026gt;to\u0026lt;/mark\u0026gt; you (to를 붙여서 말하는 대상 추가)\r\u0026gt;\tspeak /talk\r1. 말하는 내용은 about\r- We speak \u0026lt;mark\u0026gt;about\u0026lt;/mark\u0026gt; the money\r- We talk \u0026lt;mark\u0026gt;about\u0026lt;/mark\u0026gt; the money\r2. 말하는 대상은 to 사용\r- They speak to me about the money\r- please talk to me about the money\r\u0026gt;\ttell *tell은 말하는 대상과 내용이 다 나와야 합니다\r1. 대상 tell [내용/명사] / 대상 tell about [내용/명사] 3형식 - she tells me the our future\r- they told him their product\r- she tells me about the our future\r- they told him about their product\r2. tell (대상) that (내용, 문장 형태(Phrase, 구))\r*내용이 ‘누가 뭘 했다’ 등 긴 내용을 말할 때 사용. (주어와 동사 필요)\r– Paul tells me that he likes to visit the new house.\r– They told him that they didn’t buy it.\r3. tell (대상) to do (something)\r*이 경우에는 주로 ‘(누구)에게 (무엇을 하라고)명령하다’라는 뜻으로 사용됩니다.\r– Paul tells me to clean my room.\r– They told him to show them his ID card.\r 전치사를 사용한 표현 \u0026gt;\t1. talk over: ~에 대해 (깊이) 이야기 하다\r– We talked over the new project.\r– Jason talked over his plan to Paris. \u0026gt;\t2. talk (대상) into (동명사): ~하도록 설득하다\r– He talked me into buying his new painting.\r– She talked him into sending a letter.\t say-speak-talk-tell은 아래 홈페이지에서 참조\r참고 : http://cafeclass.kr/say-speak-talk-tell-%EC%B0%A8%EC%9D%B4/\rAmerica(US)\u0026rsquo;s third gender \u0026gt; 1. He\r2. She\r3. Them\r plural (\u0026lsquo;복수형 more than one\u0026rsquo;) - a. the first person plural\r- n. the first person plural\r singular (\u0026lsquo;단수형 one\u0026rsquo;) - a. the third person singular form of the verb\r- n. the first person singular\r pass down (\u0026lsquo;전달받다, 물려받다\u0026rsquo;) (casual)  One of the parents’ family names is passed down to the child in Korea. (\u0026lsquo;한국에서는 부모의 성이 아이에게 전해집니다.')\n inherit (\u0026lsquo;상속하다\u0026rsquo;) (formal)  Instead of inheriting all the financial assets to his children, he donated 70% to the society. (\u0026lsquo;모든 금융 자산을 자녀들에게 물려주는 대신 사회에 70 %를 기부했습니다.')\n refer to (\u0026lsquo;인용하다\u0026rsquo;)  he was refer to sentence of poem (\u0026lsquo;그는시의 문장을 언급했다\u0026rsquo;)\n n. ancestor (\u0026lsquo;선조\u0026rsquo;) n. descendent (\u0026lsquo;후손\u0026rsquo;) \u0026gt; (de/di- : minus, later → decline, diminish)\r n. occupation (\u0026lsquo;직업\u0026rsquo;) prince and princess → princes and princesses (plural -es: is) 발음주의 연도읽기   1908 - nineteen-o-eight \u0026gt; nineteen-hundred and eight - The Olympics was held in Pyeongchang in 2018. - 2582 B.C. 2080, 2090   본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":48,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.04.01","uri":"https://offetuoso.github.io/blog/english/202104/20210401-english-speak/"},{"content":"[문제1] 곱하기 혹은 더하기 [문제] 곱하기 혹은 더하기 : 문제 설명  각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 \u0026lsquo;x\u0026rsquo; 혹은 \u0026lsquo;+\u0026rsquo; 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성. 단, + 보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정.\n   예를 들어, 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2)x 9)x 8)x 4) = 576이다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어짐.   [문제] 조건  입력조건 첫째 줄에 여러개의 숫자로 구성된 하나의 문자열 S가 주어집니다.(1\u0026lt;=S의 길이 \u0026lt;=20)\n  출력조건 첫째 줄에 만들어 질 수 있는 가장 큰 수를 출력합니다.\n  입력예시\n02984\n  출력예시\n576\n  문자열 내 연산자 계산 가능 메소드  eval()\rresult = eval('(3+5)*7')\rprint(result) # 56\r- 리스트 내 item들을 하나의 문자열로 만들어주는 메소드 list = ['a', 'b', 'c'] print(''.join(list)) # print: abc\r- 리스트에 item 추가 시, 위치 선정이 가능토록하는 메소드\r# list = ['a', 'b', 'c'] list.insert(0, \u0026quot;new\u0026quot;)\rprint(list) # ['new', 'a', 'b', 'c']  sum_or_multiply.py s = input()\rresult=0\rfor n in list(s) :\rif result == 0 or n == 0 or result == 1 or n == 1 : result += int(n)\relse :\rresult *= int(n)\rprint(result)\r 모범답안 파이썬 data = input()\rresult = int(data[0])\rfor i in range(1,len(data)) :\rnum = int(data[i])\rif num \u0026lt;= 1 or result \u0026lt;= 1:\rresult += num\relse:\rresult *= num\rprint(result)\r SumOrMultiply.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class SumOrMultiply {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rString s = sc.nextLine();\rint result = 0;\rfor (int i = 0; i \u0026lt; s.length(); i++) {\rint n = Integer.parseInt(s.substring(i, i+1));\rif(result == 0 || n == 0 || result == 1 || n == 1) {\rresult += n;\r}else {\rresult *= n;\r}\r}\rSystem.out.println(result);\r}\r}\r 모범답안 자바 package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class SumOrMultiply {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rString str = sc.nextLine();\rlong result = str.charAt(0) - '0';\rfor(int i=1; i \u0026lt; str.length();i++) {\rint num = str.charAt(i) - '0';\rif (num \u0026lt;= 1 ||result \u0026lt;= 1) {\rresult += num;\r}else {\rresult *= num;\r}\r}\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  곱하는 것보다 더하는 것이 더 큰 값을 얻을 수 있다. 곱해서 0또는 1이되는 상황보다, 곱하는게 큰 값을 얻는다\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"최고의 숫자가 되기 위하여 더하기 혹은 곱하기를 진행","id":49,"section":"blog","tags":["Algorithm"],"title":"더하기 혹은 곱하기 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/sum-and-multiply/"},{"content":"prefers a to b (\u0026lsquo;b 보다 a를 더 선호\u0026rsquo;)  we are prefers apple to banana (\u0026lsquo;우리는 바나나보다 사과를 선호합니다.')\n giving birth (\u0026lsquo;출산\u0026rsquo;) = when the baby was born  when the mother was giving birth (\u0026lsquo;어머니가 출산 할때\u0026rsquo;)\n n. name (\u0026lsquo;이름을 지어주다\u0026rsquo;)  How do American Indian women name their babies? (\u0026lsquo;아메리칸 인디언 여성들은 아기의 이름을 어떻게 지어주나요?')\n compound words (\u0026lsquo;합성어\u0026rsquo;)  handphone is compound word that Consists of two word? (\u0026lsquo;handphone은 두 단어로 구성된 합성어입니다.')\n consists of ~ ('-로 구성된\u0026rsquo;)  notebook consists of many material (\u0026lsquo;노트북은 많은 재료로 구성됩니다.')\n v. believe (\u0026lsquo;믿다\u0026rsquo;) n. belief (\u0026lsquo;신뢰\u0026rsquo;)  belief is very important (\u0026lsquo;믿음은 매우 중요합니다.')\n tend to do (\u0026lsquo;경향이 있다.')  Believer is tend to pray before have a eating (\u0026lsquo;신자는 먹기 전에기도하는 경향이 있습니다 \u0026lsquo;)\n 새로운 단어  belief 신뢰\rgiving birth 신뢰\rprefers 선호하다\rtend to do 경향이 있다.\r 문법오류 Yes, each culture has using same names. → I think there are some common names used in many cultures. For example, Yujin , Suzan, and Susie.\rbackground → American Indian women (tend to) choose their babies’ names from what they saw while giving birth. = American Indian women tend to name their babies from what they saw while giving birth.\rthere are believe the stars and planets influence → because there are beliefs that the stars and plants have important influence (on their lives).\rthey believe astrology and Zodiac.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":50,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.26","uri":"https://offetuoso.github.io/blog/english/202103/20210326-english-speak/"},{"content":"Introduction (\u0026lsquo;소개, 서론\u0026rsquo;) Introduction → Body → Conclusion  This pagraph is book of Introduction (\u0026lsquo;이 단락은 서론입니다.')\n topic sentence (\u0026lsquo;주제 문장\u0026rsquo;)  this is topic sentence in paragraph (\u0026lsquo;이것은 단락의 주제 문장입니다\u0026rsquo;)\n Q. What is a must-included item when you summarize a text? (\u0026lsquo;글을 요약할때 꼭 포함되어야 하는것?')  main points, paraphrase the topic sentence\n plagiarism (\u0026lsquo;표절\u0026rsquo;)  this book has relate to rumor of plagiarism (\u0026lsquo;이 책은 표절 소문과 연루되어 있습니다\u0026rsquo;)\n customize  (1) to personalize to make sth fit for a certain purpose/situation/…\n  (2) 관습 each culture has its favorite names and naming-customs, so here are some from around the world.\n traditions vs. custom (\u0026lsquo;전통과 관습\u0026rsquo;) occupation (n) (\u0026lsquo;직업, Job보다 캐쥬얼 하지 않은 뜻\u0026rsquo;)  job categories → occupation categories main occupation My main occupation is a programmer, but I also work as a part-time teacher.\n elder (\u0026lsquo;무리의 가장큰 어른\u0026rsquo;) all in all - in general, most of the time (\u0026lsquo;전체적으로 \u0026lsquo;) 새로운 단어 custom 관습\roccupation 직업\rplagiarism 표절\r 문법오류 name’s meaning → meaning of names\rWhat did we do yesterday? / We learned about the meaning of names from many cultures (around the world)\rThird paragraph is the topic’s examples. Topic is culture’s names\r→ This text is introducing different naming cultures around the world. It gives/includes examples of Mongolian, North American Indian, Eskimo, and Russian cultures.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":51,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.25","uri":"https://offetuoso.github.io/blog/english/202103/20210325-english-speak/"},{"content":"Read the sentences (\u0026lsquo;문장 읽기\u0026rsquo;)  you must to read the sentences in book (\u0026lsquo;책에있는 문장을 읽어야합니다\u0026rsquo;)\n Read the sentences (\u0026lsquo;문장 읽기\u0026rsquo;)  you must to read the sentences in book (\u0026lsquo;책에있는 문장을 읽어야합니다\u0026rsquo;)\n some (\u0026lsquo;약간, 전체는 아니고, 아예 아닌것도 아님\u0026rsquo;)  some people who attempt to change (\u0026lsquo;변화를 시도하는 사람들\u0026rsquo;)\n 새로운 단어 passage 문구 / 통로\rsilently 잠자코, 조용히\rrepeat 반복\rintonation 말의 높낮이\rsome not all but not none\r 문법오류 I was weekends also studying English and.. --\u0026gt; I spudied during the weekends.\r--\u0026gt; I had to study during the weekends.\r(Subject Noun+ Action Verb + etc)\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":52,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.24","uri":"https://offetuoso.github.io/blog/english/202103/20210324-english-speak/"},{"content":"[문제1] 1이 될때까지 [문제] 1이 될때까지 : 문제 설명  어떠한 수 N이 1이 될때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 합니다. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있습니다.\n   N에서 1을 뺍니다. N에서 K로 나눕니다.    예를 들어 N이 17, K가 4라고 가정하자. 이때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이경우 전체과정을 실행한 횟수는 3이된다. 이는 N을 1로 만드는 최소 횟수이다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오\n [문제] 조건  입력조건 첫째줄에 N(2 \u0026lt;= N \u0026lt; = 100000)과 K(2 \u0026lt;= K \u0026lt; = 100000)가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 N은 항상 K보다 크거나 같다.\n  출력조건 첫째줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력한다.\n  입력예시\n25 5\n  출력예시\n2\n make_one.py n, k = map(int, input().split()) #n=13, k=5\rresult = 0\rwhile True :\r# n을 K로 나눈 몫에 k를 곱하여,\r# 나눌수 있는 값을 계산 # roof 1 step # roof 2 step\rtarget = (n // k) * k #target = 10 #target = 0\rresult += (n - target) #result += 3 \u0026lt;\u0026lt;한번에 카운트 3을 추가하고 #result(4) += 2\rn = target #n = target \u0026lt;\u0026lt;13을 10으로 만듬 #n=0\rif n \u0026lt; k : #false #true\rbreak\rresult += 1\t#나눗셈에 대한 result(3) +1\tn //= k\t#n = 2\rresult += (n - 1) #result(6) += -1 \u0026lt;n을 0까지 만들면서, 횟수 -1\rprint(result) #5  MakeOne.java package ex.Algorithm.greedy;\rimport java.util.Scanner;\rpublic class MakeOne {\rpublic static void main(String[] args) {\rScanner sc = new Scanner(System.in);\rint n = sc.nextInt();\rint k = sc.nextInt();\rint result = 0;\rwhile (true) {\rint target = (n/k)*k;\rresult += n-target;\rn = target;\rif(n \u0026lt; k) {\rbreak;\r}\rn = n / k;\rresult++;\r}\rresult += (n-1);\rSystem.out.println(result);\r}\r}\r [문제] 정당성 분석  1을 빼는 것보다 나누는 것이 더 기하급수적으로 빠르게 줄일 수 있다. K가 2보다 크다면, K로 나누는 것이 1을 빼는것 보다 항상 빠르게 N을 줄일 수 있다. 또한 N은 항상 1에 도달하게 됨.\n 이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"1이 될때까지 알고리즘.","id":53,"section":"blog","tags":["Algorithm"],"title":"1이 될때까지 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/make-one/"},{"content":"[문제1] 거스름돈 [문제] 거스름돈 : 문제 설명  당신은 음식점의 계산을 도와주는 점원입니다. 카운트에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈은 N은 항상 10의 배수입니다.\n [문제] 거스름돈 : 문제 해결 아이디어   최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐의 단위부터 돈을 거슬러 주면 됩니다. N원을 거슬러 줘야 할 때, 가장먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러줍니다. 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러주면 됩니다. N = 1,260일 때의 예시를 확인해 봅시다.    1,260 원을 500원부터 거슬러 준다면 아래와 같이\n    화페단위 500 100 50 10     손님이 받은 개수 2 2 1 1    [문제] 거스름돈 : 정당성 분석   가장큰 화폐단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요? 가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다. 만약 800원을 거슬러 주어야 하는데 화폐 단위가 500원 400원 100원이라면 어떻게 될까요 ? -\u0026gt; 400원 짜리 2개가 정답이됨 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 합니다.   reverse_change.py n =1260\rcount = 0 array = [500,100,50,10]\rfor coin in array:\rcount += n / coin\rn %= coin print(count)\r ReverseCharge.java package ex.Algorithm.greedy;\rpublic class ReverseCharge {\rpublic static void main(String[] args) {\rint n = 1260;\rint[] coins = {500,100,50,10};\rint count = 0;\rfor (int coin : coins) {\rcount += n/coin;\rn %= coin;\r}\rSystem.out.println(count);\r}\r}\r [문제] 거스름돈 : 시간 복잡도 분석   화폐의 종류가 K라고 할때, 소스코드의 시간복잡도는 O(K)이다. 이 알고리즘의 시간복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":54,"section":"blog","tags":["Algorithm","Greedy","이코테"],"title":"거스름돈 (그리디 알고리즘)","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/reverse-charge/"},{"content":"그리디 알고리즘(탐욕법) 그리디 알고리즘이란 ?  그리디 알고리즘이란\n 그리디 알고리즘(탐욕법)은 현재상황에서 가장 좋은 것만 고르는 방법을 의미. 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 있는 능력을 요구. 그리디 해법은 그 정당성 분석이 중요. 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토 필요.   [문제 상황] 루트 노드로 부터 시작하여 가는 노드의 합을 최대로 만들고 싶습니다.  Q. 최적의 해는 무엇인가요 ?\n  Q. 단순히 매 상황에서 가장큰 값을 고른다면 어떻게 될까요?\n   일반적인 상황에서 그리디알고리즘은 최적의 해를 보장할 수 없을때가 많다. 하지만 코딩 테스트에서의 대부분의 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제됨.   이 자료는 나동빈님의 이코테 유튜브 영상을 보고 정리한 자료입니다. 참고 : www.youtube.com/watch?v=m-9pAwq1o3w\u0026amp;amp;list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC\n","description":"그리디 알고리즘.","id":55,"section":"blog","tags":["Algorithm"],"title":"그리디 알고리즘","uri":"https://offetuoso.github.io/blog/codingtest/algorithm/greedy/greedy-algorithm/"},{"content":"do you mind?  (1) Are you okay/fine with it? (\u0026lsquo;괜찮나요?') Do you mind if I change the schedule? 괜찮다면, 스케쥴을 변경해도 될까요? (2) Mind your own business. (\u0026lsquo;니 일이나 신경써.') Do you mind? 니 일이나 신경써.\n attempt to ~ ('-를 시도하다.')  they are attempt to find something 그들은 무언갈 찾으려 한다. i attempt to speaking english 나는 영어로 말하길 시도한다.\n I had a meeting ~ ('-를 만났다.')  I had a meeting with english teacher 나는 영어 선생님과 Meeting을 가졌다.(만났다.) I had a meeting with my friends 나는 친구를 만났다\n - means ~ ('-의 뜻은 -입니다\u0026rsquo;)  **my name\u0026rsquo;s means a victory ** 내 이름은 승리를 의미합니다. **\u0026lsquo;팽-하\u0026rsquo; means \u0026lsquo;펭수 하이\u0026rsquo; ** \u0026lsquo;펭-하\u0026rsquo;는 \u0026lsquo;펭수-하이\u0026rsquo;를 뜻합니다.\n a. accurate (\u0026lsquo;정확한\u0026rsquo;)  **Do you think the information on the table is accurate? ** 테이블의 정보가 정확하다고 생각하나요?\n familiar with (\u0026lsquo;익숙한\u0026rsquo;)  **familiar with the technical terms ** 기술 용어에 익숙 함\n n. accuracy (\u0026lsquo;정확\u0026rsquo;) v. intend (\u0026lsquo;의도하다\u0026rsquo;)  **I didn’t intend to offend you(her) when I laughed at your(her) new haircut. ** 당신의 새 머리를 보고 웃은 것은 마음을 상하게 할 의도는 없었어요.\n 새로운 단어 honorable contribution 명예로운 공헌\rachievement 업적\rmaterial 재료\rconversation 대화\rjudgement 판단\rnervous 긴장한\r 문법오류 one time ago → an hour ago\rI has → had a meeting with Sophia an hour ago\rI have a class with June today.\rWe call him an old-fashioned man. Olivia is meaning → Olivia means Olive and peace.\rI have heard of ~\rI’ve heard of Jack from the book, I’m also familiar with the name Charlie.\rI think the Korea column is not that accurate.\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":56,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.19","uri":"https://offetuoso.github.io/blog/english/202103/20210319-english-speak/"},{"content":"Did you take a look at ~? ('-보셨나요?')  Did you take a look at the Book 책 보셨나요? Did you take a look at sky? 하늘을 보셨나요?\n I took a look at ~ (\u0026lsquo;나는 -를 보았다.')  I took a look at the book, 1 hour ago 1 시간 전에 책을 봤어요. I was took a look at sky last day 나는 어제 하늘을 봤어요\n a. impressed (\u0026lsquo;깊은 인상\u0026rsquo;) n. impression (\u0026lsquo;인상\u0026rsquo;) I’m impressed by ~ (\u0026lsquo;나는 당신의 -에 감동받았습니다.')  I’m impressed by your letter 나는 당신의 편지에 감동받았습니다. I’m impressed by your passion 나는 당신의 열정에 감동받았습니다.\n related to ~ ('-와 연관되다.')  I think, he is related to crime 그는 범죄와 관련된 것 같아요. my homework relate to math 나의 숙제는 수학과 관련있다.\n v. skim  He always skimmed the book 그는 항상 책을 훑어보았다.\n v. scan a. intermediate (중급의) beginners → intermediate → high/advanced level\r  He was in intermediate class, 3 month ago 그는 3개월 전에 중급반이였다.\n 영어 8품사 사전 표기법 \rn. 명사 (noun [naun] )\r-모든 사람, 사물, 동물의 이름을 나타내는 단어\r-문장에서 주어, 보어, 목적어가 된다.\r*C : 가산명사\r*U : 불가산명사\r*CU : 주로 가산명사\r*UC : 주로 불가산명사\r*sing. : 단수형\r*pl. : 복수형\r*n.pl. : 복수명사\r*fem. : 여성형\r*neg. : 부정형\rpron. 대명사 (pronoun [próunàun] )\r-인칭대명사: I, my, me, mine, myself, she, her, he, his, him 등\r-지시대명사: it, this, these, that, those 등\r*obj : 목적격\r*poss : 소유격\rv. 동사 (verb [vəːrb] )\rvtr. 타동사 (Transitive Verb)\rvi. 자동사 (Intransitive Verb)\r-동작이나 상태를 나타내는 단어\r-be동사 : am, are, is, was, were 등\r-일반동사 : be동사와 조동사를 제외한 나머지 동사\r*auxil. v. : 조동사 - can, may, will, should, must 등\r*p. : 과거형\r*p.p. : 과거분사형\r*pres.p. : 현재분사\r※목적어로 구분하는 자동사와 타동사\r자동사 : 목적어를 취하지 않는 동사\r타동사 : 목적어를 취하는 동사\r동사뒤에 목적어(영향을 받는 사람이나 사물)(이)가 필요한지 여부에 따라서\r자동사(Intransitive Verb)와 타동사(Transitive Verb)로 구분할 수 있습니다. adj. (or a.) 형용사 (adjective [ǽdʒiktiv] )\r-명사나 대명사를 수식하거나 보충 설명하는 단어\r-우리말에서 보통 \u0026lt; ~ㄴ, ~한\u0026gt; 으로 해석되는 단어\radv. (or ad.) 부사 (adverb [ǽdvəːrb] )\r-형용사, 다른 부사, 동사, 문장전체를 수식하는 단어\r-① 형용사 / 다른 부사 수식 : This is a very very delicious cake.\r-② 동사 수식 : She can run fast.\r-③ 문장 전체 수식 : Luckily, I passed the exam.\rprep. 전치사 (preposition [prèpəzíʃən] ) -명사나 대명사 앞에 쓰여서 장소, 시간 등을 나타내는 단어\r-in, at\r*pref. : 접두사\r*suf. : 접미사\rconj. 접속사 (conjunction [kəndʒΛŋkʃən] )\r-단어와 단어, 문장과 문장 등을 연결하는 단어\r-when, or, and\rinterj. (or int.) 감탄사 (interjection [ìntərdʒékʃən] )\r-놀람, 기쁨 등 감정을 나타내는 단어\r-Oh, Wow\r출처: https://fireball.tistory.com/409 [What's up]\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":57,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.17","uri":"https://offetuoso.github.io/blog/english/202103/20210317-english-speak/"},{"content":"I use ~ (\u0026lsquo;난 -를 사용한다.')  I use Java 난 자바를 사용한다. I use Korean 난 한국어를 사용한다.\n I’m preparing ~ ('-를 준비중입니다\u0026rsquo;)  ** I’m preparing to change job ** 나는 이직을 준비중입니다. ** I’m preparing to party in my house ** 우리 집에서 파티를 준비하고 있어요.\n ~ is intense ('-이 ~빡세다~힘들다.')\n Work is not intense 일은 힘들지 않다. Always Study is intense 공부는 힘들다.\n I learned ~ (\u0026lsquo;나는 -배웠다\u0026rsquo;)  I learned computer science in my University 나는 대학에서 컴퓨터를 전공했다. I learned baking bread 나는 빵굽기를 배웠다.\n I want to ~ ('-하고 싶습니다.')  I want to hold your hand 당신의 손을 잡고 싶습니다. I want to change job! 이직하고 싶어요!\n I\u0026rsquo;m good at ~ (\u0026lsquo;나는 -잘해\u0026rsquo;)  I\u0026rsquo;m good at make smile 나는 미소를 잘 짓습니다. I\u0026rsquo;m good at cleaning my room 나는 내방 청소를 잘해요\n I\u0026rsquo;m about to ~ (\u0026lsquo;나는 -할 예정이다\u0026rsquo;)  I\u0026rsquo;m about to go to bed 나는 자러갈 예정이다. I\u0026rsquo;m about to study english 나는 영어공부를 할 예정이다.\n Benefits \u0026amp; Drawbacks (장점 \u0026amp; 단점)\rTake your time (천천히) Achievement (성취감)\rWorking late (야근) Intense (빡센) Regular job = 정규직\rStable job = 안정감 있는 직업 Objective / Goal = 목표\rRegret = 후회\rAge Limit = 나이 제한\rVaccine = 백신\rPandemic = 전국적인 유행병\rGovernance = 통치  본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":58,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.16","uri":"https://offetuoso.github.io/blog/english/202103/20210316-english-speak/"},{"content":"I’m used to ~ (\u0026lsquo;난 -에 익숙해\u0026rsquo;)  I\u0026rsquo;m used to you 난 너에게 익숙해 I\u0026rsquo;m used to working overtime 난 야근에 익숙해\n I\u0026rsquo;m afraid ~ (\u0026lsquo;유감스럽지만,')  I\u0026rsquo;m afraid Rainy outside 유감이지만, 밖에 비가 오는 것 같아 **I\u0026rsquo;m afraid ** 유감이지만, 밖에 비가 오는 것 같아\n I’m working on ~ (\u0026lsquo;지금 -를 하고있어\u0026rsquo;)  I’m working on my English speaking 난 영어 말하기를 공부하고 있어 i\u0026rsquo;m working on study Algorithm 난 알고리즘을 공부하고 있어\n I’m ~ is bad (\u0026lsquo;난 -가 안좋다\u0026rsquo;)  I’m health is bad 난 건강이 안좋다 I\u0026rsquo;m english is bad 난 영어를 잘 못한다.\n My girlfriend is another event. → My girlfriend had a personal schedule (She went out to hang out with her friends.)\rI’m English is tiny → My English is bad. / I’m not that good at English. → I’m still learning English. / I’m working on my English speaking.\r(Q. What is the charm of skateboarding?) A. other skateboarders communication → (full sentence) I think the charm of skateboarding is that I can ride skateboards with other skateboarders. / I enjoy riding skateboards with other people → (shorter) Communicating with other skateboarders is the best. / the greatest charm. skateboarding stage → spot\rshortboard and longboard and skateboard → I started with the shortboard and then the longboard and then the skateboard. / I started with the shortboard and then the longboard. Now I can ride the standard skateboard as well.\rIsn’t/Wasn’t living in other countries tough?\rhave an access to\rhang out (Google HangOut / Meet) - to meet someone or to play with someone, usually friends.\rMy hobby is skateboarding. → I enjoy(love) skateboarding in my free time.\rI started in-door climbing recently. / I’m into sth. = having a great interest in sth\r 본 게시물은 개인 복습용이라 수업내용과 별개 입니다. 예시로 만든 문장은 문법적 오류가 있을 수 있습니다. 잘못된 점이 있다면 댓글로 남겨주시면 수정하겠습니다.\nend ","description":"영어 회화 문법정리","id":59,"section":"blog","tags":["english","speak","talk","EngAll","잉그올"],"title":"잉그올 영어 회화 21.03.15","uri":"https://offetuoso.github.io/blog/english/202103/20210315-english-speak/"},{"content":"Nothing on this page will be visible. This file exists solely to respond to /search URL.\nSetting a very low sitemap priority will tell search engines this is not important content.\n","description":"","id":60,"section":"","tags":null,"title":"Search Results","uri":"https://offetuoso.github.io/search/"}]