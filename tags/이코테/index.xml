<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>이코테 on offetuoso&#39;s Blog</title>
    <link>https://offetuoso.github.io/tags/%EC%9D%B4%EC%BD%94%ED%85%8C/</link>
    <description>Recent content in 이코테 on offetuoso&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <copyright>© 2021</copyright>
    <lastBuildDate>Wed, 05 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://offetuoso.github.io/tags/%EC%9D%B4%EC%BD%94%ED%85%8C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>왕실의 기사 (구현 알고리즘)</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/royal_knight/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/royal_knight/</guid>
      <description>[문제1] 왕실의 기사 [문제] 왕실의 기사 : 문제 설명  행복 왕국의 왕실 정원은 체스판과 같은 8 × 8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다 나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다 나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있다
   수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기   수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기   이처럼 8 × 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하라.</description>
    </item>
    
    <item>
      <title>시각 (구현 알고리즘)</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/time/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/implements/202105/time/</guid>
      <description>[문제1] 시각 [문제] 시각 : 문제 설명  정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하라. 예를 들어 1을 입력했을 때
  다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다 00시 00분 03초 00시 13분 30초
  반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다 00시 02분 55초 01시 27분 45초
 [문제] 조건  조건 풀이시간 15분 시간제한 2초, 메모리 128mb</description>
    </item>
    
    <item>
      <title>상하좌우 (구현 알고리즘)</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/implements/202104/up-down-left-right/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/implements/202104/up-down-left-right/</guid>
      <description>[문제1] 상하좌우 [문제] 상하좌우 : 문제 설명  여행가 A는 N × N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다
  계획서에는 하나의 줄에 띄어쓰기를 기준으로 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다.</description>
    </item>
    
    <item>
      <title>숫자 카드 게임 (그리디 알고리즘)</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/games-of-number-card/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/games-of-number-card/</guid>
      <description>[문제1] 숫자 카드 게임 [문제] 숫자 카드 게임 : 문제 설명  숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임이다. 단, 게임의 룰을 지키며 카드를 뽑아야 하고 룰은 다음과 같다.
  숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.</description>
    </item>
    
    <item>
      <title>큰수의 법칙 (그리디 알고리즘)</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/law-of-large-number/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202104/law-of-large-number/</guid>
      <description>[문제1] 큰 수의 법칙 [문제] 큰 수의 법칙 : 문제 설명  출제자는 큰 수의 법칙을 본인만의 방식으로 다르게 사용하고 있다. 이 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰수를 만드는 법칙이다. 단 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
  예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자.</description>
    </item>
    
    <item>
      <title>거스름돈 (그리디 알고리즘)</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/reverse-charge/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/greedy/202103/reverse-charge/</guid>
      <description>[문제1] 거스름돈 [문제] 거스름돈 : 문제 설명  당신은 음식점의 계산을 도와주는 점원입니다. 카운트에서는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때, 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬로 줘야 할 돈은 N은 항상 10의 배수입니다.
 [문제] 거스름돈 : 문제 해결 아이디어   최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐의 단위부터 돈을 거슬러 주면 됩니다. N원을 거슬러 줘야 할 때, 가장먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러줍니다.</description>
    </item>
    
  </channel>
</rss>
