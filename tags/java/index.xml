<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on offetuoso&#39;s Blog</title>
    <link>https://offetuoso.github.io/tags/java/</link>
    <description>Recent content in Java on offetuoso&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <copyright>© 2021</copyright>
    <lastBuildDate>Mon, 07 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://offetuoso.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JPA Projection(SELECT)</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/projection/</link>
      <pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/projection/</guid>
      <description>JPA Projection(SELECT)  이전 소스   src/main/java/jpql/domain/Member.java
  Member.java package jpql.domain;import javax.persistence.*;@Entitypublic class Member {public Member(){}@Id @GeneratedValueprivate Long id;private String username;private int age;@ManyToOne@JoinColumn(name = &amp;quot;TEAM_ID&amp;quot;)private Team team = new Team();public Long getId() {return id;}public void setId(Long id) {this.id = id;}public String getUsername() {return username;}public void setUsername(String username) {this.</description>
    </item>
    
    <item>
      <title>object references an unsaved transient instance - save the transient instance before flushing 에러</title>
      <link>https://offetuoso.github.io/blog/develop/troubleshooting/jpa/object-references-an-unsaved-transient-instance-save-the-transient-instance-before-flushing/</link>
      <pubDate>Mon, 07 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/troubleshooting/jpa/object-references-an-unsaved-transient-instance-save-the-transient-instance-before-flushing/</guid>
      <description>object references an unsaved transient instance - save the transient instance before flushing 에러 오류 org.hibernate.TransientPropertyValueException: object references an unsaved transient instance - save the transient instance before flushing 원인  @ManyToOne 또는 @OneToMany 매핑을 사용 할때 부모 엔티티에 포함된 FK가 아직 영속되지 않아 생긴 영속성 전이(CASCADE)에 대한 오류 발생
 문제가된 소스 설명   Member 엔티티는 id, username, team 을 가지고 있다. Team은 id 와 name 을 가지고 있다.</description>
    </item>
    
    <item>
      <title>JPQL(Java persistence Query Language)</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/jpql/</guid>
      <description>JPQL(Java persistence Query Language)  JPQL - 기본 문법과 기능  JPA에서 제공되는 다양한 쿼리 방법    JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리 하는 것이 아니라 엔티티를 대상으로 쿼리 한다. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다. JPQL은 결국 SQL로 변환된다.    객체모델
  DB모델
  JPQL을 예제 작성을 위한 Maven 프로젝트를 생성 하겠습니다.
  jpa-basic\jpql
  pom.xml
  pom.</description>
    </item>
    
    <item>
      <title>JPA 객체지향 쿼리 언어 소개</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/object-oriented-query-language/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/object-oriented-query-language/</guid>
      <description>객체지향 쿼리 언어 (JPQL)  목차    객체지향 커리 언어 소개 JPQL 기본 문법과 기능 패치 조인 경로 표현식 다형성 쿼리 엔티티 직접 사용 Named 쿼리 벌크 연산   객체지향 쿼리 언어 소개  JPA에서 제공되는 다양한 쿼리 방법   JPA에서는 실무에서 사용하기 위한 다양한 검색 조건과 Join을 사용하여 조회 등 복잡한 쿼리를 구현할 수 있도록 기능 다양한 쿼리 방법을 제공합니다.
   JPQL 엔티티 객체를 조회하는 객체지향 쿼리다.</description>
    </item>
    
    <item>
      <title>JPA 실전 예제 6 - 값 타입 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-6/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-6/</guid>
      <description>실전 예제 6 - 값 타입 매핑  값 타입 추가    city, street, zipcode 는 Address 값 타입으로 변경   값 타입 추가 순서    값 타입 클래스 추가 - Address.java    @Embeddable 어노테이션 추가    불변 객체로 생성 3.1. 필드(맴버 변수) 추가 3.2. getter 추가 3.3. setter private로 생성 또는 생성 X   값 타입은 공유해서 사용시 변경이 되면 같이 사용하는 값 모두 변경되므로 주의 값 타입은 변경하지 말고 객체를 새로 생성해서 갈아껴야함.</description>
    </item>
    
    <item>
      <title>JPA 값 타입 컬렉션</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/value-type-collection/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/value-type-collection/</guid>
      <description>값 타입 컬렉션 (Value Type Collection)  값 타입 컬렉션   값 타입 컬렉션이란 값타입을 컬렉션에 담아서 사용하는 것을 의미 합니다.
  Member가 faviriteFoods와 addressHistory 라는 두가지 컬렉션을 가지고 있습니다.
  DB 테이블로 구현할때 문제가 됩니다. 값 타입이 하나 일때는 필드 속성으로 해서 Member 테이블에 넣으면 되었는데
  관계형 DB에는 컬렉션을 담을 수 있는 구조가 없습니다. 요즘에서야 JSON 타입을 지원하는 데이터베이스도 있긴합니다.
  관계형 DB에서 이런 구조를 사용하기 위해 1:N 관계의 각 테이블을 생성하여야 합니다.</description>
    </item>
    
    <item>
      <title>JPA 값 타입과 불변 객체</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/immutable-object/</link>
      <pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/immutable-object/</guid>
      <description>값 타입과 불변 객체  값 타입   값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.
  값 타입 공유 참조     임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함 부작용(side effect) 발생    회원 1과 회원 2가 같은 값 타입인 주소를 바라보고 있는데 NewCity로 값을 바꾸면, 회원1과 회원2의 주소가 모두 NewCity로 변경됩니다.</description>
    </item>
    
    <item>
      <title>JPA 임베디드 타입</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/embedded-type/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/embedded-type/</guid>
      <description>임베디드 타입  임베디드(복합 값) 타입    새로운 값 타입을 정의할 수 있음 JPA는 임베디드 타입(embedded type)이라 함 주로 기본 값 타임을 모아 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입 (엔티티 아님)   임베디드 타입   회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다.
  회원 엔티티는 이름, 근무 기간, 집 주소를 가진다.
   Period는 startDate와 endDate를 가지게 클래스로 만들어 값 타입을 만듭니다.</description>
    </item>
    
    <item>
      <title>JPA 값 타입</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/value-type/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/value-type/</guid>
      <description>값 타입  목차    기본값 타입 임베디드 타입(복합 값 타입) 값 타입과 불변 객체 값 타입의 비교 값 타입 컬렉션   기본값 타입  JPA의 데이터 타입 분류   엔티티 타입  @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적 가능 예) 회원의 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능       값 타입  int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경시 추적불가 예)숫자 100을 200으로 변경하면 완전히 다른 값으로 대체     값 타입 분류   기본값 타입  자바 기본 타입(int, double) 래퍼 클래스(Integer, Long) String   임베디드 타입(embedded type, 복합 값 타입) 예) 좌표 X,Y 묶어서 Position 객체 하나로 사용     컬렉션 값 타입(collection value type) 자바 컬렉션 객체안에 기본값 타입 혹은 임베디드 타입 등을 추가해 사용   기본값 타입    예) String name, int age 생명주기를 엔티티에 의존  예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제   값 티입은 공유하면 안됨(사이드 이팩트, 부수효과 조심)  예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨     참고 : 자바의 기본 타입은 절대 공유 X   int, double 같은 기본 타입(primitive type)은 절대 공유 되면 안됨 기본 타입은 항상 값을 복사함 Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경X    ValueMain.</description>
    </item>
    
    <item>
      <title>JPA 실전 예제 5 - 연관관계 관리</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-5/</link>
      <pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-5/</guid>
      <description>실전 예제 5 - 연관관계 관리  글로벌 페치 전략 설정    모든 연관관계를 지연로딩으로 @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 지연로딩으로 변경하길 권장   글로벌 페치 전략 예제소스에 적용   기존 작성했던 엔티티중 @ManyToOne, @OneToOne에는 (fetch = FetchType.LAZY)를 추가한다.
  Album.java
 package jpabasic.jpashop.domain;import javax.persistence.DiscriminatorValue;import javax.persistence.Entity;@Entity@DiscriminatorValue(&amp;quot;A&amp;quot;)public class Album extends Item{private String artist;private String etc;public String getArtist() {return artist;}public void setArtist(String artist) {this.</description>
    </item>
    
    <item>
      <title>JPA 영속성 전이(CASCADE)와 고아 객체</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/cascade/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/cascade/</guid>
      <description>영속성 전이(CASCADE)와 고아 객체  목록    영속성 전이 고아 객체   영속성 전이  앞에서 나온 즉시 로딩, 지연 로딩, 연관관계 세팅 이 세가지와 완전 별개의 개념
   특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때 예 : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.   영속성 전이: 저장  @OneToMany(mappedBy=&amp;quot;parent&amp;quot;, cascade=CasecadeType.PERSIST)  Parent.java
 package relativemapping;import javax.</description>
    </item>
    
    <item>
      <title>JPA 즉시 로딩과 지연로딩</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/eager-loading-and-lazy-loading/</link>
      <pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/eager-loading-and-lazy-loading/</guid>
      <description>프록시와 연관관계 관리  즉시 로딩과 지연로딩  지연 로딩  Member를 조회할때 Team도 함께 조회해야 할까?  단순히 Member 정보만 사용하는 비지니스 로직 println(member.getName()); 연관관계가 등록되어 있어도 지금처럼 member만 사용하면 손해일 수 있습니다.
 ![contact](/images/develop/backend/orm-jpa-basic/eager-loading-and-lazy-loading/im g-001.png)
지연 로딩 LAZY을 사용해서 프록시로 조회 	@Entitypublic class Member {@Id @generatedValueprivate Long id;@Column(name = &amp;quot;USERNAME&amp;quot;)private String name;@ManyToOne(fetch = FetchType.LAZY)@JoinColumn(name = &amp;quot;TEAM_ID&amp;quot;)private Team team;}  Member.</description>
    </item>
    
    <item>
      <title>JPA 프록시와 연관관계</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/proxy-and-relation/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/proxy-and-relation/</guid>
      <description>프록시와 상속관계  목차    프록시 즉시 로딩과 지연 로딩 지연 로딩 활용 영속성 전이 : CASCADE 고아 객체 영속성 전이 + 고아객체, 생명주기   프록시  Member를 조회할때 Team도 함께 조회해야 할까?  JpaMain.java
  private static void printMember(Member member){System.out.println(&amp;quot;username = &amp;quot;+member.getUsername());}private static void printMemberAndTeam(Member member){String username = member.getUsername();System.out.println(&amp;quot;username = &amp;quot;+username);Team team = member.getTeam();System.out.println(&amp;quot;team = &amp;quot;+team.getName());}  Member객체를 출력하는 메서드와 Member객체와 Member가 가지는 Team 객체를 출력하는 메서드가 있을때, Member만 조회하는 쿼리를 수행할때 Team까지 Join을 통하여 조회 쿼리를 수행한다면 자원낭비이다.</description>
    </item>
    
    <item>
      <title>JPA 실전 예제 4 - 상속관계 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-4/</link>
      <pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-4/</guid>
      <description>실전 예제 4 - 상속관계 매핑  요구사항 추가    상품의 종류는 음반, 도서, 영화가 있고 이후 더 확장될 수 있다. 모든 데이터는 등록일과 수정일이 필수다.   도메인 모델  도메인 모델 상세  테이블 설계 상속관계 매핑 추가  Item.java
   Item.java를 abstract로 바꾼다. 단일 테이블 전략이기 때문에 Item.java에 @Inheritance(strategy = InheritanceType.SINGLE_TABLE) 를 추가한다. @DiscriminatorColumn를 추가하여 DTYPE를 추가한다.   package jpabasic.jpashop.domain;import javax.persistence.*;import java.</description>
    </item>
    
    <item>
      <title>JPA @MappedSuperclass</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapped-superclass/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapped-superclass/</guid>
      <description>상속관계 매핑  목차    상속관계 매핑 @MappedSuperclass   MappedSuperclass  @MappedSuperclass  예를 들어 이전의 상속관계 매핑을 사용하지 않고 단순하게 객체의 입장에서 id와 name이 계속 나오게 되는데 매번 만들기 귀찮아서 부모 클래스에 두고 속성만 상속받아서 사용하고 싶을때 사용.   DB에서는 각각 테이블에 id, name을 포함하며 DB와 구조가 다르지만, 매번 추가 해야하는 속성을 엔티티마다 추가해야 하는 불편함을 줄여보자 해서 나오게 된 기능입니다.
 @MappedSuperclass 예제  DBA의 요청으로 엔티티 마다 생성한 사람의 ID, 생성한 시간, 마지막 수정한 사람 ID, 마지막 수정한 시간을 각각 추가하려 합니다.</description>
    </item>
    
    <item>
      <title>JPA 상속관계 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/proxy-and-relation/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/proxy-and-relation/</guid>
      <description>상속관계 매핑  목차    상속관계 매핑 @MappedSuperclass   상속관계 매핑    객체는 상속관계가 있지만, 관계형 데이터베이스에는 상속 관계 없음 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 관계를 매핑    음반, 영화, 책의 공통 속성은 물품에 두고, 각각의 속성들을 밑의 서브 타입에 지정하여 논리 모델을 구성합니다.
  객체는 Item이라는 추상 클래스를 만들고 Item을 상속받는 Album, Movie, Book 객체를 구성할 수 있습니다.</description>
    </item>
    
    <item>
      <title>JPA 실전 예제 3 - 다양한 연관관계 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-3/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-3/</guid>
      <description>실전 예제 3 - 다양한 연관관계 매핑  요구사항 분석  배송, 카테고리 추가 - 엔티티    주문과 뱌송은 1:1(@OneToOne) 상품과 카테고리는 N:M(@ManyToMany)   배송, 카테고리 추가 - ERD   Delivery.java 와 Category.java를 생성합니다.
 일대일 양방향 관계 Order.java - Delivery.java   주 객체은 외래키를 가지고 있는 Order.java  @OneToOne @JoinColumn(name = &amp;ldquo;DELIVERY_ID&amp;rdquo;) private Delivery delivery;       대상 객체는 상대 객체인 Delivery.</description>
    </item>
    
    <item>
      <title>JPA 다양한 연관관계 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapping-various-associations/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/mapping-various-associations/</guid>
      <description>다양한 연관관계 매핑  목차    연관관계 매핑시 고려사항 3가지 다대일 [N:1] 일대다 [1:N] 일대일 [1:1] 다대다 [N:M]   연관관계 매핑시 고려사항 3가지    다중성 단방향, 양방향 연관관계의 주인   다중성    다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany (실무에서 사용X)    애매한 경우 반대의 경우를 생각해 보면 된다. 다대일의 반대는 일대다, 일대일의 반대는 일대일, 다대다의 반대는 다대다.</description>
    </item>
    
    <item>
      <title>JPA 실전 예제 2 - 연관관계 매핑 시작</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-2/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-2/</guid>
      <description>실전 예제 2 - 연관관계 매핑 시작 요구사항 분석   실전 예제 1 요구사항 분석과 기본 매핑에서 테이블에 맞춘 설계를 했던 것에 연관 관계 매핑을 적용 시켜 보도록 하겠습니다.
 테이블 구조   테이블 구조는 이전과 같다.
 객체 구조   참조를 사용하도록 변경
  OrderItem과 Item에서 N:1이면서 화살표가 OrderItem에서 Item으로 단방향인 것을 알 수 있는데, 이는 주문된 아이템(OrderItem) 입장에서는 어떠한 아이템(Item)인지 알아야하지만, 아이템 입장에서는 통계 같은 프로그램을 하지 않는 이상 이 아이템이 어떠한 아이템 주문이 되었는지 알 필요가 없습니다.</description>
    </item>
    
    <item>
      <title>JPA 연관관계 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/relation-mapping/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/relation-mapping/</guid>
      <description>연관관계 매핑   테이블에 맞춰서 외래키를 가져오면서 설계하는 방식이 아닌 order.getMember()이런식으로 연관관계를 맺어서 좀더 객체지향 식으로 설계할 수 있는지 알아보겠습니다. 여태 까지는 어려움이 없었겠지만, 관계형 DB와 객체지향 사이에서 오는 간극이 크고 각각의 패러다임이 다르기 때문에 어려움이 있습니다.
 목표    객체와 테이블 연관관계 차이를 이해 객체의 참조와 테이블의 외래 키를 매핑 용어 이해  방향(Direction) : 단방향, 양방향 다중성(Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)의 이해 연관관계의 주인(Owner) : 객체의 양방향 관계는 괸리 주인이 필요     목차    연관관계가 필요한 이유 단방향 연관관계 양방향 연관관계와 연관관계의 주인 실전예제 - 2.</description>
    </item>
    
    <item>
      <title>JPA 기본키 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/primary-key-mapping/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/primary-key-mapping/</guid>
      <description>기본키 매핑  기본 키 매핑 어노테이션    @Id @GeneratedValue   @Id @GeneratedValue(strategy = GenerationTpye.AUTO)private Long id; 기본 키 매핑 방법    직접 할당 : @Id 만 사용 자동 생성(@GeneratedValue)  IDENTITY : 데이터베이스에 위임, MySLQ) SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE  @SequenceGenerator 필요     TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용  @TableGenerator 필요   AUTO: 방언에 따라 자동 지정, 기본값   Id 직접할당 - @Id 사용   Member.</description>
    </item>
    
    <item>
      <title>JPA 실전 예제 1 - 요구사항 분석과 기본 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-1/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/practical-example-1/</guid>
      <description>실전 예제 1 - 요구사항 분석과 기본 매핑  요구사항 분석    회원은 상품을 주문할 수 있다. 주문 시 여러 종류의 상품을 선택할 수 있다.   기능 목록    회원 기능  회원등록 회원조회       상품 기능  상품등록 상품수정 상품조회       주문 기능  상품주문 주문내역조회 주문취소     도메인 모델 분석    회원과 주문의 관계 : 회원은 여러 번 주문할 수 있다.</description>
    </item>
    
    <item>
      <title>JPA 객체와 매핑</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/entity-mapping/</link>
      <pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/entity-mapping/</guid>
      <description>객체와 매핑  객체와 테이블 매핑  목차    객체와 테이블 매핑 필드와 컬럼 매핑 기본 키 매핑 실전 예제 - 1. 요구사항 분석과 기본 매핑   엔티티 매핑 소개    객체와 테이블 매핑 : @Entity, @Table 필드와 컬럼 매핑 : @Column 기본키 매핑 : @Id 연관관계 매핑 : @ManyToOne, @JoinColumn   객체와 테이블 매핑  @Entity    @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 부른다.</description>
    </item>
    
    <item>
      <title>JPA 영속성 관리</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/persistence-manage/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/persistence-manage/</guid>
      <description>JPA 영속성 관리 - 내부 동작 방식  영속성 컨텍스트  JPA에서 가장 중요한 2가지    객체와 관계형 데이터베이트 매핑하기 (Object Relational Mapping) 영속성 컨텍스트   엔티티 매니저 팩토리와 앤티티 매니저   요청이 오면 앤티티 매니저 팩토리를 통해 엔티티 매니저를 생성하고, 앤티티 매니저는 커넥션풀을 이용해 DB에 접근 합니다.
 영속성 컨텍스트    JPA를 이해하는데 가장 중요한 용어 &amp;ldquo;엔티티를 영구 저장하는 환경&amp;quot;이라는 뜻 EntitiyManager.persist(entity); // persist 메소드는 DB에 저장하는게 아니라 entity를 영속성 컨텍스트에 저장한다는 것   엔티티 매니저?</description>
    </item>
    
    <item>
      <title>JPA 시작</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/start-jpa/</link>
      <pubDate>Sat, 18 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/start-jpa/</guid>
      <description>JPA 시작하기  Hello JPA - 프로젝트 생성  H2 Database 설치   H2 홈페이지에서 OS에 맞는 설치 파일을 다운로드한다.
  C:\Program Files (x86)\H2\bin\h2.bat 실행
  http://localhost:8082/login.jsp 에서 연결버튼 클릭
 SpringBoot 프로젝트 생성  pom.xml  hibernate와 h2database dependency 추가
 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&amp;lt;groupId&amp;gt;jpa-basic&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;ex1-hello-jpa&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;&amp;lt;properties&amp;gt;&amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt;&amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;dependencies&amp;gt;&amp;lt;!-- JPA 하이버네이트 --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;hibernate-entitymanager&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;5.6.1.Final&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!</description>
    </item>
    
    <item>
      <title>JPA 소개</title>
      <link>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/about-jpa/</link>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/develop/backend/orm-jpa-basic/about-jpa/</guid>
      <description>JPA 애플리케이션   지금 시대는 객체를 관계형 DB에 관리 객체 지향 언어를 사용한 프로젝트라고 하여도 결국엔 SQL이 제일 중요할 수 밖에 없다. 관계형 DB가 알아 들을 수 있는 것은 SQL이니까
 SQL 중심적인 개발의 문제점    무한 반복, 지루한 코드   CRUD    INSERT UPDATE SELECT DELETE 자바 객체를 SQL로 .. SQL을 자바 객체로 ..   객체 CRUD   간단히 Member라는 객체를 생성하고, sql로 CRUD를 개발하였다고 생각하자.</description>
    </item>
    
  </channel>
</rss>
