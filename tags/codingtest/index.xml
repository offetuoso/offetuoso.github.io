<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodingTest on offetuoso&#39;s Blog</title>
    <link>https://offetuoso.github.io/tags/codingtest/</link>
    <description>Recent content in CodingTest on offetuoso&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <copyright>© 2021</copyright>
    <lastBuildDate>Tue, 29 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://offetuoso.github.io/tags/codingtest/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BAEKJOON - OX 퀴즈</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/ox-quiz/</link>
      <pubDate>Tue, 29 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/ox-quiz/</guid>
      <description>백준 8958 ox quiz Task description  &amp;ldquo;OOXXOXXOOO&amp;quot;와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.
  &amp;ldquo;OOXXOXXOOO&amp;quot;의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.
  OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.
 Condition   첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다.</description>
    </item>
    
    <item>
      <title>Codility - PermCheck</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-check/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-check/</guid>
      <description>PermCheck  Codility - Lesson4 - Counting Elements - PermCheck
 Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다.
순열은 1부터 N까지의 각 요소를 한 번만 포함하는 시퀀스입니다. 예를 들어 배열 A는 다음과 같습니다.
  A [0] = 4A [1] = 1A [2] = 3A [3] = 2  순열이지만 배열 A는 다음과 같습니다.
  A [0] = 4A [1] = 1A [2] = 3  값 2가 없기 때문에 순열이 아닙니다.</description>
    </item>
    
    <item>
      <title>BAEKJOON - 설탕배달</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/sugar-delivery/</link>
      <pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/braekjoon/sugar-delivery/</guid>
      <description>백준 2839 설탕배달 Task description  상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.
  상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.
  상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>Codility - MaxCounter</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/max-counter/</link>
      <pubDate>Sat, 26 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/max-counter/</guid>
      <description>MaxCounter  Codility - Lesson4 - Counting Elements - MaxCounter
 Task description  처음에는 0으로 설정된 N 개의 카운터가 제공되며 두 가지 가능한 작업이 있습니다.
  증가 (X) -카운터 X가 1 증가합니다. 최대 카운터 -모든 카운터는 모든 카운터의 최대 값으로 설정됩니다. M 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 이 배열은 연속 작업을 나타냅니다.
  A [K] = X, 즉 1 ≤ X ≤ N이면 연산 K는 증가 (X), A [K] = N + 1이면 작업 K는 최대 카운터입니다.</description>
    </item>
    
    <item>
      <title>Codility - FrogRiverOne</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/frog-river-one/</link>
      <pubDate>Sat, 12 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/frog-river-one/</guid>
      <description>FrogRiverOne  Codility - Lesson4 - Counting Elements - FrogRiverOne
 Task description  은 개구리가 강 건너편으로 가고 싶어합니다. 개구리는 처음에 강의 한 둑 (위치 0)에 있으며 반대쪽 둑 (위치 X + 1)에 도달하려고합니다. 잎은 나무에서 강 표면으로 떨어집니다.
  엽을 나타내는 N 개의 정수로 구성된 배열 A가 제공됩니다. A[K]는 초 단위로 측정 된 시간 K에서 한 잎이 떨어지는 위치를 나타냅니다.
  는 개구리가 강 반대편으로 점프 할 수있는 가장 빠른 시간을 찾는 것입니다.</description>
    </item>
    
    <item>
      <title>Codility - TapeEquilibrium</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/tape-equilibrium/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/tape-equilibrium/</guid>
      <description>Tape Equilibrium  Codility - Lesson3 - Time Complexity - TapeEquilibrium
 Task description  N 개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 0 &amp;lt;P &amp;lt;N 인 정수 P는이 배열 A를 두 부분으로 분할합니다 (A [0], A [1], &amp;hellip;, A [P − 1] 및 A [P], A [ P + 1], &amp;hellip;, A [N-1]) 분할 된 두 부분의 차이는 다음의 값입니다. | (A [0] + A [1] + &amp;hellip; + A [P − 1]) − (A [P] + A [P + 1] + .</description>
    </item>
    
    <item>
      <title>Codility - PermMissingElem</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-missing-elem/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/perm-missing-elem/</guid>
      <description>Perm Missing Elem  Codility - Lesson3 - Time Complexity - PermMissingElem
 Task description  배열 A는 1 ~ N+1의 범위의 정수를 담고 있는 배열이며 1 ~ N+1의 정수중 1개의 숫자(요소)가 빠져있다.
  예를 들면 다음과 같습니다.
  A[0] = 2A[1] = 3A[2] = 1A[3] = 5  1~5까지의 숫자중 4가 빠져 있기 때문에 4를 반환
 Condition   다음 가정에 대한 효율적인 알고리즘을 작성하십시오.</description>
    </item>
    
    <item>
      <title>Codility - Frog Jmp</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-frog-jmp/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-frog-jmp/</guid>
      <description>Frog Jmp  Codility - Lesson3 - Time Complexity - Frog Jmp
 Task description  세 개의 정수 X, Y, D를 입력받는 함수를 작성합니다.
 X는 개구리의 위치 Y는 개구리의 목표 위치 Y는 개구리의 이동거리 위치 X에서 D씩 최소의 이동을 하여 목표를 Y에 도달하거나 넘어가기 위하여 이동하는 최소 횟수 반환    예를 들면 다음과 같습니다.
  X = 10Y = 85D = 30  개구리는 다음과 같이 위치하므로 함수는 3을 반환해야합니다.</description>
    </item>
    
    <item>
      <title>Codility - Odd Occurrences In Array</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-odd-occurrences-in-array/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-odd-occurrences-in-array/</guid>
      <description>Odd Occurrences In Array  Codility - Lesson2 - Array - Odd Occurrences In Array
 Task description  N개의 정수가 담긴 배열 A를 입력받습니다 배열에는 홀수 개의 요소가 포함됩니다. 배열의 각 요소는 짝을 이루지 않는 한 요소를 제외하고 동일한 값을 가진 다른 요소와 짝을 가지고 있습니다. 짝이 없는 요소를 찾으면 해결됩니다
  예를 들어, 주어진 A 배열은 이렇습니다.
  A [0] = 9 A [1] = 3 A [2] = 9A [3] = 3 A [4] = 9 A [5] = 7A [6] = 9   인덱스 0과 2에있는 요소의 값은 9입니다.</description>
    </item>
    
    <item>
      <title>Codility - Cyclic Rotation</title>
      <link>https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-cyclic-rotation/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://offetuoso.github.io/blog/codingtest/algorithm/codility/codility-cyclic-rotation/</guid>
      <description>CyclicRotation  Codility - Lesson2 - Array - CyclicRotation
 Task description  N 개의 정수로 구성된 배열 A와 오른쪽으로 회전할 횟수 K가 제공됩니다. A의 각 요소가 오른쪽으로 K 번 이동합니다. N 개의 정수와 K로 구성된 배열 A가 주어지면 배열 A가 K 번 회전 된 배열을 반환합니다.
  예를 들어, 주어진
   A = [3, 8, 9, 7, 6] K = 3    함수는 [9, 7, 6, 3, 8]을 반환해야합니다.</description>
    </item>
    
  </channel>
</rss>
